webpackJsonp([1],{

/***/ 204:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_compiler__ = __webpack_require__(213);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(36);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_common__ = __webpack_require__(73);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__ = __webpack_require__(62);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RESOURCE_CACHE_PROVIDER\", function() { return RESOURCE_CACHE_PROVIDER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"platformBrowserDynamic\", function() { return platformBrowserDynamic; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return VERSION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵINTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS\", function() { return INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ɵResourceLoaderImpl\", function() { return ResourceLoaderImpl; });\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * @license Angular v4.1.0\n * (c) 2010-2017 Google, Inc. https://angular.io/\n * License: MIT\n */\n\n\n\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ResourceLoaderImpl = (function (_super) {\n    __extends(ResourceLoaderImpl, _super);\n    function ResourceLoaderImpl() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ResourceLoaderImpl.prototype.get = function (url) {\n        var resolve;\n        var reject;\n        var promise = new Promise(function (res, rej) {\n            resolve = res;\n            reject = rej;\n        });\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.responseType = 'text';\n        xhr.onload = function () {\n            // responseText is the old-school way of retrieving response (supported by IE8 & 9)\n            // response/responseType properties were introduced in ResourceLoader Level2 spec (supported\n            // by IE10)\n            var response = xhr.response || xhr.responseText;\n            // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n            var status = xhr.status === 1223 ? 204 : xhr.status;\n            // fix status code when it is 0 (0 status is undocumented).\n            // Occurs when accessing file resources or on Android 4.1 stock browser\n            // while retrieving files from application cache.\n            if (status === 0) {\n                status = response ? 200 : 0;\n            }\n            if (200 <= status && status <= 300) {\n                resolve(response);\n            }\n            else {\n                reject(\"Failed to load \" + url);\n            }\n        };\n        xhr.onerror = function () { reject(\"Failed to load \" + url); };\n        xhr.send();\n        return promise;\n    };\n    return ResourceLoaderImpl;\n}(__WEBPACK_IMPORTED_MODULE_0__angular_compiler__[\"a\" /* ResourceLoader */]));\nResourceLoaderImpl.decorators = [\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"] },\n];\n/** @nocollapse */\nResourceLoaderImpl.ctorParameters = function () { return []; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS = [\n    __WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__[\"ɵINTERNAL_BROWSER_PLATFORM_PROVIDERS\"],\n    {\n        provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"COMPILER_OPTIONS\"],\n        useValue: { providers: [{ provide: __WEBPACK_IMPORTED_MODULE_0__angular_compiler__[\"a\" /* ResourceLoader */], useClass: ResourceLoaderImpl }] },\n        multi: true\n    },\n    { provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"PLATFORM_ID\"], useValue: __WEBPACK_IMPORTED_MODULE_2__angular_common__[\"ɵPLATFORM_BROWSER_ID\"] },\n];\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An implementation of ResourceLoader that uses a template cache to avoid doing an actual\n * ResourceLoader.\n *\n * The template cache needs to be built and loaded into window.$templateCache\n * via a separate mechanism.\n */\nvar CachedResourceLoader = (function (_super) {\n    __extends(CachedResourceLoader, _super);\n    function CachedResourceLoader() {\n        var _this = _super.call(this) || this;\n        _this._cache = __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"ɵglobal\"].$templateCache;\n        if (_this._cache == null) {\n            throw new Error('CachedResourceLoader: Template cache was not found in $templateCache.');\n        }\n        return _this;\n    }\n    CachedResourceLoader.prototype.get = function (url) {\n        if (this._cache.hasOwnProperty(url)) {\n            return Promise.resolve(this._cache[url]);\n        }\n        else {\n            return Promise.reject('CachedResourceLoader: Did not find cached template for ' + url);\n        }\n    };\n    return CachedResourceLoader;\n}(__WEBPACK_IMPORTED_MODULE_0__angular_compiler__[\"a\" /* ResourceLoader */]));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the common package.\n */\n/**\n * @stable\n */\nvar VERSION = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Version\"]('4.1.0');\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @experimental\n */\nvar RESOURCE_CACHE_PROVIDER = [{ provide: __WEBPACK_IMPORTED_MODULE_0__angular_compiler__[\"a\" /* ResourceLoader */], useClass: CachedResourceLoader }];\n/**\n * @stable\n */\nvar platformBrowserDynamic = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"createPlatformFactory\"])(__WEBPACK_IMPORTED_MODULE_0__angular_compiler__[\"b\" /* platformCoreDynamic */], 'browserDynamic', INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS);\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the platform-browser-dynamic package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n//# sourceMappingURL=platform-browser-dynamic.es5.js.map\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL34vQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy5lczUuanM/NGQ1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2NC4xLjBcbiAqIChjKSAyMDEwLTIwMTcgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG5pbXBvcnQgeyBSZXNvdXJjZUxvYWRlciwgcGxhdGZvcm1Db3JlRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL2NvbXBpbGVyJztcbmltcG9ydCB7IENPTVBJTEVSX09QVElPTlMsIEluamVjdGFibGUsIFBMQVRGT1JNX0lELCBWZXJzaW9uLCBjcmVhdGVQbGF0Zm9ybUZhY3RvcnksIMm1Z2xvYmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyDJtVBMQVRGT1JNX0JST1dTRVJfSUQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgybVJTlRFUk5BTF9CUk9XU0VSX1BMQVRGT1JNX1BST1ZJREVSUyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFJlc291cmNlTG9hZGVySW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlc291cmNlTG9hZGVySW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXNvdXJjZUxvYWRlckltcGwoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgUmVzb3VyY2VMb2FkZXJJbXBsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHZhciByZXNvbHZlO1xuICAgICAgICB2YXIgcmVqZWN0O1xuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMsIHJlaikge1xuICAgICAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgIHJlamVjdCA9IHJlajtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAndGV4dCc7XG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyByZXNwb25zZVRleHQgaXMgdGhlIG9sZC1zY2hvb2wgd2F5IG9mIHJldHJpZXZpbmcgcmVzcG9uc2UgKHN1cHBvcnRlZCBieSBJRTggJiA5KVxuICAgICAgICAgICAgLy8gcmVzcG9uc2UvcmVzcG9uc2VUeXBlIHByb3BlcnRpZXMgd2VyZSBpbnRyb2R1Y2VkIGluIFJlc291cmNlTG9hZGVyIExldmVsMiBzcGVjIChzdXBwb3J0ZWRcbiAgICAgICAgICAgIC8vIGJ5IElFMTApXG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB4aHIucmVzcG9uc2UgfHwgeGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBJRTkgYnVnIChodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwKVxuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzO1xuICAgICAgICAgICAgLy8gZml4IHN0YXR1cyBjb2RlIHdoZW4gaXQgaXMgMCAoMCBzdGF0dXMgaXMgdW5kb2N1bWVudGVkKS5cbiAgICAgICAgICAgIC8vIE9jY3VycyB3aGVuIGFjY2Vzc2luZyBmaWxlIHJlc291cmNlcyBvciBvbiBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXG4gICAgICAgICAgICAvLyB3aGlsZSByZXRyaWV2aW5nIGZpbGVzIGZyb20gYXBwbGljYXRpb24gY2FjaGUuXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gcmVzcG9uc2UgPyAyMDAgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKDIwMCA8PSBzdGF0dXMgJiYgc3RhdHVzIDw9IDMwMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiRmFpbGVkIHRvIGxvYWQgXCIgKyB1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgcmVqZWN0KFwiRmFpbGVkIHRvIGxvYWQgXCIgKyB1cmwpOyB9O1xuICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICAgIHJldHVybiBSZXNvdXJjZUxvYWRlckltcGw7XG59KFJlc291cmNlTG9hZGVyKSk7XG5SZXNvdXJjZUxvYWRlckltcGwuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbl07XG4vKiogQG5vY29sbGFwc2UgKi9cblJlc291cmNlTG9hZGVySW1wbC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIElOVEVSTkFMX0JST1dTRVJfRFlOQU1JQ19QTEFURk9STV9QUk9WSURFUlMgPSBbXG4gICAgybVJTlRFUk5BTF9CUk9XU0VSX1BMQVRGT1JNX1BST1ZJREVSUyxcbiAgICB7XG4gICAgICAgIHByb3ZpZGU6IENPTVBJTEVSX09QVElPTlMsXG4gICAgICAgIHVzZVZhbHVlOiB7IHByb3ZpZGVyczogW3sgcHJvdmlkZTogUmVzb3VyY2VMb2FkZXIsIHVzZUNsYXNzOiBSZXNvdXJjZUxvYWRlckltcGwgfV0gfSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9LFxuICAgIHsgcHJvdmlkZTogUExBVEZPUk1fSUQsIHVzZVZhbHVlOiDJtVBMQVRGT1JNX0JST1dTRVJfSUQgfSxcbl07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIFJlc291cmNlTG9hZGVyIHRoYXQgdXNlcyBhIHRlbXBsYXRlIGNhY2hlIHRvIGF2b2lkIGRvaW5nIGFuIGFjdHVhbFxuICogUmVzb3VyY2VMb2FkZXIuXG4gKlxuICogVGhlIHRlbXBsYXRlIGNhY2hlIG5lZWRzIHRvIGJlIGJ1aWx0IGFuZCBsb2FkZWQgaW50byB3aW5kb3cuJHRlbXBsYXRlQ2FjaGVcbiAqIHZpYSBhIHNlcGFyYXRlIG1lY2hhbmlzbS5cbiAqL1xudmFyIENhY2hlZFJlc291cmNlTG9hZGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2FjaGVkUmVzb3VyY2VMb2FkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FjaGVkUmVzb3VyY2VMb2FkZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9jYWNoZSA9IMm1Z2xvYmFsLiR0ZW1wbGF0ZUNhY2hlO1xuICAgICAgICBpZiAoX3RoaXMuX2NhY2hlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FjaGVkUmVzb3VyY2VMb2FkZXI6IFRlbXBsYXRlIGNhY2hlIHdhcyBub3QgZm91bmQgaW4gJHRlbXBsYXRlQ2FjaGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDYWNoZWRSZXNvdXJjZUxvYWRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICBpZiAodGhpcy5fY2FjaGUuaGFzT3duUHJvcGVydHkodXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9jYWNoZVt1cmxdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FjaGVkUmVzb3VyY2VMb2FkZXI6IERpZCBub3QgZmluZCBjYWNoZWQgdGVtcGxhdGUgZm9yICcgKyB1cmwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2FjaGVkUmVzb3VyY2VMb2FkZXI7XG59KFJlc291cmNlTG9hZGVyKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBtb2R1bGVcbiAqIEBkZXNjcmlwdGlvblxuICogRW50cnkgcG9pbnQgZm9yIGFsbCBwdWJsaWMgQVBJcyBvZiB0aGUgY29tbW9uIHBhY2thZ2UuXG4gKi9cbi8qKlxuICogQHN0YWJsZVxuICovXG52YXIgVkVSU0lPTiA9IG5ldyBWZXJzaW9uKCc0LjEuMCcpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBSRVNPVVJDRV9DQUNIRV9QUk9WSURFUiA9IFt7IHByb3ZpZGU6IFJlc291cmNlTG9hZGVyLCB1c2VDbGFzczogQ2FjaGVkUmVzb3VyY2VMb2FkZXIgfV07XG4vKipcbiAqIEBzdGFibGVcbiAqL1xudmFyIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgPSBjcmVhdGVQbGF0Zm9ybUZhY3RvcnkocGxhdGZvcm1Db3JlRHluYW1pYywgJ2Jyb3dzZXJEeW5hbWljJywgSU5URVJOQUxfQlJPV1NFUl9EWU5BTUlDX1BMQVRGT1JNX1BST1ZJREVSUyk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBtb2R1bGVcbiAqIEBkZXNjcmlwdGlvblxuICogRW50cnkgcG9pbnQgZm9yIGFsbCBwdWJsaWMgQVBJcyBvZiB0aGUgcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljIHBhY2thZ2UuXG4gKi9cbi8vIFRoaXMgZmlsZSBvbmx5IHJlZXhwb3J0cyBjb250ZW50IG9mIHRoZSBgc3JjYCBmb2xkZXIuIEtlZXAgaXQgdGhhdCB3YXkuXG5leHBvcnQgeyBSRVNPVVJDRV9DQUNIRV9QUk9WSURFUiwgcGxhdGZvcm1Ccm93c2VyRHluYW1pYywgVkVSU0lPTiwgSU5URVJOQUxfQlJPV1NFUl9EWU5BTUlDX1BMQVRGT1JNX1BST1ZJREVSUyBhcyDJtUlOVEVSTkFMX0JST1dTRVJfRFlOQU1JQ19QTEFURk9STV9QUk9WSURFUlMsIFJlc291cmNlTG9hZGVySW1wbCBhcyDJtVJlc291cmNlTG9hZGVySW1wbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGxhdGZvcm0tYnJvd3Nlci1keW5hbWljLmVzNS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy5lczUuanNcbi8vIG1vZHVsZSBpZCA9IDIwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 206:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    }return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = __webpack_require__(36);\nvar platform_browser_1 = __webpack_require__(62);\nvar app_component_1 = __webpack_require__(214);\nvar AppModule = function AppModule() {\n    _classCallCheck(this, AppModule);\n};\nAppModule = __decorate([core_1.NgModule({\n    imports: [platform_browser_1.BrowserModule],\n    declarations: [app_component_1.AppComponent],\n    bootstrap: [app_component_1.AppComponent]\n})], AppModule);\nexports.AppModule = AppModule;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcHAubW9kdWxlLnRzPzgwYzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdNb2R1bGUgfSAgICAgIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQnJvd3Nlck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuXG5pbXBvcnQgeyBBcHBDb21wb25lbnQgfSAgZnJvbSAnLi9hcHAuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogICAgICBbIEJyb3dzZXJNb2R1bGUgXSxcbiAgZGVjbGFyYXRpb25zOiBbIEFwcENvbXBvbmVudCBdLFxuICBib290c3RyYXA6ICAgIFsgQXBwQ29tcG9uZW50IF1cbn0pXG5leHBvcnQgY2xhc3MgQXBwTW9kdWxlIHsgfVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zY3JpcHRzL2FwcC5tb2R1bGUudHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFFQTtBQU9BO0FBQUE7O0FBQUE7QUFKQTtBQUNBO0FBQ0E7QUFIQTtBQUtBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 207:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// The file contents for the current environment will overwrite these during build.\n// The build system defaults to the dev environment which uses `environment.ts`, but if you do\n// `ng build --env=prod` then `environment.prod.ts` will be used instead.\n// The list of which env maps to which file can be found in `.angular-cli.json`.\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.environment = {\n    production: false\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9lbnZpcm9ubWVudHMvZW52aXJvbm1lbnQudHM/ZjExNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGUgZmlsZSBjb250ZW50cyBmb3IgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgd2lsbCBvdmVyd3JpdGUgdGhlc2UgZHVyaW5nIGJ1aWxkLlxuLy8gVGhlIGJ1aWxkIHN5c3RlbSBkZWZhdWx0cyB0byB0aGUgZGV2IGVudmlyb25tZW50IHdoaWNoIHVzZXMgYGVudmlyb25tZW50LnRzYCwgYnV0IGlmIHlvdSBkb1xuLy8gYG5nIGJ1aWxkIC0tZW52PXByb2RgIHRoZW4gYGVudmlyb25tZW50LnByb2QudHNgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuLy8gVGhlIGxpc3Qgb2Ygd2hpY2ggZW52IG1hcHMgdG8gd2hpY2ggZmlsZSBjYW4gYmUgZm91bmQgaW4gYC5hbmd1bGFyLWNsaS5qc29uYC5cblxuZXhwb3J0IGNvbnN0IGVudmlyb25tZW50ID0ge1xuICBwcm9kdWN0aW9uOiBmYWxzZVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc2NyaXB0cy9lbnZpcm9ubWVudHMvZW52aXJvbm1lbnQudHMiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFEQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 209:
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vY3NzL3N0eWxlcy5zY3NzP2E2YmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Nzcy9zdHlsZXMuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMjA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 213:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(36);\n/* unused harmony export VERSION */\n/* unused harmony export TEMPLATE_TRANSFORMS */\n/* unused harmony export CompilerConfig */\n/* unused harmony export JitCompiler */\n/* unused harmony export DirectiveResolver */\n/* unused harmony export PipeResolver */\n/* unused harmony export NgModuleResolver */\n/* unused harmony export DEFAULT_INTERPOLATION_CONFIG */\n/* unused harmony export InterpolationConfig */\n/* unused harmony export NgModuleCompiler */\n/* unused harmony export ViewCompiler */\n/* unused harmony export isSyntaxError */\n/* unused harmony export syntaxError */\n/* unused harmony export TextAst */\n/* unused harmony export BoundTextAst */\n/* unused harmony export AttrAst */\n/* unused harmony export BoundElementPropertyAst */\n/* unused harmony export BoundEventAst */\n/* unused harmony export ReferenceAst */\n/* unused harmony export VariableAst */\n/* unused harmony export ElementAst */\n/* unused harmony export EmbeddedTemplateAst */\n/* unused harmony export BoundDirectivePropertyAst */\n/* unused harmony export DirectiveAst */\n/* unused harmony export ProviderAst */\n/* unused harmony export ProviderAstType */\n/* unused harmony export NgContentAst */\n/* unused harmony export PropertyBindingType */\n/* unused harmony export templateVisitAll */\n/* unused harmony export CompileAnimationEntryMetadata */\n/* unused harmony export CompileAnimationStateMetadata */\n/* unused harmony export CompileAnimationStateDeclarationMetadata */\n/* unused harmony export CompileAnimationStateTransitionMetadata */\n/* unused harmony export CompileAnimationMetadata */\n/* unused harmony export CompileAnimationKeyframesSequenceMetadata */\n/* unused harmony export CompileAnimationStyleMetadata */\n/* unused harmony export CompileAnimationAnimateMetadata */\n/* unused harmony export CompileAnimationWithStepsMetadata */\n/* unused harmony export CompileAnimationSequenceMetadata */\n/* unused harmony export CompileAnimationGroupMetadata */\n/* unused harmony export identifierName */\n/* unused harmony export identifierModuleUrl */\n/* unused harmony export viewClassName */\n/* unused harmony export rendererTypeName */\n/* unused harmony export hostViewClassName */\n/* unused harmony export dirWrapperClassName */\n/* unused harmony export componentFactoryName */\n/* unused harmony export CompileSummaryKind */\n/* unused harmony export tokenName */\n/* unused harmony export tokenReference */\n/* unused harmony export CompileStylesheetMetadata */\n/* unused harmony export CompileTemplateMetadata */\n/* unused harmony export CompileDirectiveMetadata */\n/* unused harmony export createHostComponentMeta */\n/* unused harmony export CompilePipeMetadata */\n/* unused harmony export CompileNgModuleMetadata */\n/* unused harmony export TransitiveCompileNgModuleMetadata */\n/* unused harmony export ProviderMeta */\n/* unused harmony export flatten */\n/* unused harmony export sourceUrl */\n/* unused harmony export templateSourceUrl */\n/* unused harmony export sharedStylesheetJitUrl */\n/* unused harmony export ngModuleJitUrl */\n/* unused harmony export templateJitUrl */\n/* unused harmony export createAotCompiler */\n/* unused harmony export AotCompiler */\n/* unused harmony export analyzeNgModules */\n/* unused harmony export analyzeAndValidateNgModules */\n/* unused harmony export extractProgramSymbols */\n/* unused harmony export GeneratedFile */\n/* unused harmony export StaticReflector */\n/* unused harmony export StaticAndDynamicReflectionCapabilities */\n/* unused harmony export StaticSymbol */\n/* unused harmony export StaticSymbolCache */\n/* unused harmony export ResolvedStaticSymbol */\n/* unused harmony export StaticSymbolResolver */\n/* unused harmony export unescapeIdentifier */\n/* unused harmony export AotSummaryResolver */\n/* unused harmony export SummaryResolver */\n/* unused harmony export i18nHtmlParserFactory */\n/* unused harmony export COMPILER_PROVIDERS */\n/* unused harmony export JitCompilerFactory */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return platformCoreDynamic; });\n/* unused harmony export createUrlResolverWithoutPackagePrefix */\n/* unused harmony export createOfflineCompileUrlResolver */\n/* unused harmony export DEFAULT_PACKAGE_URL_PROVIDER */\n/* unused harmony export UrlResolver */\n/* unused harmony export getUrlScheme */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return ResourceLoader; });\n/* unused harmony export ElementSchemaRegistry */\n/* unused harmony export Extractor */\n/* unused harmony export I18NHtmlParser */\n/* unused harmony export MessageBundle */\n/* unused harmony export Serializer */\n/* unused harmony export Xliff */\n/* unused harmony export Xliff2 */\n/* unused harmony export Xmb */\n/* unused harmony export Xtb */\n/* unused harmony export DirectiveNormalizer */\n/* unused harmony export ParserError */\n/* unused harmony export ParseSpan */\n/* unused harmony export AST */\n/* unused harmony export Quote */\n/* unused harmony export EmptyExpr */\n/* unused harmony export ImplicitReceiver */\n/* unused harmony export Chain */\n/* unused harmony export Conditional */\n/* unused harmony export PropertyRead */\n/* unused harmony export PropertyWrite */\n/* unused harmony export SafePropertyRead */\n/* unused harmony export KeyedRead */\n/* unused harmony export KeyedWrite */\n/* unused harmony export BindingPipe */\n/* unused harmony export LiteralPrimitive */\n/* unused harmony export LiteralArray */\n/* unused harmony export LiteralMap */\n/* unused harmony export Interpolation */\n/* unused harmony export Binary */\n/* unused harmony export PrefixNot */\n/* unused harmony export MethodCall */\n/* unused harmony export SafeMethodCall */\n/* unused harmony export FunctionCall */\n/* unused harmony export ASTWithSource */\n/* unused harmony export TemplateBinding */\n/* unused harmony export RecursiveAstVisitor */\n/* unused harmony export AstTransformer */\n/* unused harmony export TokenType */\n/* unused harmony export Lexer */\n/* unused harmony export Token */\n/* unused harmony export EOF */\n/* unused harmony export isIdentifier */\n/* unused harmony export isQuote */\n/* unused harmony export SplitInterpolation */\n/* unused harmony export TemplateBindingParseResult */\n/* unused harmony export Parser */\n/* unused harmony export _ParseAST */\n/* unused harmony export ERROR_COLLECTOR_TOKEN */\n/* unused harmony export CompileMetadataResolver */\n/* unused harmony export componentModuleUrl */\n/* unused harmony export Text */\n/* unused harmony export Expansion */\n/* unused harmony export ExpansionCase */\n/* unused harmony export Attribute */\n/* unused harmony export Element */\n/* unused harmony export Comment */\n/* unused harmony export visitAll */\n/* unused harmony export ParseTreeResult */\n/* unused harmony export TreeError */\n/* unused harmony export HtmlParser */\n/* unused harmony export HtmlTagDefinition */\n/* unused harmony export getHtmlTagDefinition */\n/* unused harmony export TagContentType */\n/* unused harmony export splitNsName */\n/* unused harmony export isNgContainer */\n/* unused harmony export isNgContent */\n/* unused harmony export isNgTemplate */\n/* unused harmony export getNsPrefix */\n/* unused harmony export mergeNsAndName */\n/* unused harmony export NAMED_ENTITIES */\n/* unused harmony export ImportResolver */\n/* unused harmony export debugOutputAstAsTypeScript */\n/* unused harmony export TypeScriptEmitter */\n/* unused harmony export ParseLocation */\n/* unused harmony export ParseSourceFile */\n/* unused harmony export ParseSourceSpan */\n/* unused harmony export ParseErrorLevel */\n/* unused harmony export ParseError */\n/* unused harmony export typeSourceSpan */\n/* unused harmony export DomElementSchemaRegistry */\n/* unused harmony export CssSelector */\n/* unused harmony export SelectorMatcher */\n/* unused harmony export SelectorListContext */\n/* unused harmony export SelectorContext */\n/* unused harmony export StylesCompileDependency */\n/* unused harmony export StylesCompileResult */\n/* unused harmony export CompiledStylesheet */\n/* unused harmony export StyleCompiler */\n/* unused harmony export TemplateParseError */\n/* unused harmony export TemplateParseResult */\n/* unused harmony export TemplateParser */\n/* unused harmony export splitClasses */\n/* unused harmony export createElementCssSelector */\n/* unused harmony export removeSummaryDuplicates */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * @license Angular v4.1.0\n * (c) 2010-2017 Google, Inc. https://angular.io/\n * License: MIT\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the common package.\n */\n/**\n * \\@stable\n */\nvar VERSION = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Version\"]('4.1.0');\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A segment of text within the template.\n */\nvar TextAst = (function () {\n    /**\n     * @param {?} value\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    function TextAst(value, ngContentIndex, sourceSpan) {\n        this.value = value;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    TextAst.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\n    return TextAst;\n}());\n/**\n * A bound expression within the text of a template.\n */\nvar BoundTextAst = (function () {\n    /**\n     * @param {?} value\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    function BoundTextAst(value, ngContentIndex, sourceSpan) {\n        this.value = value;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BoundTextAst.prototype.visit = function (visitor, context) {\n        return visitor.visitBoundText(this, context);\n    };\n    return BoundTextAst;\n}());\n/**\n * A plain attribute on an element.\n */\nvar AttrAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function AttrAst(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    AttrAst.prototype.visit = function (visitor, context) { return visitor.visitAttr(this, context); };\n    return AttrAst;\n}());\n/**\n * A binding for an element property (e.g. `[property]=\"expression\"`) or an animation trigger (e.g.\n * `[\\@trigger]=\"stateExp\"`)\n */\nvar BoundElementPropertyAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} type\n     * @param {?} securityContext\n     * @param {?} value\n     * @param {?} unit\n     * @param {?} sourceSpan\n     */\n    function BoundElementPropertyAst(name, type, securityContext, value, unit, sourceSpan) {\n        this.name = name;\n        this.type = type;\n        this.securityContext = securityContext;\n        this.value = value;\n        this.unit = unit;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BoundElementPropertyAst.prototype.visit = function (visitor, context) {\n        return visitor.visitElementProperty(this, context);\n    };\n    Object.defineProperty(BoundElementPropertyAst.prototype, \"isAnimation\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.type === PropertyBindingType.Animation; },\n        enumerable: true,\n        configurable: true\n    });\n    return BoundElementPropertyAst;\n}());\n/**\n * A binding for an element event (e.g. `(event)=\"handler()\"`) or an animation trigger event (e.g.\n * `(\\@trigger.phase)=\"callback($event)\"`).\n */\nvar BoundEventAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} target\n     * @param {?} phase\n     * @param {?} handler\n     * @param {?} sourceSpan\n     */\n    function BoundEventAst(name, target, phase, handler, sourceSpan) {\n        this.name = name;\n        this.target = target;\n        this.phase = phase;\n        this.handler = handler;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} name\n     * @param {?} target\n     * @param {?} phase\n     * @return {?}\n     */\n    BoundEventAst.calcFullName = function (name, target, phase) {\n        if (target) {\n            return target + \":\" + name;\n        }\n        else if (phase) {\n            return \"@\" + name + \".\" + phase;\n        }\n        else {\n            return name;\n        }\n    };\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BoundEventAst.prototype.visit = function (visitor, context) {\n        return visitor.visitEvent(this, context);\n    };\n    Object.defineProperty(BoundEventAst.prototype, \"fullName\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return BoundEventAst.calcFullName(this.name, this.target, this.phase); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BoundEventAst.prototype, \"isAnimation\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return !!this.phase; },\n        enumerable: true,\n        configurable: true\n    });\n    return BoundEventAst;\n}());\n/**\n * A reference declaration on an element (e.g. `let someName=\"expression\"`).\n */\nvar ReferenceAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function ReferenceAst(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReferenceAst.prototype.visit = function (visitor, context) {\n        return visitor.visitReference(this, context);\n    };\n    return ReferenceAst;\n}());\n/**\n * A variable declaration on a <ng-template> (e.g. `var-someName=\"someLocalName\"`).\n */\nvar VariableAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function VariableAst(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    VariableAst.prototype.visit = function (visitor, context) {\n        return visitor.visitVariable(this, context);\n    };\n    return VariableAst;\n}());\n/**\n * An element declaration in a template.\n */\nvar ElementAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} attrs\n     * @param {?} inputs\n     * @param {?} outputs\n     * @param {?} references\n     * @param {?} directives\n     * @param {?} providers\n     * @param {?} hasViewContainer\n     * @param {?} queryMatches\n     * @param {?} children\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     * @param {?} endSourceSpan\n     */\n    function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan, endSourceSpan) {\n        this.name = name;\n        this.attrs = attrs;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.references = references;\n        this.directives = directives;\n        this.providers = providers;\n        this.hasViewContainer = hasViewContainer;\n        this.queryMatches = queryMatches;\n        this.children = children;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n        this.endSourceSpan = endSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ElementAst.prototype.visit = function (visitor, context) {\n        return visitor.visitElement(this, context);\n    };\n    return ElementAst;\n}());\n/**\n * A `<ng-template>` element included in an Angular template.\n */\nvar EmbeddedTemplateAst = (function () {\n    /**\n     * @param {?} attrs\n     * @param {?} outputs\n     * @param {?} references\n     * @param {?} variables\n     * @param {?} directives\n     * @param {?} providers\n     * @param {?} hasViewContainer\n     * @param {?} queryMatches\n     * @param {?} children\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan) {\n        this.attrs = attrs;\n        this.outputs = outputs;\n        this.references = references;\n        this.variables = variables;\n        this.directives = directives;\n        this.providers = providers;\n        this.hasViewContainer = hasViewContainer;\n        this.queryMatches = queryMatches;\n        this.children = children;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    EmbeddedTemplateAst.prototype.visit = function (visitor, context) {\n        return visitor.visitEmbeddedTemplate(this, context);\n    };\n    return EmbeddedTemplateAst;\n}());\n/**\n * A directive property with a bound value (e.g. `*ngIf=\"condition\").\n */\nvar BoundDirectivePropertyAst = (function () {\n    /**\n     * @param {?} directiveName\n     * @param {?} templateName\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {\n        this.directiveName = directiveName;\n        this.templateName = templateName;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BoundDirectivePropertyAst.prototype.visit = function (visitor, context) {\n        return visitor.visitDirectiveProperty(this, context);\n    };\n    return BoundDirectivePropertyAst;\n}());\n/**\n * A directive declared on an element.\n */\nvar DirectiveAst = (function () {\n    /**\n     * @param {?} directive\n     * @param {?} inputs\n     * @param {?} hostProperties\n     * @param {?} hostEvents\n     * @param {?} contentQueryStartId\n     * @param {?} sourceSpan\n     */\n    function DirectiveAst(directive, inputs, hostProperties, hostEvents, contentQueryStartId, sourceSpan) {\n        this.directive = directive;\n        this.inputs = inputs;\n        this.hostProperties = hostProperties;\n        this.hostEvents = hostEvents;\n        this.contentQueryStartId = contentQueryStartId;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    DirectiveAst.prototype.visit = function (visitor, context) {\n        return visitor.visitDirective(this, context);\n    };\n    return DirectiveAst;\n}());\n/**\n * A provider declared on an element\n */\nvar ProviderAst = (function () {\n    /**\n     * @param {?} token\n     * @param {?} multiProvider\n     * @param {?} eager\n     * @param {?} providers\n     * @param {?} providerType\n     * @param {?} lifecycleHooks\n     * @param {?} sourceSpan\n     */\n    function ProviderAst(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan) {\n        this.token = token;\n        this.multiProvider = multiProvider;\n        this.eager = eager;\n        this.providers = providers;\n        this.providerType = providerType;\n        this.lifecycleHooks = lifecycleHooks;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ProviderAst.prototype.visit = function (visitor, context) {\n        // No visit method in the visitor for now...\n        return null;\n    };\n    return ProviderAst;\n}());\nvar ProviderAstType = {};\nProviderAstType.PublicService = 0;\nProviderAstType.PrivateService = 1;\nProviderAstType.Component = 2;\nProviderAstType.Directive = 3;\nProviderAstType.Builtin = 4;\nProviderAstType[ProviderAstType.PublicService] = \"PublicService\";\nProviderAstType[ProviderAstType.PrivateService] = \"PrivateService\";\nProviderAstType[ProviderAstType.Component] = \"Component\";\nProviderAstType[ProviderAstType.Directive] = \"Directive\";\nProviderAstType[ProviderAstType.Builtin] = \"Builtin\";\n/**\n * Position where content is to be projected (instance of `<ng-content>` in a template).\n */\nvar NgContentAst = (function () {\n    /**\n     * @param {?} index\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    function NgContentAst(index, ngContentIndex, sourceSpan) {\n        this.index = index;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    NgContentAst.prototype.visit = function (visitor, context) {\n        return visitor.visitNgContent(this, context);\n    };\n    return NgContentAst;\n}());\nvar PropertyBindingType = {};\nPropertyBindingType.Property = 0;\nPropertyBindingType.Attribute = 1;\nPropertyBindingType.Class = 2;\nPropertyBindingType.Style = 3;\nPropertyBindingType.Animation = 4;\nPropertyBindingType[PropertyBindingType.Property] = \"Property\";\nPropertyBindingType[PropertyBindingType.Attribute] = \"Attribute\";\nPropertyBindingType[PropertyBindingType.Class] = \"Class\";\nPropertyBindingType[PropertyBindingType.Style] = \"Style\";\nPropertyBindingType[PropertyBindingType.Animation] = \"Animation\";\n/**\n * Visit every node in a list of {\\@link TemplateAst}s with the given {\\@link TemplateAstVisitor}.\n * @param {?} visitor\n * @param {?} asts\n * @param {?=} context\n * @return {?}\n */\nfunction templateVisitAll(visitor, asts, context) {\n    if (context === void 0) { context = null; }\n    var /** @type {?} */ result = [];\n    var /** @type {?} */ visit = visitor.visit ?\n        function (ast) { return ((visitor.visit))(ast, context) || ast.visit(visitor, context); } :\n        function (ast) { return ast.visit(visitor, context); };\n    asts.forEach(function (ast) {\n        var /** @type {?} */ astResult = visit(ast);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\n/**\n * A token representing the a reference to a static type.\n *\n * This token is unique for a filePath and name and can be used as a hash table key.\n */\nvar StaticSymbol = (function () {\n    /**\n     * @param {?} filePath\n     * @param {?} name\n     * @param {?} members\n     */\n    function StaticSymbol(filePath, name, members) {\n        this.filePath = filePath;\n        this.name = name;\n        this.members = members;\n    }\n    /**\n     * @return {?}\n     */\n    StaticSymbol.prototype.assertNoMembers = function () {\n        if (this.members.length) {\n            throw new Error(\"Illegal state: symbol without members expected, but got \" + JSON.stringify(this) + \".\");\n        }\n    };\n    return StaticSymbol;\n}());\n/**\n * A cache of static symbol used by the StaticReflector to return the same symbol for the\n * same symbol values.\n */\nvar StaticSymbolCache = (function () {\n    function StaticSymbolCache() {\n        this.cache = new Map();\n    }\n    /**\n     * @param {?} declarationFile\n     * @param {?} name\n     * @param {?=} members\n     * @return {?}\n     */\n    StaticSymbolCache.prototype.get = function (declarationFile, name, members) {\n        members = members || [];\n        var /** @type {?} */ memberSuffix = members.length ? \".\" + members.join('.') : '';\n        var /** @type {?} */ key = \"\\\"\" + declarationFile + \"\\\".\" + name + memberSuffix;\n        var /** @type {?} */ result = this.cache.get(key);\n        if (!result) {\n            result = new StaticSymbol(declarationFile, name, members);\n            this.cache.set(key, result);\n        }\n        return result;\n    };\n    return StaticSymbolCache;\n}());\nvar TagContentType = {};\nTagContentType.RAW_TEXT = 0;\nTagContentType.ESCAPABLE_RAW_TEXT = 1;\nTagContentType.PARSABLE_DATA = 2;\nTagContentType[TagContentType.RAW_TEXT] = \"RAW_TEXT\";\nTagContentType[TagContentType.ESCAPABLE_RAW_TEXT] = \"ESCAPABLE_RAW_TEXT\";\nTagContentType[TagContentType.PARSABLE_DATA] = \"PARSABLE_DATA\";\n/**\n * @param {?} elementName\n * @return {?}\n */\nfunction splitNsName(elementName) {\n    if (elementName[0] != ':') {\n        return [null, elementName];\n    }\n    var /** @type {?} */ colonIndex = elementName.indexOf(':', 1);\n    if (colonIndex == -1) {\n        throw new Error(\"Unsupported format \\\"\" + elementName + \"\\\" expecting \\\":namespace:name\\\"\");\n    }\n    return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n/**\n * @param {?} tagName\n * @return {?}\n */\nfunction isNgContainer(tagName) {\n    return splitNsName(tagName)[1] === 'ng-container';\n}\n/**\n * @param {?} tagName\n * @return {?}\n */\nfunction isNgContent(tagName) {\n    return splitNsName(tagName)[1] === 'ng-content';\n}\n/**\n * @param {?} tagName\n * @return {?}\n */\nfunction isNgTemplate(tagName) {\n    return splitNsName(tagName)[1] === 'ng-template';\n}\n/**\n * @param {?} fullName\n * @return {?}\n */\nfunction getNsPrefix(fullName) {\n    return fullName === null ? null : splitNsName(fullName)[0];\n}\n/**\n * @param {?} prefix\n * @param {?} localName\n * @return {?}\n */\nfunction mergeNsAndName(prefix, localName) {\n    return prefix ? \":\" + prefix + \":\" + localName : localName;\n}\n// see http://www.w3.org/TR/html51/syntax.html#named-character-references\n// see https://html.spec.whatwg.org/multipage/entities.json\n// This list is not exhaustive to keep the compiler footprint low.\n// The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not\n// exist.\nvar NAMED_ENTITIES = {\n    'Aacute': '\\u00C1',\n    'aacute': '\\u00E1',\n    'Acirc': '\\u00C2',\n    'acirc': '\\u00E2',\n    'acute': '\\u00B4',\n    'AElig': '\\u00C6',\n    'aelig': '\\u00E6',\n    'Agrave': '\\u00C0',\n    'agrave': '\\u00E0',\n    'alefsym': '\\u2135',\n    'Alpha': '\\u0391',\n    'alpha': '\\u03B1',\n    'amp': '&',\n    'and': '\\u2227',\n    'ang': '\\u2220',\n    'apos': '\\u0027',\n    'Aring': '\\u00C5',\n    'aring': '\\u00E5',\n    'asymp': '\\u2248',\n    'Atilde': '\\u00C3',\n    'atilde': '\\u00E3',\n    'Auml': '\\u00C4',\n    'auml': '\\u00E4',\n    'bdquo': '\\u201E',\n    'Beta': '\\u0392',\n    'beta': '\\u03B2',\n    'brvbar': '\\u00A6',\n    'bull': '\\u2022',\n    'cap': '\\u2229',\n    'Ccedil': '\\u00C7',\n    'ccedil': '\\u00E7',\n    'cedil': '\\u00B8',\n    'cent': '\\u00A2',\n    'Chi': '\\u03A7',\n    'chi': '\\u03C7',\n    'circ': '\\u02C6',\n    'clubs': '\\u2663',\n    'cong': '\\u2245',\n    'copy': '\\u00A9',\n    'crarr': '\\u21B5',\n    'cup': '\\u222A',\n    'curren': '\\u00A4',\n    'dagger': '\\u2020',\n    'Dagger': '\\u2021',\n    'darr': '\\u2193',\n    'dArr': '\\u21D3',\n    'deg': '\\u00B0',\n    'Delta': '\\u0394',\n    'delta': '\\u03B4',\n    'diams': '\\u2666',\n    'divide': '\\u00F7',\n    'Eacute': '\\u00C9',\n    'eacute': '\\u00E9',\n    'Ecirc': '\\u00CA',\n    'ecirc': '\\u00EA',\n    'Egrave': '\\u00C8',\n    'egrave': '\\u00E8',\n    'empty': '\\u2205',\n    'emsp': '\\u2003',\n    'ensp': '\\u2002',\n    'Epsilon': '\\u0395',\n    'epsilon': '\\u03B5',\n    'equiv': '\\u2261',\n    'Eta': '\\u0397',\n    'eta': '\\u03B7',\n    'ETH': '\\u00D0',\n    'eth': '\\u00F0',\n    'Euml': '\\u00CB',\n    'euml': '\\u00EB',\n    'euro': '\\u20AC',\n    'exist': '\\u2203',\n    'fnof': '\\u0192',\n    'forall': '\\u2200',\n    'frac12': '\\u00BD',\n    'frac14': '\\u00BC',\n    'frac34': '\\u00BE',\n    'frasl': '\\u2044',\n    'Gamma': '\\u0393',\n    'gamma': '\\u03B3',\n    'ge': '\\u2265',\n    'gt': '>',\n    'harr': '\\u2194',\n    'hArr': '\\u21D4',\n    'hearts': '\\u2665',\n    'hellip': '\\u2026',\n    'Iacute': '\\u00CD',\n    'iacute': '\\u00ED',\n    'Icirc': '\\u00CE',\n    'icirc': '\\u00EE',\n    'iexcl': '\\u00A1',\n    'Igrave': '\\u00CC',\n    'igrave': '\\u00EC',\n    'image': '\\u2111',\n    'infin': '\\u221E',\n    'int': '\\u222B',\n    'Iota': '\\u0399',\n    'iota': '\\u03B9',\n    'iquest': '\\u00BF',\n    'isin': '\\u2208',\n    'Iuml': '\\u00CF',\n    'iuml': '\\u00EF',\n    'Kappa': '\\u039A',\n    'kappa': '\\u03BA',\n    'Lambda': '\\u039B',\n    'lambda': '\\u03BB',\n    'lang': '\\u27E8',\n    'laquo': '\\u00AB',\n    'larr': '\\u2190',\n    'lArr': '\\u21D0',\n    'lceil': '\\u2308',\n    'ldquo': '\\u201C',\n    'le': '\\u2264',\n    'lfloor': '\\u230A',\n    'lowast': '\\u2217',\n    'loz': '\\u25CA',\n    'lrm': '\\u200E',\n    'lsaquo': '\\u2039',\n    'lsquo': '\\u2018',\n    'lt': '<',\n    'macr': '\\u00AF',\n    'mdash': '\\u2014',\n    'micro': '\\u00B5',\n    'middot': '\\u00B7',\n    'minus': '\\u2212',\n    'Mu': '\\u039C',\n    'mu': '\\u03BC',\n    'nabla': '\\u2207',\n    'nbsp': '\\u00A0',\n    'ndash': '\\u2013',\n    'ne': '\\u2260',\n    'ni': '\\u220B',\n    'not': '\\u00AC',\n    'notin': '\\u2209',\n    'nsub': '\\u2284',\n    'Ntilde': '\\u00D1',\n    'ntilde': '\\u00F1',\n    'Nu': '\\u039D',\n    'nu': '\\u03BD',\n    'Oacute': '\\u00D3',\n    'oacute': '\\u00F3',\n    'Ocirc': '\\u00D4',\n    'ocirc': '\\u00F4',\n    'OElig': '\\u0152',\n    'oelig': '\\u0153',\n    'Ograve': '\\u00D2',\n    'ograve': '\\u00F2',\n    'oline': '\\u203E',\n    'Omega': '\\u03A9',\n    'omega': '\\u03C9',\n    'Omicron': '\\u039F',\n    'omicron': '\\u03BF',\n    'oplus': '\\u2295',\n    'or': '\\u2228',\n    'ordf': '\\u00AA',\n    'ordm': '\\u00BA',\n    'Oslash': '\\u00D8',\n    'oslash': '\\u00F8',\n    'Otilde': '\\u00D5',\n    'otilde': '\\u00F5',\n    'otimes': '\\u2297',\n    'Ouml': '\\u00D6',\n    'ouml': '\\u00F6',\n    'para': '\\u00B6',\n    'permil': '\\u2030',\n    'perp': '\\u22A5',\n    'Phi': '\\u03A6',\n    'phi': '\\u03C6',\n    'Pi': '\\u03A0',\n    'pi': '\\u03C0',\n    'piv': '\\u03D6',\n    'plusmn': '\\u00B1',\n    'pound': '\\u00A3',\n    'prime': '\\u2032',\n    'Prime': '\\u2033',\n    'prod': '\\u220F',\n    'prop': '\\u221D',\n    'Psi': '\\u03A8',\n    'psi': '\\u03C8',\n    'quot': '\\u0022',\n    'radic': '\\u221A',\n    'rang': '\\u27E9',\n    'raquo': '\\u00BB',\n    'rarr': '\\u2192',\n    'rArr': '\\u21D2',\n    'rceil': '\\u2309',\n    'rdquo': '\\u201D',\n    'real': '\\u211C',\n    'reg': '\\u00AE',\n    'rfloor': '\\u230B',\n    'Rho': '\\u03A1',\n    'rho': '\\u03C1',\n    'rlm': '\\u200F',\n    'rsaquo': '\\u203A',\n    'rsquo': '\\u2019',\n    'sbquo': '\\u201A',\n    'Scaron': '\\u0160',\n    'scaron': '\\u0161',\n    'sdot': '\\u22C5',\n    'sect': '\\u00A7',\n    'shy': '\\u00AD',\n    'Sigma': '\\u03A3',\n    'sigma': '\\u03C3',\n    'sigmaf': '\\u03C2',\n    'sim': '\\u223C',\n    'spades': '\\u2660',\n    'sub': '\\u2282',\n    'sube': '\\u2286',\n    'sum': '\\u2211',\n    'sup': '\\u2283',\n    'sup1': '\\u00B9',\n    'sup2': '\\u00B2',\n    'sup3': '\\u00B3',\n    'supe': '\\u2287',\n    'szlig': '\\u00DF',\n    'Tau': '\\u03A4',\n    'tau': '\\u03C4',\n    'there4': '\\u2234',\n    'Theta': '\\u0398',\n    'theta': '\\u03B8',\n    'thetasym': '\\u03D1',\n    'thinsp': '\\u2009',\n    'THORN': '\\u00DE',\n    'thorn': '\\u00FE',\n    'tilde': '\\u02DC',\n    'times': '\\u00D7',\n    'trade': '\\u2122',\n    'Uacute': '\\u00DA',\n    'uacute': '\\u00FA',\n    'uarr': '\\u2191',\n    'uArr': '\\u21D1',\n    'Ucirc': '\\u00DB',\n    'ucirc': '\\u00FB',\n    'Ugrave': '\\u00D9',\n    'ugrave': '\\u00F9',\n    'uml': '\\u00A8',\n    'upsih': '\\u03D2',\n    'Upsilon': '\\u03A5',\n    'upsilon': '\\u03C5',\n    'Uuml': '\\u00DC',\n    'uuml': '\\u00FC',\n    'weierp': '\\u2118',\n    'Xi': '\\u039E',\n    'xi': '\\u03BE',\n    'Yacute': '\\u00DD',\n    'yacute': '\\u00FD',\n    'yen': '\\u00A5',\n    'yuml': '\\u00FF',\n    'Yuml': '\\u0178',\n    'Zeta': '\\u0396',\n    'zeta': '\\u03B6',\n    'zwj': '\\u200D',\n    'zwnj': '\\u200C',\n};\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar HtmlTagDefinition = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function HtmlTagDefinition(_a) {\n        var _b = _a === void 0 ? {} : _a, closedByChildren = _b.closedByChildren, requiredParents = _b.requiredParents, implicitNamespacePrefix = _b.implicitNamespacePrefix, _c = _b.contentType, contentType = _c === void 0 ? TagContentType.PARSABLE_DATA : _c, _d = _b.closedByParent, closedByParent = _d === void 0 ? false : _d, _e = _b.isVoid, isVoid = _e === void 0 ? false : _e, _f = _b.ignoreFirstLf, ignoreFirstLf = _f === void 0 ? false : _f;\n        var _this = this;\n        this.closedByChildren = {};\n        this.closedByParent = false;\n        this.canSelfClose = false;\n        if (closedByChildren && closedByChildren.length > 0) {\n            closedByChildren.forEach(function (tagName) { return _this.closedByChildren[tagName] = true; });\n        }\n        this.isVoid = isVoid;\n        this.closedByParent = closedByParent || isVoid;\n        if (requiredParents && requiredParents.length > 0) {\n            this.requiredParents = {};\n            // The first parent is the list is automatically when none of the listed parents are present\n            this.parentToAdd = requiredParents[0];\n            requiredParents.forEach(function (tagName) { return _this.requiredParents[tagName] = true; });\n        }\n        this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n        this.contentType = contentType;\n        this.ignoreFirstLf = ignoreFirstLf;\n    }\n    /**\n     * @param {?} currentParent\n     * @return {?}\n     */\n    HtmlTagDefinition.prototype.requireExtraParent = function (currentParent) {\n        if (!this.requiredParents) {\n            return false;\n        }\n        if (!currentParent) {\n            return true;\n        }\n        var /** @type {?} */ lcParent = currentParent.toLowerCase();\n        var /** @type {?} */ isParentTemplate = lcParent === 'template' || currentParent === 'ng-template';\n        return !isParentTemplate && this.requiredParents[lcParent] != true;\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    HtmlTagDefinition.prototype.isClosedByChild = function (name) {\n        return this.isVoid || name.toLowerCase() in this.closedByChildren;\n    };\n    return HtmlTagDefinition;\n}());\n// see http://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\nvar TAG_DEFINITIONS = {\n    'base': new HtmlTagDefinition({ isVoid: true }),\n    'meta': new HtmlTagDefinition({ isVoid: true }),\n    'area': new HtmlTagDefinition({ isVoid: true }),\n    'embed': new HtmlTagDefinition({ isVoid: true }),\n    'link': new HtmlTagDefinition({ isVoid: true }),\n    'img': new HtmlTagDefinition({ isVoid: true }),\n    'input': new HtmlTagDefinition({ isVoid: true }),\n    'param': new HtmlTagDefinition({ isVoid: true }),\n    'hr': new HtmlTagDefinition({ isVoid: true }),\n    'br': new HtmlTagDefinition({ isVoid: true }),\n    'source': new HtmlTagDefinition({ isVoid: true }),\n    'track': new HtmlTagDefinition({ isVoid: true }),\n    'wbr': new HtmlTagDefinition({ isVoid: true }),\n    'p': new HtmlTagDefinition({\n        closedByChildren: [\n            'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form',\n            'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr',\n            'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'\n        ],\n        closedByParent: true\n    }),\n    'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),\n    'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),\n    'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),\n    'tr': new HtmlTagDefinition({\n        closedByChildren: ['tr'],\n        requiredParents: ['tbody', 'tfoot', 'thead'],\n        closedByParent: true\n    }),\n    'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n    'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n    'col': new HtmlTagDefinition({ requiredParents: ['colgroup'], isVoid: true }),\n    'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),\n    'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),\n    'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),\n    'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),\n    'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),\n    'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n    'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n    'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),\n    'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n    'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),\n    'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),\n    'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),\n    'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),\n    'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n    'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n    'title': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT }),\n    'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),\n};\nvar _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\n/**\n * @param {?} tagName\n * @return {?}\n */\nfunction getHtmlTagDefinition(tagName) {\n    return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _SELECTOR_REGEXP = new RegExp('(\\\\:not\\\\()|' +\n    '([-\\\\w]+)|' +\n    '(?:\\\\.([-\\\\w]+))|' +\n    // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n    '(?:\\\\[([-.\\\\w*]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' +\n    // \"[name=\"value\"]\",\n    // \"[name='value']\"\n    '(\\\\))|' +\n    '(\\\\s*,\\\\s*)', // \",\"\n'g');\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nvar CssSelector = (function () {\n    function CssSelector() {\n        this.element = null;\n        this.classNames = [];\n        this.attrs = [];\n        this.notSelectors = [];\n    }\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    CssSelector.parse = function (selector) {\n        var /** @type {?} */ results = [];\n        var /** @type {?} */ _addResult = function (res, cssSel) {\n            if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n                cssSel.attrs.length == 0) {\n                cssSel.element = '*';\n            }\n            res.push(cssSel);\n        };\n        var /** @type {?} */ cssSelector = new CssSelector();\n        var /** @type {?} */ match;\n        var /** @type {?} */ current = cssSelector;\n        var /** @type {?} */ inNot = false;\n        _SELECTOR_REGEXP.lastIndex = 0;\n        while (match = _SELECTOR_REGEXP.exec(selector)) {\n            if (match[1]) {\n                if (inNot) {\n                    throw new Error('Nesting :not is not allowed in a selector');\n                }\n                inNot = true;\n                current = new CssSelector();\n                cssSelector.notSelectors.push(current);\n            }\n            if (match[2]) {\n                current.setElement(match[2]);\n            }\n            if (match[3]) {\n                current.addClassName(match[3]);\n            }\n            if (match[4]) {\n                current.addAttribute(match[4], match[6]);\n            }\n            if (match[7]) {\n                inNot = false;\n                current = cssSelector;\n            }\n            if (match[8]) {\n                if (inNot) {\n                    throw new Error('Multiple selectors in :not are not supported');\n                }\n                _addResult(results, cssSelector);\n                cssSelector = current = new CssSelector();\n            }\n        }\n        _addResult(results, cssSelector);\n        return results;\n    };\n    /**\n     * @return {?}\n     */\n    CssSelector.prototype.isElementSelector = function () {\n        return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n            this.notSelectors.length === 0;\n    };\n    /**\n     * @return {?}\n     */\n    CssSelector.prototype.hasElementSelector = function () { return !!this.element; };\n    /**\n     * @param {?=} element\n     * @return {?}\n     */\n    CssSelector.prototype.setElement = function (element) {\n        if (element === void 0) { element = null; }\n        this.element = element;\n    };\n    /**\n     * Gets a template string for an element that matches the selector.\n     * @return {?}\n     */\n    CssSelector.prototype.getMatchingElementTemplate = function () {\n        var /** @type {?} */ tagName = this.element || 'div';\n        var /** @type {?} */ classAttr = this.classNames.length > 0 ? \" class=\\\"\" + this.classNames.join(' ') + \"\\\"\" : '';\n        var /** @type {?} */ attrs = '';\n        for (var /** @type {?} */ i = 0; i < this.attrs.length; i += 2) {\n            var /** @type {?} */ attrName = this.attrs[i];\n            var /** @type {?} */ attrValue = this.attrs[i + 1] !== '' ? \"=\\\"\" + this.attrs[i + 1] + \"\\\"\" : '';\n            attrs += \" \" + attrName + attrValue;\n        }\n        return getHtmlTagDefinition(tagName).isVoid ? \"<\" + tagName + classAttr + attrs + \"/>\" :\n            \"<\" + tagName + classAttr + attrs + \"></\" + tagName + \">\";\n    };\n    /**\n     * @param {?} name\n     * @param {?=} value\n     * @return {?}\n     */\n    CssSelector.prototype.addAttribute = function (name, value) {\n        if (value === void 0) { value = ''; }\n        this.attrs.push(name, value && value.toLowerCase() || '');\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    CssSelector.prototype.addClassName = function (name) { this.classNames.push(name.toLowerCase()); };\n    /**\n     * @return {?}\n     */\n    CssSelector.prototype.toString = function () {\n        var /** @type {?} */ res = this.element || '';\n        if (this.classNames) {\n            this.classNames.forEach(function (klass) { return res += \".\" + klass; });\n        }\n        if (this.attrs) {\n            for (var /** @type {?} */ i = 0; i < this.attrs.length; i += 2) {\n                var /** @type {?} */ name = this.attrs[i];\n                var /** @type {?} */ value = this.attrs[i + 1];\n                res += \"[\" + name + (value ? '=' + value : '') + \"]\";\n            }\n        }\n        this.notSelectors.forEach(function (notSelector) { return res += \":not(\" + notSelector + \")\"; });\n        return res;\n    };\n    return CssSelector;\n}());\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nvar SelectorMatcher = (function () {\n    function SelectorMatcher() {\n        this._elementMap = new Map();\n        this._elementPartialMap = new Map();\n        this._classMap = new Map();\n        this._classPartialMap = new Map();\n        this._attrValueMap = new Map();\n        this._attrValuePartialMap = new Map();\n        this._listContexts = [];\n    }\n    /**\n     * @param {?} notSelectors\n     * @return {?}\n     */\n    SelectorMatcher.createNotMatcher = function (notSelectors) {\n        var /** @type {?} */ notMatcher = new SelectorMatcher();\n        notMatcher.addSelectables(notSelectors, null);\n        return notMatcher;\n    };\n    /**\n     * @param {?} cssSelectors\n     * @param {?=} callbackCtxt\n     * @return {?}\n     */\n    SelectorMatcher.prototype.addSelectables = function (cssSelectors, callbackCtxt) {\n        var /** @type {?} */ listContext = ((null));\n        if (cssSelectors.length > 1) {\n            listContext = new SelectorListContext(cssSelectors);\n            this._listContexts.push(listContext);\n        }\n        for (var /** @type {?} */ i = 0; i < cssSelectors.length; i++) {\n            this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n        }\n    };\n    /**\n     * Add an object that can be found later on by calling `match`.\n     * @param {?} cssSelector A css selector\n     * @param {?} callbackCtxt An opaque object that will be given to the callback of the `match` function\n     * @param {?} listContext\n     * @return {?}\n     */\n    SelectorMatcher.prototype._addSelectable = function (cssSelector, callbackCtxt, listContext) {\n        var /** @type {?} */ matcher = this;\n        var /** @type {?} */ element = cssSelector.element;\n        var /** @type {?} */ classNames = cssSelector.classNames;\n        var /** @type {?} */ attrs = cssSelector.attrs;\n        var /** @type {?} */ selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n        if (element) {\n            var /** @type {?} */ isTerminal = attrs.length === 0 && classNames.length === 0;\n            if (isTerminal) {\n                this._addTerminal(matcher._elementMap, element, selectable);\n            }\n            else {\n                matcher = this._addPartial(matcher._elementPartialMap, element);\n            }\n        }\n        if (classNames) {\n            for (var /** @type {?} */ i = 0; i < classNames.length; i++) {\n                var /** @type {?} */ isTerminal = attrs.length === 0 && i === classNames.length - 1;\n                var /** @type {?} */ className = classNames[i];\n                if (isTerminal) {\n                    this._addTerminal(matcher._classMap, className, selectable);\n                }\n                else {\n                    matcher = this._addPartial(matcher._classPartialMap, className);\n                }\n            }\n        }\n        if (attrs) {\n            for (var /** @type {?} */ i = 0; i < attrs.length; i += 2) {\n                var /** @type {?} */ isTerminal = i === attrs.length - 2;\n                var /** @type {?} */ name = attrs[i];\n                var /** @type {?} */ value = attrs[i + 1];\n                if (isTerminal) {\n                    var /** @type {?} */ terminalMap = matcher._attrValueMap;\n                    var /** @type {?} */ terminalValuesMap = terminalMap.get(name);\n                    if (!terminalValuesMap) {\n                        terminalValuesMap = new Map();\n                        terminalMap.set(name, terminalValuesMap);\n                    }\n                    this._addTerminal(terminalValuesMap, value, selectable);\n                }\n                else {\n                    var /** @type {?} */ partialMap = matcher._attrValuePartialMap;\n                    var /** @type {?} */ partialValuesMap = partialMap.get(name);\n                    if (!partialValuesMap) {\n                        partialValuesMap = new Map();\n                        partialMap.set(name, partialValuesMap);\n                    }\n                    matcher = this._addPartial(partialValuesMap, value);\n                }\n            }\n        }\n    };\n    /**\n     * @param {?} map\n     * @param {?} name\n     * @param {?} selectable\n     * @return {?}\n     */\n    SelectorMatcher.prototype._addTerminal = function (map, name, selectable) {\n        var /** @type {?} */ terminalList = map.get(name);\n        if (!terminalList) {\n            terminalList = [];\n            map.set(name, terminalList);\n        }\n        terminalList.push(selectable);\n    };\n    /**\n     * @param {?} map\n     * @param {?} name\n     * @return {?}\n     */\n    SelectorMatcher.prototype._addPartial = function (map, name) {\n        var /** @type {?} */ matcher = map.get(name);\n        if (!matcher) {\n            matcher = new SelectorMatcher();\n            map.set(name, matcher);\n        }\n        return matcher;\n    };\n    /**\n     * Find the objects that have been added via `addSelectable`\n     * whose css selector is contained in the given css selector.\n     * @param {?} cssSelector A css selector\n     * @param {?} matchedCallback This callback will be called with the object handed into `addSelectable`\n     * @return {?} boolean true if a match was found\n     */\n    SelectorMatcher.prototype.match = function (cssSelector, matchedCallback) {\n        var /** @type {?} */ result = false;\n        var /** @type {?} */ element = ((cssSelector.element));\n        var /** @type {?} */ classNames = cssSelector.classNames;\n        var /** @type {?} */ attrs = cssSelector.attrs;\n        for (var /** @type {?} */ i = 0; i < this._listContexts.length; i++) {\n            this._listContexts[i].alreadyMatched = false;\n        }\n        result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n        result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n            result;\n        if (classNames) {\n            for (var /** @type {?} */ i = 0; i < classNames.length; i++) {\n                var /** @type {?} */ className = classNames[i];\n                result =\n                    this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n                result =\n                    this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n                        result;\n            }\n        }\n        if (attrs) {\n            for (var /** @type {?} */ i = 0; i < attrs.length; i += 2) {\n                var /** @type {?} */ name = attrs[i];\n                var /** @type {?} */ value = attrs[i + 1];\n                var /** @type {?} */ terminalValuesMap = ((this._attrValueMap.get(name)));\n                if (value) {\n                    result =\n                        this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n                var /** @type {?} */ partialValuesMap = ((this._attrValuePartialMap.get(name)));\n                if (value) {\n                    result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n            }\n        }\n        return result;\n    };\n    /**\n     * \\@internal\n     * @param {?} map\n     * @param {?} name\n     * @param {?} cssSelector\n     * @param {?} matchedCallback\n     * @return {?}\n     */\n    SelectorMatcher.prototype._matchTerminal = function (map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        var /** @type {?} */ selectables = map.get(name) || [];\n        var /** @type {?} */ starSelectables = ((map.get('*')));\n        if (starSelectables) {\n            selectables = selectables.concat(starSelectables);\n        }\n        if (selectables.length === 0) {\n            return false;\n        }\n        var /** @type {?} */ selectable;\n        var /** @type {?} */ result = false;\n        for (var /** @type {?} */ i = 0; i < selectables.length; i++) {\n            selectable = selectables[i];\n            result = selectable.finalize(cssSelector, matchedCallback) || result;\n        }\n        return result;\n    };\n    /**\n     * \\@internal\n     * @param {?} map\n     * @param {?} name\n     * @param {?} cssSelector\n     * @param {?} matchedCallback\n     * @return {?}\n     */\n    SelectorMatcher.prototype._matchPartial = function (map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        var /** @type {?} */ nestedSelector = map.get(name);\n        if (!nestedSelector) {\n            return false;\n        }\n        // TODO(perf): get rid of recursion and measure again\n        // TODO(perf): don't pass the whole selector into the recursion,\n        // but only the not processed parts\n        return nestedSelector.match(cssSelector, matchedCallback);\n    };\n    return SelectorMatcher;\n}());\nvar SelectorListContext = (function () {\n    /**\n     * @param {?} selectors\n     */\n    function SelectorListContext(selectors) {\n        this.selectors = selectors;\n        this.alreadyMatched = false;\n    }\n    return SelectorListContext;\n}());\nvar SelectorContext = (function () {\n    /**\n     * @param {?} selector\n     * @param {?} cbContext\n     * @param {?} listContext\n     */\n    function SelectorContext(selector, cbContext, listContext) {\n        this.selector = selector;\n        this.cbContext = cbContext;\n        this.listContext = listContext;\n        this.notSelectors = selector.notSelectors;\n    }\n    /**\n     * @param {?} cssSelector\n     * @param {?} callback\n     * @return {?}\n     */\n    SelectorContext.prototype.finalize = function (cssSelector, callback) {\n        var /** @type {?} */ result = true;\n        if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n            var /** @type {?} */ notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n            result = !notMatcher.match(cssSelector, null);\n        }\n        if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n            if (this.listContext) {\n                this.listContext.alreadyMatched = true;\n            }\n            callback(this.selector, this.cbContext);\n        }\n        return result;\n    };\n    return SelectorContext;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar MODULE_SUFFIX = '';\nvar DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n/**\n * @param {?} input\n * @return {?}\n */\n/**\n * @param {?} input\n * @return {?}\n */\nfunction dashCaseToCamelCase(input) {\n    return input.replace(DASH_CASE_REGEXP, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        return m[1].toUpperCase();\n    });\n}\n/**\n * @param {?} input\n * @param {?} defaultValues\n * @return {?}\n */\nfunction splitAtColon(input, defaultValues) {\n    return _splitAt(input, ':', defaultValues);\n}\n/**\n * @param {?} input\n * @param {?} defaultValues\n * @return {?}\n */\nfunction splitAtPeriod(input, defaultValues) {\n    return _splitAt(input, '.', defaultValues);\n}\n/**\n * @param {?} input\n * @param {?} character\n * @param {?} defaultValues\n * @return {?}\n */\nfunction _splitAt(input, character, defaultValues) {\n    var /** @type {?} */ characterIndex = input.indexOf(character);\n    if (characterIndex == -1)\n        return defaultValues;\n    return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\n/**\n * @param {?} value\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nfunction visitValue(value, visitor, context) {\n    if (Array.isArray(value)) {\n        return visitor.visitArray(/** @type {?} */ (value), context);\n    }\n    if (isStrictStringMap(value)) {\n        return visitor.visitStringMap(/** @type {?} */ (value), context);\n    }\n    if (value == null || typeof value == 'string' || typeof value == 'number' ||\n        typeof value == 'boolean') {\n        return visitor.visitPrimitive(value, context);\n    }\n    return visitor.visitOther(value, context);\n}\n/**\n * @param {?} val\n * @return {?}\n */\nfunction isDefined(val) {\n    return val !== null && val !== undefined;\n}\n/**\n * @template T\n * @param {?} val\n * @return {?}\n */\nfunction noUndefined(val) {\n    return val === undefined ? ((null)) : val;\n}\nvar ValueTransformer = (function () {\n    function ValueTransformer() {\n    }\n    /**\n     * @param {?} arr\n     * @param {?} context\n     * @return {?}\n     */\n    ValueTransformer.prototype.visitArray = function (arr, context) {\n        var _this = this;\n        return arr.map(function (value) { return visitValue(value, _this, context); });\n    };\n    /**\n     * @param {?} map\n     * @param {?} context\n     * @return {?}\n     */\n    ValueTransformer.prototype.visitStringMap = function (map, context) {\n        var _this = this;\n        var /** @type {?} */ result = {};\n        Object.keys(map).forEach(function (key) { result[key] = visitValue(map[key], _this, context); });\n        return result;\n    };\n    /**\n     * @param {?} value\n     * @param {?} context\n     * @return {?}\n     */\n    ValueTransformer.prototype.visitPrimitive = function (value, context) { return value; };\n    /**\n     * @param {?} value\n     * @param {?} context\n     * @return {?}\n     */\n    ValueTransformer.prototype.visitOther = function (value, context) { return value; };\n    return ValueTransformer;\n}());\nvar SyncAsyncResult = (function () {\n    /**\n     * @param {?} syncResult\n     * @param {?=} asyncResult\n     */\n    function SyncAsyncResult(syncResult, asyncResult) {\n        if (asyncResult === void 0) { asyncResult = null; }\n        this.syncResult = syncResult;\n        this.asyncResult = asyncResult;\n        if (!asyncResult) {\n            this.asyncResult = Promise.resolve(syncResult);\n        }\n    }\n    return SyncAsyncResult;\n}());\n/**\n * @param {?} msg\n * @return {?}\n */\nfunction syntaxError(msg) {\n    var /** @type {?} */ error = Error(msg);\n    ((error))[ERROR_SYNTAX_ERROR] = true;\n    return error;\n}\nvar ERROR_SYNTAX_ERROR = 'ngSyntaxError';\n/**\n * @param {?} error\n * @return {?}\n */\nfunction isSyntaxError(error) {\n    return ((error))[ERROR_SYNTAX_ERROR];\n}\n/**\n * @param {?} s\n * @return {?}\n */\nfunction escapeRegExp(s) {\n    return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\nvar STRING_MAP_PROTO = Object.getPrototypeOf({});\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction isStrictStringMap(obj) {\n    return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n}\n/**\n * @param {?} str\n * @return {?}\n */\nfunction utf8Encode(str) {\n    var /** @type {?} */ encoded = '';\n    for (var /** @type {?} */ index = 0; index < str.length; index++) {\n        var /** @type {?} */ codePoint = str.charCodeAt(index);\n        // decode surrogate\n        // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {\n            var /** @type {?} */ low = str.charCodeAt(index + 1);\n            if (low >= 0xdc00 && low <= 0xdfff) {\n                index++;\n                codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n            }\n        }\n        if (codePoint <= 0x7f) {\n            encoded += String.fromCharCode(codePoint);\n        }\n        else if (codePoint <= 0x7ff) {\n            encoded += String.fromCharCode(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0xffff) {\n            encoded += String.fromCharCode((codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0x1fffff) {\n            encoded += String.fromCharCode(((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n    }\n    return encoded;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// group 0: \"[prop] or (event) or @trigger\"\n// group 1: \"prop\" from \"[prop]\"\n// group 2: \"event\" from \"(event)\"\n// group 3: \"@trigger\" from \"@trigger\"\nvar HOST_REG_EXP = /^(?:(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\)))|(\\@[-\\w]+)$/;\nvar CompileAnimationEntryMetadata = (function () {\n    /**\n     * @param {?=} name\n     * @param {?=} definitions\n     */\n    function CompileAnimationEntryMetadata(name, definitions) {\n        if (name === void 0) { name = null; }\n        if (definitions === void 0) { definitions = null; }\n        this.name = name;\n        this.definitions = definitions;\n    }\n    return CompileAnimationEntryMetadata;\n}());\n/**\n * @abstract\n */\nvar CompileAnimationStateMetadata = (function () {\n    function CompileAnimationStateMetadata() {\n    }\n    return CompileAnimationStateMetadata;\n}());\nvar CompileAnimationStateDeclarationMetadata = (function (_super) {\n    __extends(CompileAnimationStateDeclarationMetadata, _super);\n    /**\n     * @param {?} stateNameExpr\n     * @param {?} styles\n     */\n    function CompileAnimationStateDeclarationMetadata(stateNameExpr, styles) {\n        var _this = _super.call(this) || this;\n        _this.stateNameExpr = stateNameExpr;\n        _this.styles = styles;\n        return _this;\n    }\n    return CompileAnimationStateDeclarationMetadata;\n}(CompileAnimationStateMetadata));\nvar CompileAnimationStateTransitionMetadata = (function (_super) {\n    __extends(CompileAnimationStateTransitionMetadata, _super);\n    /**\n     * @param {?} stateChangeExpr\n     * @param {?} steps\n     */\n    function CompileAnimationStateTransitionMetadata(stateChangeExpr, steps) {\n        var _this = _super.call(this) || this;\n        _this.stateChangeExpr = stateChangeExpr;\n        _this.steps = steps;\n        return _this;\n    }\n    return CompileAnimationStateTransitionMetadata;\n}(CompileAnimationStateMetadata));\n/**\n * @abstract\n */\nvar CompileAnimationMetadata = (function () {\n    function CompileAnimationMetadata() {\n    }\n    return CompileAnimationMetadata;\n}());\nvar CompileAnimationKeyframesSequenceMetadata = (function (_super) {\n    __extends(CompileAnimationKeyframesSequenceMetadata, _super);\n    /**\n     * @param {?=} steps\n     */\n    function CompileAnimationKeyframesSequenceMetadata(steps) {\n        if (steps === void 0) { steps = []; }\n        var _this = _super.call(this) || this;\n        _this.steps = steps;\n        return _this;\n    }\n    return CompileAnimationKeyframesSequenceMetadata;\n}(CompileAnimationMetadata));\nvar CompileAnimationStyleMetadata = (function (_super) {\n    __extends(CompileAnimationStyleMetadata, _super);\n    /**\n     * @param {?} offset\n     * @param {?=} styles\n     */\n    function CompileAnimationStyleMetadata(offset, styles) {\n        if (styles === void 0) { styles = null; }\n        var _this = _super.call(this) || this;\n        _this.offset = offset;\n        _this.styles = styles;\n        return _this;\n    }\n    return CompileAnimationStyleMetadata;\n}(CompileAnimationMetadata));\nvar CompileAnimationAnimateMetadata = (function (_super) {\n    __extends(CompileAnimationAnimateMetadata, _super);\n    /**\n     * @param {?=} timings\n     * @param {?=} styles\n     */\n    function CompileAnimationAnimateMetadata(timings, styles) {\n        if (timings === void 0) { timings = 0; }\n        if (styles === void 0) { styles = null; }\n        var _this = _super.call(this) || this;\n        _this.timings = timings;\n        _this.styles = styles;\n        return _this;\n    }\n    return CompileAnimationAnimateMetadata;\n}(CompileAnimationMetadata));\n/**\n * @abstract\n */\nvar CompileAnimationWithStepsMetadata = (function (_super) {\n    __extends(CompileAnimationWithStepsMetadata, _super);\n    /**\n     * @param {?=} steps\n     */\n    function CompileAnimationWithStepsMetadata(steps) {\n        if (steps === void 0) { steps = null; }\n        var _this = _super.call(this) || this;\n        _this.steps = steps;\n        return _this;\n    }\n    return CompileAnimationWithStepsMetadata;\n}(CompileAnimationMetadata));\nvar CompileAnimationSequenceMetadata = (function (_super) {\n    __extends(CompileAnimationSequenceMetadata, _super);\n    /**\n     * @param {?=} steps\n     */\n    function CompileAnimationSequenceMetadata(steps) {\n        if (steps === void 0) { steps = null; }\n        return _super.call(this, steps) || this;\n    }\n    return CompileAnimationSequenceMetadata;\n}(CompileAnimationWithStepsMetadata));\nvar CompileAnimationGroupMetadata = (function (_super) {\n    __extends(CompileAnimationGroupMetadata, _super);\n    /**\n     * @param {?=} steps\n     */\n    function CompileAnimationGroupMetadata(steps) {\n        if (steps === void 0) { steps = null; }\n        return _super.call(this, steps) || this;\n    }\n    return CompileAnimationGroupMetadata;\n}(CompileAnimationWithStepsMetadata));\n/**\n * @param {?} name\n * @return {?}\n */\nfunction _sanitizeIdentifier(name) {\n    return name.replace(/\\W/g, '_');\n}\nvar _anonymousTypeIndex = 0;\n/**\n * @param {?} compileIdentifier\n * @return {?}\n */\nfunction identifierName(compileIdentifier) {\n    if (!compileIdentifier || !compileIdentifier.reference) {\n        return null;\n    }\n    var /** @type {?} */ ref = compileIdentifier.reference;\n    if (ref instanceof StaticSymbol) {\n        return ref.name;\n    }\n    if (ref['__anonymousType']) {\n        return ref['__anonymousType'];\n    }\n    var /** @type {?} */ identifier = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵstringify\"])(ref);\n    if (identifier.indexOf('(') >= 0) {\n        // case: anonymous functions!\n        identifier = \"anonymous_\" + _anonymousTypeIndex++;\n        ref['__anonymousType'] = identifier;\n    }\n    else {\n        identifier = _sanitizeIdentifier(identifier);\n    }\n    return identifier;\n}\n/**\n * @param {?} compileIdentifier\n * @return {?}\n */\nfunction identifierModuleUrl(compileIdentifier) {\n    var /** @type {?} */ ref = compileIdentifier.reference;\n    if (ref instanceof StaticSymbol) {\n        return ref.filePath;\n    }\n    return __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵreflector\"].importUri(ref);\n}\n/**\n * @param {?} compType\n * @param {?} embeddedTemplateIndex\n * @return {?}\n */\nfunction viewClassName(compType, embeddedTemplateIndex) {\n    return \"View_\" + identifierName({ reference: compType }) + \"_\" + embeddedTemplateIndex;\n}\n/**\n * @param {?} compType\n * @return {?}\n */\nfunction rendererTypeName(compType) {\n    return \"RenderType_\" + identifierName({ reference: compType });\n}\n/**\n * @param {?} compType\n * @return {?}\n */\nfunction hostViewClassName(compType) {\n    return \"HostView_\" + identifierName({ reference: compType });\n}\n/**\n * @param {?} dirType\n * @return {?}\n */\nfunction dirWrapperClassName(dirType) {\n    return \"Wrapper_\" + identifierName({ reference: dirType });\n}\n/**\n * @param {?} compType\n * @return {?}\n */\nfunction componentFactoryName(compType) {\n    return identifierName({ reference: compType }) + \"NgFactory\";\n}\nvar CompileSummaryKind = {};\nCompileSummaryKind.Pipe = 0;\nCompileSummaryKind.Directive = 1;\nCompileSummaryKind.NgModule = 2;\nCompileSummaryKind.Injectable = 3;\nCompileSummaryKind[CompileSummaryKind.Pipe] = \"Pipe\";\nCompileSummaryKind[CompileSummaryKind.Directive] = \"Directive\";\nCompileSummaryKind[CompileSummaryKind.NgModule] = \"NgModule\";\nCompileSummaryKind[CompileSummaryKind.Injectable] = \"Injectable\";\n/**\n * @param {?} token\n * @return {?}\n */\nfunction tokenName(token) {\n    return token.value != null ? _sanitizeIdentifier(token.value) : identifierName(token.identifier);\n}\n/**\n * @param {?} token\n * @return {?}\n */\nfunction tokenReference(token) {\n    if (token.identifier != null) {\n        return token.identifier.reference;\n    }\n    else {\n        return token.value;\n    }\n}\n/**\n * Metadata about a stylesheet\n */\nvar CompileStylesheetMetadata = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function CompileStylesheetMetadata(_a) {\n        var _b = _a === void 0 ? {} : _a, moduleUrl = _b.moduleUrl, styles = _b.styles, styleUrls = _b.styleUrls;\n        this.moduleUrl = moduleUrl || null;\n        this.styles = _normalizeArray(styles);\n        this.styleUrls = _normalizeArray(styleUrls);\n    }\n    return CompileStylesheetMetadata;\n}());\n/**\n * Metadata regarding compilation of a template.\n */\nvar CompileTemplateMetadata = (function () {\n    /**\n     * @param {?} __0\n     */\n    function CompileTemplateMetadata(_a) {\n        var encapsulation = _a.encapsulation, template = _a.template, templateUrl = _a.templateUrl, styles = _a.styles, styleUrls = _a.styleUrls, externalStylesheets = _a.externalStylesheets, animations = _a.animations, ngContentSelectors = _a.ngContentSelectors, interpolation = _a.interpolation, isInline = _a.isInline;\n        this.encapsulation = encapsulation;\n        this.template = template;\n        this.templateUrl = templateUrl;\n        this.styles = _normalizeArray(styles);\n        this.styleUrls = _normalizeArray(styleUrls);\n        this.externalStylesheets = _normalizeArray(externalStylesheets);\n        this.animations = animations ? flatten(animations) : [];\n        this.ngContentSelectors = ngContentSelectors || [];\n        if (interpolation && interpolation.length != 2) {\n            throw new Error(\"'interpolation' should have a start and an end symbol.\");\n        }\n        this.interpolation = interpolation;\n        this.isInline = isInline;\n    }\n    /**\n     * @return {?}\n     */\n    CompileTemplateMetadata.prototype.toSummary = function () {\n        return {\n            animations: this.animations.map(function (anim) { return anim.name; }),\n            ngContentSelectors: this.ngContentSelectors,\n            encapsulation: this.encapsulation,\n        };\n    };\n    return CompileTemplateMetadata;\n}());\n/**\n * Metadata regarding compilation of a directive.\n */\nvar CompileDirectiveMetadata = (function () {\n    /**\n     * @param {?} __0\n     */\n    function CompileDirectiveMetadata(_a) {\n        var isHost = _a.isHost, type = _a.type, isComponent = _a.isComponent, selector = _a.selector, exportAs = _a.exportAs, changeDetection = _a.changeDetection, inputs = _a.inputs, outputs = _a.outputs, hostListeners = _a.hostListeners, hostProperties = _a.hostProperties, hostAttributes = _a.hostAttributes, providers = _a.providers, viewProviders = _a.viewProviders, queries = _a.queries, viewQueries = _a.viewQueries, entryComponents = _a.entryComponents, template = _a.template, componentViewType = _a.componentViewType, rendererType = _a.rendererType, componentFactory = _a.componentFactory;\n        this.isHost = !!isHost;\n        this.type = type;\n        this.isComponent = isComponent;\n        this.selector = selector;\n        this.exportAs = exportAs;\n        this.changeDetection = changeDetection;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.hostListeners = hostListeners;\n        this.hostProperties = hostProperties;\n        this.hostAttributes = hostAttributes;\n        this.providers = _normalizeArray(providers);\n        this.viewProviders = _normalizeArray(viewProviders);\n        this.queries = _normalizeArray(queries);\n        this.viewQueries = _normalizeArray(viewQueries);\n        this.entryComponents = _normalizeArray(entryComponents);\n        this.template = template;\n        this.componentViewType = componentViewType;\n        this.rendererType = rendererType;\n        this.componentFactory = componentFactory;\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    CompileDirectiveMetadata.create = function (_a) {\n        var isHost = _a.isHost, type = _a.type, isComponent = _a.isComponent, selector = _a.selector, exportAs = _a.exportAs, changeDetection = _a.changeDetection, inputs = _a.inputs, outputs = _a.outputs, host = _a.host, providers = _a.providers, viewProviders = _a.viewProviders, queries = _a.queries, viewQueries = _a.viewQueries, entryComponents = _a.entryComponents, template = _a.template, componentViewType = _a.componentViewType, rendererType = _a.rendererType, componentFactory = _a.componentFactory;\n        var /** @type {?} */ hostListeners = {};\n        var /** @type {?} */ hostProperties = {};\n        var /** @type {?} */ hostAttributes = {};\n        if (host != null) {\n            Object.keys(host).forEach(function (key) {\n                var /** @type {?} */ value = host[key];\n                var /** @type {?} */ matches = key.match(HOST_REG_EXP);\n                if (matches === null) {\n                    hostAttributes[key] = value;\n                }\n                else if (matches[1] != null) {\n                    hostProperties[matches[1]] = value;\n                }\n                else if (matches[2] != null) {\n                    hostListeners[matches[2]] = value;\n                }\n            });\n        }\n        var /** @type {?} */ inputsMap = {};\n        if (inputs != null) {\n            inputs.forEach(function (bindConfig) {\n                // canonical syntax: `dirProp: elProp`\n                // if there is no `:`, use dirProp = elProp\n                var /** @type {?} */ parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n                inputsMap[parts[0]] = parts[1];\n            });\n        }\n        var /** @type {?} */ outputsMap = {};\n        if (outputs != null) {\n            outputs.forEach(function (bindConfig) {\n                // canonical syntax: `dirProp: elProp`\n                // if there is no `:`, use dirProp = elProp\n                var /** @type {?} */ parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n                outputsMap[parts[0]] = parts[1];\n            });\n        }\n        return new CompileDirectiveMetadata({\n            isHost: isHost,\n            type: type,\n            isComponent: !!isComponent, selector: selector, exportAs: exportAs, changeDetection: changeDetection,\n            inputs: inputsMap,\n            outputs: outputsMap,\n            hostListeners: hostListeners,\n            hostProperties: hostProperties,\n            hostAttributes: hostAttributes,\n            providers: providers,\n            viewProviders: viewProviders,\n            queries: queries,\n            viewQueries: viewQueries,\n            entryComponents: entryComponents,\n            template: template,\n            componentViewType: componentViewType,\n            rendererType: rendererType,\n            componentFactory: componentFactory,\n        });\n    };\n    /**\n     * @return {?}\n     */\n    CompileDirectiveMetadata.prototype.toSummary = function () {\n        return {\n            summaryKind: CompileSummaryKind.Directive,\n            type: this.type,\n            isComponent: this.isComponent,\n            selector: this.selector,\n            exportAs: this.exportAs,\n            inputs: this.inputs,\n            outputs: this.outputs,\n            hostListeners: this.hostListeners,\n            hostProperties: this.hostProperties,\n            hostAttributes: this.hostAttributes,\n            providers: this.providers,\n            viewProviders: this.viewProviders,\n            queries: this.queries,\n            viewQueries: this.viewQueries,\n            entryComponents: this.entryComponents,\n            changeDetection: this.changeDetection,\n            template: this.template && this.template.toSummary(),\n            componentViewType: this.componentViewType,\n            rendererType: this.rendererType,\n            componentFactory: this.componentFactory\n        };\n    };\n    return CompileDirectiveMetadata;\n}());\n/**\n * Construct {\\@link CompileDirectiveMetadata} from {\\@link ComponentTypeMetadata} and a selector.\n * @param {?} hostTypeReference\n * @param {?} compMeta\n * @param {?} hostViewType\n * @return {?}\n */\nfunction createHostComponentMeta(hostTypeReference, compMeta, hostViewType) {\n    var /** @type {?} */ template = CssSelector.parse(/** @type {?} */ ((compMeta.selector)))[0].getMatchingElementTemplate();\n    return CompileDirectiveMetadata.create({\n        isHost: true,\n        type: { reference: hostTypeReference, diDeps: [], lifecycleHooks: [] },\n        template: new CompileTemplateMetadata({\n            encapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewEncapsulation\"].None,\n            template: template,\n            templateUrl: '',\n            styles: [],\n            styleUrls: [],\n            ngContentSelectors: [],\n            animations: [],\n            isInline: true,\n            externalStylesheets: [],\n            interpolation: null\n        }),\n        exportAs: null,\n        changeDetection: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ChangeDetectionStrategy\"].Default,\n        inputs: [],\n        outputs: [],\n        host: {},\n        isComponent: true,\n        selector: '*',\n        providers: [],\n        viewProviders: [],\n        queries: [],\n        viewQueries: [],\n        componentViewType: hostViewType,\n        rendererType: { id: '__Host__', encapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewEncapsulation\"].None, styles: [], data: {} },\n        entryComponents: [],\n        componentFactory: null\n    });\n}\nvar CompilePipeMetadata = (function () {\n    /**\n     * @param {?} __0\n     */\n    function CompilePipeMetadata(_a) {\n        var type = _a.type, name = _a.name, pure = _a.pure;\n        this.type = type;\n        this.name = name;\n        this.pure = !!pure;\n    }\n    /**\n     * @return {?}\n     */\n    CompilePipeMetadata.prototype.toSummary = function () {\n        return {\n            summaryKind: CompileSummaryKind.Pipe,\n            type: this.type,\n            name: this.name,\n            pure: this.pure\n        };\n    };\n    return CompilePipeMetadata;\n}());\n/**\n * Metadata regarding compilation of a module.\n */\nvar CompileNgModuleMetadata = (function () {\n    /**\n     * @param {?} __0\n     */\n    function CompileNgModuleMetadata(_a) {\n        var type = _a.type, providers = _a.providers, declaredDirectives = _a.declaredDirectives, exportedDirectives = _a.exportedDirectives, declaredPipes = _a.declaredPipes, exportedPipes = _a.exportedPipes, entryComponents = _a.entryComponents, bootstrapComponents = _a.bootstrapComponents, importedModules = _a.importedModules, exportedModules = _a.exportedModules, schemas = _a.schemas, transitiveModule = _a.transitiveModule, id = _a.id;\n        this.type = type || null;\n        this.declaredDirectives = _normalizeArray(declaredDirectives);\n        this.exportedDirectives = _normalizeArray(exportedDirectives);\n        this.declaredPipes = _normalizeArray(declaredPipes);\n        this.exportedPipes = _normalizeArray(exportedPipes);\n        this.providers = _normalizeArray(providers);\n        this.entryComponents = _normalizeArray(entryComponents);\n        this.bootstrapComponents = _normalizeArray(bootstrapComponents);\n        this.importedModules = _normalizeArray(importedModules);\n        this.exportedModules = _normalizeArray(exportedModules);\n        this.schemas = _normalizeArray(schemas);\n        this.id = id || null;\n        this.transitiveModule = transitiveModule || null;\n    }\n    /**\n     * @return {?}\n     */\n    CompileNgModuleMetadata.prototype.toSummary = function () {\n        var /** @type {?} */ module = ((this.transitiveModule));\n        return {\n            summaryKind: CompileSummaryKind.NgModule,\n            type: this.type,\n            entryComponents: module.entryComponents,\n            providers: module.providers,\n            modules: module.modules,\n            exportedDirectives: module.exportedDirectives,\n            exportedPipes: module.exportedPipes\n        };\n    };\n    return CompileNgModuleMetadata;\n}());\nvar TransitiveCompileNgModuleMetadata = (function () {\n    function TransitiveCompileNgModuleMetadata() {\n        this.directivesSet = new Set();\n        this.directives = [];\n        this.exportedDirectivesSet = new Set();\n        this.exportedDirectives = [];\n        this.pipesSet = new Set();\n        this.pipes = [];\n        this.exportedPipesSet = new Set();\n        this.exportedPipes = [];\n        this.modulesSet = new Set();\n        this.modules = [];\n        this.entryComponentsSet = new Set();\n        this.entryComponents = [];\n        this.providers = [];\n    }\n    /**\n     * @param {?} provider\n     * @param {?} module\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addProvider = function (provider, module) {\n        this.providers.push({ provider: provider, module: module });\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addDirective = function (id) {\n        if (!this.directivesSet.has(id.reference)) {\n            this.directivesSet.add(id.reference);\n            this.directives.push(id);\n        }\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addExportedDirective = function (id) {\n        if (!this.exportedDirectivesSet.has(id.reference)) {\n            this.exportedDirectivesSet.add(id.reference);\n            this.exportedDirectives.push(id);\n        }\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addPipe = function (id) {\n        if (!this.pipesSet.has(id.reference)) {\n            this.pipesSet.add(id.reference);\n            this.pipes.push(id);\n        }\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addExportedPipe = function (id) {\n        if (!this.exportedPipesSet.has(id.reference)) {\n            this.exportedPipesSet.add(id.reference);\n            this.exportedPipes.push(id);\n        }\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addModule = function (id) {\n        if (!this.modulesSet.has(id.reference)) {\n            this.modulesSet.add(id.reference);\n            this.modules.push(id);\n        }\n    };\n    /**\n     * @param {?} ec\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addEntryComponent = function (ec) {\n        if (!this.entryComponentsSet.has(ec.componentType)) {\n            this.entryComponentsSet.add(ec.componentType);\n            this.entryComponents.push(ec);\n        }\n    };\n    return TransitiveCompileNgModuleMetadata;\n}());\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction _normalizeArray(obj) {\n    return obj || [];\n}\nvar ProviderMeta = (function () {\n    /**\n     * @param {?} token\n     * @param {?} __1\n     */\n    function ProviderMeta(token, _a) {\n        var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;\n        this.token = token;\n        this.useClass = useClass || null;\n        this.useValue = useValue;\n        this.useExisting = useExisting;\n        this.useFactory = useFactory || null;\n        this.dependencies = deps || null;\n        this.multi = !!multi;\n    }\n    return ProviderMeta;\n}());\n/**\n * @template T\n * @param {?} list\n * @return {?}\n */\nfunction flatten(list) {\n    return list.reduce(function (flat, item) {\n        var /** @type {?} */ flatItem = Array.isArray(item) ? flatten(item) : item;\n        return ((flat)).concat(flatItem);\n    }, []);\n}\n/**\n * @param {?} url\n * @return {?}\n */\nfunction sourceUrl(url) {\n    // Note: We need 3 \"/\" so that ng shows up as a separate domain\n    // in the chrome dev tools.\n    return url.replace(/(\\w+:\\/\\/[\\w:-]+)?(\\/+)?/, 'ng:///');\n}\n/**\n * @param {?} ngModuleType\n * @param {?} compMeta\n * @param {?} templateMeta\n * @return {?}\n */\nfunction templateSourceUrl(ngModuleType, compMeta, templateMeta) {\n    var /** @type {?} */ url;\n    if (templateMeta.isInline) {\n        if (compMeta.type.reference instanceof StaticSymbol) {\n            // Note: a .ts file might contain multiple components with inline templates,\n            // so we need to give them unique urls, as these will be used for sourcemaps.\n            url = compMeta.type.reference.filePath + \".\" + compMeta.type.reference.name + \".html\";\n        }\n        else {\n            url = identifierName(ngModuleType) + \"/\" + identifierName(compMeta.type) + \".html\";\n        }\n    }\n    else {\n        url = ((templateMeta.templateUrl));\n    }\n    // always prepend ng:// to make angular resources easy to find and not clobber\n    // user resources.\n    return sourceUrl(url);\n}\n/**\n * @param {?} meta\n * @param {?} id\n * @return {?}\n */\nfunction sharedStylesheetJitUrl(meta, id) {\n    var /** @type {?} */ pathParts = ((meta.moduleUrl)).split(/\\/\\\\/g);\n    var /** @type {?} */ baseName = pathParts[pathParts.length - 1];\n    return sourceUrl(\"css/\" + id + baseName + \".ngstyle.js\");\n}\n/**\n * @param {?} moduleMeta\n * @return {?}\n */\nfunction ngModuleJitUrl(moduleMeta) {\n    return sourceUrl(identifierName(moduleMeta.type) + \"/module.ngfactory.js\");\n}\n/**\n * @param {?} ngModuleType\n * @param {?} compMeta\n * @return {?}\n */\nfunction templateJitUrl(ngModuleType, compMeta) {\n    return sourceUrl(identifierName(ngModuleType) + \"/\" + identifierName(compMeta.type) + \".ngfactory.js\");\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CompilerConfig = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function CompilerConfig(_a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.defaultEncapsulation, defaultEncapsulation = _c === void 0 ? __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewEncapsulation\"].Emulated : _c, _d = _b.useJit, useJit = _d === void 0 ? true : _d, missingTranslation = _b.missingTranslation, enableLegacyTemplate = _b.enableLegacyTemplate;\n        this.defaultEncapsulation = defaultEncapsulation;\n        this.useJit = !!useJit;\n        this.missingTranslation = missingTranslation || null;\n        this.enableLegacyTemplate = enableLegacyTemplate !== false;\n    }\n    return CompilerConfig;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ParserError = (function () {\n    /**\n     * @param {?} message\n     * @param {?} input\n     * @param {?} errLocation\n     * @param {?=} ctxLocation\n     */\n    function ParserError(message, input, errLocation, ctxLocation) {\n        this.input = input;\n        this.errLocation = errLocation;\n        this.ctxLocation = ctxLocation;\n        this.message = \"Parser Error: \" + message + \" \" + errLocation + \" [\" + input + \"] in \" + ctxLocation;\n    }\n    return ParserError;\n}());\nvar ParseSpan = (function () {\n    /**\n     * @param {?} start\n     * @param {?} end\n     */\n    function ParseSpan(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    return ParseSpan;\n}());\nvar AST = (function () {\n    /**\n     * @param {?} span\n     */\n    function AST(span) {\n        this.span = span;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    AST.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return null;\n    };\n    /**\n     * @return {?}\n     */\n    AST.prototype.toString = function () { return 'AST'; };\n    return AST;\n}());\n/**\n * Represents a quoted expression of the form:\n *\n * quote = prefix `:` uninterpretedExpression\n * prefix = identifier\n * uninterpretedExpression = arbitrary string\n *\n * A quoted expression is meant to be pre-processed by an AST transformer that\n * converts it into another AST that no longer contains quoted expressions.\n * It is meant to allow third-party developers to extend Angular template\n * expression language. The `uninterpretedExpression` part of the quote is\n * therefore not interpreted by the Angular's own expression parser.\n */\nvar Quote = (function (_super) {\n    __extends(Quote, _super);\n    /**\n     * @param {?} span\n     * @param {?} prefix\n     * @param {?} uninterpretedExpression\n     * @param {?} location\n     */\n    function Quote(span, prefix, uninterpretedExpression, location) {\n        var _this = _super.call(this, span) || this;\n        _this.prefix = prefix;\n        _this.uninterpretedExpression = uninterpretedExpression;\n        _this.location = location;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Quote.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitQuote(this, context);\n    };\n    /**\n     * @return {?}\n     */\n    Quote.prototype.toString = function () { return 'Quote'; };\n    return Quote;\n}(AST));\nvar EmptyExpr = (function (_super) {\n    __extends(EmptyExpr, _super);\n    function EmptyExpr() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    EmptyExpr.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        // do nothing\n    };\n    return EmptyExpr;\n}(AST));\nvar ImplicitReceiver = (function (_super) {\n    __extends(ImplicitReceiver, _super);\n    function ImplicitReceiver() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    ImplicitReceiver.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitImplicitReceiver(this, context);\n    };\n    return ImplicitReceiver;\n}(AST));\n/**\n * Multiple expressions separated by a semicolon.\n */\nvar Chain = (function (_super) {\n    __extends(Chain, _super);\n    /**\n     * @param {?} span\n     * @param {?} expressions\n     */\n    function Chain(span, expressions) {\n        var _this = _super.call(this, span) || this;\n        _this.expressions = expressions;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Chain.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitChain(this, context);\n    };\n    return Chain;\n}(AST));\nvar Conditional = (function (_super) {\n    __extends(Conditional, _super);\n    /**\n     * @param {?} span\n     * @param {?} condition\n     * @param {?} trueExp\n     * @param {?} falseExp\n     */\n    function Conditional(span, condition, trueExp, falseExp) {\n        var _this = _super.call(this, span) || this;\n        _this.condition = condition;\n        _this.trueExp = trueExp;\n        _this.falseExp = falseExp;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Conditional.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitConditional(this, context);\n    };\n    return Conditional;\n}(AST));\nvar PropertyRead = (function (_super) {\n    __extends(PropertyRead, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     */\n    function PropertyRead(span, receiver, name) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    PropertyRead.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPropertyRead(this, context);\n    };\n    return PropertyRead;\n}(AST));\nvar PropertyWrite = (function (_super) {\n    __extends(PropertyWrite, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} value\n     */\n    function PropertyWrite(span, receiver, name, value) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    PropertyWrite.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPropertyWrite(this, context);\n    };\n    return PropertyWrite;\n}(AST));\nvar SafePropertyRead = (function (_super) {\n    __extends(SafePropertyRead, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     */\n    function SafePropertyRead(span, receiver, name) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    SafePropertyRead.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitSafePropertyRead(this, context);\n    };\n    return SafePropertyRead;\n}(AST));\nvar KeyedRead = (function (_super) {\n    __extends(KeyedRead, _super);\n    /**\n     * @param {?} span\n     * @param {?} obj\n     * @param {?} key\n     */\n    function KeyedRead(span, obj, key) {\n        var _this = _super.call(this, span) || this;\n        _this.obj = obj;\n        _this.key = key;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    KeyedRead.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitKeyedRead(this, context);\n    };\n    return KeyedRead;\n}(AST));\nvar KeyedWrite = (function (_super) {\n    __extends(KeyedWrite, _super);\n    /**\n     * @param {?} span\n     * @param {?} obj\n     * @param {?} key\n     * @param {?} value\n     */\n    function KeyedWrite(span, obj, key, value) {\n        var _this = _super.call(this, span) || this;\n        _this.obj = obj;\n        _this.key = key;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    KeyedWrite.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitKeyedWrite(this, context);\n    };\n    return KeyedWrite;\n}(AST));\nvar BindingPipe = (function (_super) {\n    __extends(BindingPipe, _super);\n    /**\n     * @param {?} span\n     * @param {?} exp\n     * @param {?} name\n     * @param {?} args\n     */\n    function BindingPipe(span, exp, name, args) {\n        var _this = _super.call(this, span) || this;\n        _this.exp = exp;\n        _this.name = name;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    BindingPipe.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPipe(this, context);\n    };\n    return BindingPipe;\n}(AST));\nvar LiteralPrimitive = (function (_super) {\n    __extends(LiteralPrimitive, _super);\n    /**\n     * @param {?} span\n     * @param {?} value\n     */\n    function LiteralPrimitive(span, value) {\n        var _this = _super.call(this, span) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    LiteralPrimitive.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitLiteralPrimitive(this, context);\n    };\n    return LiteralPrimitive;\n}(AST));\nvar LiteralArray = (function (_super) {\n    __extends(LiteralArray, _super);\n    /**\n     * @param {?} span\n     * @param {?} expressions\n     */\n    function LiteralArray(span, expressions) {\n        var _this = _super.call(this, span) || this;\n        _this.expressions = expressions;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    LiteralArray.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitLiteralArray(this, context);\n    };\n    return LiteralArray;\n}(AST));\nvar LiteralMap = (function (_super) {\n    __extends(LiteralMap, _super);\n    /**\n     * @param {?} span\n     * @param {?} keys\n     * @param {?} values\n     */\n    function LiteralMap(span, keys, values) {\n        var _this = _super.call(this, span) || this;\n        _this.keys = keys;\n        _this.values = values;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    LiteralMap.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitLiteralMap(this, context);\n    };\n    return LiteralMap;\n}(AST));\nvar Interpolation = (function (_super) {\n    __extends(Interpolation, _super);\n    /**\n     * @param {?} span\n     * @param {?} strings\n     * @param {?} expressions\n     */\n    function Interpolation(span, strings, expressions) {\n        var _this = _super.call(this, span) || this;\n        _this.strings = strings;\n        _this.expressions = expressions;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Interpolation.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitInterpolation(this, context);\n    };\n    return Interpolation;\n}(AST));\nvar Binary = (function (_super) {\n    __extends(Binary, _super);\n    /**\n     * @param {?} span\n     * @param {?} operation\n     * @param {?} left\n     * @param {?} right\n     */\n    function Binary(span, operation, left, right) {\n        var _this = _super.call(this, span) || this;\n        _this.operation = operation;\n        _this.left = left;\n        _this.right = right;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Binary.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitBinary(this, context);\n    };\n    return Binary;\n}(AST));\nvar PrefixNot = (function (_super) {\n    __extends(PrefixNot, _super);\n    /**\n     * @param {?} span\n     * @param {?} expression\n     */\n    function PrefixNot(span, expression) {\n        var _this = _super.call(this, span) || this;\n        _this.expression = expression;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    PrefixNot.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPrefixNot(this, context);\n    };\n    return PrefixNot;\n}(AST));\nvar MethodCall = (function (_super) {\n    __extends(MethodCall, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} args\n     */\n    function MethodCall(span, receiver, name, args) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    MethodCall.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitMethodCall(this, context);\n    };\n    return MethodCall;\n}(AST));\nvar SafeMethodCall = (function (_super) {\n    __extends(SafeMethodCall, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} args\n     */\n    function SafeMethodCall(span, receiver, name, args) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    SafeMethodCall.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitSafeMethodCall(this, context);\n    };\n    return SafeMethodCall;\n}(AST));\nvar FunctionCall = (function (_super) {\n    __extends(FunctionCall, _super);\n    /**\n     * @param {?} span\n     * @param {?} target\n     * @param {?} args\n     */\n    function FunctionCall(span, target, args) {\n        var _this = _super.call(this, span) || this;\n        _this.target = target;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    FunctionCall.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitFunctionCall(this, context);\n    };\n    return FunctionCall;\n}(AST));\nvar ASTWithSource = (function (_super) {\n    __extends(ASTWithSource, _super);\n    /**\n     * @param {?} ast\n     * @param {?} source\n     * @param {?} location\n     * @param {?} errors\n     */\n    function ASTWithSource(ast, source, location, errors) {\n        var _this = _super.call(this, new ParseSpan(0, source == null ? 0 : source.length)) || this;\n        _this.ast = ast;\n        _this.source = source;\n        _this.location = location;\n        _this.errors = errors;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    ASTWithSource.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return this.ast.visit(visitor, context);\n    };\n    /**\n     * @return {?}\n     */\n    ASTWithSource.prototype.toString = function () { return this.source + \" in \" + this.location; };\n    return ASTWithSource;\n}(AST));\nvar TemplateBinding = (function () {\n    /**\n     * @param {?} span\n     * @param {?} key\n     * @param {?} keyIsVar\n     * @param {?} name\n     * @param {?} expression\n     */\n    function TemplateBinding(span, key, keyIsVar, name, expression) {\n        this.span = span;\n        this.key = key;\n        this.keyIsVar = keyIsVar;\n        this.name = name;\n        this.expression = expression;\n    }\n    return TemplateBinding;\n}());\nvar RecursiveAstVisitor = (function () {\n    function RecursiveAstVisitor() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitBinary = function (ast, context) {\n        ast.left.visit(this);\n        ast.right.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitChain = function (ast, context) { return this.visitAll(ast.expressions, context); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitConditional = function (ast, context) {\n        ast.condition.visit(this);\n        ast.trueExp.visit(this);\n        ast.falseExp.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitPipe = function (ast, context) {\n        ast.exp.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitFunctionCall = function (ast, context) {\n        ((ast.target)).visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitImplicitReceiver = function (ast, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitInterpolation = function (ast, context) {\n        return this.visitAll(ast.expressions, context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitKeyedRead = function (ast, context) {\n        ast.obj.visit(this);\n        ast.key.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitKeyedWrite = function (ast, context) {\n        ast.obj.visit(this);\n        ast.key.visit(this);\n        ast.value.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitLiteralArray = function (ast, context) {\n        return this.visitAll(ast.expressions, context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitLiteralMap = function (ast, context) { return this.visitAll(ast.values, context); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitLiteralPrimitive = function (ast, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitMethodCall = function (ast, context) {\n        ast.receiver.visit(this);\n        return this.visitAll(ast.args, context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitPrefixNot = function (ast, context) {\n        ast.expression.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitPropertyRead = function (ast, context) {\n        ast.receiver.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitPropertyWrite = function (ast, context) {\n        ast.receiver.visit(this);\n        ast.value.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitSafePropertyRead = function (ast, context) {\n        ast.receiver.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitSafeMethodCall = function (ast, context) {\n        ast.receiver.visit(this);\n        return this.visitAll(ast.args, context);\n    };\n    /**\n     * @param {?} asts\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitAll = function (asts, context) {\n        var _this = this;\n        asts.forEach(function (ast) { return ast.visit(_this, context); });\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitQuote = function (ast, context) { return null; };\n    return RecursiveAstVisitor;\n}());\nvar AstTransformer = (function () {\n    function AstTransformer() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitImplicitReceiver = function (ast, context) { return ast; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitInterpolation = function (ast, context) {\n        return new Interpolation(ast.span, ast.strings, this.visitAll(ast.expressions));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitLiteralPrimitive = function (ast, context) {\n        return new LiteralPrimitive(ast.span, ast.value);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitPropertyRead = function (ast, context) {\n        return new PropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitPropertyWrite = function (ast, context) {\n        return new PropertyWrite(ast.span, ast.receiver.visit(this), ast.name, ast.value.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitSafePropertyRead = function (ast, context) {\n        return new SafePropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitMethodCall = function (ast, context) {\n        return new MethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitSafeMethodCall = function (ast, context) {\n        return new SafeMethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitFunctionCall = function (ast, context) {\n        return new FunctionCall(ast.span, /** @type {?} */ ((ast.target)).visit(this), this.visitAll(ast.args));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitLiteralArray = function (ast, context) {\n        return new LiteralArray(ast.span, this.visitAll(ast.expressions));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitLiteralMap = function (ast, context) {\n        return new LiteralMap(ast.span, ast.keys, this.visitAll(ast.values));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitBinary = function (ast, context) {\n        return new Binary(ast.span, ast.operation, ast.left.visit(this), ast.right.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitPrefixNot = function (ast, context) {\n        return new PrefixNot(ast.span, ast.expression.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitConditional = function (ast, context) {\n        return new Conditional(ast.span, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitPipe = function (ast, context) {\n        return new BindingPipe(ast.span, ast.exp.visit(this), ast.name, this.visitAll(ast.args));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitKeyedRead = function (ast, context) {\n        return new KeyedRead(ast.span, ast.obj.visit(this), ast.key.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitKeyedWrite = function (ast, context) {\n        return new KeyedWrite(ast.span, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\n    };\n    /**\n     * @param {?} asts\n     * @return {?}\n     */\n    AstTransformer.prototype.visitAll = function (asts) {\n        var /** @type {?} */ res = new Array(asts.length);\n        for (var /** @type {?} */ i = 0; i < asts.length; ++i) {\n            res[i] = asts[i].visit(this);\n        }\n        return res;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitChain = function (ast, context) {\n        return new Chain(ast.span, this.visitAll(ast.expressions));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitQuote = function (ast, context) {\n        return new Quote(ast.span, ast.prefix, ast.uninterpretedExpression, ast.location);\n    };\n    return AstTransformer;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar $EOF = 0;\nvar $TAB = 9;\nvar $LF = 10;\nvar $VTAB = 11;\nvar $FF = 12;\nvar $CR = 13;\nvar $SPACE = 32;\nvar $BANG = 33;\nvar $DQ = 34;\nvar $HASH = 35;\nvar $$ = 36;\nvar $PERCENT = 37;\nvar $AMPERSAND = 38;\nvar $SQ = 39;\nvar $LPAREN = 40;\nvar $RPAREN = 41;\nvar $STAR = 42;\nvar $PLUS = 43;\nvar $COMMA = 44;\nvar $MINUS = 45;\nvar $PERIOD = 46;\nvar $SLASH = 47;\nvar $COLON = 58;\nvar $SEMICOLON = 59;\nvar $LT = 60;\nvar $EQ = 61;\nvar $GT = 62;\nvar $QUESTION = 63;\nvar $0 = 48;\nvar $9 = 57;\nvar $A = 65;\nvar $E = 69;\nvar $F = 70;\nvar $X = 88;\nvar $Z = 90;\nvar $LBRACKET = 91;\nvar $BACKSLASH = 92;\nvar $RBRACKET = 93;\nvar $CARET = 94;\nvar $_ = 95;\nvar $a = 97;\nvar $e = 101;\nvar $f = 102;\nvar $n = 110;\nvar $r = 114;\nvar $t = 116;\nvar $u = 117;\nvar $v = 118;\nvar $x = 120;\nvar $z = 122;\nvar $LBRACE = 123;\nvar $BAR = 124;\nvar $RBRACE = 125;\nvar $NBSP = 160;\nvar $BT = 96;\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isWhitespace(code) {\n    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isDigit(code) {\n    return $0 <= code && code <= $9;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isAsciiLetter(code) {\n    return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isAsciiHexDigit(code) {\n    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\n/**\n * A replacement for \\@Injectable to be used in the compiler, so that\n * we don't try to evaluate the metadata in the compiler during AoT.\n * This decorator is enough to make the compiler work with the ReflectiveInjector though.\n * \\@Annotation\n * @return {?}\n */\nfunction CompilerInjectable() {\n    return function (x) { return x; };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} identifier\n * @param {?} value\n * @return {?}\n */\nfunction assertArrayOfStrings(identifier, value) {\n    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"isDevMode\"])() || value == null) {\n        return;\n    }\n    if (!Array.isArray(value)) {\n        throw new Error(\"Expected '\" + identifier + \"' to be an array of strings.\");\n    }\n    for (var /** @type {?} */ i = 0; i < value.length; i += 1) {\n        if (typeof value[i] !== 'string') {\n            throw new Error(\"Expected '\" + identifier + \"' to be an array of strings.\");\n        }\n    }\n}\nvar INTERPOLATION_BLACKLIST_REGEXPS = [\n    /^\\s*$/,\n    /[<>]/,\n    /^[{}]$/,\n    /&(#|[a-z])/i,\n    /^\\/\\//,\n];\n/**\n * @param {?} identifier\n * @param {?} value\n * @return {?}\n */\nfunction assertInterpolationSymbols(identifier, value) {\n    if (value != null && !(Array.isArray(value) && value.length == 2)) {\n        throw new Error(\"Expected '\" + identifier + \"' to be an array, [start, end].\");\n    }\n    else if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"isDevMode\"])() && value != null) {\n        var /** @type {?} */ start_1 = (value[0]);\n        var /** @type {?} */ end_1 = (value[1]);\n        // black list checking\n        INTERPOLATION_BLACKLIST_REGEXPS.forEach(function (regexp) {\n            if (regexp.test(start_1) || regexp.test(end_1)) {\n                throw new Error(\"['\" + start_1 + \"', '\" + end_1 + \"'] contains unusable interpolation symbol.\");\n            }\n        });\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar InterpolationConfig = (function () {\n    /**\n     * @param {?} start\n     * @param {?} end\n     */\n    function InterpolationConfig(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    /**\n     * @param {?} markers\n     * @return {?}\n     */\n    InterpolationConfig.fromArray = function (markers) {\n        if (!markers) {\n            return DEFAULT_INTERPOLATION_CONFIG;\n        }\n        assertInterpolationSymbols('interpolation', markers);\n        return new InterpolationConfig(markers[0], markers[1]);\n    };\n    ;\n    return InterpolationConfig;\n}());\nvar DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TokenType = {};\nTokenType.Character = 0;\nTokenType.Identifier = 1;\nTokenType.Keyword = 2;\nTokenType.String = 3;\nTokenType.Operator = 4;\nTokenType.Number = 5;\nTokenType.Error = 6;\nTokenType[TokenType.Character] = \"Character\";\nTokenType[TokenType.Identifier] = \"Identifier\";\nTokenType[TokenType.Keyword] = \"Keyword\";\nTokenType[TokenType.String] = \"String\";\nTokenType[TokenType.Operator] = \"Operator\";\nTokenType[TokenType.Number] = \"Number\";\nTokenType[TokenType.Error] = \"Error\";\nvar KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\nvar Lexer = (function () {\n    function Lexer() {\n    }\n    /**\n     * @param {?} text\n     * @return {?}\n     */\n    Lexer.prototype.tokenize = function (text) {\n        var /** @type {?} */ scanner = new _Scanner(text);\n        var /** @type {?} */ tokens = [];\n        var /** @type {?} */ token = scanner.scanToken();\n        while (token != null) {\n            tokens.push(token);\n            token = scanner.scanToken();\n        }\n        return tokens;\n    };\n    return Lexer;\n}());\nLexer.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nLexer.ctorParameters = function () { return []; };\nvar Token = (function () {\n    /**\n     * @param {?} index\n     * @param {?} type\n     * @param {?} numValue\n     * @param {?} strValue\n     */\n    function Token(index, type, numValue, strValue) {\n        this.index = index;\n        this.type = type;\n        this.numValue = numValue;\n        this.strValue = strValue;\n    }\n    /**\n     * @param {?} code\n     * @return {?}\n     */\n    Token.prototype.isCharacter = function (code) {\n        return this.type == TokenType.Character && this.numValue == code;\n    };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isNumber = function () { return this.type == TokenType.Number; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isString = function () { return this.type == TokenType.String; };\n    /**\n     * @param {?} operater\n     * @return {?}\n     */\n    Token.prototype.isOperator = function (operater) {\n        return this.type == TokenType.Operator && this.strValue == operater;\n    };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isIdentifier = function () { return this.type == TokenType.Identifier; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeyword = function () { return this.type == TokenType.Keyword; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordLet = function () { return this.type == TokenType.Keyword && this.strValue == 'let'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordAs = function () { return this.type == TokenType.Keyword && this.strValue == 'as'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordNull = function () { return this.type == TokenType.Keyword && this.strValue == 'null'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordUndefined = function () {\n        return this.type == TokenType.Keyword && this.strValue == 'undefined';\n    };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordTrue = function () { return this.type == TokenType.Keyword && this.strValue == 'true'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordFalse = function () { return this.type == TokenType.Keyword && this.strValue == 'false'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordThis = function () { return this.type == TokenType.Keyword && this.strValue == 'this'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isError = function () { return this.type == TokenType.Error; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.toNumber = function () { return this.type == TokenType.Number ? this.numValue : -1; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.toString = function () {\n        switch (this.type) {\n            case TokenType.Character:\n            case TokenType.Identifier:\n            case TokenType.Keyword:\n            case TokenType.Operator:\n            case TokenType.String:\n            case TokenType.Error:\n                return this.strValue;\n            case TokenType.Number:\n                return this.numValue.toString();\n            default:\n                return null;\n        }\n    };\n    return Token;\n}());\n/**\n * @param {?} index\n * @param {?} code\n * @return {?}\n */\nfunction newCharacterToken(index, code) {\n    return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newIdentifierToken(index, text) {\n    return new Token(index, TokenType.Identifier, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newKeywordToken(index, text) {\n    return new Token(index, TokenType.Keyword, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newOperatorToken(index, text) {\n    return new Token(index, TokenType.Operator, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newStringToken(index, text) {\n    return new Token(index, TokenType.String, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} n\n * @return {?}\n */\nfunction newNumberToken(index, n) {\n    return new Token(index, TokenType.Number, n, '');\n}\n/**\n * @param {?} index\n * @param {?} message\n * @return {?}\n */\nfunction newErrorToken(index, message) {\n    return new Token(index, TokenType.Error, 0, message);\n}\nvar EOF = new Token(-1, TokenType.Character, 0, '');\nvar _Scanner = (function () {\n    /**\n     * @param {?} input\n     */\n    function _Scanner(input) {\n        this.input = input;\n        this.peek = 0;\n        this.index = -1;\n        this.length = input.length;\n        this.advance();\n    }\n    /**\n     * @return {?}\n     */\n    _Scanner.prototype.advance = function () {\n        this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);\n    };\n    /**\n     * @return {?}\n     */\n    _Scanner.prototype.scanToken = function () {\n        var /** @type {?} */ input = this.input, /** @type {?} */ length = this.length;\n        var /** @type {?} */ peek = this.peek, /** @type {?} */ index = this.index;\n        // Skip whitespace.\n        while (peek <= $SPACE) {\n            if (++index >= length) {\n                peek = $EOF;\n                break;\n            }\n            else {\n                peek = input.charCodeAt(index);\n            }\n        }\n        this.peek = peek;\n        this.index = index;\n        if (index >= length) {\n            return null;\n        }\n        // Handle identifiers and numbers.\n        if (isIdentifierStart(peek))\n            return this.scanIdentifier();\n        if (isDigit(peek))\n            return this.scanNumber(index);\n        var /** @type {?} */ start = index;\n        switch (peek) {\n            case $PERIOD:\n                this.advance();\n                return isDigit(this.peek) ? this.scanNumber(start) :\n                    newCharacterToken(start, $PERIOD);\n            case $LPAREN:\n            case $RPAREN:\n            case $LBRACE:\n            case $RBRACE:\n            case $LBRACKET:\n            case $RBRACKET:\n            case $COMMA:\n            case $COLON:\n            case $SEMICOLON:\n                return this.scanCharacter(start, peek);\n            case $SQ:\n            case $DQ:\n                return this.scanString();\n            case $HASH:\n            case $PLUS:\n            case $MINUS:\n            case $STAR:\n            case $SLASH:\n            case $PERCENT:\n            case $CARET:\n                return this.scanOperator(start, String.fromCharCode(peek));\n            case $QUESTION:\n                return this.scanComplexOperator(start, '?', $PERIOD, '.');\n            case $LT:\n            case $GT:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');\n            case $BANG:\n            case $EQ:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');\n            case $AMPERSAND:\n                return this.scanComplexOperator(start, '&', $AMPERSAND, '&');\n            case $BAR:\n                return this.scanComplexOperator(start, '|', $BAR, '|');\n            case $NBSP:\n                while (isWhitespace(this.peek))\n                    this.advance();\n                return this.scanToken();\n        }\n        this.advance();\n        return this.error(\"Unexpected character [\" + String.fromCharCode(peek) + \"]\", 0);\n    };\n    /**\n     * @param {?} start\n     * @param {?} code\n     * @return {?}\n     */\n    _Scanner.prototype.scanCharacter = function (start, code) {\n        this.advance();\n        return newCharacterToken(start, code);\n    };\n    /**\n     * @param {?} start\n     * @param {?} str\n     * @return {?}\n     */\n    _Scanner.prototype.scanOperator = function (start, str) {\n        this.advance();\n        return newOperatorToken(start, str);\n    };\n    /**\n     * Tokenize a 2/3 char long operator\n     *\n     * @param {?} start start index in the expression\n     * @param {?} one first symbol (always part of the operator)\n     * @param {?} twoCode code point for the second symbol\n     * @param {?} two second symbol (part of the operator when the second code point matches)\n     * @param {?=} threeCode code point for the third symbol\n     * @param {?=} three third symbol (part of the operator when provided and matches source expression)\n     * @return {?}\n     */\n    _Scanner.prototype.scanComplexOperator = function (start, one, twoCode, two, threeCode, three) {\n        this.advance();\n        var /** @type {?} */ str = one;\n        if (this.peek == twoCode) {\n            this.advance();\n            str += two;\n        }\n        if (threeCode != null && this.peek == threeCode) {\n            this.advance();\n            str += three;\n        }\n        return newOperatorToken(start, str);\n    };\n    /**\n     * @return {?}\n     */\n    _Scanner.prototype.scanIdentifier = function () {\n        var /** @type {?} */ start = this.index;\n        this.advance();\n        while (isIdentifierPart(this.peek))\n            this.advance();\n        var /** @type {?} */ str = this.input.substring(start, this.index);\n        return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :\n            newIdentifierToken(start, str);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Scanner.prototype.scanNumber = function (start) {\n        var /** @type {?} */ simple = (this.index === start);\n        this.advance(); // Skip initial digit.\n        while (true) {\n            if (isDigit(this.peek)) {\n            }\n            else if (this.peek == $PERIOD) {\n                simple = false;\n            }\n            else if (isExponentStart(this.peek)) {\n                this.advance();\n                if (isExponentSign(this.peek))\n                    this.advance();\n                if (!isDigit(this.peek))\n                    return this.error('Invalid exponent', -1);\n                simple = false;\n            }\n            else {\n                break;\n            }\n            this.advance();\n        }\n        var /** @type {?} */ str = this.input.substring(start, this.index);\n        var /** @type {?} */ value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n        return newNumberToken(start, value);\n    };\n    /**\n     * @return {?}\n     */\n    _Scanner.prototype.scanString = function () {\n        var /** @type {?} */ start = this.index;\n        var /** @type {?} */ quote = this.peek;\n        this.advance(); // Skip initial quote.\n        var /** @type {?} */ buffer = '';\n        var /** @type {?} */ marker = this.index;\n        var /** @type {?} */ input = this.input;\n        while (this.peek != quote) {\n            if (this.peek == $BACKSLASH) {\n                buffer += input.substring(marker, this.index);\n                this.advance();\n                var /** @type {?} */ unescapedCode = void 0;\n                // Workaround for TS2.1-introduced type strictness\n                this.peek = this.peek;\n                if (this.peek == $u) {\n                    // 4 character hex code for unicode character.\n                    var /** @type {?} */ hex = input.substring(this.index + 1, this.index + 5);\n                    if (/^[0-9a-f]+$/i.test(hex)) {\n                        unescapedCode = parseInt(hex, 16);\n                    }\n                    else {\n                        return this.error(\"Invalid unicode escape [\\\\u\" + hex + \"]\", 0);\n                    }\n                    for (var /** @type {?} */ i = 0; i < 5; i++) {\n                        this.advance();\n                    }\n                }\n                else {\n                    unescapedCode = unescape(this.peek);\n                    this.advance();\n                }\n                buffer += String.fromCharCode(unescapedCode);\n                marker = this.index;\n            }\n            else if (this.peek == $EOF) {\n                return this.error('Unterminated quote', 0);\n            }\n            else {\n                this.advance();\n            }\n        }\n        var /** @type {?} */ last = input.substring(marker, this.index);\n        this.advance(); // Skip terminating quote.\n        return newStringToken(start, buffer + last);\n    };\n    /**\n     * @param {?} message\n     * @param {?} offset\n     * @return {?}\n     */\n    _Scanner.prototype.error = function (message, offset) {\n        var /** @type {?} */ position = this.index + offset;\n        return newErrorToken(position, \"Lexer Error: \" + message + \" at column \" + position + \" in expression [\" + this.input + \"]\");\n    };\n    return _Scanner;\n}());\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierStart(code) {\n    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||\n        (code == $_) || (code == $$);\n}\n/**\n * @param {?} input\n * @return {?}\n */\nfunction isIdentifier(input) {\n    if (input.length == 0)\n        return false;\n    var /** @type {?} */ scanner = new _Scanner(input);\n    if (!isIdentifierStart(scanner.peek))\n        return false;\n    scanner.advance();\n    while (scanner.peek !== $EOF) {\n        if (!isIdentifierPart(scanner.peek))\n            return false;\n        scanner.advance();\n    }\n    return true;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierPart(code) {\n    return isAsciiLetter(code) || isDigit(code) || (code == $_) ||\n        (code == $$);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentStart(code) {\n    return code == $e || code == $E;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentSign(code) {\n    return code == $MINUS || code == $PLUS;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isQuote(code) {\n    return code === $SQ || code === $DQ || code === $BT;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction unescape(code) {\n    switch (code) {\n        case $n:\n            return $LF;\n        case $f:\n            return $FF;\n        case $r:\n            return $CR;\n        case $t:\n            return $TAB;\n        case $v:\n            return $VTAB;\n        default:\n            return code;\n    }\n}\n/**\n * @param {?} text\n * @return {?}\n */\nfunction parseIntAutoRadix(text) {\n    var /** @type {?} */ result = parseInt(text);\n    if (isNaN(result)) {\n        throw new Error('Invalid integer literal when parsing ' + text);\n    }\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar SplitInterpolation = (function () {\n    /**\n     * @param {?} strings\n     * @param {?} expressions\n     * @param {?} offsets\n     */\n    function SplitInterpolation(strings, expressions, offsets) {\n        this.strings = strings;\n        this.expressions = expressions;\n        this.offsets = offsets;\n    }\n    return SplitInterpolation;\n}());\nvar TemplateBindingParseResult = (function () {\n    /**\n     * @param {?} templateBindings\n     * @param {?} warnings\n     * @param {?} errors\n     */\n    function TemplateBindingParseResult(templateBindings, warnings, errors) {\n        this.templateBindings = templateBindings;\n        this.warnings = warnings;\n        this.errors = errors;\n    }\n    return TemplateBindingParseResult;\n}());\n/**\n * @param {?} config\n * @return {?}\n */\nfunction _createInterpolateRegExp(config) {\n    var /** @type {?} */ pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\n    return new RegExp(pattern, 'g');\n}\nvar Parser = (function () {\n    /**\n     * @param {?} _lexer\n     */\n    function Parser(_lexer) {\n        this._lexer = _lexer;\n        this.errors = [];\n    }\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.parseAction = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        var /** @type {?} */ sourceToLex = this._stripComments(input);\n        var /** @type {?} */ tokens = this._lexer.tokenize(this._stripComments(input));\n        var /** @type {?} */ ast = new _ParseAST(input, location, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length)\n            .parseChain();\n        return new ASTWithSource(ast, input, location, this.errors);\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.parseBinding = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ ast = this._parseBindingAst(input, location, interpolationConfig);\n        return new ASTWithSource(ast, input, location, this.errors);\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.parseSimpleBinding = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ ast = this._parseBindingAst(input, location, interpolationConfig);\n        var /** @type {?} */ errors = SimpleExpressionChecker.check(ast);\n        if (errors.length > 0) {\n            this._reportError(\"Host binding expression cannot contain \" + errors.join(' '), input, location);\n        }\n        return new ASTWithSource(ast, input, location, this.errors);\n    };\n    /**\n     * @param {?} message\n     * @param {?} input\n     * @param {?} errLocation\n     * @param {?=} ctxLocation\n     * @return {?}\n     */\n    Parser.prototype._reportError = function (message, input, errLocation, ctxLocation) {\n        this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype._parseBindingAst = function (input, location, interpolationConfig) {\n        // Quotes expressions use 3rd-party expression language. We don't want to use\n        // our lexer or parser for that, so we check for that ahead of time.\n        var /** @type {?} */ quote = this._parseQuote(input, location);\n        if (quote != null) {\n            return quote;\n        }\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        var /** @type {?} */ sourceToLex = this._stripComments(input);\n        var /** @type {?} */ tokens = this._lexer.tokenize(sourceToLex);\n        return new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length)\n            .parseChain();\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @return {?}\n     */\n    Parser.prototype._parseQuote = function (input, location) {\n        if (input == null)\n            return null;\n        var /** @type {?} */ prefixSeparatorIndex = input.indexOf(':');\n        if (prefixSeparatorIndex == -1)\n            return null;\n        var /** @type {?} */ prefix = input.substring(0, prefixSeparatorIndex).trim();\n        if (!isIdentifier(prefix))\n            return null;\n        var /** @type {?} */ uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n        return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n    };\n    /**\n     * @param {?} prefixToken\n     * @param {?} input\n     * @param {?} location\n     * @return {?}\n     */\n    Parser.prototype.parseTemplateBindings = function (prefixToken, input, location) {\n        var /** @type {?} */ tokens = this._lexer.tokenize(input);\n        if (prefixToken) {\n            // Prefix the tokens with the tokens from prefixToken but have them take no space (0 index).\n            var /** @type {?} */ prefixTokens = this._lexer.tokenize(prefixToken).map(function (t) {\n                t.index = 0;\n                return t;\n            });\n            tokens.unshift.apply(tokens, prefixTokens);\n        }\n        return new _ParseAST(input, location, tokens, input.length, false, this.errors, 0)\n            .parseTemplateBindings();\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.parseInterpolation = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ split = this.splitInterpolation(input, location, interpolationConfig);\n        if (split == null)\n            return null;\n        var /** @type {?} */ expressions = [];\n        for (var /** @type {?} */ i = 0; i < split.expressions.length; ++i) {\n            var /** @type {?} */ expressionText = split.expressions[i];\n            var /** @type {?} */ sourceToLex = this._stripComments(expressionText);\n            var /** @type {?} */ tokens = this._lexer.tokenize(this._stripComments(split.expressions[i]));\n            var /** @type {?} */ ast = new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, split.offsets[i] + (expressionText.length - sourceToLex.length))\n                .parseChain();\n            expressions.push(ast);\n        }\n        return new ASTWithSource(new Interpolation(new ParseSpan(0, input == null ? 0 : input.length), split.strings, expressions), input, location, this.errors);\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.splitInterpolation = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ regexp = _createInterpolateRegExp(interpolationConfig);\n        var /** @type {?} */ parts = input.split(regexp);\n        if (parts.length <= 1) {\n            return null;\n        }\n        var /** @type {?} */ strings = [];\n        var /** @type {?} */ expressions = [];\n        var /** @type {?} */ offsets = [];\n        var /** @type {?} */ offset = 0;\n        for (var /** @type {?} */ i = 0; i < parts.length; i++) {\n            var /** @type {?} */ part = parts[i];\n            if (i % 2 === 0) {\n                // fixed string\n                strings.push(part);\n                offset += part.length;\n            }\n            else if (part.trim().length > 0) {\n                offset += interpolationConfig.start.length;\n                expressions.push(part);\n                offsets.push(offset);\n                offset += part.length + interpolationConfig.end.length;\n            }\n            else {\n                this._reportError('Blank expressions are not allowed in interpolated strings', input, \"at column \" + this._findInterpolationErrorColumn(parts, i, interpolationConfig) + \" in\", location);\n                expressions.push('$implict');\n                offsets.push(offset);\n            }\n        }\n        return new SplitInterpolation(strings, expressions, offsets);\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @return {?}\n     */\n    Parser.prototype.wrapLiteralPrimitive = function (input, location) {\n        return new ASTWithSource(new LiteralPrimitive(new ParseSpan(0, input == null ? 0 : input.length), input), input, location, this.errors);\n    };\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    Parser.prototype._stripComments = function (input) {\n        var /** @type {?} */ i = this._commentStart(input);\n        return i != null ? input.substring(0, i).trim() : input;\n    };\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    Parser.prototype._commentStart = function (input) {\n        var /** @type {?} */ outerQuote = null;\n        for (var /** @type {?} */ i = 0; i < input.length - 1; i++) {\n            var /** @type {?} */ char = input.charCodeAt(i);\n            var /** @type {?} */ nextChar = input.charCodeAt(i + 1);\n            if (char === $SLASH && nextChar == $SLASH && outerQuote == null)\n                return i;\n            if (outerQuote === char) {\n                outerQuote = null;\n            }\n            else if (outerQuote == null && isQuote(char)) {\n                outerQuote = char;\n            }\n        }\n        return null;\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype._checkNoInterpolation = function (input, location, interpolationConfig) {\n        var /** @type {?} */ regexp = _createInterpolateRegExp(interpolationConfig);\n        var /** @type {?} */ parts = input.split(regexp);\n        if (parts.length > 1) {\n            this._reportError(\"Got interpolation (\" + interpolationConfig.start + interpolationConfig.end + \") where expression was expected\", input, \"at column \" + this._findInterpolationErrorColumn(parts, 1, interpolationConfig) + \" in\", location);\n        }\n    };\n    /**\n     * @param {?} parts\n     * @param {?} partInErrIdx\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype._findInterpolationErrorColumn = function (parts, partInErrIdx, interpolationConfig) {\n        var /** @type {?} */ errLocation = '';\n        for (var /** @type {?} */ j = 0; j < partInErrIdx; j++) {\n            errLocation += j % 2 === 0 ?\n                parts[j] :\n                \"\" + interpolationConfig.start + parts[j] + interpolationConfig.end;\n        }\n        return errLocation.length;\n    };\n    return Parser;\n}());\nParser.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nParser.ctorParameters = function () { return [\n    { type: Lexer, },\n]; };\nvar _ParseAST = (function () {\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?} tokens\n     * @param {?} inputLength\n     * @param {?} parseAction\n     * @param {?} errors\n     * @param {?} offset\n     */\n    function _ParseAST(input, location, tokens, inputLength, parseAction, errors, offset) {\n        this.input = input;\n        this.location = location;\n        this.tokens = tokens;\n        this.inputLength = inputLength;\n        this.parseAction = parseAction;\n        this.errors = errors;\n        this.offset = offset;\n        this.rparensExpected = 0;\n        this.rbracketsExpected = 0;\n        this.rbracesExpected = 0;\n        this.index = 0;\n    }\n    /**\n     * @param {?} offset\n     * @return {?}\n     */\n    _ParseAST.prototype.peek = function (offset) {\n        var /** @type {?} */ i = this.index + offset;\n        return i < this.tokens.length ? this.tokens[i] : EOF;\n    };\n    Object.defineProperty(_ParseAST.prototype, \"next\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.peek(0); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(_ParseAST.prototype, \"inputIndex\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return (this.index < this.tokens.length) ? this.next.index + this.offset :\n                this.inputLength + this.offset;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _ParseAST.prototype.span = function (start) { return new ParseSpan(start, this.inputIndex); };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.advance = function () { this.index++; };\n    /**\n     * @param {?} code\n     * @return {?}\n     */\n    _ParseAST.prototype.optionalCharacter = function (code) {\n        if (this.next.isCharacter(code)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.peekKeywordLet = function () { return this.next.isKeywordLet(); };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.peekKeywordAs = function () { return this.next.isKeywordAs(); };\n    /**\n     * @param {?} code\n     * @return {?}\n     */\n    _ParseAST.prototype.expectCharacter = function (code) {\n        if (this.optionalCharacter(code))\n            return;\n        this.error(\"Missing expected \" + String.fromCharCode(code));\n    };\n    /**\n     * @param {?} op\n     * @return {?}\n     */\n    _ParseAST.prototype.optionalOperator = function (op) {\n        if (this.next.isOperator(op)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * @param {?} operator\n     * @return {?}\n     */\n    _ParseAST.prototype.expectOperator = function (operator) {\n        if (this.optionalOperator(operator))\n            return;\n        this.error(\"Missing expected operator \" + operator);\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.expectIdentifierOrKeyword = function () {\n        var /** @type {?} */ n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword()) {\n            this.error(\"Unexpected token \" + n + \", expected identifier or keyword\");\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.expectIdentifierOrKeywordOrString = function () {\n        var /** @type {?} */ n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n            this.error(\"Unexpected token \" + n + \", expected identifier, keyword, or string\");\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseChain = function () {\n        var /** @type {?} */ exprs = [];\n        var /** @type {?} */ start = this.inputIndex;\n        while (this.index < this.tokens.length) {\n            var /** @type {?} */ expr = this.parsePipe();\n            exprs.push(expr);\n            if (this.optionalCharacter($SEMICOLON)) {\n                if (!this.parseAction) {\n                    this.error('Binding expression cannot contain chained expression');\n                }\n                while (this.optionalCharacter($SEMICOLON)) {\n                } // read all semicolons\n            }\n            else if (this.index < this.tokens.length) {\n                this.error(\"Unexpected token '\" + this.next + \"'\");\n            }\n        }\n        if (exprs.length == 0)\n            return new EmptyExpr(this.span(start));\n        if (exprs.length == 1)\n            return exprs[0];\n        return new Chain(this.span(start), exprs);\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parsePipe = function () {\n        var /** @type {?} */ result = this.parseExpression();\n        if (this.optionalOperator('|')) {\n            if (this.parseAction) {\n                this.error('Cannot have a pipe in an action expression');\n            }\n            do {\n                var /** @type {?} */ name = ((this.expectIdentifierOrKeyword()));\n                var /** @type {?} */ args = [];\n                while (this.optionalCharacter($COLON)) {\n                    args.push(this.parseExpression());\n                }\n                result = new BindingPipe(this.span(result.span.start), result, name, args);\n            } while (this.optionalOperator('|'));\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseExpression = function () { return this.parseConditional(); };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseConditional = function () {\n        var /** @type {?} */ start = this.inputIndex;\n        var /** @type {?} */ result = this.parseLogicalOr();\n        if (this.optionalOperator('?')) {\n            var /** @type {?} */ yes = this.parsePipe();\n            var /** @type {?} */ no = void 0;\n            if (!this.optionalCharacter($COLON)) {\n                var /** @type {?} */ end = this.inputIndex;\n                var /** @type {?} */ expression = this.input.substring(start, end);\n                this.error(\"Conditional expression \" + expression + \" requires all 3 expressions\");\n                no = new EmptyExpr(this.span(start));\n            }\n            else {\n                no = this.parsePipe();\n            }\n            return new Conditional(this.span(start), result, yes, no);\n        }\n        else {\n            return result;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseLogicalOr = function () {\n        // '||'\n        var /** @type {?} */ result = this.parseLogicalAnd();\n        while (this.optionalOperator('||')) {\n            var /** @type {?} */ right = this.parseLogicalAnd();\n            result = new Binary(this.span(result.span.start), '||', result, right);\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseLogicalAnd = function () {\n        // '&&'\n        var /** @type {?} */ result = this.parseEquality();\n        while (this.optionalOperator('&&')) {\n            var /** @type {?} */ right = this.parseEquality();\n            result = new Binary(this.span(result.span.start), '&&', result, right);\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseEquality = function () {\n        // '==','!=','===','!=='\n        var /** @type {?} */ result = this.parseRelational();\n        while (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '==':\n                case '===':\n                case '!=':\n                case '!==':\n                    this.advance();\n                    var /** @type {?} */ right = this.parseRelational();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseRelational = function () {\n        // '<', '>', '<=', '>='\n        var /** @type {?} */ result = this.parseAdditive();\n        while (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '<':\n                case '>':\n                case '<=':\n                case '>=':\n                    this.advance();\n                    var /** @type {?} */ right = this.parseAdditive();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseAdditive = function () {\n        // '+', '-'\n        var /** @type {?} */ result = this.parseMultiplicative();\n        while (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '+':\n                case '-':\n                    this.advance();\n                    var /** @type {?} */ right = this.parseMultiplicative();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseMultiplicative = function () {\n        // '*', '%', '/'\n        var /** @type {?} */ result = this.parsePrefix();\n        while (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '*':\n                case '%':\n                case '/':\n                    this.advance();\n                    var /** @type {?} */ right = this.parsePrefix();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parsePrefix = function () {\n        if (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ start = this.inputIndex;\n            var /** @type {?} */ operator = this.next.strValue;\n            var /** @type {?} */ result = void 0;\n            switch (operator) {\n                case '+':\n                    this.advance();\n                    return this.parsePrefix();\n                case '-':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new Binary(this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0), result);\n                case '!':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new PrefixNot(this.span(start), result);\n            }\n        }\n        return this.parseCallChain();\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseCallChain = function () {\n        var /** @type {?} */ result = this.parsePrimary();\n        while (true) {\n            if (this.optionalCharacter($PERIOD)) {\n                result = this.parseAccessMemberOrMethodCall(result, false);\n            }\n            else if (this.optionalOperator('?.')) {\n                result = this.parseAccessMemberOrMethodCall(result, true);\n            }\n            else if (this.optionalCharacter($LBRACKET)) {\n                this.rbracketsExpected++;\n                var /** @type {?} */ key = this.parsePipe();\n                this.rbracketsExpected--;\n                this.expectCharacter($RBRACKET);\n                if (this.optionalOperator('=')) {\n                    var /** @type {?} */ value = this.parseConditional();\n                    result = new KeyedWrite(this.span(result.span.start), result, key, value);\n                }\n                else {\n                    result = new KeyedRead(this.span(result.span.start), result, key);\n                }\n            }\n            else if (this.optionalCharacter($LPAREN)) {\n                this.rparensExpected++;\n                var /** @type {?} */ args = this.parseCallArguments();\n                this.rparensExpected--;\n                this.expectCharacter($RPAREN);\n                result = new FunctionCall(this.span(result.span.start), result, args);\n            }\n            else {\n                return result;\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parsePrimary = function () {\n        var /** @type {?} */ start = this.inputIndex;\n        if (this.optionalCharacter($LPAREN)) {\n            this.rparensExpected++;\n            var /** @type {?} */ result = this.parsePipe();\n            this.rparensExpected--;\n            this.expectCharacter($RPAREN);\n            return result;\n        }\n        else if (this.next.isKeywordNull()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), null);\n        }\n        else if (this.next.isKeywordUndefined()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), void 0);\n        }\n        else if (this.next.isKeywordTrue()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), true);\n        }\n        else if (this.next.isKeywordFalse()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), false);\n        }\n        else if (this.next.isKeywordThis()) {\n            this.advance();\n            return new ImplicitReceiver(this.span(start));\n        }\n        else if (this.optionalCharacter($LBRACKET)) {\n            this.rbracketsExpected++;\n            var /** @type {?} */ elements = this.parseExpressionList($RBRACKET);\n            this.rbracketsExpected--;\n            this.expectCharacter($RBRACKET);\n            return new LiteralArray(this.span(start), elements);\n        }\n        else if (this.next.isCharacter($LBRACE)) {\n            return this.parseLiteralMap();\n        }\n        else if (this.next.isIdentifier()) {\n            return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n        }\n        else if (this.next.isNumber()) {\n            var /** @type {?} */ value = this.next.toNumber();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), value);\n        }\n        else if (this.next.isString()) {\n            var /** @type {?} */ literalValue = this.next.toString();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), literalValue);\n        }\n        else if (this.index >= this.tokens.length) {\n            this.error(\"Unexpected end of expression: \" + this.input);\n            return new EmptyExpr(this.span(start));\n        }\n        else {\n            this.error(\"Unexpected token \" + this.next);\n            return new EmptyExpr(this.span(start));\n        }\n    };\n    /**\n     * @param {?} terminator\n     * @return {?}\n     */\n    _ParseAST.prototype.parseExpressionList = function (terminator) {\n        var /** @type {?} */ result = [];\n        if (!this.next.isCharacter(terminator)) {\n            do {\n                result.push(this.parsePipe());\n            } while (this.optionalCharacter($COMMA));\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseLiteralMap = function () {\n        var /** @type {?} */ keys = [];\n        var /** @type {?} */ values = [];\n        var /** @type {?} */ start = this.inputIndex;\n        this.expectCharacter($LBRACE);\n        if (!this.optionalCharacter($RBRACE)) {\n            this.rbracesExpected++;\n            do {\n                var /** @type {?} */ key = ((this.expectIdentifierOrKeywordOrString()));\n                keys.push(key);\n                this.expectCharacter($COLON);\n                values.push(this.parsePipe());\n            } while (this.optionalCharacter($COMMA));\n            this.rbracesExpected--;\n            this.expectCharacter($RBRACE);\n        }\n        return new LiteralMap(this.span(start), keys, values);\n    };\n    /**\n     * @param {?} receiver\n     * @param {?=} isSafe\n     * @return {?}\n     */\n    _ParseAST.prototype.parseAccessMemberOrMethodCall = function (receiver, isSafe) {\n        if (isSafe === void 0) { isSafe = false; }\n        var /** @type {?} */ start = receiver.span.start;\n        var /** @type {?} */ id = ((this.expectIdentifierOrKeyword()));\n        if (this.optionalCharacter($LPAREN)) {\n            this.rparensExpected++;\n            var /** @type {?} */ args = this.parseCallArguments();\n            this.expectCharacter($RPAREN);\n            this.rparensExpected--;\n            var /** @type {?} */ span = this.span(start);\n            return isSafe ? new SafeMethodCall(span, receiver, id, args) :\n                new MethodCall(span, receiver, id, args);\n        }\n        else {\n            if (isSafe) {\n                if (this.optionalOperator('=')) {\n                    this.error('The \\'?.\\' operator cannot be used in the assignment');\n                    return new EmptyExpr(this.span(start));\n                }\n                else {\n                    return new SafePropertyRead(this.span(start), receiver, id);\n                }\n            }\n            else {\n                if (this.optionalOperator('=')) {\n                    if (!this.parseAction) {\n                        this.error('Bindings cannot contain assignments');\n                        return new EmptyExpr(this.span(start));\n                    }\n                    var /** @type {?} */ value = this.parseConditional();\n                    return new PropertyWrite(this.span(start), receiver, id, value);\n                }\n                else {\n                    return new PropertyRead(this.span(start), receiver, id);\n                }\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseCallArguments = function () {\n        if (this.next.isCharacter($RPAREN))\n            return [];\n        var /** @type {?} */ positionals = [];\n        do {\n            positionals.push(this.parsePipe());\n        } while (this.optionalCharacter($COMMA));\n        return (positionals);\n    };\n    /**\n     * An identifier, a keyword, a string with an optional `-` inbetween.\n     * @return {?}\n     */\n    _ParseAST.prototype.expectTemplateBindingKey = function () {\n        var /** @type {?} */ result = '';\n        var /** @type {?} */ operatorFound = false;\n        do {\n            result += this.expectIdentifierOrKeywordOrString();\n            operatorFound = this.optionalOperator('-');\n            if (operatorFound) {\n                result += '-';\n            }\n        } while (operatorFound);\n        return result.toString();\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseTemplateBindings = function () {\n        var /** @type {?} */ bindings = [];\n        var /** @type {?} */ prefix = ((null));\n        var /** @type {?} */ warnings = [];\n        while (this.index < this.tokens.length) {\n            var /** @type {?} */ start = this.inputIndex;\n            var /** @type {?} */ keyIsVar = this.peekKeywordLet();\n            if (keyIsVar) {\n                this.advance();\n            }\n            var /** @type {?} */ rawKey = this.expectTemplateBindingKey();\n            var /** @type {?} */ key = rawKey;\n            if (!keyIsVar) {\n                if (prefix == null) {\n                    prefix = key;\n                }\n                else {\n                    key = prefix + key[0].toUpperCase() + key.substring(1);\n                }\n            }\n            this.optionalCharacter($COLON);\n            var /** @type {?} */ name = ((null));\n            var /** @type {?} */ expression = ((null));\n            if (keyIsVar) {\n                if (this.optionalOperator('=')) {\n                    name = this.expectTemplateBindingKey();\n                }\n                else {\n                    name = '\\$implicit';\n                }\n            }\n            else if (this.peekKeywordAs()) {\n                var /** @type {?} */ letStart = this.inputIndex;\n                this.advance(); // consume `as`\n                name = rawKey;\n                key = this.expectTemplateBindingKey(); // read local var name\n                keyIsVar = true;\n            }\n            else if (this.next !== EOF && !this.peekKeywordLet()) {\n                var /** @type {?} */ start_2 = this.inputIndex;\n                var /** @type {?} */ ast = this.parsePipe();\n                var /** @type {?} */ source = this.input.substring(start_2 - this.offset, this.inputIndex - this.offset);\n                expression = new ASTWithSource(ast, source, this.location, this.errors);\n            }\n            bindings.push(new TemplateBinding(this.span(start), key, keyIsVar, name, expression));\n            if (this.peekKeywordAs() && !keyIsVar) {\n                var /** @type {?} */ letStart = this.inputIndex;\n                this.advance(); // consume `as`\n                var /** @type {?} */ letName = this.expectTemplateBindingKey(); // read local var name\n                bindings.push(new TemplateBinding(this.span(letStart), letName, true, key, /** @type {?} */ ((null))));\n            }\n            if (!this.optionalCharacter($SEMICOLON)) {\n                this.optionalCharacter($COMMA);\n            }\n        }\n        return new TemplateBindingParseResult(bindings, warnings, this.errors);\n    };\n    /**\n     * @param {?} message\n     * @param {?=} index\n     * @return {?}\n     */\n    _ParseAST.prototype.error = function (message, index) {\n        if (index === void 0) { index = null; }\n        this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n        this.skip();\n    };\n    /**\n     * @param {?=} index\n     * @return {?}\n     */\n    _ParseAST.prototype.locationText = function (index) {\n        if (index === void 0) { index = null; }\n        if (index == null)\n            index = this.index;\n        return (index < this.tokens.length) ? \"at column \" + (this.tokens[index].index + 1) + \" in\" :\n            \"at the end of the expression\";\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.skip = function () {\n        var /** @type {?} */ n = this.next;\n        while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&\n            (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&\n            (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&\n            (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET))) {\n            if (this.next.isError()) {\n                this.errors.push(new ParserError(/** @type {?} */ ((this.next.toString())), this.input, this.locationText(), this.location));\n            }\n            this.advance();\n            n = this.next;\n        }\n    };\n    return _ParseAST;\n}());\nvar SimpleExpressionChecker = (function () {\n    function SimpleExpressionChecker() {\n        this.errors = [];\n    }\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    SimpleExpressionChecker.check = function (ast) {\n        var /** @type {?} */ s = new SimpleExpressionChecker();\n        ast.visit(s);\n        return s.errors;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitImplicitReceiver = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitInterpolation = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitLiteralPrimitive = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitPropertyRead = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitPropertyWrite = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitSafePropertyRead = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitMethodCall = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitSafeMethodCall = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitFunctionCall = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitLiteralArray = function (ast, context) { this.visitAll(ast.expressions); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitLiteralMap = function (ast, context) { this.visitAll(ast.values); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitBinary = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitPrefixNot = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitConditional = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitPipe = function (ast, context) { this.errors.push('pipes'); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitKeyedRead = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitKeyedWrite = function (ast, context) { };\n    /**\n     * @param {?} asts\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitAll = function (asts) {\n        var _this = this;\n        return asts.map(function (node) { return node.visit(_this); });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitChain = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitQuote = function (ast, context) { };\n    return SimpleExpressionChecker;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ParseLocation = (function () {\n    /**\n     * @param {?} file\n     * @param {?} offset\n     * @param {?} line\n     * @param {?} col\n     */\n    function ParseLocation(file, offset, line, col) {\n        this.file = file;\n        this.offset = offset;\n        this.line = line;\n        this.col = col;\n    }\n    /**\n     * @return {?}\n     */\n    ParseLocation.prototype.toString = function () {\n        return this.offset != null ? this.file.url + \"@\" + this.line + \":\" + this.col : this.file.url;\n    };\n    /**\n     * @param {?} delta\n     * @return {?}\n     */\n    ParseLocation.prototype.moveBy = function (delta) {\n        var /** @type {?} */ source = this.file.content;\n        var /** @type {?} */ len = source.length;\n        var /** @type {?} */ offset = this.offset;\n        var /** @type {?} */ line = this.line;\n        var /** @type {?} */ col = this.col;\n        while (offset > 0 && delta < 0) {\n            offset--;\n            delta++;\n            var /** @type {?} */ ch = source.charCodeAt(offset);\n            if (ch == $LF) {\n                line--;\n                var /** @type {?} */ priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));\n                col = priorLine > 0 ? offset - priorLine : offset;\n            }\n            else {\n                col--;\n            }\n        }\n        while (offset < len && delta > 0) {\n            var /** @type {?} */ ch = source.charCodeAt(offset);\n            offset++;\n            delta--;\n            if (ch == $LF) {\n                line++;\n                col = 0;\n            }\n            else {\n                col++;\n            }\n        }\n        return new ParseLocation(this.file, offset, line, col);\n    };\n    /**\n     * @param {?} maxChars\n     * @param {?} maxLines\n     * @return {?}\n     */\n    ParseLocation.prototype.getContext = function (maxChars, maxLines) {\n        var /** @type {?} */ content = this.file.content;\n        var /** @type {?} */ startOffset = this.offset;\n        if (startOffset != null) {\n            if (startOffset > content.length - 1) {\n                startOffset = content.length - 1;\n            }\n            var /** @type {?} */ endOffset = startOffset;\n            var /** @type {?} */ ctxChars = 0;\n            var /** @type {?} */ ctxLines = 0;\n            while (ctxChars < maxChars && startOffset > 0) {\n                startOffset--;\n                ctxChars++;\n                if (content[startOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            ctxChars = 0;\n            ctxLines = 0;\n            while (ctxChars < maxChars && endOffset < content.length - 1) {\n                endOffset++;\n                ctxChars++;\n                if (content[endOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            return {\n                before: content.substring(startOffset, this.offset),\n                after: content.substring(this.offset, endOffset + 1),\n            };\n        }\n        return null;\n    };\n    return ParseLocation;\n}());\nvar ParseSourceFile = (function () {\n    /**\n     * @param {?} content\n     * @param {?} url\n     */\n    function ParseSourceFile(content, url) {\n        this.content = content;\n        this.url = url;\n    }\n    return ParseSourceFile;\n}());\nvar ParseSourceSpan = (function () {\n    /**\n     * @param {?} start\n     * @param {?} end\n     * @param {?=} details\n     */\n    function ParseSourceSpan(start, end, details) {\n        if (details === void 0) { details = null; }\n        this.start = start;\n        this.end = end;\n        this.details = details;\n    }\n    /**\n     * @return {?}\n     */\n    ParseSourceSpan.prototype.toString = function () {\n        return this.start.file.content.substring(this.start.offset, this.end.offset);\n    };\n    return ParseSourceSpan;\n}());\nvar ParseErrorLevel = {};\nParseErrorLevel.WARNING = 0;\nParseErrorLevel.ERROR = 1;\nParseErrorLevel[ParseErrorLevel.WARNING] = \"WARNING\";\nParseErrorLevel[ParseErrorLevel.ERROR] = \"ERROR\";\nvar ParseError = (function () {\n    /**\n     * @param {?} span\n     * @param {?} msg\n     * @param {?=} level\n     */\n    function ParseError(span, msg, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this.span = span;\n        this.msg = msg;\n        this.level = level;\n    }\n    /**\n     * @return {?}\n     */\n    ParseError.prototype.toString = function () {\n        var /** @type {?} */ ctx = this.span.start.getContext(100, 3);\n        var /** @type {?} */ contextStr = ctx ? \" (\\\"\" + ctx.before + \"[\" + ParseErrorLevel[this.level] + \" ->]\" + ctx.after + \"\\\")\" : '';\n        var /** @type {?} */ details = this.span.details ? \", \" + this.span.details : '';\n        return \"\" + this.msg + contextStr + \": \" + this.span.start + details;\n    };\n    return ParseError;\n}());\n/**\n * @param {?} kind\n * @param {?} type\n * @return {?}\n */\nfunction typeSourceSpan(kind, type) {\n    var /** @type {?} */ moduleUrl = identifierModuleUrl(type);\n    var /** @type {?} */ sourceFileName = moduleUrl != null ? \"in \" + kind + \" \" + identifierName(type) + \" in \" + moduleUrl :\n        \"in \" + kind + \" \" + identifierName(type);\n    var /** @type {?} */ sourceFile = new ParseSourceFile('', sourceFileName);\n    return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Text = (function () {\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function Text(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Text.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\n    return Text;\n}());\nvar Expansion = (function () {\n    /**\n     * @param {?} switchValue\n     * @param {?} type\n     * @param {?} cases\n     * @param {?} sourceSpan\n     * @param {?} switchValueSourceSpan\n     */\n    function Expansion(switchValue, type, cases, sourceSpan, switchValueSourceSpan) {\n        this.switchValue = switchValue;\n        this.type = type;\n        this.cases = cases;\n        this.sourceSpan = sourceSpan;\n        this.switchValueSourceSpan = switchValueSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Expansion.prototype.visit = function (visitor, context) { return visitor.visitExpansion(this, context); };\n    return Expansion;\n}());\nvar ExpansionCase = (function () {\n    /**\n     * @param {?} value\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} valueSourceSpan\n     * @param {?} expSourceSpan\n     */\n    function ExpansionCase(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {\n        this.value = value;\n        this.expression = expression;\n        this.sourceSpan = sourceSpan;\n        this.valueSourceSpan = valueSourceSpan;\n        this.expSourceSpan = expSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ExpansionCase.prototype.visit = function (visitor, context) { return visitor.visitExpansionCase(this, context); };\n    return ExpansionCase;\n}());\nvar Attribute$1 = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?=} valueSpan\n     */\n    function Attribute$1(name, value, sourceSpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Attribute$1.prototype.visit = function (visitor, context) { return visitor.visitAttribute(this, context); };\n    return Attribute$1;\n}());\nvar Element = (function () {\n    /**\n     * @param {?} name\n     * @param {?} attrs\n     * @param {?} children\n     * @param {?} sourceSpan\n     * @param {?=} startSourceSpan\n     * @param {?=} endSourceSpan\n     */\n    function Element(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan) {\n        if (startSourceSpan === void 0) { startSourceSpan = null; }\n        if (endSourceSpan === void 0) { endSourceSpan = null; }\n        this.name = name;\n        this.attrs = attrs;\n        this.children = children;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Element.prototype.visit = function (visitor, context) { return visitor.visitElement(this, context); };\n    return Element;\n}());\nvar Comment = (function () {\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function Comment(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Comment.prototype.visit = function (visitor, context) { return visitor.visitComment(this, context); };\n    return Comment;\n}());\n/**\n * @param {?} visitor\n * @param {?} nodes\n * @param {?=} context\n * @return {?}\n */\nfunction visitAll(visitor, nodes, context) {\n    if (context === void 0) { context = null; }\n    var /** @type {?} */ result = [];\n    var /** @type {?} */ visit = visitor.visit ?\n        function (ast) { return ((visitor.visit))(ast, context) || ast.visit(visitor, context); } :\n        function (ast) { return ast.visit(visitor, context); };\n    nodes.forEach(function (ast) {\n        var /** @type {?} */ astResult = visit(ast);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TokenType$1 = {};\nTokenType$1.TAG_OPEN_START = 0;\nTokenType$1.TAG_OPEN_END = 1;\nTokenType$1.TAG_OPEN_END_VOID = 2;\nTokenType$1.TAG_CLOSE = 3;\nTokenType$1.TEXT = 4;\nTokenType$1.ESCAPABLE_RAW_TEXT = 5;\nTokenType$1.RAW_TEXT = 6;\nTokenType$1.COMMENT_START = 7;\nTokenType$1.COMMENT_END = 8;\nTokenType$1.CDATA_START = 9;\nTokenType$1.CDATA_END = 10;\nTokenType$1.ATTR_NAME = 11;\nTokenType$1.ATTR_VALUE = 12;\nTokenType$1.DOC_TYPE = 13;\nTokenType$1.EXPANSION_FORM_START = 14;\nTokenType$1.EXPANSION_CASE_VALUE = 15;\nTokenType$1.EXPANSION_CASE_EXP_START = 16;\nTokenType$1.EXPANSION_CASE_EXP_END = 17;\nTokenType$1.EXPANSION_FORM_END = 18;\nTokenType$1.EOF = 19;\nTokenType$1[TokenType$1.TAG_OPEN_START] = \"TAG_OPEN_START\";\nTokenType$1[TokenType$1.TAG_OPEN_END] = \"TAG_OPEN_END\";\nTokenType$1[TokenType$1.TAG_OPEN_END_VOID] = \"TAG_OPEN_END_VOID\";\nTokenType$1[TokenType$1.TAG_CLOSE] = \"TAG_CLOSE\";\nTokenType$1[TokenType$1.TEXT] = \"TEXT\";\nTokenType$1[TokenType$1.ESCAPABLE_RAW_TEXT] = \"ESCAPABLE_RAW_TEXT\";\nTokenType$1[TokenType$1.RAW_TEXT] = \"RAW_TEXT\";\nTokenType$1[TokenType$1.COMMENT_START] = \"COMMENT_START\";\nTokenType$1[TokenType$1.COMMENT_END] = \"COMMENT_END\";\nTokenType$1[TokenType$1.CDATA_START] = \"CDATA_START\";\nTokenType$1[TokenType$1.CDATA_END] = \"CDATA_END\";\nTokenType$1[TokenType$1.ATTR_NAME] = \"ATTR_NAME\";\nTokenType$1[TokenType$1.ATTR_VALUE] = \"ATTR_VALUE\";\nTokenType$1[TokenType$1.DOC_TYPE] = \"DOC_TYPE\";\nTokenType$1[TokenType$1.EXPANSION_FORM_START] = \"EXPANSION_FORM_START\";\nTokenType$1[TokenType$1.EXPANSION_CASE_VALUE] = \"EXPANSION_CASE_VALUE\";\nTokenType$1[TokenType$1.EXPANSION_CASE_EXP_START] = \"EXPANSION_CASE_EXP_START\";\nTokenType$1[TokenType$1.EXPANSION_CASE_EXP_END] = \"EXPANSION_CASE_EXP_END\";\nTokenType$1[TokenType$1.EXPANSION_FORM_END] = \"EXPANSION_FORM_END\";\nTokenType$1[TokenType$1.EOF] = \"EOF\";\nvar Token$1 = (function () {\n    /**\n     * @param {?} type\n     * @param {?} parts\n     * @param {?} sourceSpan\n     */\n    function Token$1(type, parts, sourceSpan) {\n        this.type = type;\n        this.parts = parts;\n        this.sourceSpan = sourceSpan;\n    }\n    return Token$1;\n}());\nvar TokenError = (function (_super) {\n    __extends(TokenError, _super);\n    /**\n     * @param {?} errorMsg\n     * @param {?} tokenType\n     * @param {?} span\n     */\n    function TokenError(errorMsg, tokenType, span) {\n        var _this = _super.call(this, span, errorMsg) || this;\n        _this.tokenType = tokenType;\n        return _this;\n    }\n    return TokenError;\n}(ParseError));\nvar TokenizeResult = (function () {\n    /**\n     * @param {?} tokens\n     * @param {?} errors\n     */\n    function TokenizeResult(tokens, errors) {\n        this.tokens = tokens;\n        this.errors = errors;\n    }\n    return TokenizeResult;\n}());\n/**\n * @param {?} source\n * @param {?} url\n * @param {?} getTagDefinition\n * @param {?=} tokenizeExpansionForms\n * @param {?=} interpolationConfig\n * @return {?}\n */\nfunction tokenize(source, url, getTagDefinition, tokenizeExpansionForms, interpolationConfig) {\n    if (tokenizeExpansionForms === void 0) { tokenizeExpansionForms = false; }\n    if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n    return new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, tokenizeExpansionForms, interpolationConfig)\n        .tokenize();\n}\nvar _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n/**\n * @param {?} charCode\n * @return {?}\n */\nfunction _unexpectedCharacterErrorMsg(charCode) {\n    var /** @type {?} */ char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);\n    return \"Unexpected character \\\"\" + char + \"\\\"\";\n}\n/**\n * @param {?} entitySrc\n * @return {?}\n */\nfunction _unknownEntityErrorMsg(entitySrc) {\n    return \"Unknown entity \\\"\" + entitySrc + \"\\\" - use the \\\"&#<decimal>;\\\" or  \\\"&#x<hex>;\\\" syntax\";\n}\nvar _ControlFlowError = (function () {\n    /**\n     * @param {?} error\n     */\n    function _ControlFlowError(error) {\n        this.error = error;\n    }\n    return _ControlFlowError;\n}());\nvar _Tokenizer = (function () {\n    /**\n     * @param {?} _file The html source\n     * @param {?} _getTagDefinition\n     * @param {?} _tokenizeIcu Whether to tokenize ICU messages (considered as text nodes when false)\n     * @param {?=} _interpolationConfig\n     */\n    function _Tokenizer(_file, _getTagDefinition, _tokenizeIcu, _interpolationConfig) {\n        if (_interpolationConfig === void 0) { _interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        this._file = _file;\n        this._getTagDefinition = _getTagDefinition;\n        this._tokenizeIcu = _tokenizeIcu;\n        this._interpolationConfig = _interpolationConfig;\n        this._peek = -1;\n        this._nextPeek = -1;\n        this._index = -1;\n        this._line = 0;\n        this._column = -1;\n        this._expansionCaseStack = [];\n        this._inInterpolation = false;\n        this.tokens = [];\n        this.errors = [];\n        this._input = _file.content;\n        this._length = _file.content.length;\n        this._advance();\n    }\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n    _Tokenizer.prototype._processCarriageReturns = function (content) {\n        // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream\n        // In order to keep the original position in the source, we can not\n        // pre-process it.\n        // Instead CRs are processed right before instantiating the tokens.\n        return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype.tokenize = function () {\n        while (this._peek !== $EOF) {\n            var /** @type {?} */ start = this._getLocation();\n            try {\n                if (this._attemptCharCode($LT)) {\n                    if (this._attemptCharCode($BANG)) {\n                        if (this._attemptCharCode($LBRACKET)) {\n                            this._consumeCdata(start);\n                        }\n                        else if (this._attemptCharCode($MINUS)) {\n                            this._consumeComment(start);\n                        }\n                        else {\n                            this._consumeDocType(start);\n                        }\n                    }\n                    else if (this._attemptCharCode($SLASH)) {\n                        this._consumeTagClose(start);\n                    }\n                    else {\n                        this._consumeTagOpen(start);\n                    }\n                }\n                else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n                    this._consumeText();\n                }\n            }\n            catch (e) {\n                if (e instanceof _ControlFlowError) {\n                    this.errors.push(e.error);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        this._beginToken(TokenType$1.EOF);\n        this._endToken([]);\n        return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);\n    };\n    /**\n     * \\@internal\n     * @return {?}\n     */\n    _Tokenizer.prototype._tokenizeExpansionForm = function () {\n        if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n            this._consumeExpansionFormStart();\n            return true;\n        }\n        if (isExpansionCaseStart(this._peek) && this._isInExpansionForm()) {\n            this._consumeExpansionCaseStart();\n            return true;\n        }\n        if (this._peek === $RBRACE) {\n            if (this._isInExpansionCase()) {\n                this._consumeExpansionCaseEnd();\n                return true;\n            }\n            if (this._isInExpansionForm()) {\n                this._consumeExpansionFormEnd();\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._getLocation = function () {\n        return new ParseLocation(this._file, this._index, this._line, this._column);\n    };\n    /**\n     * @param {?=} start\n     * @param {?=} end\n     * @return {?}\n     */\n    _Tokenizer.prototype._getSpan = function (start, end) {\n        if (start === void 0) { start = this._getLocation(); }\n        if (end === void 0) { end = this._getLocation(); }\n        return new ParseSourceSpan(start, end);\n    };\n    /**\n     * @param {?} type\n     * @param {?=} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._beginToken = function (type, start) {\n        if (start === void 0) { start = this._getLocation(); }\n        this._currentTokenStart = start;\n        this._currentTokenType = type;\n    };\n    /**\n     * @param {?} parts\n     * @param {?=} end\n     * @return {?}\n     */\n    _Tokenizer.prototype._endToken = function (parts, end) {\n        if (end === void 0) { end = this._getLocation(); }\n        var /** @type {?} */ token = new Token$1(this._currentTokenType, parts, new ParseSourceSpan(this._currentTokenStart, end));\n        this.tokens.push(token);\n        this._currentTokenStart = ((null));\n        this._currentTokenType = ((null));\n        return token;\n    };\n    /**\n     * @param {?} msg\n     * @param {?} span\n     * @return {?}\n     */\n    _Tokenizer.prototype._createError = function (msg, span) {\n        if (this._isInExpansionForm()) {\n            msg += \" (Do you have an unescaped \\\"{\\\" in your template? Use \\\"{{ '{' }}\\\") to escape it.)\";\n        }\n        var /** @type {?} */ error = new TokenError(msg, this._currentTokenType, span);\n        this._currentTokenStart = ((null));\n        this._currentTokenType = ((null));\n        return new _ControlFlowError(error);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._advance = function () {\n        if (this._index >= this._length) {\n            throw this._createError(_unexpectedCharacterErrorMsg($EOF), this._getSpan());\n        }\n        if (this._peek === $LF) {\n            this._line++;\n            this._column = 0;\n        }\n        else if (this._peek !== $LF && this._peek !== $CR) {\n            this._column++;\n        }\n        this._index++;\n        this._peek = this._index >= this._length ? $EOF : this._input.charCodeAt(this._index);\n        this._nextPeek =\n            this._index + 1 >= this._length ? $EOF : this._input.charCodeAt(this._index + 1);\n    };\n    /**\n     * @param {?} charCode\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptCharCode = function (charCode) {\n        if (this._peek === charCode) {\n            this._advance();\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} charCode\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptCharCodeCaseInsensitive = function (charCode) {\n        if (compareCharCodeCaseInsensitive(this._peek, charCode)) {\n            this._advance();\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} charCode\n     * @return {?}\n     */\n    _Tokenizer.prototype._requireCharCode = function (charCode) {\n        var /** @type {?} */ location = this._getLocation();\n        if (!this._attemptCharCode(charCode)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));\n        }\n    };\n    /**\n     * @param {?} chars\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptStr = function (chars) {\n        var /** @type {?} */ len = chars.length;\n        if (this._index + len > this._length) {\n            return false;\n        }\n        var /** @type {?} */ initialPosition = this._savePosition();\n        for (var /** @type {?} */ i = 0; i < len; i++) {\n            if (!this._attemptCharCode(chars.charCodeAt(i))) {\n                // If attempting to parse the string fails, we want to reset the parser\n                // to where it was before the attempt\n                this._restorePosition(initialPosition);\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * @param {?} chars\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptStrCaseInsensitive = function (chars) {\n        for (var /** @type {?} */ i = 0; i < chars.length; i++) {\n            if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * @param {?} chars\n     * @return {?}\n     */\n    _Tokenizer.prototype._requireStr = function (chars) {\n        var /** @type {?} */ location = this._getLocation();\n        if (!this._attemptStr(chars)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));\n        }\n    };\n    /**\n     * @param {?} predicate\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptCharCodeUntilFn = function (predicate) {\n        while (!predicate(this._peek)) {\n            this._advance();\n        }\n    };\n    /**\n     * @param {?} predicate\n     * @param {?} len\n     * @return {?}\n     */\n    _Tokenizer.prototype._requireCharCodeUntilFn = function (predicate, len) {\n        var /** @type {?} */ start = this._getLocation();\n        this._attemptCharCodeUntilFn(predicate);\n        if (this._index - start.offset < len) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));\n        }\n    };\n    /**\n     * @param {?} char\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptUntilChar = function (char) {\n        while (this._peek !== char) {\n            this._advance();\n        }\n    };\n    /**\n     * @param {?} decodeEntities\n     * @return {?}\n     */\n    _Tokenizer.prototype._readChar = function (decodeEntities) {\n        if (decodeEntities && this._peek === $AMPERSAND) {\n            return this._decodeEntity();\n        }\n        else {\n            var /** @type {?} */ index = this._index;\n            this._advance();\n            return this._input[index];\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._decodeEntity = function () {\n        var /** @type {?} */ start = this._getLocation();\n        this._advance();\n        if (this._attemptCharCode($HASH)) {\n            var /** @type {?} */ isHex = this._attemptCharCode($x) || this._attemptCharCode($X);\n            var /** @type {?} */ numberStart = this._getLocation().offset;\n            this._attemptCharCodeUntilFn(isDigitEntityEnd);\n            if (this._peek != $SEMICOLON) {\n                throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n            }\n            this._advance();\n            var /** @type {?} */ strNum = this._input.substring(numberStart, this._index - 1);\n            try {\n                var /** @type {?} */ charCode = parseInt(strNum, isHex ? 16 : 10);\n                return String.fromCharCode(charCode);\n            }\n            catch (e) {\n                var /** @type {?} */ entity = this._input.substring(start.offset + 1, this._index - 1);\n                throw this._createError(_unknownEntityErrorMsg(entity), this._getSpan(start));\n            }\n        }\n        else {\n            var /** @type {?} */ startPosition = this._savePosition();\n            this._attemptCharCodeUntilFn(isNamedEntityEnd);\n            if (this._peek != $SEMICOLON) {\n                this._restorePosition(startPosition);\n                return '&';\n            }\n            this._advance();\n            var /** @type {?} */ name = this._input.substring(start.offset + 1, this._index - 1);\n            var /** @type {?} */ char = NAMED_ENTITIES[name];\n            if (!char) {\n                throw this._createError(_unknownEntityErrorMsg(name), this._getSpan(start));\n            }\n            return char;\n        }\n    };\n    /**\n     * @param {?} decodeEntities\n     * @param {?} firstCharOfEnd\n     * @param {?} attemptEndRest\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeRawText = function (decodeEntities, firstCharOfEnd, attemptEndRest) {\n        var /** @type {?} */ tagCloseStart;\n        var /** @type {?} */ textStart = this._getLocation();\n        this._beginToken(decodeEntities ? TokenType$1.ESCAPABLE_RAW_TEXT : TokenType$1.RAW_TEXT, textStart);\n        var /** @type {?} */ parts = [];\n        while (true) {\n            tagCloseStart = this._getLocation();\n            if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {\n                break;\n            }\n            if (this._index > tagCloseStart.offset) {\n                // add the characters consumed by the previous if statement to the output\n                parts.push(this._input.substring(tagCloseStart.offset, this._index));\n            }\n            while (this._peek !== firstCharOfEnd) {\n                parts.push(this._readChar(decodeEntities));\n            }\n        }\n        return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeComment = function (start) {\n        var _this = this;\n        this._beginToken(TokenType$1.COMMENT_START, start);\n        this._requireCharCode($MINUS);\n        this._endToken([]);\n        var /** @type {?} */ textToken = this._consumeRawText(false, $MINUS, function () { return _this._attemptStr('->'); });\n        this._beginToken(TokenType$1.COMMENT_END, textToken.sourceSpan.end);\n        this._endToken([]);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeCdata = function (start) {\n        var _this = this;\n        this._beginToken(TokenType$1.CDATA_START, start);\n        this._requireStr('CDATA[');\n        this._endToken([]);\n        var /** @type {?} */ textToken = this._consumeRawText(false, $RBRACKET, function () { return _this._attemptStr(']>'); });\n        this._beginToken(TokenType$1.CDATA_END, textToken.sourceSpan.end);\n        this._endToken([]);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeDocType = function (start) {\n        this._beginToken(TokenType$1.DOC_TYPE, start);\n        this._attemptUntilChar($GT);\n        this._advance();\n        this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumePrefixAndName = function () {\n        var /** @type {?} */ nameOrPrefixStart = this._index;\n        var /** @type {?} */ prefix = ((null));\n        while (this._peek !== $COLON && !isPrefixEnd(this._peek)) {\n            this._advance();\n        }\n        var /** @type {?} */ nameStart;\n        if (this._peek === $COLON) {\n            this._advance();\n            prefix = this._input.substring(nameOrPrefixStart, this._index - 1);\n            nameStart = this._index;\n        }\n        else {\n            nameStart = nameOrPrefixStart;\n        }\n        this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);\n        var /** @type {?} */ name = this._input.substring(nameStart, this._index);\n        return [prefix, name];\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeTagOpen = function (start) {\n        var /** @type {?} */ savedPos = this._savePosition();\n        var /** @type {?} */ tagName;\n        var /** @type {?} */ lowercaseTagName;\n        try {\n            if (!isAsciiLetter(this._peek)) {\n                throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n            }\n            var /** @type {?} */ nameStart = this._index;\n            this._consumeTagOpenStart(start);\n            tagName = this._input.substring(nameStart, this._index);\n            lowercaseTagName = tagName.toLowerCase();\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n            while (this._peek !== $SLASH && this._peek !== $GT) {\n                this._consumeAttributeName();\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n                if (this._attemptCharCode($EQ)) {\n                    this._attemptCharCodeUntilFn(isNotWhitespace);\n                    this._consumeAttributeValue();\n                }\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n            }\n            this._consumeTagOpenEnd();\n        }\n        catch (e) {\n            if (e instanceof _ControlFlowError) {\n                // When the start tag is invalid, assume we want a \"<\"\n                this._restorePosition(savedPos);\n                // Back to back text tokens are merged at the end\n                this._beginToken(TokenType$1.TEXT, start);\n                this._endToken(['<']);\n                return;\n            }\n            throw e;\n        }\n        var /** @type {?} */ contentTokenType = this._getTagDefinition(tagName).contentType;\n        if (contentTokenType === TagContentType.RAW_TEXT) {\n            this._consumeRawTextWithTagClose(lowercaseTagName, false);\n        }\n        else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n            this._consumeRawTextWithTagClose(lowercaseTagName, true);\n        }\n    };\n    /**\n     * @param {?} lowercaseTagName\n     * @param {?} decodeEntities\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeRawTextWithTagClose = function (lowercaseTagName, decodeEntities) {\n        var _this = this;\n        var /** @type {?} */ textToken = this._consumeRawText(decodeEntities, $LT, function () {\n            if (!_this._attemptCharCode($SLASH))\n                return false;\n            _this._attemptCharCodeUntilFn(isNotWhitespace);\n            if (!_this._attemptStrCaseInsensitive(lowercaseTagName))\n                return false;\n            _this._attemptCharCodeUntilFn(isNotWhitespace);\n            return _this._attemptCharCode($GT);\n        });\n        this._beginToken(TokenType$1.TAG_CLOSE, textToken.sourceSpan.end);\n        this._endToken([/** @type {?} */ ((null)), lowercaseTagName]);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeTagOpenStart = function (start) {\n        this._beginToken(TokenType$1.TAG_OPEN_START, start);\n        var /** @type {?} */ parts = this._consumePrefixAndName();\n        this._endToken(parts);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeAttributeName = function () {\n        this._beginToken(TokenType$1.ATTR_NAME);\n        var /** @type {?} */ prefixAndName = this._consumePrefixAndName();\n        this._endToken(prefixAndName);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeAttributeValue = function () {\n        this._beginToken(TokenType$1.ATTR_VALUE);\n        var /** @type {?} */ value;\n        if (this._peek === $SQ || this._peek === $DQ) {\n            var /** @type {?} */ quoteChar = this._peek;\n            this._advance();\n            var /** @type {?} */ parts = [];\n            while (this._peek !== quoteChar) {\n                parts.push(this._readChar(true));\n            }\n            value = parts.join('');\n            this._advance();\n        }\n        else {\n            var /** @type {?} */ valueStart = this._index;\n            this._requireCharCodeUntilFn(isNameEnd, 1);\n            value = this._input.substring(valueStart, this._index);\n        }\n        this._endToken([this._processCarriageReturns(value)]);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeTagOpenEnd = function () {\n        var /** @type {?} */ tokenType = this._attemptCharCode($SLASH) ? TokenType$1.TAG_OPEN_END_VOID : TokenType$1.TAG_OPEN_END;\n        this._beginToken(tokenType);\n        this._requireCharCode($GT);\n        this._endToken([]);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeTagClose = function (start) {\n        this._beginToken(TokenType$1.TAG_CLOSE, start);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        var /** @type {?} */ prefixAndName = this._consumePrefixAndName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._requireCharCode($GT);\n        this._endToken(prefixAndName);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeExpansionFormStart = function () {\n        this._beginToken(TokenType$1.EXPANSION_FORM_START, this._getLocation());\n        this._requireCharCode($LBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.push(TokenType$1.EXPANSION_FORM_START);\n        this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());\n        var /** @type {?} */ condition = this._readUntil($COMMA);\n        this._endToken([condition], this._getLocation());\n        this._requireCharCode($COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());\n        var /** @type {?} */ type = this._readUntil($COMMA);\n        this._endToken([type], this._getLocation());\n        this._requireCharCode($COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeExpansionCaseStart = function () {\n        this._beginToken(TokenType$1.EXPANSION_CASE_VALUE, this._getLocation());\n        var /** @type {?} */ value = this._readUntil($LBRACE).trim();\n        this._endToken([value], this._getLocation());\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(TokenType$1.EXPANSION_CASE_EXP_START, this._getLocation());\n        this._requireCharCode($LBRACE);\n        this._endToken([], this._getLocation());\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.push(TokenType$1.EXPANSION_CASE_EXP_START);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeExpansionCaseEnd = function () {\n        this._beginToken(TokenType$1.EXPANSION_CASE_EXP_END, this._getLocation());\n        this._requireCharCode($RBRACE);\n        this._endToken([], this._getLocation());\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.pop();\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeExpansionFormEnd = function () {\n        this._beginToken(TokenType$1.EXPANSION_FORM_END, this._getLocation());\n        this._requireCharCode($RBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.pop();\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeText = function () {\n        var /** @type {?} */ start = this._getLocation();\n        this._beginToken(TokenType$1.TEXT, start);\n        var /** @type {?} */ parts = [];\n        do {\n            if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n                parts.push(this._interpolationConfig.start);\n                this._inInterpolation = true;\n            }\n            else if (this._interpolationConfig && this._inInterpolation &&\n                this._attemptStr(this._interpolationConfig.end)) {\n                parts.push(this._interpolationConfig.end);\n                this._inInterpolation = false;\n            }\n            else {\n                parts.push(this._readChar(true));\n            }\n        } while (!this._isTextEnd());\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._isTextEnd = function () {\n        if (this._peek === $LT || this._peek === $EOF) {\n            return true;\n        }\n        if (this._tokenizeIcu && !this._inInterpolation) {\n            if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n                // start of an expansion form\n                return true;\n            }\n            if (this._peek === $RBRACE && this._isInExpansionCase()) {\n                // end of and expansion case\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._savePosition = function () {\n        return [this._peek, this._index, this._column, this._line, this.tokens.length];\n    };\n    /**\n     * @param {?} char\n     * @return {?}\n     */\n    _Tokenizer.prototype._readUntil = function (char) {\n        var /** @type {?} */ start = this._index;\n        this._attemptUntilChar(char);\n        return this._input.substring(start, this._index);\n    };\n    /**\n     * @param {?} position\n     * @return {?}\n     */\n    _Tokenizer.prototype._restorePosition = function (position) {\n        this._peek = position[0];\n        this._index = position[1];\n        this._column = position[2];\n        this._line = position[3];\n        var /** @type {?} */ nbTokens = position[4];\n        if (nbTokens < this.tokens.length) {\n            // remove any extra tokens\n            this.tokens = this.tokens.slice(0, nbTokens);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._isInExpansionCase = function () {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                TokenType$1.EXPANSION_CASE_EXP_START;\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._isInExpansionForm = function () {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                TokenType$1.EXPANSION_FORM_START;\n    };\n    return _Tokenizer;\n}());\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isNotWhitespace(code) {\n    return !isWhitespace(code) || code === $EOF;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isNameEnd(code) {\n    return isWhitespace(code) || code === $GT || code === $SLASH ||\n        code === $SQ || code === $DQ || code === $EQ;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isPrefixEnd(code) {\n    return (code < $a || $z < code) && (code < $A || $Z < code) &&\n        (code < $0 || code > $9);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isDigitEntityEnd(code) {\n    return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isNamedEntityEnd(code) {\n    return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);\n}\n/**\n * @param {?} input\n * @param {?} offset\n * @param {?} interpolationConfig\n * @return {?}\n */\nfunction isExpansionFormStart(input, offset, interpolationConfig) {\n    var /** @type {?} */ isInterpolationStart = interpolationConfig ? input.indexOf(interpolationConfig.start, offset) == offset : false;\n    return input.charCodeAt(offset) == $LBRACE && !isInterpolationStart;\n}\n/**\n * @param {?} peek\n * @return {?}\n */\nfunction isExpansionCaseStart(peek) {\n    return peek === $EQ || isAsciiLetter(peek);\n}\n/**\n * @param {?} code1\n * @param {?} code2\n * @return {?}\n */\nfunction compareCharCodeCaseInsensitive(code1, code2) {\n    return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction toUpperCaseCharCode(code) {\n    return code >= $a && code <= $z ? code - $a + $A : code;\n}\n/**\n * @param {?} srcTokens\n * @return {?}\n */\nfunction mergeTextTokens(srcTokens) {\n    var /** @type {?} */ dstTokens = [];\n    var /** @type {?} */ lastDstToken = undefined;\n    for (var /** @type {?} */ i = 0; i < srcTokens.length; i++) {\n        var /** @type {?} */ token = srcTokens[i];\n        if (lastDstToken && lastDstToken.type == TokenType$1.TEXT && token.type == TokenType$1.TEXT) {\n            lastDstToken.parts[0] += token.parts[0];\n            lastDstToken.sourceSpan.end = token.sourceSpan.end;\n        }\n        else {\n            lastDstToken = token;\n            dstTokens.push(lastDstToken);\n        }\n    }\n    return dstTokens;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TreeError = (function (_super) {\n    __extends(TreeError, _super);\n    /**\n     * @param {?} elementName\n     * @param {?} span\n     * @param {?} msg\n     */\n    function TreeError(elementName, span, msg) {\n        var _this = _super.call(this, span, msg) || this;\n        _this.elementName = elementName;\n        return _this;\n    }\n    /**\n     * @param {?} elementName\n     * @param {?} span\n     * @param {?} msg\n     * @return {?}\n     */\n    TreeError.create = function (elementName, span, msg) {\n        return new TreeError(elementName, span, msg);\n    };\n    return TreeError;\n}(ParseError));\nvar ParseTreeResult = (function () {\n    /**\n     * @param {?} rootNodes\n     * @param {?} errors\n     */\n    function ParseTreeResult(rootNodes, errors) {\n        this.rootNodes = rootNodes;\n        this.errors = errors;\n    }\n    return ParseTreeResult;\n}());\nvar Parser$1 = (function () {\n    /**\n     * @param {?} getTagDefinition\n     */\n    function Parser$1(getTagDefinition) {\n        this.getTagDefinition = getTagDefinition;\n    }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser$1.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {\n        if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ tokensAndErrors = tokenize(source, url, this.getTagDefinition, parseExpansionForms, interpolationConfig);\n        var /** @type {?} */ treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();\n        return new ParseTreeResult(treeAndErrors.rootNodes, ((tokensAndErrors.errors)).concat(treeAndErrors.errors));\n    };\n    return Parser$1;\n}());\nvar _TreeBuilder = (function () {\n    /**\n     * @param {?} tokens\n     * @param {?} getTagDefinition\n     */\n    function _TreeBuilder(tokens, getTagDefinition) {\n        this.tokens = tokens;\n        this.getTagDefinition = getTagDefinition;\n        this._index = -1;\n        this._rootNodes = [];\n        this._errors = [];\n        this._elementStack = [];\n        this._advance();\n    }\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype.build = function () {\n        while (this._peek.type !== TokenType$1.EOF) {\n            if (this._peek.type === TokenType$1.TAG_OPEN_START) {\n                this._consumeStartTag(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.TAG_CLOSE) {\n                this._consumeEndTag(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.CDATA_START) {\n                this._closeVoidElement();\n                this._consumeCdata(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.COMMENT_START) {\n                this._closeVoidElement();\n                this._consumeComment(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.TEXT || this._peek.type === TokenType$1.RAW_TEXT ||\n                this._peek.type === TokenType$1.ESCAPABLE_RAW_TEXT) {\n                this._closeVoidElement();\n                this._consumeText(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.EXPANSION_FORM_START) {\n                this._consumeExpansion(this._advance());\n            }\n            else {\n                // Skip all other tokens...\n                this._advance();\n            }\n        }\n        return new ParseTreeResult(this._rootNodes, this._errors);\n    };\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype._advance = function () {\n        var /** @type {?} */ prev = this._peek;\n        if (this._index < this.tokens.length - 1) {\n            // Note: there is always an EOF token at the end\n            this._index++;\n        }\n        this._peek = this.tokens[this._index];\n        return prev;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    _TreeBuilder.prototype._advanceIf = function (type) {\n        if (this._peek.type === type) {\n            return this._advance();\n        }\n        return null;\n    };\n    /**\n     * @param {?} startToken\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeCdata = function (startToken) {\n        this._consumeText(this._advance());\n        this._advanceIf(TokenType$1.CDATA_END);\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeComment = function (token) {\n        var /** @type {?} */ text = this._advanceIf(TokenType$1.RAW_TEXT);\n        this._advanceIf(TokenType$1.COMMENT_END);\n        var /** @type {?} */ value = text != null ? text.parts[0].trim() : null;\n        this._addToParent(new Comment(value, token.sourceSpan));\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeExpansion = function (token) {\n        var /** @type {?} */ switchValue = this._advance();\n        var /** @type {?} */ type = this._advance();\n        var /** @type {?} */ cases = [];\n        // read =\n        while (this._peek.type === TokenType$1.EXPANSION_CASE_VALUE) {\n            var /** @type {?} */ expCase = this._parseExpansionCase();\n            if (!expCase)\n                return; // error\n            cases.push(expCase);\n        }\n        // read the final }\n        if (this._peek.type !== TokenType$1.EXPANSION_FORM_END) {\n            this._errors.push(TreeError.create(null, this._peek.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n            return;\n        }\n        var /** @type {?} */ sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);\n        this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n        this._advance();\n    };\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype._parseExpansionCase = function () {\n        var /** @type {?} */ value = this._advance();\n        // read {\n        if (this._peek.type !== TokenType$1.EXPANSION_CASE_EXP_START) {\n            this._errors.push(TreeError.create(null, this._peek.sourceSpan, \"Invalid ICU message. Missing '{'.\"));\n            return null;\n        }\n        // read until }\n        var /** @type {?} */ start = this._advance();\n        var /** @type {?} */ exp = this._collectExpansionExpTokens(start);\n        if (!exp)\n            return null;\n        var /** @type {?} */ end = this._advance();\n        exp.push(new Token$1(TokenType$1.EOF, [], end.sourceSpan));\n        // parse everything in between { and }\n        var /** @type {?} */ parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();\n        if (parsedExp.errors.length > 0) {\n            this._errors = this._errors.concat(/** @type {?} */ (parsedExp.errors));\n            return null;\n        }\n        var /** @type {?} */ sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);\n        var /** @type {?} */ expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);\n        return new ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _TreeBuilder.prototype._collectExpansionExpTokens = function (start) {\n        var /** @type {?} */ exp = [];\n        var /** @type {?} */ expansionFormStack = [TokenType$1.EXPANSION_CASE_EXP_START];\n        while (true) {\n            if (this._peek.type === TokenType$1.EXPANSION_FORM_START ||\n                this._peek.type === TokenType$1.EXPANSION_CASE_EXP_START) {\n                expansionFormStack.push(this._peek.type);\n            }\n            if (this._peek.type === TokenType$1.EXPANSION_CASE_EXP_END) {\n                if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_CASE_EXP_START)) {\n                    expansionFormStack.pop();\n                    if (expansionFormStack.length == 0)\n                        return exp;\n                }\n                else {\n                    this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                    return null;\n                }\n            }\n            if (this._peek.type === TokenType$1.EXPANSION_FORM_END) {\n                if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_FORM_START)) {\n                    expansionFormStack.pop();\n                }\n                else {\n                    this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                    return null;\n                }\n            }\n            if (this._peek.type === TokenType$1.EOF) {\n                this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                return null;\n            }\n            exp.push(this._advance());\n        }\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeText = function (token) {\n        var /** @type {?} */ text = token.parts[0];\n        if (text.length > 0 && text[0] == '\\n') {\n            var /** @type {?} */ parent = this._getParentElement();\n            if (parent != null && parent.children.length == 0 &&\n                this.getTagDefinition(parent.name).ignoreFirstLf) {\n                text = text.substring(1);\n            }\n        }\n        if (text.length > 0) {\n            this._addToParent(new Text(text, token.sourceSpan));\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype._closeVoidElement = function () {\n        if (this._elementStack.length > 0) {\n            var /** @type {?} */ el = this._elementStack[this._elementStack.length - 1];\n            if (this.getTagDefinition(el.name).isVoid) {\n                this._elementStack.pop();\n            }\n        }\n    };\n    /**\n     * @param {?} startTagToken\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeStartTag = function (startTagToken) {\n        var /** @type {?} */ prefix = startTagToken.parts[0];\n        var /** @type {?} */ name = startTagToken.parts[1];\n        var /** @type {?} */ attrs = [];\n        while (this._peek.type === TokenType$1.ATTR_NAME) {\n            attrs.push(this._consumeAttr(this._advance()));\n        }\n        var /** @type {?} */ fullName = this._getElementFullName(prefix, name, this._getParentElement());\n        var /** @type {?} */ selfClosing = false;\n        // Note: There could have been a tokenizer error\n        // so that we don't get a token for the end tag...\n        if (this._peek.type === TokenType$1.TAG_OPEN_END_VOID) {\n            this._advance();\n            selfClosing = true;\n            var /** @type {?} */ tagDef = this.getTagDefinition(fullName);\n            if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n                this._errors.push(TreeError.create(fullName, startTagToken.sourceSpan, \"Only void and foreign elements can be self closed \\\"\" + startTagToken.parts[1] + \"\\\"\"));\n            }\n        }\n        else if (this._peek.type === TokenType$1.TAG_OPEN_END) {\n            this._advance();\n            selfClosing = false;\n        }\n        var /** @type {?} */ end = this._peek.sourceSpan.start;\n        var /** @type {?} */ span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);\n        var /** @type {?} */ el = new Element(fullName, attrs, [], span, span, undefined);\n        this._pushElement(el);\n        if (selfClosing) {\n            this._popElement(fullName);\n            el.endSourceSpan = span;\n        }\n    };\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    _TreeBuilder.prototype._pushElement = function (el) {\n        if (this._elementStack.length > 0) {\n            var /** @type {?} */ parentEl = this._elementStack[this._elementStack.length - 1];\n            if (this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n                this._elementStack.pop();\n            }\n        }\n        var /** @type {?} */ tagDef = this.getTagDefinition(el.name);\n        var _a = this._getParentElementSkippingContainers(), parent = _a.parent, container = _a.container;\n        if (parent && tagDef.requireExtraParent(parent.name)) {\n            var /** @type {?} */ newParent = new Element(tagDef.parentToAdd, [], [], el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n            this._insertBeforeContainer(parent, container, newParent);\n        }\n        this._addToParent(el);\n        this._elementStack.push(el);\n    };\n    /**\n     * @param {?} endTagToken\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeEndTag = function (endTagToken) {\n        var /** @type {?} */ fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n        if (this._getParentElement()) {\n            ((this._getParentElement())).endSourceSpan = endTagToken.sourceSpan;\n        }\n        if (this.getTagDefinition(fullName).isVoid) {\n            this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, \"Void elements do not have end tags \\\"\" + endTagToken.parts[1] + \"\\\"\"));\n        }\n        else if (!this._popElement(fullName)) {\n            var /** @type {?} */ errMsg = \"Unexpected closing tag \\\"\" + fullName + \"\\\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags\";\n            this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n        }\n    };\n    /**\n     * @param {?} fullName\n     * @return {?}\n     */\n    _TreeBuilder.prototype._popElement = function (fullName) {\n        for (var /** @type {?} */ stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n            var /** @type {?} */ el = this._elementStack[stackIndex];\n            if (el.name == fullName) {\n                this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n                return true;\n            }\n            if (!this.getTagDefinition(el.name).closedByParent) {\n                return false;\n            }\n        }\n        return false;\n    };\n    /**\n     * @param {?} attrName\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeAttr = function (attrName) {\n        var /** @type {?} */ fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n        var /** @type {?} */ end = attrName.sourceSpan.end;\n        var /** @type {?} */ value = '';\n        var /** @type {?} */ valueSpan = ((undefined));\n        if (this._peek.type === TokenType$1.ATTR_VALUE) {\n            var /** @type {?} */ valueToken = this._advance();\n            value = valueToken.parts[0];\n            end = valueToken.sourceSpan.end;\n            valueSpan = valueToken.sourceSpan;\n        }\n        return new Attribute$1(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);\n    };\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype._getParentElement = function () {\n        return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n    };\n    /**\n     * Returns the parent in the DOM and the container.\n     *\n     * `<ng-container>` elements are skipped as they are not rendered as DOM element.\n     * @return {?}\n     */\n    _TreeBuilder.prototype._getParentElementSkippingContainers = function () {\n        var /** @type {?} */ container = null;\n        for (var /** @type {?} */ i = this._elementStack.length - 1; i >= 0; i--) {\n            if (!isNgContainer(this._elementStack[i].name)) {\n                return { parent: this._elementStack[i], container: container };\n            }\n            container = this._elementStack[i];\n        }\n        return { parent: this._elementStack[this._elementStack.length - 1], container: container };\n    };\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    _TreeBuilder.prototype._addToParent = function (node) {\n        var /** @type {?} */ parent = this._getParentElement();\n        if (parent != null) {\n            parent.children.push(node);\n        }\n        else {\n            this._rootNodes.push(node);\n        }\n    };\n    /**\n     * Insert a node between the parent and the container.\n     * When no container is given, the node is appended as a child of the parent.\n     * Also updates the element stack accordingly.\n     *\n     * \\@internal\n     * @param {?} parent\n     * @param {?} container\n     * @param {?} node\n     * @return {?}\n     */\n    _TreeBuilder.prototype._insertBeforeContainer = function (parent, container, node) {\n        if (!container) {\n            this._addToParent(node);\n            this._elementStack.push(node);\n        }\n        else {\n            if (parent) {\n                // replace the container with the new node in the children\n                var /** @type {?} */ index = parent.children.indexOf(container);\n                parent.children[index] = node;\n            }\n            else {\n                this._rootNodes.push(node);\n            }\n            node.children.push(container);\n            this._elementStack.splice(this._elementStack.indexOf(container), 0, node);\n        }\n    };\n    /**\n     * @param {?} prefix\n     * @param {?} localName\n     * @param {?} parentElement\n     * @return {?}\n     */\n    _TreeBuilder.prototype._getElementFullName = function (prefix, localName, parentElement) {\n        if (prefix == null) {\n            prefix = ((this.getTagDefinition(localName).implicitNamespacePrefix));\n            if (prefix == null && parentElement != null) {\n                prefix = getNsPrefix(parentElement.name);\n            }\n        }\n        return mergeNsAndName(prefix, localName);\n    };\n    return _TreeBuilder;\n}());\n/**\n * @param {?} stack\n * @param {?} element\n * @return {?}\n */\nfunction lastOnStack(stack, element) {\n    return stack.length > 0 && stack[stack.length - 1] === element;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Message = (function () {\n    /**\n     * @param {?} nodes message AST\n     * @param {?} placeholders maps placeholder names to static content\n     * @param {?} placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n     * @param {?} meaning\n     * @param {?} description\n     * @param {?} id\n     */\n    function Message(nodes, placeholders, placeholderToMessage, meaning, description, id) {\n        this.nodes = nodes;\n        this.placeholders = placeholders;\n        this.placeholderToMessage = placeholderToMessage;\n        this.meaning = meaning;\n        this.description = description;\n        this.id = id;\n        if (nodes.length) {\n            this.sources = [{\n                    filePath: nodes[0].sourceSpan.start.file.url,\n                    startLine: nodes[0].sourceSpan.start.line + 1,\n                    startCol: nodes[0].sourceSpan.start.col + 1,\n                    endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n                    endCol: nodes[0].sourceSpan.start.col + 1\n                }];\n        }\n        else {\n            this.sources = [];\n        }\n    }\n    return Message;\n}());\nvar Text$1 = (function () {\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function Text$1(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Text$1.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\n    return Text$1;\n}());\nvar Container = (function () {\n    /**\n     * @param {?} children\n     * @param {?} sourceSpan\n     */\n    function Container(children, sourceSpan) {\n        this.children = children;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Container.prototype.visit = function (visitor, context) { return visitor.visitContainer(this, context); };\n    return Container;\n}());\nvar Icu = (function () {\n    /**\n     * @param {?} expression\n     * @param {?} type\n     * @param {?} cases\n     * @param {?} sourceSpan\n     */\n    function Icu(expression, type, cases, sourceSpan) {\n        this.expression = expression;\n        this.type = type;\n        this.cases = cases;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Icu.prototype.visit = function (visitor, context) { return visitor.visitIcu(this, context); };\n    return Icu;\n}());\nvar TagPlaceholder = (function () {\n    /**\n     * @param {?} tag\n     * @param {?} attrs\n     * @param {?} startName\n     * @param {?} closeName\n     * @param {?} children\n     * @param {?} isVoid\n     * @param {?} sourceSpan\n     */\n    function TagPlaceholder(tag, attrs, startName, closeName, children, isVoid, sourceSpan) {\n        this.tag = tag;\n        this.attrs = attrs;\n        this.startName = startName;\n        this.closeName = closeName;\n        this.children = children;\n        this.isVoid = isVoid;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    TagPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitTagPlaceholder(this, context); };\n    return TagPlaceholder;\n}());\nvar Placeholder = (function () {\n    /**\n     * @param {?} value\n     * @param {?} name\n     * @param {?} sourceSpan\n     */\n    function Placeholder(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Placeholder.prototype.visit = function (visitor, context) { return visitor.visitPlaceholder(this, context); };\n    return Placeholder;\n}());\nvar IcuPlaceholder = (function () {\n    /**\n     * @param {?} value\n     * @param {?} name\n     * @param {?} sourceSpan\n     */\n    function IcuPlaceholder(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    IcuPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitIcuPlaceholder(this, context); };\n    return IcuPlaceholder;\n}());\nvar CloneVisitor = (function () {\n    function CloneVisitor() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitText = function (text, context) { return new Text$1(text.value, text.sourceSpan); };\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var /** @type {?} */ children = container.children.map(function (n) { return n.visit(_this, context); });\n        return new Container(children, container.sourceSpan);\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ cases = {};\n        Object.keys(icu.cases).forEach(function (key) { return cases[key] = icu.cases[key].visit(_this, context); });\n        var /** @type {?} */ msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan);\n        msg.expressionPlaceholder = icu.expressionPlaceholder;\n        return msg;\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        var /** @type {?} */ children = ph.children.map(function (n) { return n.visit(_this, context); });\n        return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitPlaceholder = function (ph, context) {\n        return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n    };\n    return CloneVisitor;\n}());\nvar RecurseVisitor = (function () {\n    function RecurseVisitor() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitText = function (text, context) { };\n    ;\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        container.children.forEach(function (child) { return child.visit(_this); });\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        Object.keys(icu.cases).forEach(function (k) { icu.cases[k].visit(_this); });\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        ph.children.forEach(function (child) { return child.visit(_this); });\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitPlaceholder = function (ph, context) { };\n    ;\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitIcuPlaceholder = function (ph, context) { };\n    ;\n    return RecurseVisitor;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TAG_TO_PLACEHOLDER_NAMES = {\n    'A': 'LINK',\n    'B': 'BOLD_TEXT',\n    'BR': 'LINE_BREAK',\n    'EM': 'EMPHASISED_TEXT',\n    'H1': 'HEADING_LEVEL1',\n    'H2': 'HEADING_LEVEL2',\n    'H3': 'HEADING_LEVEL3',\n    'H4': 'HEADING_LEVEL4',\n    'H5': 'HEADING_LEVEL5',\n    'H6': 'HEADING_LEVEL6',\n    'HR': 'HORIZONTAL_RULE',\n    'I': 'ITALIC_TEXT',\n    'LI': 'LIST_ITEM',\n    'LINK': 'MEDIA_LINK',\n    'OL': 'ORDERED_LIST',\n    'P': 'PARAGRAPH',\n    'Q': 'QUOTATION',\n    'S': 'STRIKETHROUGH_TEXT',\n    'SMALL': 'SMALL_TEXT',\n    'SUB': 'SUBSTRIPT',\n    'SUP': 'SUPERSCRIPT',\n    'TBODY': 'TABLE_BODY',\n    'TD': 'TABLE_CELL',\n    'TFOOT': 'TABLE_FOOTER',\n    'TH': 'TABLE_HEADER_CELL',\n    'THEAD': 'TABLE_HEADER',\n    'TR': 'TABLE_ROW',\n    'TT': 'MONOSPACED_TEXT',\n    'U': 'UNDERLINED_TEXT',\n    'UL': 'UNORDERED_LIST',\n};\n/**\n * Creates unique names for placeholder with different content.\n *\n * Returns the same placeholder name when the content is identical.\n *\n * \\@internal\n */\nvar PlaceholderRegistry = (function () {\n    function PlaceholderRegistry() {\n        this._placeHolderNameCounts = {};\n        this._signatureToName = {};\n    }\n    /**\n     * @param {?} tag\n     * @param {?} attrs\n     * @param {?} isVoid\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype.getStartTagPlaceholderName = function (tag, attrs, isVoid) {\n        var /** @type {?} */ signature = this._hashTag(tag, attrs, isVoid);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        var /** @type {?} */ upperTag = tag.toUpperCase();\n        var /** @type {?} */ baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || \"TAG_\" + upperTag;\n        var /** @type {?} */ name = this._generateUniqueName(isVoid ? baseName : \"START_\" + baseName);\n        this._signatureToName[signature] = name;\n        return name;\n    };\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype.getCloseTagPlaceholderName = function (tag) {\n        var /** @type {?} */ signature = this._hashClosingTag(tag);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        var /** @type {?} */ upperTag = tag.toUpperCase();\n        var /** @type {?} */ baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || \"TAG_\" + upperTag;\n        var /** @type {?} */ name = this._generateUniqueName(\"CLOSE_\" + baseName);\n        this._signatureToName[signature] = name;\n        return name;\n    };\n    /**\n     * @param {?} name\n     * @param {?} content\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype.getPlaceholderName = function (name, content) {\n        var /** @type {?} */ upperName = name.toUpperCase();\n        var /** @type {?} */ signature = \"PH: \" + upperName + \"=\" + content;\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        var /** @type {?} */ uniqueName = this._generateUniqueName(upperName);\n        this._signatureToName[signature] = uniqueName;\n        return uniqueName;\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype.getUniquePlaceholder = function (name) {\n        return this._generateUniqueName(name.toUpperCase());\n    };\n    /**\n     * @param {?} tag\n     * @param {?} attrs\n     * @param {?} isVoid\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype._hashTag = function (tag, attrs, isVoid) {\n        var /** @type {?} */ start = \"<\" + tag;\n        var /** @type {?} */ strAttrs = Object.keys(attrs).sort().map(function (name) { return \" \" + name + \"=\" + attrs[name]; }).join('');\n        var /** @type {?} */ end = isVoid ? '/>' : \"></\" + tag + \">\";\n        return start + strAttrs + end;\n    };\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype._hashClosingTag = function (tag) { return this._hashTag(\"/\" + tag, {}, false); };\n    /**\n     * @param {?} base\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype._generateUniqueName = function (base) {\n        var /** @type {?} */ seen = this._placeHolderNameCounts.hasOwnProperty(base);\n        if (!seen) {\n            this._placeHolderNameCounts[base] = 1;\n            return base;\n        }\n        var /** @type {?} */ id = this._placeHolderNameCounts[base];\n        this._placeHolderNameCounts[base] = id + 1;\n        return base + \"_\" + id;\n    };\n    return PlaceholderRegistry;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _expParser = new Parser(new Lexer());\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n * @param {?} interpolationConfig\n * @return {?}\n */\nfunction createI18nMessageFactory(interpolationConfig) {\n    var /** @type {?} */ visitor = new _I18nVisitor(_expParser, interpolationConfig);\n    return function (nodes, meaning, description, id) { return visitor.toI18nMessage(nodes, meaning, description, id); };\n}\nvar _I18nVisitor = (function () {\n    /**\n     * @param {?} _expressionParser\n     * @param {?} _interpolationConfig\n     */\n    function _I18nVisitor(_expressionParser, _interpolationConfig) {\n        this._expressionParser = _expressionParser;\n        this._interpolationConfig = _interpolationConfig;\n    }\n    /**\n     * @param {?} nodes\n     * @param {?} meaning\n     * @param {?} description\n     * @param {?} id\n     * @return {?}\n     */\n    _I18nVisitor.prototype.toI18nMessage = function (nodes, meaning, description, id) {\n        this._isIcu = nodes.length == 1 && nodes[0] instanceof Expansion;\n        this._icuDepth = 0;\n        this._placeholderRegistry = new PlaceholderRegistry();\n        this._placeholderToContent = {};\n        this._placeholderToMessage = {};\n        var /** @type {?} */ i18nodes = visitAll(this, nodes, {});\n        return new Message(i18nodes, this._placeholderToContent, this._placeholderToMessage, meaning, description, id);\n    };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitElement = function (el, context) {\n        var /** @type {?} */ children = visitAll(this, el.children);\n        var /** @type {?} */ attrs = {};\n        el.attrs.forEach(function (attr) {\n            // Do not visit the attributes, translatable ones are top-level ASTs\n            attrs[attr.name] = attr.value;\n        });\n        var /** @type {?} */ isVoid = getHtmlTagDefinition(el.name).isVoid;\n        var /** @type {?} */ startPhName = this._placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n        this._placeholderToContent[startPhName] = ((el.sourceSpan)).toString();\n        var /** @type {?} */ closePhName = '';\n        if (!isVoid) {\n            closePhName = this._placeholderRegistry.getCloseTagPlaceholderName(el.name);\n            this._placeholderToContent[closePhName] = \"</\" + el.name + \">\";\n        }\n        return new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, /** @type {?} */ ((el.sourceSpan)));\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitAttribute = function (attribute, context) {\n        return this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan);\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitText = function (text, context) {\n        return this._visitTextWithInterpolation(text.value, /** @type {?} */ ((text.sourceSpan)));\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitComment = function (comment, context) { return null; };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitExpansion = function (icu, context) {\n        var _this = this;\n        this._icuDepth++;\n        var /** @type {?} */ i18nIcuCases = {};\n        var /** @type {?} */ i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n        icu.cases.forEach(function (caze) {\n            i18nIcuCases[caze.value] = new Container(caze.expression.map(function (node) { return node.visit(_this, {}); }), caze.expSourceSpan);\n        });\n        this._icuDepth--;\n        if (this._isIcu || this._icuDepth > 0) {\n            // Returns an ICU node when:\n            // - the message (vs a part of the message) is an ICU message, or\n            // - the ICU message is nested.\n            var /** @type {?} */ expPh = this._placeholderRegistry.getUniquePlaceholder(\"VAR_\" + icu.type);\n            i18nIcu.expressionPlaceholder = expPh;\n            this._placeholderToContent[expPh] = icu.switchValue;\n            return i18nIcu;\n        }\n        // Else returns a placeholder\n        // ICU placeholders should not be replaced with their original content but with the their\n        // translations. We need to create a new visitor (they are not re-entrant) to compute the\n        // message id.\n        // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n        var /** @type {?} */ phName = this._placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n        var /** @type {?} */ visitor = new _I18nVisitor(this._expressionParser, this._interpolationConfig);\n        this._placeholderToMessage[phName] = visitor.toI18nMessage([icu], '', '', '');\n        return new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitExpansionCase = function (icuCase, context) {\n        throw new Error('Unreachable code');\n    };\n    /**\n     * @param {?} text\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    _I18nVisitor.prototype._visitTextWithInterpolation = function (text, sourceSpan) {\n        var /** @type {?} */ splitInterpolation = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);\n        if (!splitInterpolation) {\n            // No expression, return a single text\n            return new Text$1(text, sourceSpan);\n        }\n        // Return a group of text + expressions\n        var /** @type {?} */ nodes = [];\n        var /** @type {?} */ container = new Container(nodes, sourceSpan);\n        var _a = this._interpolationConfig, sDelimiter = _a.start, eDelimiter = _a.end;\n        for (var /** @type {?} */ i = 0; i < splitInterpolation.strings.length - 1; i++) {\n            var /** @type {?} */ expression = splitInterpolation.expressions[i];\n            var /** @type {?} */ baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';\n            var /** @type {?} */ phName = this._placeholderRegistry.getPlaceholderName(baseName, expression);\n            if (splitInterpolation.strings[i].length) {\n                // No need to add empty strings\n                nodes.push(new Text$1(splitInterpolation.strings[i], sourceSpan));\n            }\n            nodes.push(new Placeholder(expression, phName, sourceSpan));\n            this._placeholderToContent[phName] = sDelimiter + expression + eDelimiter;\n        }\n        // The last index contains no expression\n        var /** @type {?} */ lastStringIdx = splitInterpolation.strings.length - 1;\n        if (splitInterpolation.strings[lastStringIdx].length) {\n            nodes.push(new Text$1(splitInterpolation.strings[lastStringIdx], sourceSpan));\n        }\n        return container;\n    };\n    return _I18nVisitor;\n}());\nvar _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\n/**\n * @param {?} input\n * @return {?}\n */\nfunction _extractPlaceholderName(input) {\n    return input.split(_CUSTOM_PH_EXP)[2];\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An i18n error.\n */\nvar I18nError = (function (_super) {\n    __extends(I18nError, _super);\n    /**\n     * @param {?} span\n     * @param {?} msg\n     */\n    function I18nError(span, msg) {\n        return _super.call(this, span, msg) || this;\n    }\n    return I18nError;\n}(ParseError));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _I18N_ATTR = 'i18n';\nvar _I18N_ATTR_PREFIX = 'i18n-';\nvar _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\nvar MEANING_SEPARATOR = '|';\nvar ID_SEPARATOR = '@@';\n/**\n * Extract translatable messages from an html AST\n * @param {?} nodes\n * @param {?} interpolationConfig\n * @param {?} implicitTags\n * @param {?} implicitAttrs\n * @return {?}\n */\nfunction extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {\n    var /** @type {?} */ visitor = new _Visitor(implicitTags, implicitAttrs);\n    return visitor.extract(nodes, interpolationConfig);\n}\n/**\n * @param {?} nodes\n * @param {?} translations\n * @param {?} interpolationConfig\n * @param {?} implicitTags\n * @param {?} implicitAttrs\n * @return {?}\n */\nfunction mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {\n    var /** @type {?} */ visitor = new _Visitor(implicitTags, implicitAttrs);\n    return visitor.merge(nodes, translations, interpolationConfig);\n}\nvar ExtractionResult = (function () {\n    /**\n     * @param {?} messages\n     * @param {?} errors\n     */\n    function ExtractionResult(messages, errors) {\n        this.messages = messages;\n        this.errors = errors;\n    }\n    return ExtractionResult;\n}());\nvar _VisitorMode = {};\n_VisitorMode.Extract = 0;\n_VisitorMode.Merge = 1;\n_VisitorMode[_VisitorMode.Extract] = \"Extract\";\n_VisitorMode[_VisitorMode.Merge] = \"Merge\";\n/**\n * This Visitor is used:\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\n *\n * \\@internal\n */\nvar _Visitor = (function () {\n    /**\n     * @param {?} _implicitTags\n     * @param {?} _implicitAttrs\n     */\n    function _Visitor(_implicitTags, _implicitAttrs) {\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n    }\n    /**\n     * Extracts the messages from the tree\n     * @param {?} nodes\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    _Visitor.prototype.extract = function (nodes, interpolationConfig) {\n        var _this = this;\n        this._init(_VisitorMode.Extract, interpolationConfig);\n        nodes.forEach(function (node) { return node.visit(_this, null); });\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ExtractionResult(this._messages, this._errors);\n    };\n    /**\n     * Returns a tree where all translatable nodes are translated\n     * @param {?} nodes\n     * @param {?} translations\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    _Visitor.prototype.merge = function (nodes, translations, interpolationConfig) {\n        this._init(_VisitorMode.Merge, interpolationConfig);\n        this._translations = translations;\n        // Construct a single fake root element\n        var /** @type {?} */ wrapper = new Element('wrapper', [], nodes, /** @type {?} */ ((undefined)), undefined, undefined);\n        var /** @type {?} */ translatedNode = wrapper.visit(this, null);\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ParseTreeResult(translatedNode.children, this._errors);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitExpansionCase = function (icuCase, context) {\n        // Parse cases for translatable html attributes\n        var /** @type {?} */ expression = visitAll(this, icuCase.expression, context);\n        if (this._mode === _VisitorMode.Merge) {\n            return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);\n        }\n    };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitExpansion = function (icu, context) {\n        this._mayBeAddBlockChildren(icu);\n        var /** @type {?} */ wasInIcu = this._inIcu;\n        if (!this._inIcu) {\n            // nested ICU messages should not be extracted but top-level translated as a whole\n            if (this._isInTranslatableSection) {\n                this._addMessage([icu]);\n            }\n            this._inIcu = true;\n        }\n        var /** @type {?} */ cases = visitAll(this, icu.cases, context);\n        if (this._mode === _VisitorMode.Merge) {\n            icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n        }\n        this._inIcu = wasInIcu;\n        return icu;\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitComment = function (comment, context) {\n        var /** @type {?} */ isOpening = _isOpeningComment(comment);\n        if (isOpening && this._isInTranslatableSection) {\n            this._reportError(comment, 'Could not start a block inside a translatable section');\n            return;\n        }\n        var /** @type {?} */ isClosing = _isClosingComment(comment);\n        if (isClosing && !this._inI18nBlock) {\n            this._reportError(comment, 'Trying to close an unopened block');\n            return;\n        }\n        if (!this._inI18nNode && !this._inIcu) {\n            if (!this._inI18nBlock) {\n                if (isOpening) {\n                    this._inI18nBlock = true;\n                    this._blockStartDepth = this._depth;\n                    this._blockChildren = [];\n                    this._blockMeaningAndDesc = ((comment.value)).replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n                    this._openTranslatableSection(comment);\n                }\n            }\n            else {\n                if (isClosing) {\n                    if (this._depth == this._blockStartDepth) {\n                        this._closeTranslatableSection(comment, this._blockChildren);\n                        this._inI18nBlock = false;\n                        var /** @type {?} */ message = ((this._addMessage(this._blockChildren, this._blockMeaningAndDesc)));\n                        // merge attributes in sections\n                        var /** @type {?} */ nodes = this._translateMessage(comment, message);\n                        return visitAll(this, nodes);\n                    }\n                    else {\n                        this._reportError(comment, 'I18N blocks should not cross element boundaries');\n                        return;\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitText = function (text, context) {\n        if (this._isInTranslatableSection) {\n            this._mayBeAddBlockChildren(text);\n        }\n        return text;\n    };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitElement = function (el, context) {\n        var _this = this;\n        this._mayBeAddBlockChildren(el);\n        this._depth++;\n        var /** @type {?} */ wasInI18nNode = this._inI18nNode;\n        var /** @type {?} */ wasInImplicitNode = this._inImplicitNode;\n        var /** @type {?} */ childNodes = [];\n        var /** @type {?} */ translatedChildNodes = ((undefined));\n        // Extract:\n        // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n        // - ICU messages\n        var /** @type {?} */ i18nAttr = _getI18nAttr(el);\n        var /** @type {?} */ i18nMeta = i18nAttr ? i18nAttr.value : '';\n        var /** @type {?} */ isImplicit = this._implicitTags.some(function (tag) { return el.name === tag; }) && !this._inIcu &&\n            !this._isInTranslatableSection;\n        var /** @type {?} */ isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n        this._inImplicitNode = wasInImplicitNode || isImplicit;\n        if (!this._isInTranslatableSection && !this._inIcu) {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._inI18nNode = true;\n                var /** @type {?} */ message = ((this._addMessage(el.children, i18nMeta)));\n                translatedChildNodes = this._translateMessage(el, message);\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                var /** @type {?} */ isTranslatable = i18nAttr || isTopLevelImplicit;\n                if (isTranslatable)\n                    this._openTranslatableSection(el);\n                visitAll(this, el.children);\n                if (isTranslatable)\n                    this._closeTranslatableSection(el, el.children);\n            }\n        }\n        else {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._reportError(el, 'Could not mark an element as translatable inside a translatable section');\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                // Descend into child nodes for extraction\n                visitAll(this, el.children);\n            }\n        }\n        if (this._mode === _VisitorMode.Merge) {\n            var /** @type {?} */ visitNodes = translatedChildNodes || el.children;\n            visitNodes.forEach(function (child) {\n                var /** @type {?} */ visited = child.visit(_this, context);\n                if (visited && !_this._isInTranslatableSection) {\n                    // Do not add the children from translatable sections (= i18n blocks here)\n                    // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n                    childNodes = childNodes.concat(visited);\n                }\n            });\n        }\n        this._visitAttributesOf(el);\n        this._depth--;\n        this._inI18nNode = wasInI18nNode;\n        this._inImplicitNode = wasInImplicitNode;\n        if (this._mode === _VisitorMode.Merge) {\n            var /** @type {?} */ translatedAttrs = this._translateAttributes(el);\n            return new Element(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n        }\n        return null;\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitAttribute = function (attribute, context) {\n        throw new Error('unreachable code');\n    };\n    /**\n     * @param {?} mode\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    _Visitor.prototype._init = function (mode, interpolationConfig) {\n        this._mode = mode;\n        this._inI18nBlock = false;\n        this._inI18nNode = false;\n        this._depth = 0;\n        this._inIcu = false;\n        this._msgCountAtSectionStart = undefined;\n        this._errors = [];\n        this._messages = [];\n        this._inImplicitNode = false;\n        this._createI18nMessage = createI18nMessageFactory(interpolationConfig);\n    };\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    _Visitor.prototype._visitAttributesOf = function (el) {\n        var _this = this;\n        var /** @type {?} */ explicitAttrNameToValue = {};\n        var /** @type {?} */ implicitAttrNames = this._implicitAttrs[el.name] || [];\n        el.attrs.filter(function (attr) { return attr.name.startsWith(_I18N_ATTR_PREFIX); })\n            .forEach(function (attr) { return explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n            attr.value; });\n        el.attrs.forEach(function (attr) {\n            if (attr.name in explicitAttrNameToValue) {\n                _this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n            }\n            else if (implicitAttrNames.some(function (name) { return attr.name === name; })) {\n                _this._addMessage([attr]);\n            }\n        });\n    };\n    /**\n     * @param {?} ast\n     * @param {?=} msgMeta\n     * @return {?}\n     */\n    _Visitor.prototype._addMessage = function (ast, msgMeta) {\n        if (ast.length == 0 ||\n            ast.length == 1 && ast[0] instanceof Attribute$1 && !((ast[0])).value) {\n            // Do not create empty messages\n            return null;\n        }\n        var _a = _parseMessageMeta(msgMeta), meaning = _a.meaning, description = _a.description, id = _a.id;\n        var /** @type {?} */ message = this._createI18nMessage(ast, meaning, description, id);\n        this._messages.push(message);\n        return message;\n    };\n    /**\n     * @param {?} el\n     * @param {?} message\n     * @return {?}\n     */\n    _Visitor.prototype._translateMessage = function (el, message) {\n        if (message && this._mode === _VisitorMode.Merge) {\n            var /** @type {?} */ nodes = this._translations.get(message);\n            if (nodes) {\n                return nodes;\n            }\n            this._reportError(el, \"Translation unavailable for message id=\\\"\" + this._translations.digest(message) + \"\\\"\");\n        }\n        return [];\n    };\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    _Visitor.prototype._translateAttributes = function (el) {\n        var _this = this;\n        var /** @type {?} */ attributes = el.attrs;\n        var /** @type {?} */ i18nParsedMessageMeta = {};\n        attributes.forEach(function (attr) {\n            if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n                    _parseMessageMeta(attr.value);\n            }\n        });\n        var /** @type {?} */ translatedAttributes = [];\n        attributes.forEach(function (attr) {\n            if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                // strip i18n specific attributes\n                return;\n            }\n            if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n                var _a = i18nParsedMessageMeta[attr.name], meaning = _a.meaning, description = _a.description, id = _a.id;\n                var /** @type {?} */ message = _this._createI18nMessage([attr], meaning, description, id);\n                var /** @type {?} */ nodes = _this._translations.get(message);\n                if (nodes) {\n                    if (nodes.length == 0) {\n                        translatedAttributes.push(new Attribute$1(attr.name, '', attr.sourceSpan));\n                    }\n                    else if (nodes[0] instanceof Text) {\n                        var /** @type {?} */ value = ((nodes[0])).value;\n                        translatedAttributes.push(new Attribute$1(attr.name, value, attr.sourceSpan));\n                    }\n                    else {\n                        _this._reportError(el, \"Unexpected translation for attribute \\\"\" + attr.name + \"\\\" (id=\\\"\" + (id || _this._translations.digest(message)) + \"\\\")\");\n                    }\n                }\n                else {\n                    _this._reportError(el, \"Translation unavailable for attribute \\\"\" + attr.name + \"\\\" (id=\\\"\" + (id || _this._translations.digest(message)) + \"\\\")\");\n                }\n            }\n            else {\n                translatedAttributes.push(attr);\n            }\n        });\n        return translatedAttributes;\n    };\n    /**\n     * Add the node as a child of the block when:\n     * - we are in a block,\n     * - we are not inside a ICU message (those are handled separately),\n     * - the node is a \"direct child\" of the block\n     * @param {?} node\n     * @return {?}\n     */\n    _Visitor.prototype._mayBeAddBlockChildren = function (node) {\n        if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n            this._blockChildren.push(node);\n        }\n    };\n    /**\n     * Marks the start of a section, see `_closeTranslatableSection`\n     * @param {?} node\n     * @return {?}\n     */\n    _Visitor.prototype._openTranslatableSection = function (node) {\n        if (this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section start');\n        }\n        else {\n            this._msgCountAtSectionStart = this._messages.length;\n        }\n    };\n    Object.defineProperty(_Visitor.prototype, \"_isInTranslatableSection\", {\n        /**\n         * A translatable section could be:\n         * - the content of translatable element,\n         * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n         * @return {?}\n         */\n        get: function () {\n            return this._msgCountAtSectionStart !== void 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Terminates a section.\n     *\n     * If a section has only one significant children (comments not significant) then we should not\n     * keep the message from this children:\n     *\n     * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n     * - one for the <p> content with meaning and description,\n     * - another one for the ICU message.\n     *\n     * In this case the last message is discarded as it contains less information (the AST is\n     * otherwise identical).\n     *\n     * Note that we should still keep messages extracted from attributes inside the section (ie in the\n     * ICU message here)\n     * @param {?} node\n     * @param {?} directChildren\n     * @return {?}\n     */\n    _Visitor.prototype._closeTranslatableSection = function (node, directChildren) {\n        if (!this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section end');\n            return;\n        }\n        var /** @type {?} */ startIndex = this._msgCountAtSectionStart;\n        var /** @type {?} */ significantChildren = directChildren.reduce(function (count, node) { return count + (node instanceof Comment ? 0 : 1); }, 0);\n        if (significantChildren == 1) {\n            for (var /** @type {?} */ i = this._messages.length - 1; i >= startIndex; i--) {\n                var /** @type {?} */ ast = this._messages[i].nodes;\n                if (!(ast.length == 1 && ast[0] instanceof Text$1)) {\n                    this._messages.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        this._msgCountAtSectionStart = undefined;\n    };\n    /**\n     * @param {?} node\n     * @param {?} msg\n     * @return {?}\n     */\n    _Visitor.prototype._reportError = function (node, msg) {\n        this._errors.push(new I18nError(/** @type {?} */ ((node.sourceSpan)), msg));\n    };\n    return _Visitor;\n}());\n/**\n * @param {?} n\n * @return {?}\n */\nfunction _isOpeningComment(n) {\n    return !!(n instanceof Comment && n.value && n.value.startsWith('i18n'));\n}\n/**\n * @param {?} n\n * @return {?}\n */\nfunction _isClosingComment(n) {\n    return !!(n instanceof Comment && n.value && n.value === '/i18n');\n}\n/**\n * @param {?} p\n * @return {?}\n */\nfunction _getI18nAttr(p) {\n    return p.attrs.find(function (attr) { return attr.name === _I18N_ATTR; }) || null;\n}\n/**\n * @param {?=} i18n\n * @return {?}\n */\nfunction _parseMessageMeta(i18n) {\n    if (!i18n)\n        return { meaning: '', description: '', id: '' };\n    var /** @type {?} */ idIndex = i18n.indexOf(ID_SEPARATOR);\n    var /** @type {?} */ descIndex = i18n.indexOf(MEANING_SEPARATOR);\n    var _a = (idIndex > -1) ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''], meaningAndDesc = _a[0], id = _a[1];\n    var _b = (descIndex > -1) ?\n        [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n        ['', meaningAndDesc], meaning = _b[0], description = _b[1];\n    return { meaning: meaning, description: description, id: id };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar XmlTagDefinition = (function () {\n    function XmlTagDefinition() {\n        this.closedByParent = false;\n        this.contentType = TagContentType.PARSABLE_DATA;\n        this.isVoid = false;\n        this.ignoreFirstLf = false;\n        this.canSelfClose = true;\n    }\n    /**\n     * @param {?} currentParent\n     * @return {?}\n     */\n    XmlTagDefinition.prototype.requireExtraParent = function (currentParent) { return false; };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    XmlTagDefinition.prototype.isClosedByChild = function (name) { return false; };\n    return XmlTagDefinition;\n}());\nvar _TAG_DEFINITION = new XmlTagDefinition();\n/**\n * @param {?} tagName\n * @return {?}\n */\nfunction getXmlTagDefinition(tagName) {\n    return _TAG_DEFINITION;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar XmlParser = (function (_super) {\n    __extends(XmlParser, _super);\n    function XmlParser() {\n        return _super.call(this, getXmlTagDefinition) || this;\n    }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @return {?}\n     */\n    XmlParser.prototype.parse = function (source, url, parseExpansionForms) {\n        if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n        return _super.prototype.parse.call(this, source, url, parseExpansionForms);\n    };\n    return XmlParser;\n}(Parser$1));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} message\n * @return {?}\n */\nfunction digest(message) {\n    return message.id || sha1(serializeNodes(message.nodes).join('') + (\"[\" + message.meaning + \"]\"));\n}\n/**\n * @param {?} message\n * @return {?}\n */\nfunction decimalDigest(message) {\n    if (message.id) {\n        return message.id;\n    }\n    var /** @type {?} */ visitor = new _SerializerIgnoreIcuExpVisitor();\n    var /** @type {?} */ parts = message.nodes.map(function (a) { return a.visit(visitor, null); });\n    return computeMsgId(parts.join(''), message.meaning);\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * \\@internal\n */\nvar _SerializerVisitor = (function () {\n    function _SerializerVisitor() {\n    }\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitText = function (text, context) { return text.value; };\n    /**\n     * @param {?} container\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        return \"[\" + container.children.map(function (child) { return child.visit(_this); }).join(', ') + \"]\";\n    };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ strCases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        return \"{\" + icu.expression + \", \" + icu.type + \", \" + strCases.join(', ') + \"}\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        return ph.isVoid ?\n            \"<ph tag name=\\\"\" + ph.startName + \"\\\"/>\" :\n            \"<ph tag name=\\\"\" + ph.startName + \"\\\">\" + ph.children.map(function (child) { return child.visit(_this); }).join(', ') + \"</ph name=\\\"\" + ph.closeName + \"\\\">\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitPlaceholder = function (ph, context) {\n        return ph.value ? \"<ph name=\\\"\" + ph.name + \"\\\">\" + ph.value + \"</ph>\" : \"<ph name=\\\"\" + ph.name + \"\\\"/>\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return \"<ph icu name=\\\"\" + ph.name + \"\\\">\" + ph.value.visit(this) + \"</ph>\";\n    };\n    return _SerializerVisitor;\n}());\nvar serializerVisitor = new _SerializerVisitor();\n/**\n * @param {?} nodes\n * @return {?}\n */\nfunction serializeNodes(nodes) {\n    return nodes.map(function (a) { return a.visit(serializerVisitor, null); });\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * \\@internal\n */\nvar _SerializerIgnoreIcuExpVisitor = (function (_super) {\n    __extends(_SerializerIgnoreIcuExpVisitor, _super);\n    function _SerializerIgnoreIcuExpVisitor() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerIgnoreIcuExpVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ strCases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        // Do not take the expression into account\n        return \"{\" + icu.type + \", \" + strCases.join(', ') + \"}\";\n    };\n    return _SerializerIgnoreIcuExpVisitor;\n}(_SerializerVisitor));\n/**\n * Compute the SHA1 of the given string\n *\n * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n * @param {?} str\n * @return {?}\n */\nfunction sha1(str) {\n    var /** @type {?} */ utf8 = utf8Encode(str);\n    var /** @type {?} */ words32 = stringToWords32(utf8, Endian.Big);\n    var /** @type {?} */ len = utf8.length * 8;\n    var /** @type {?} */ w = new Array(80);\n    var _a = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0], a = _a[0], b = _a[1], c = _a[2], d = _a[3], e = _a[4];\n    words32[len >> 5] |= 0x80 << (24 - len % 32);\n    words32[((len + 64 >> 9) << 4) + 15] = len;\n    for (var /** @type {?} */ i = 0; i < words32.length; i += 16) {\n        var _b = [a, b, c, d, e], h0 = _b[0], h1 = _b[1], h2 = _b[2], h3 = _b[3], h4 = _b[4];\n        for (var /** @type {?} */ j = 0; j < 80; j++) {\n            if (j < 16) {\n                w[j] = words32[i + j];\n            }\n            else {\n                w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n            }\n            var _c = fk(j, b, c, d), f = _c[0], k = _c[1];\n            var /** @type {?} */ temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n            _d = [d, c, rol32(b, 30), a, temp], e = _d[0], d = _d[1], c = _d[2], b = _d[3], a = _d[4];\n        }\n        _e = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)], a = _e[0], b = _e[1], c = _e[2], d = _e[3], e = _e[4];\n    }\n    return byteStringToHexString(words32ToByteString([a, b, c, d, e]));\n    var _d, _e;\n}\n/**\n * @param {?} index\n * @param {?} b\n * @param {?} c\n * @param {?} d\n * @return {?}\n */\nfunction fk(index, b, c, d) {\n    if (index < 20) {\n        return [(b & c) | (~b & d), 0x5a827999];\n    }\n    if (index < 40) {\n        return [b ^ c ^ d, 0x6ed9eba1];\n    }\n    if (index < 60) {\n        return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n    }\n    return [b ^ c ^ d, 0xca62c1d6];\n}\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n * @param {?} str\n * @return {?}\n */\nfunction fingerprint(str) {\n    var /** @type {?} */ utf8 = utf8Encode(str);\n    var _a = [hash32(utf8, 0), hash32(utf8, 102072)], hi = _a[0], lo = _a[1];\n    if (hi == 0 && (lo == 0 || lo == 1)) {\n        hi = hi ^ 0x130f9bef;\n        lo = lo ^ -0x6b5f56d8;\n    }\n    return [hi, lo];\n}\n/**\n * @param {?} msg\n * @param {?} meaning\n * @return {?}\n */\nfunction computeMsgId(msg, meaning) {\n    var _a = fingerprint(msg), hi = _a[0], lo = _a[1];\n    if (meaning) {\n        var _b = fingerprint(meaning), him = _b[0], lom = _b[1];\n        _c = add64(rol64([hi, lo], 1), [him, lom]), hi = _c[0], lo = _c[1];\n    }\n    return byteStringToDecString(words32ToByteString([hi & 0x7fffffff, lo]));\n    var _c;\n}\n/**\n * @param {?} str\n * @param {?} c\n * @return {?}\n */\nfunction hash32(str, c) {\n    var _a = [0x9e3779b9, 0x9e3779b9], a = _a[0], b = _a[1];\n    var /** @type {?} */ i;\n    var /** @type {?} */ len = str.length;\n    for (i = 0; i + 12 <= len; i += 12) {\n        a = add32(a, wordAt(str, i, Endian.Little));\n        b = add32(b, wordAt(str, i + 4, Endian.Little));\n        c = add32(c, wordAt(str, i + 8, Endian.Little));\n        _b = mix([a, b, c]), a = _b[0], b = _b[1], c = _b[2];\n    }\n    a = add32(a, wordAt(str, i, Endian.Little));\n    b = add32(b, wordAt(str, i + 4, Endian.Little));\n    // the first byte of c is reserved for the length\n    c = add32(c, len);\n    c = add32(c, wordAt(str, i + 8, Endian.Little) << 8);\n    return mix([a, b, c])[2];\n    var _b;\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction mix(_a) {\n    var a = _a[0], b = _a[1], c = _a[2];\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 13;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 8;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 13;\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 12;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 16;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 5;\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 3;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 10;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 15;\n    return [a, b, c];\n}\nvar Endian = {};\nEndian.Little = 0;\nEndian.Big = 1;\nEndian[Endian.Little] = \"Little\";\nEndian[Endian.Big] = \"Big\";\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction add32(a, b) {\n    return add32to64(a, b)[1];\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction add32to64(a, b) {\n    var /** @type {?} */ low = (a & 0xffff) + (b & 0xffff);\n    var /** @type {?} */ high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n    return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\n/**\n * @param {?} __0\n * @param {?} __1\n * @return {?}\n */\nfunction add64(_a, _b) {\n    var ah = _a[0], al = _a[1];\n    var bh = _b[0], bl = _b[1];\n    var _c = add32to64(al, bl), carry = _c[0], l = _c[1];\n    var /** @type {?} */ h = add32(add32(ah, bh), carry);\n    return [h, l];\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction sub32(a, b) {\n    var /** @type {?} */ low = (a & 0xffff) - (b & 0xffff);\n    var /** @type {?} */ high = (a >> 16) - (b >> 16) + (low >> 16);\n    return (high << 16) | (low & 0xffff);\n}\n/**\n * @param {?} a\n * @param {?} count\n * @return {?}\n */\nfunction rol32(a, count) {\n    return (a << count) | (a >>> (32 - count));\n}\n/**\n * @param {?} __0\n * @param {?} count\n * @return {?}\n */\nfunction rol64(_a, count) {\n    var hi = _a[0], lo = _a[1];\n    var /** @type {?} */ h = (hi << count) | (lo >>> (32 - count));\n    var /** @type {?} */ l = (lo << count) | (hi >>> (32 - count));\n    return [h, l];\n}\n/**\n * @param {?} str\n * @param {?} endian\n * @return {?}\n */\nfunction stringToWords32(str, endian) {\n    var /** @type {?} */ words32 = Array((str.length + 3) >>> 2);\n    for (var /** @type {?} */ i = 0; i < words32.length; i++) {\n        words32[i] = wordAt(str, i * 4, endian);\n    }\n    return words32;\n}\n/**\n * @param {?} str\n * @param {?} index\n * @return {?}\n */\nfunction byteAt(str, index) {\n    return index >= str.length ? 0 : str.charCodeAt(index) & 0xff;\n}\n/**\n * @param {?} str\n * @param {?} index\n * @param {?} endian\n * @return {?}\n */\nfunction wordAt(str, index, endian) {\n    var /** @type {?} */ word = 0;\n    if (endian === Endian.Big) {\n        for (var /** @type {?} */ i = 0; i < 4; i++) {\n            word += byteAt(str, index + i) << (24 - 8 * i);\n        }\n    }\n    else {\n        for (var /** @type {?} */ i = 0; i < 4; i++) {\n            word += byteAt(str, index + i) << 8 * i;\n        }\n    }\n    return word;\n}\n/**\n * @param {?} words32\n * @return {?}\n */\nfunction words32ToByteString(words32) {\n    return words32.reduce(function (str, word) { return str + word32ToByteString(word); }, '');\n}\n/**\n * @param {?} word\n * @return {?}\n */\nfunction word32ToByteString(word) {\n    var /** @type {?} */ str = '';\n    for (var /** @type {?} */ i = 0; i < 4; i++) {\n        str += String.fromCharCode((word >>> 8 * (3 - i)) & 0xff);\n    }\n    return str;\n}\n/**\n * @param {?} str\n * @return {?}\n */\nfunction byteStringToHexString(str) {\n    var /** @type {?} */ hex = '';\n    for (var /** @type {?} */ i = 0; i < str.length; i++) {\n        var /** @type {?} */ b = byteAt(str, i);\n        hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\n    }\n    return hex.toLowerCase();\n}\n/**\n * @param {?} str\n * @return {?}\n */\nfunction byteStringToDecString(str) {\n    var /** @type {?} */ decimal = '';\n    var /** @type {?} */ toThePower = '1';\n    for (var /** @type {?} */ i = str.length - 1; i >= 0; i--) {\n        decimal = addBigInt(decimal, numberTimesBigInt(byteAt(str, i), toThePower));\n        toThePower = numberTimesBigInt(256, toThePower);\n    }\n    return decimal.split('').reverse().join('');\n}\n/**\n * @param {?} x\n * @param {?} y\n * @return {?}\n */\nfunction addBigInt(x, y) {\n    var /** @type {?} */ sum = '';\n    var /** @type {?} */ len = Math.max(x.length, y.length);\n    for (var /** @type {?} */ i = 0, /** @type {?} */ carry = 0; i < len || carry; i++) {\n        var /** @type {?} */ tmpSum = carry + +(x[i] || 0) + +(y[i] || 0);\n        if (tmpSum >= 10) {\n            carry = 1;\n            sum += tmpSum - 10;\n        }\n        else {\n            carry = 0;\n            sum += tmpSum;\n        }\n    }\n    return sum;\n}\n/**\n * @param {?} num\n * @param {?} b\n * @return {?}\n */\nfunction numberTimesBigInt(num, b) {\n    var /** @type {?} */ product = '';\n    var /** @type {?} */ bToThePower = b;\n    for (; num !== 0; num = num >>> 1) {\n        if (num & 1)\n            product = addBigInt(product, bToThePower);\n        bToThePower = addBigInt(bToThePower, bToThePower);\n    }\n    return product;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @abstract\n */\nvar Serializer = (function () {\n    function Serializer() {\n    }\n    /**\n     * @abstract\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Serializer.prototype.write = function (messages, locale) { };\n    /**\n     * @abstract\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Serializer.prototype.load = function (content, url) { };\n    /**\n     * @abstract\n     * @param {?} message\n     * @return {?}\n     */\n    Serializer.prototype.digest = function (message) { };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Serializer.prototype.createNameMapper = function (message) { return null; };\n    return Serializer;\n}());\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nvar SimplePlaceholderMapper = (function (_super) {\n    __extends(SimplePlaceholderMapper, _super);\n    /**\n     * @param {?} message\n     * @param {?} mapName\n     */\n    function SimplePlaceholderMapper(message, mapName) {\n        var _this = _super.call(this) || this;\n        _this.mapName = mapName;\n        _this.internalToPublic = {};\n        _this.publicToNextId = {};\n        _this.publicToInternal = {};\n        message.nodes.forEach(function (node) { return node.visit(_this); });\n        return _this;\n    }\n    /**\n     * @param {?} internalName\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.toPublicName = function (internalName) {\n        return this.internalToPublic.hasOwnProperty(internalName) ?\n            this.internalToPublic[internalName] :\n            null;\n    };\n    /**\n     * @param {?} publicName\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.toInternalName = function (publicName) {\n        return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] :\n            null;\n    };\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitText = function (text, context) { return null; };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitTagPlaceholder = function (ph, context) {\n        this.visitPlaceholderName(ph.startName);\n        _super.prototype.visitTagPlaceholder.call(this, ph, context);\n        this.visitPlaceholderName(ph.closeName);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitPlaceholder = function (ph, context) { this.visitPlaceholderName(ph.name); };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitIcuPlaceholder = function (ph, context) {\n        this.visitPlaceholderName(ph.name);\n    };\n    /**\n     * @param {?} internalName\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitPlaceholderName = function (internalName) {\n        if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n            return;\n        }\n        var /** @type {?} */ publicName = this.mapName(internalName);\n        if (this.publicToInternal.hasOwnProperty(publicName)) {\n            // Create a new XMB when it has already been used\n            var /** @type {?} */ nextId = this.publicToNextId[publicName];\n            this.publicToNextId[publicName] = nextId + 1;\n            publicName = publicName + \"_\" + nextId;\n        }\n        else {\n            this.publicToNextId[publicName] = 1;\n        }\n        this.internalToPublic[internalName] = publicName;\n        this.publicToInternal[publicName] = internalName;\n    };\n    return SimplePlaceholderMapper;\n}(RecurseVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _Visitor$1 = (function () {\n    function _Visitor$1() {\n    }\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    _Visitor$1.prototype.visitTag = function (tag) {\n        var _this = this;\n        var /** @type {?} */ strAttrs = this._serializeAttributes(tag.attrs);\n        if (tag.children.length == 0) {\n            return \"<\" + tag.name + strAttrs + \"/>\";\n        }\n        var /** @type {?} */ strChildren = tag.children.map(function (node) { return node.visit(_this); });\n        return \"<\" + tag.name + strAttrs + \">\" + strChildren.join('') + \"</\" + tag.name + \">\";\n    };\n    /**\n     * @param {?} text\n     * @return {?}\n     */\n    _Visitor$1.prototype.visitText = function (text) { return text.value; };\n    /**\n     * @param {?} decl\n     * @return {?}\n     */\n    _Visitor$1.prototype.visitDeclaration = function (decl) {\n        return \"<?xml\" + this._serializeAttributes(decl.attrs) + \" ?>\";\n    };\n    /**\n     * @param {?} attrs\n     * @return {?}\n     */\n    _Visitor$1.prototype._serializeAttributes = function (attrs) {\n        var /** @type {?} */ strAttrs = Object.keys(attrs).map(function (name) { return name + \"=\\\"\" + attrs[name] + \"\\\"\"; }).join(' ');\n        return strAttrs.length > 0 ? ' ' + strAttrs : '';\n    };\n    /**\n     * @param {?} doctype\n     * @return {?}\n     */\n    _Visitor$1.prototype.visitDoctype = function (doctype) {\n        return \"<!DOCTYPE \" + doctype.rootTag + \" [\\n\" + doctype.dtd + \"\\n]>\";\n    };\n    return _Visitor$1;\n}());\nvar _visitor = new _Visitor$1();\n/**\n * @param {?} nodes\n * @return {?}\n */\nfunction serialize(nodes) {\n    return nodes.map(function (node) { return node.visit(_visitor); }).join('');\n}\nvar Declaration = (function () {\n    /**\n     * @param {?} unescapedAttrs\n     */\n    function Declaration(unescapedAttrs) {\n        var _this = this;\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach(function (k) {\n            _this.attrs[k] = _escapeXml(unescapedAttrs[k]);\n        });\n    }\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    Declaration.prototype.visit = function (visitor) { return visitor.visitDeclaration(this); };\n    return Declaration;\n}());\nvar Doctype = (function () {\n    /**\n     * @param {?} rootTag\n     * @param {?} dtd\n     */\n    function Doctype(rootTag, dtd) {\n        this.rootTag = rootTag;\n        this.dtd = dtd;\n    }\n    ;\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    Doctype.prototype.visit = function (visitor) { return visitor.visitDoctype(this); };\n    return Doctype;\n}());\nvar Tag = (function () {\n    /**\n     * @param {?} name\n     * @param {?=} unescapedAttrs\n     * @param {?=} children\n     */\n    function Tag(name, unescapedAttrs, children) {\n        if (unescapedAttrs === void 0) { unescapedAttrs = {}; }\n        if (children === void 0) { children = []; }\n        var _this = this;\n        this.name = name;\n        this.children = children;\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach(function (k) {\n            _this.attrs[k] = _escapeXml(unescapedAttrs[k]);\n        });\n    }\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    Tag.prototype.visit = function (visitor) { return visitor.visitTag(this); };\n    return Tag;\n}());\nvar Text$2 = (function () {\n    /**\n     * @param {?} unescapedValue\n     */\n    function Text$2(unescapedValue) {\n        this.value = _escapeXml(unescapedValue);\n    }\n    ;\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    Text$2.prototype.visit = function (visitor) { return visitor.visitText(this); };\n    return Text$2;\n}());\nvar CR = (function (_super) {\n    __extends(CR, _super);\n    /**\n     * @param {?=} ws\n     */\n    function CR(ws) {\n        if (ws === void 0) { ws = 0; }\n        return _super.call(this, \"\\n\" + new Array(ws + 1).join(' ')) || this;\n    }\n    return CR;\n}(Text$2));\nvar _ESCAPED_CHARS = [\n    [/&/g, '&amp;'],\n    [/\"/g, '&quot;'],\n    [/'/g, '&apos;'],\n    [/</g, '&lt;'],\n    [/>/g, '&gt;'],\n];\n/**\n * @param {?} text\n * @return {?}\n */\nfunction _escapeXml(text) {\n    return _ESCAPED_CHARS.reduce(function (text, entry) { return text.replace(entry[0], entry[1]); }, text);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _VERSION = '1.2';\nvar _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2';\n// TODO(vicb): make this a param (s/_/-/)\nvar _DEFAULT_SOURCE_LANG = 'en';\nvar _PLACEHOLDER_TAG = 'x';\nvar _FILE_TAG = 'file';\nvar _SOURCE_TAG = 'source';\nvar _TARGET_TAG = 'target';\nvar _UNIT_TAG = 'trans-unit';\nvar _CONTEXT_GROUP_TAG = 'context-group';\nvar _CONTEXT_TAG = 'context';\nvar Xliff = (function (_super) {\n    __extends(Xliff, _super);\n    function Xliff() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Xliff.prototype.write = function (messages, locale) {\n        var /** @type {?} */ visitor = new _WriteVisitor();\n        var /** @type {?} */ transUnits = [];\n        messages.forEach(function (message) {\n            var /** @type {?} */ contextTags = [];\n            message.sources.forEach(function (source) {\n                var /** @type {?} */ contextGroupTag = new Tag(_CONTEXT_GROUP_TAG, { purpose: 'location' });\n                contextGroupTag.children.push(new CR(10), new Tag(_CONTEXT_TAG, { 'context-type': 'sourcefile' }, [new Text$2(source.filePath)]), new CR(10), new Tag(_CONTEXT_TAG, { 'context-type': 'linenumber' }, [new Text$2(\"\" + source.startLine)]), new CR(8));\n                contextTags.push(new CR(8), contextGroupTag);\n            });\n            var /** @type {?} */ transUnit = new Tag(_UNIT_TAG, { id: message.id, datatype: 'html' });\n            (_a = transUnit.children).push.apply(_a, [new CR(8), new Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new CR(8), new Tag(_TARGET_TAG)].concat(contextTags));\n            if (message.description) {\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'description' }, [new Text$2(message.description)]));\n            }\n            if (message.meaning) {\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'meaning' }, [new Text$2(message.meaning)]));\n            }\n            transUnit.children.push(new CR(6));\n            transUnits.push(new CR(6), transUnit);\n            var _a;\n        });\n        var /** @type {?} */ body = new Tag('body', {}, transUnits.concat([new CR(4)]));\n        var /** @type {?} */ file = new Tag('file', {\n            'source-language': locale || _DEFAULT_SOURCE_LANG,\n            datatype: 'plaintext',\n            original: 'ng2.template',\n        }, [new CR(4), body, new CR(2)]);\n        var /** @type {?} */ xliff = new Tag('xliff', { version: _VERSION, xmlns: _XMLNS }, [new CR(2), file, new CR()]);\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\n        ]);\n    };\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Xliff.prototype.load = function (content, url) {\n        // xliff to xml nodes\n        var /** @type {?} */ xliffParser = new XliffParser();\n        var _a = xliffParser.parse(content, url), locale = _a.locale, msgIdToHtml = _a.msgIdToHtml, errors = _a.errors;\n        // xml nodes to i18n nodes\n        var /** @type {?} */ i18nNodesByMsgId = {};\n        var /** @type {?} */ converter = new XmlToI18n();\n        Object.keys(msgIdToHtml).forEach(function (msgId) {\n            var _a = converter.convert(msgIdToHtml[msgId], url), i18nNodes = _a.i18nNodes, e = _a.errors;\n            errors.push.apply(errors, e);\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(\"xliff parse errors:\\n\" + errors.join('\\n'));\n        }\n        return { locale: /** @type {?} */ ((locale)), i18nNodesByMsgId: i18nNodesByMsgId };\n    };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xliff.prototype.digest = function (message) { return digest(message); };\n    return Xliff;\n}(Serializer));\nvar _WriteVisitor = (function () {\n    function _WriteVisitor() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [];\n        container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });\n        return nodes;\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [new Text$2(\"{\" + icu.expressionPlaceholder + \", \" + icu.type + \", \")];\n        Object.keys(icu.cases).forEach(function (c) {\n            nodes.push.apply(nodes, [new Text$2(c + \" {\")].concat(icu.cases[c].visit(_this), [new Text$2(\"} \")]));\n        });\n        nodes.push(new Text$2(\"}\"));\n        return nodes;\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var /** @type {?} */ ctype = getCtypeForTag(ph.tag);\n        var /** @type {?} */ startTagPh = new Tag(_PLACEHOLDER_TAG, { id: ph.startName, ctype: ctype });\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [startTagPh];\n        }\n        var /** @type {?} */ closeTagPh = new Tag(_PLACEHOLDER_TAG, { id: ph.closeName, ctype: ctype });\n        return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG, { id: ph.name })];\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG, { id: ph.name })];\n    };\n    /**\n     * @param {?} nodes\n     * @return {?}\n     */\n    _WriteVisitor.prototype.serialize = function (nodes) {\n        var _this = this;\n        return [].concat.apply([], nodes.map(function (node) { return node.visit(_this); }));\n    };\n    return _WriteVisitor;\n}());\nvar XliffParser = (function () {\n    function XliffParser() {\n        this._locale = null;\n    }\n    /**\n     * @param {?} xliff\n     * @param {?} url\n     * @return {?}\n     */\n    XliffParser.prototype.parse = function (xliff, url) {\n        this._unitMlString = null;\n        this._msgIdToHtml = {};\n        var /** @type {?} */ xml = new XmlParser().parse(xliff, url, false);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes, null);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitElement = function (element, context) {\n        switch (element.name) {\n            case _UNIT_TAG:\n                this._unitMlString = ((null));\n                var /** @type {?} */ idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                if (!idAttr) {\n                    this._addError(element, \"<\" + _UNIT_TAG + \"> misses the \\\"id\\\" attribute\");\n                }\n                else {\n                    var /** @type {?} */ id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, \"Duplicated translations for msg \" + id);\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                        if (typeof this._unitMlString === 'string') {\n                            this._msgIdToHtml[id] = this._unitMlString;\n                        }\n                        else {\n                            this._addError(element, \"Message \" + id + \" misses a translation\");\n                        }\n                    }\n                }\n                break;\n            case _SOURCE_TAG:\n                // ignore source message\n                break;\n            case _TARGET_TAG:\n                var /** @type {?} */ innerTextStart = ((element.startSourceSpan)).end.offset;\n                var /** @type {?} */ innerTextEnd = ((element.endSourceSpan)).start.offset;\n                var /** @type {?} */ content = ((element.startSourceSpan)).start.file.content;\n                var /** @type {?} */ innerText = content.slice(innerTextStart, innerTextEnd);\n                this._unitMlString = innerText;\n                break;\n            case _FILE_TAG:\n                var /** @type {?} */ localeAttr = element.attrs.find(function (attr) { return attr.name === 'target-language'; });\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                visitAll(this, element.children, null);\n                break;\n            default:\n                // TODO(vicb): assert file structure, xliff version\n                // For now only recurse on unhandled nodes\n                visitAll(this, element.children, null);\n        }\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitText = function (text, context) { };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitExpansion = function (expansion, context) { };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitExpansionCase = function (expansionCase, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XliffParser.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(/** @type {?} */ ((node.sourceSpan)), message));\n    };\n    return XliffParser;\n}());\nvar XmlToI18n = (function () {\n    function XmlToI18n() {\n    }\n    /**\n     * @param {?} message\n     * @param {?} url\n     * @return {?}\n     */\n    XmlToI18n.prototype.convert = function (message, url) {\n        var /** @type {?} */ xmlIcu = new XmlParser().parse(message, url, true);\n        this._errors = xmlIcu.errors;\n        var /** @type {?} */ i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            visitAll(this, xmlIcu.rootNodes);\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitText = function (text, context) { return new Text$1(text.value, /** @type {?} */ ((text.sourceSpan))); };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitElement = function (el, context) {\n        if (el.name === _PLACEHOLDER_TAG) {\n            var /** @type {?} */ nameAttr = el.attrs.find(function (attr) { return attr.name === 'id'; });\n            if (nameAttr) {\n                return new Placeholder('', nameAttr.value, /** @type {?} */ ((el.sourceSpan)));\n            }\n            this._addError(el, \"<\" + _PLACEHOLDER_TAG + \"> misses the \\\"id\\\" attribute\");\n        }\n        else {\n            this._addError(el, \"Unexpected tag\");\n        }\n        return null;\n    };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitExpansion = function (icu, context) {\n        var /** @type {?} */ caseMap = {};\n        visitAll(this, icu.cases).forEach(function (c) {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitExpansionCase = function (icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: visitAll(this, icuCase.expression),\n        };\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XmlToI18n.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(/** @type {?} */ ((node.sourceSpan)), message));\n    };\n    return XmlToI18n;\n}());\n/**\n * @param {?} tag\n * @return {?}\n */\nfunction getCtypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n            return 'lb';\n        case 'img':\n            return 'image';\n        default:\n            return \"x-\" + tag;\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _VERSION$1 = '2.0';\nvar _XMLNS$1 = 'urn:oasis:names:tc:xliff:document:2.0';\n// TODO(vicb): make this a param (s/_/-/)\nvar _DEFAULT_SOURCE_LANG$1 = 'en';\nvar _PLACEHOLDER_TAG$1 = 'ph';\nvar _PLACEHOLDER_SPANNING_TAG = 'pc';\nvar _XLIFF_TAG = 'xliff';\nvar _SOURCE_TAG$1 = 'source';\nvar _TARGET_TAG$1 = 'target';\nvar _UNIT_TAG$1 = 'unit';\nvar Xliff2 = (function (_super) {\n    __extends(Xliff2, _super);\n    function Xliff2() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Xliff2.prototype.write = function (messages, locale) {\n        var /** @type {?} */ visitor = new _WriteVisitor$1();\n        var /** @type {?} */ units = [];\n        messages.forEach(function (message) {\n            var /** @type {?} */ unit = new Tag(_UNIT_TAG$1, { id: message.id });\n            if (message.description || message.meaning) {\n                var /** @type {?} */ notes = new Tag('notes');\n                if (message.description) {\n                    notes.children.push(new CR(8), new Tag('note', { category: 'description' }, [new Text$2(message.description)]));\n                }\n                if (message.meaning) {\n                    notes.children.push(new CR(8), new Tag('note', { category: 'meaning' }, [new Text$2(message.meaning)]));\n                }\n                notes.children.push(new CR(6));\n                unit.children.push(new CR(6), notes);\n            }\n            var /** @type {?} */ segment = new Tag('segment');\n            segment.children.push(new CR(8), new Tag(_SOURCE_TAG$1, {}, visitor.serialize(message.nodes)), new CR(6));\n            unit.children.push(new CR(6), segment, new CR(4));\n            units.push(new CR(4), unit);\n        });\n        var /** @type {?} */ file = new Tag('file', { 'original': 'ng.template', id: 'ngi18n' }, units.concat([new CR(2)]));\n        var /** @type {?} */ xliff = new Tag(_XLIFF_TAG, { version: _VERSION$1, xmlns: _XMLNS$1, srcLang: locale || _DEFAULT_SOURCE_LANG$1 }, [new CR(2), file, new CR()]);\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\n        ]);\n    };\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Xliff2.prototype.load = function (content, url) {\n        // xliff to xml nodes\n        var /** @type {?} */ xliff2Parser = new Xliff2Parser();\n        var _a = xliff2Parser.parse(content, url), locale = _a.locale, msgIdToHtml = _a.msgIdToHtml, errors = _a.errors;\n        // xml nodes to i18n nodes\n        var /** @type {?} */ i18nNodesByMsgId = {};\n        var /** @type {?} */ converter = new XmlToI18n$1();\n        Object.keys(msgIdToHtml).forEach(function (msgId) {\n            var _a = converter.convert(msgIdToHtml[msgId], url), i18nNodes = _a.i18nNodes, e = _a.errors;\n            errors.push.apply(errors, e);\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(\"xliff2 parse errors:\\n\" + errors.join('\\n'));\n        }\n        return { locale: /** @type {?} */ ((locale)), i18nNodesByMsgId: i18nNodesByMsgId };\n    };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xliff2.prototype.digest = function (message) { return decimalDigest(message); };\n    return Xliff2;\n}(Serializer));\nvar _WriteVisitor$1 = (function () {\n    function _WriteVisitor$1() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [];\n        container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });\n        return nodes;\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [new Text$2(\"{\" + icu.expressionPlaceholder + \", \" + icu.type + \", \")];\n        Object.keys(icu.cases).forEach(function (c) {\n            nodes.push.apply(nodes, [new Text$2(c + \" {\")].concat(icu.cases[c].visit(_this), [new Text$2(\"} \")]));\n        });\n        nodes.push(new Text$2(\"}\"));\n        return nodes;\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        var /** @type {?} */ type = getTypeForTag(ph.tag);\n        if (ph.isVoid) {\n            var /** @type {?} */ tagPh = new Tag(_PLACEHOLDER_TAG$1, {\n                id: (this._nextPlaceholderId++).toString(),\n                equiv: ph.startName,\n                type: type,\n                disp: \"<\" + ph.tag + \"/>\",\n            });\n            return [tagPh];\n        }\n        var /** @type {?} */ tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {\n            id: (this._nextPlaceholderId++).toString(),\n            equivStart: ph.startName,\n            equivEnd: ph.closeName,\n            type: type,\n            dispStart: \"<\" + ph.tag + \">\",\n            dispEnd: \"</\" + ph.tag + \">\",\n        });\n        var /** @type {?} */ nodes = [].concat.apply([], ph.children.map(function (node) { return node.visit(_this); }));\n        if (nodes.length) {\n            nodes.forEach(function (node) { return tagPc.children.push(node); });\n        }\n        else {\n            tagPc.children.push(new Text$2(''));\n        }\n        return [tagPc];\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.visitPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG$1, {\n                id: (this._nextPlaceholderId++).toString(),\n                equiv: ph.name,\n                disp: \"{{\" + ph.value + \"}}\",\n            })];\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.visitIcuPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG$1, { id: (this._nextPlaceholderId++).toString() })];\n    };\n    /**\n     * @param {?} nodes\n     * @return {?}\n     */\n    _WriteVisitor$1.prototype.serialize = function (nodes) {\n        var _this = this;\n        this._nextPlaceholderId = 0;\n        return [].concat.apply([], nodes.map(function (node) { return node.visit(_this); }));\n    };\n    return _WriteVisitor$1;\n}());\nvar Xliff2Parser = (function () {\n    function Xliff2Parser() {\n        this._locale = null;\n    }\n    /**\n     * @param {?} xliff\n     * @param {?} url\n     * @return {?}\n     */\n    Xliff2Parser.prototype.parse = function (xliff, url) {\n        this._unitMlString = null;\n        this._msgIdToHtml = {};\n        var /** @type {?} */ xml = new XmlParser().parse(xliff, url, false);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes, null);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    Xliff2Parser.prototype.visitElement = function (element, context) {\n        switch (element.name) {\n            case _UNIT_TAG$1:\n                this._unitMlString = null;\n                var /** @type {?} */ idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                if (!idAttr) {\n                    this._addError(element, \"<\" + _UNIT_TAG$1 + \"> misses the \\\"id\\\" attribute\");\n                }\n                else {\n                    var /** @type {?} */ id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, \"Duplicated translations for msg \" + id);\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                        if (typeof this._unitMlString === 'string') {\n                            this._msgIdToHtml[id] = this._unitMlString;\n                        }\n                        else {\n                            this._addError(element, \"Message \" + id + \" misses a translation\");\n                        }\n                    }\n                }\n                break;\n            case _SOURCE_TAG$1:\n                // ignore source message\n                break;\n            case _TARGET_TAG$1:\n                var /** @type {?} */ innerTextStart = ((element.startSourceSpan)).end.offset;\n                var /** @type {?} */ innerTextEnd = ((element.endSourceSpan)).start.offset;\n                var /** @type {?} */ content = ((element.startSourceSpan)).start.file.content;\n                var /** @type {?} */ innerText = content.slice(innerTextStart, innerTextEnd);\n                this._unitMlString = innerText;\n                break;\n            case _XLIFF_TAG:\n                var /** @type {?} */ localeAttr = element.attrs.find(function (attr) { return attr.name === 'trgLang'; });\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                var /** @type {?} */ versionAttr = element.attrs.find(function (attr) { return attr.name === 'version'; });\n                if (versionAttr) {\n                    var /** @type {?} */ version = versionAttr.value;\n                    if (version !== '2.0') {\n                        this._addError(element, \"The XLIFF file version \" + version + \" is not compatible with XLIFF 2.0 serializer\");\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                    }\n                }\n                break;\n            default:\n                visitAll(this, element.children, null);\n        }\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    Xliff2Parser.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    Xliff2Parser.prototype.visitText = function (text, context) { };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    Xliff2Parser.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    Xliff2Parser.prototype.visitExpansion = function (expansion, context) { };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    Xliff2Parser.prototype.visitExpansionCase = function (expansionCase, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    Xliff2Parser.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return Xliff2Parser;\n}());\nvar XmlToI18n$1 = (function () {\n    function XmlToI18n$1() {\n    }\n    /**\n     * @param {?} message\n     * @param {?} url\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.convert = function (message, url) {\n        var /** @type {?} */ xmlIcu = new XmlParser().parse(message, url, true);\n        this._errors = xmlIcu.errors;\n        var /** @type {?} */ i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] : [].concat.apply([], visitAll(this, xmlIcu.rootNodes));\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitText = function (text, context) { return new Text$1(text.value, text.sourceSpan); };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitElement = function (el, context) {\n        var _this = this;\n        switch (el.name) {\n            case _PLACEHOLDER_TAG$1:\n                var /** @type {?} */ nameAttr = el.attrs.find(function (attr) { return attr.name === 'equiv'; });\n                if (nameAttr) {\n                    return [new Placeholder('', nameAttr.value, el.sourceSpan)];\n                }\n                this._addError(el, \"<\" + _PLACEHOLDER_TAG$1 + \"> misses the \\\"equiv\\\" attribute\");\n                break;\n            case _PLACEHOLDER_SPANNING_TAG:\n                var /** @type {?} */ startAttr = el.attrs.find(function (attr) { return attr.name === 'equivStart'; });\n                var /** @type {?} */ endAttr = el.attrs.find(function (attr) { return attr.name === 'equivEnd'; });\n                if (!startAttr) {\n                    this._addError(el, \"<\" + _PLACEHOLDER_TAG$1 + \"> misses the \\\"equivStart\\\" attribute\");\n                }\n                else if (!endAttr) {\n                    this._addError(el, \"<\" + _PLACEHOLDER_TAG$1 + \"> misses the \\\"equivEnd\\\" attribute\");\n                }\n                else {\n                    var /** @type {?} */ startId = startAttr.value;\n                    var /** @type {?} */ endId = endAttr.value;\n                    var /** @type {?} */ nodes = [];\n                    return nodes.concat.apply(nodes, [new Placeholder('', startId, el.sourceSpan)].concat(el.children.map(function (node) { return node.visit(_this, null); }), [new Placeholder('', endId, el.sourceSpan)]));\n                }\n                break;\n            default:\n                this._addError(el, \"Unexpected tag\");\n        }\n        return null;\n    };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitExpansion = function (icu, context) {\n        var /** @type {?} */ caseMap = {};\n        visitAll(this, icu.cases).forEach(function (c) {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitExpansionCase = function (icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: [].concat.apply([], visitAll(this, icuCase.expression)),\n        };\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XmlToI18n$1.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XmlToI18n$1;\n}());\n/**\n * @param {?} tag\n * @return {?}\n */\nfunction getTypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n        case 'b':\n        case 'i':\n        case 'u':\n            return 'fmt';\n        case 'img':\n            return 'image';\n        case 'a':\n            return 'link';\n        default:\n            return 'other';\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _MESSAGES_TAG = 'messagebundle';\nvar _MESSAGE_TAG = 'msg';\nvar _PLACEHOLDER_TAG$2 = 'ph';\nvar _EXEMPLE_TAG = 'ex';\nvar _SOURCE_TAG$2 = 'source';\nvar _DOCTYPE = \"<!ELEMENT messagebundle (msg)*>\\n<!ATTLIST messagebundle class CDATA #IMPLIED>\\n\\n<!ELEMENT msg (#PCDATA|ph|source)*>\\n<!ATTLIST msg id CDATA #IMPLIED>\\n<!ATTLIST msg seq CDATA #IMPLIED>\\n<!ATTLIST msg name CDATA #IMPLIED>\\n<!ATTLIST msg desc CDATA #IMPLIED>\\n<!ATTLIST msg meaning CDATA #IMPLIED>\\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\\n<!ATTLIST msg xml:space (default|preserve) \\\"default\\\">\\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\\n\\n<!ELEMENT source (#PCDATA)>\\n\\n<!ELEMENT ph (#PCDATA|ex)*>\\n<!ATTLIST ph name CDATA #REQUIRED>\\n\\n<!ELEMENT ex (#PCDATA)>\";\nvar Xmb = (function (_super) {\n    __extends(Xmb, _super);\n    function Xmb() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Xmb.prototype.write = function (messages, locale) {\n        var /** @type {?} */ exampleVisitor = new ExampleVisitor();\n        var /** @type {?} */ visitor = new _Visitor$2();\n        var /** @type {?} */ rootNode = new Tag(_MESSAGES_TAG);\n        messages.forEach(function (message) {\n            var /** @type {?} */ attrs = { id: message.id };\n            if (message.description) {\n                attrs['desc'] = message.description;\n            }\n            if (message.meaning) {\n                attrs['meaning'] = message.meaning;\n            }\n            var /** @type {?} */ sourceTags = [];\n            message.sources.forEach(function (source) {\n                sourceTags.push(new Tag(_SOURCE_TAG$2, {}, [\n                    new Text$2(source.filePath + \":\" + source.startLine + (source.endLine !== source.startLine ? ',' + source.endLine : ''))\n                ]));\n            });\n            rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, sourceTags.concat(visitor.serialize(message.nodes))));\n        });\n        rootNode.children.push(new CR());\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }),\n            new CR(),\n            new Doctype(_MESSAGES_TAG, _DOCTYPE),\n            new CR(),\n            exampleVisitor.addDefaultExamples(rootNode),\n            new CR(),\n        ]);\n    };\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Xmb.prototype.load = function (content, url) {\n        throw new Error('Unsupported');\n    };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xmb.prototype.digest = function (message) { return digest$1(message); };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xmb.prototype.createNameMapper = function (message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    };\n    return Xmb;\n}(Serializer));\nvar _Visitor$2 = (function () {\n    function _Visitor$2() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };\n    /**\n     * @param {?} container\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [];\n        container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });\n        return nodes;\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [new Text$2(\"{\" + icu.expressionPlaceholder + \", \" + icu.type + \", \")];\n        Object.keys(icu.cases).forEach(function (c) {\n            nodes.push.apply(nodes, [new Text$2(c + \" {\")].concat(icu.cases[c].visit(_this), [new Text$2(\"} \")]));\n        });\n        nodes.push(new Text$2(\"}\"));\n        return nodes;\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitTagPlaceholder = function (ph, context) {\n        var /** @type {?} */ startEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2(\"<\" + ph.tag + \">\")]);\n        var /** @type {?} */ startTagPh = new Tag(_PLACEHOLDER_TAG$2, { name: ph.startName }, [startEx]);\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [startTagPh];\n        }\n        var /** @type {?} */ closeEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2(\"</\" + ph.tag + \">\")]);\n        var /** @type {?} */ closeTagPh = new Tag(_PLACEHOLDER_TAG$2, { name: ph.closeName }, [closeEx]);\n        return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG$2, { name: ph.name })];\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitIcuPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG$2, { name: ph.name })];\n    };\n    /**\n     * @param {?} nodes\n     * @return {?}\n     */\n    _Visitor$2.prototype.serialize = function (nodes) {\n        var _this = this;\n        return [].concat.apply([], nodes.map(function (node) { return node.visit(_this); }));\n    };\n    return _Visitor$2;\n}());\n/**\n * @param {?} message\n * @return {?}\n */\nfunction digest$1(message) {\n    return decimalDigest(message);\n}\nvar ExampleVisitor = (function () {\n    function ExampleVisitor() {\n    }\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    ExampleVisitor.prototype.addDefaultExamples = function (node) {\n        node.visit(this);\n        return node;\n    };\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    ExampleVisitor.prototype.visitTag = function (tag) {\n        var _this = this;\n        if (tag.name === _PLACEHOLDER_TAG$2) {\n            if (!tag.children || tag.children.length == 0) {\n                var /** @type {?} */ exText = new Text$2(tag.attrs['name'] || '...');\n                tag.children = [new Tag(_EXEMPLE_TAG, {}, [exText])];\n            }\n        }\n        else if (tag.children) {\n            tag.children.forEach(function (node) { return node.visit(_this); });\n        }\n    };\n    /**\n     * @param {?} text\n     * @return {?}\n     */\n    ExampleVisitor.prototype.visitText = function (text) { };\n    /**\n     * @param {?} decl\n     * @return {?}\n     */\n    ExampleVisitor.prototype.visitDeclaration = function (decl) { };\n    /**\n     * @param {?} doctype\n     * @return {?}\n     */\n    ExampleVisitor.prototype.visitDoctype = function (doctype) { };\n    return ExampleVisitor;\n}());\n/**\n * @param {?} internalName\n * @return {?}\n */\nfunction toPublicName(internalName) {\n    return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _TRANSLATIONS_TAG = 'translationbundle';\nvar _TRANSLATION_TAG = 'translation';\nvar _PLACEHOLDER_TAG$3 = 'ph';\nvar Xtb = (function (_super) {\n    __extends(Xtb, _super);\n    function Xtb() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Xtb.prototype.write = function (messages, locale) { throw new Error('Unsupported'); };\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Xtb.prototype.load = function (content, url) {\n        // xtb to xml nodes\n        var /** @type {?} */ xtbParser = new XtbParser();\n        var _a = xtbParser.parse(content, url), locale = _a.locale, msgIdToHtml = _a.msgIdToHtml, errors = _a.errors;\n        // xml nodes to i18n nodes\n        var /** @type {?} */ i18nNodesByMsgId = {};\n        var /** @type {?} */ converter = new XmlToI18n$2();\n        // Because we should be able to load xtb files that rely on features not supported by angular,\n        // we need to delay the conversion of html to i18n nodes so that non angular messages are not\n        // converted\n        Object.keys(msgIdToHtml).forEach(function (msgId) {\n            var /** @type {?} */ valueFn = function () {\n                var _a = converter.convert(msgIdToHtml[msgId], url), i18nNodes = _a.i18nNodes, errors = _a.errors;\n                if (errors.length) {\n                    throw new Error(\"xtb parse errors:\\n\" + errors.join('\\n'));\n                }\n                return i18nNodes;\n            };\n            createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n        });\n        if (errors.length) {\n            throw new Error(\"xtb parse errors:\\n\" + errors.join('\\n'));\n        }\n        return { locale: /** @type {?} */ ((locale)), i18nNodesByMsgId: i18nNodesByMsgId };\n    };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xtb.prototype.digest = function (message) { return digest$1(message); };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xtb.prototype.createNameMapper = function (message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    };\n    return Xtb;\n}(Serializer));\n/**\n * @param {?} messages\n * @param {?} id\n * @param {?} valueFn\n * @return {?}\n */\nfunction createLazyProperty(messages, id, valueFn) {\n    Object.defineProperty(messages, id, {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n            var /** @type {?} */ value = valueFn();\n            Object.defineProperty(messages, id, { enumerable: true, value: value });\n            return value;\n        },\n        set: function (_) { throw new Error('Could not overwrite an XTB translation'); },\n    });\n}\nvar XtbParser = (function () {\n    function XtbParser() {\n        this._locale = null;\n    }\n    /**\n     * @param {?} xtb\n     * @param {?} url\n     * @return {?}\n     */\n    XtbParser.prototype.parse = function (xtb, url) {\n        this._bundleDepth = 0;\n        this._msgIdToHtml = {};\n        // We can not parse the ICU messages at this point as some messages might not originate\n        // from Angular that could not be lex'd.\n        var /** @type {?} */ xml = new XmlParser().parse(xtb, url, false);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitElement = function (element, context) {\n        switch (element.name) {\n            case _TRANSLATIONS_TAG:\n                this._bundleDepth++;\n                if (this._bundleDepth > 1) {\n                    this._addError(element, \"<\" + _TRANSLATIONS_TAG + \"> elements can not be nested\");\n                }\n                var /** @type {?} */ langAttr = element.attrs.find(function (attr) { return attr.name === 'lang'; });\n                if (langAttr) {\n                    this._locale = langAttr.value;\n                }\n                visitAll(this, element.children, null);\n                this._bundleDepth--;\n                break;\n            case _TRANSLATION_TAG:\n                var /** @type {?} */ idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                if (!idAttr) {\n                    this._addError(element, \"<\" + _TRANSLATION_TAG + \"> misses the \\\"id\\\" attribute\");\n                }\n                else {\n                    var /** @type {?} */ id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, \"Duplicated translations for msg \" + id);\n                    }\n                    else {\n                        var /** @type {?} */ innerTextStart = ((element.startSourceSpan)).end.offset;\n                        var /** @type {?} */ innerTextEnd = ((element.endSourceSpan)).start.offset;\n                        var /** @type {?} */ content = ((element.startSourceSpan)).start.file.content;\n                        var /** @type {?} */ innerText = content.slice(/** @type {?} */ ((innerTextStart)), /** @type {?} */ ((innerTextEnd)));\n                        this._msgIdToHtml[id] = innerText;\n                    }\n                }\n                break;\n            default:\n                this._addError(element, 'Unexpected tag');\n        }\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitText = function (text, context) { };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitExpansion = function (expansion, context) { };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitExpansionCase = function (expansionCase, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XtbParser.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(/** @type {?} */ ((node.sourceSpan)), message));\n    };\n    return XtbParser;\n}());\nvar XmlToI18n$2 = (function () {\n    function XmlToI18n$2() {\n    }\n    /**\n     * @param {?} message\n     * @param {?} url\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.convert = function (message, url) {\n        var /** @type {?} */ xmlIcu = new XmlParser().parse(message, url, true);\n        this._errors = xmlIcu.errors;\n        var /** @type {?} */ i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            visitAll(this, xmlIcu.rootNodes);\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.visitText = function (text, context) { return new Text$1(text.value, /** @type {?} */ ((text.sourceSpan))); };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.visitExpansion = function (icu, context) {\n        var /** @type {?} */ caseMap = {};\n        visitAll(this, icu.cases).forEach(function (c) {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.visitExpansionCase = function (icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: visitAll(this, icuCase.expression),\n        };\n    };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.visitElement = function (el, context) {\n        if (el.name === _PLACEHOLDER_TAG$3) {\n            var /** @type {?} */ nameAttr = el.attrs.find(function (attr) { return attr.name === 'name'; });\n            if (nameAttr) {\n                return new Placeholder('', nameAttr.value, /** @type {?} */ ((el.sourceSpan)));\n            }\n            this._addError(el, \"<\" + _PLACEHOLDER_TAG$3 + \"> misses the \\\"name\\\" attribute\");\n        }\n        else {\n            this._addError(el, \"Unexpected tag\");\n        }\n        return null;\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$2.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XmlToI18n$2.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(/** @type {?} */ ((node.sourceSpan)), message));\n    };\n    return XmlToI18n$2;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar HtmlParser = (function (_super) {\n    __extends(HtmlParser, _super);\n    function HtmlParser() {\n        return _super.call(this, getHtmlTagDefinition) || this;\n    }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    HtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {\n        if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        return _super.prototype.parse.call(this, source, url, parseExpansionForms, interpolationConfig);\n    };\n    return HtmlParser;\n}(Parser$1));\nHtmlParser.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nHtmlParser.ctorParameters = function () { return []; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A container for translated messages\n */\nvar TranslationBundle = (function () {\n    /**\n     * @param {?=} _i18nNodesByMsgId\n     * @param {?=} locale\n     * @param {?=} digest\n     * @param {?=} mapperFactory\n     * @param {?=} missingTranslationStrategy\n     * @param {?=} console\n     */\n    function TranslationBundle(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console) {\n        if (_i18nNodesByMsgId === void 0) { _i18nNodesByMsgId = {}; }\n        if (missingTranslationStrategy === void 0) { missingTranslationStrategy = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"MissingTranslationStrategy\"].Warning; }\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this.digest = digest;\n        this.mapperFactory = mapperFactory;\n        this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);\n    }\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @param {?} serializer\n     * @param {?} missingTranslationStrategy\n     * @param {?=} console\n     * @return {?}\n     */\n    TranslationBundle.load = function (content, url, serializer, missingTranslationStrategy, console) {\n        var _a = serializer.load(content, url), locale = _a.locale, i18nNodesByMsgId = _a.i18nNodesByMsgId;\n        var /** @type {?} */ digestFn = function (m) { return serializer.digest(m); };\n        var /** @type {?} */ mapperFactory = function (m) { return ((serializer.createNameMapper(m))); };\n        return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);\n    };\n    /**\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    TranslationBundle.prototype.get = function (srcMsg) {\n        var /** @type {?} */ html = this._i18nToHtml.convert(srcMsg);\n        if (html.errors.length) {\n            throw new Error(html.errors.join('\\n'));\n        }\n        return html.nodes;\n    };\n    /**\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    TranslationBundle.prototype.has = function (srcMsg) { return this.digest(srcMsg) in this._i18nNodesByMsgId; };\n    return TranslationBundle;\n}());\nvar I18nToHtmlVisitor = (function () {\n    /**\n     * @param {?=} _i18nNodesByMsgId\n     * @param {?=} _locale\n     * @param {?=} _digest\n     * @param {?=} _mapperFactory\n     * @param {?=} _missingTranslationStrategy\n     * @param {?=} _console\n     */\n    function I18nToHtmlVisitor(_i18nNodesByMsgId, _locale, _digest, _mapperFactory, _missingTranslationStrategy, _console) {\n        if (_i18nNodesByMsgId === void 0) { _i18nNodesByMsgId = {}; }\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this._locale = _locale;\n        this._digest = _digest;\n        this._mapperFactory = _mapperFactory;\n        this._missingTranslationStrategy = _missingTranslationStrategy;\n        this._console = _console;\n        this._contextStack = [];\n        this._errors = [];\n    }\n    /**\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.convert = function (srcMsg) {\n        this._contextStack.length = 0;\n        this._errors.length = 0;\n        // i18n to text\n        var /** @type {?} */ text = this._convertToText(srcMsg);\n        // text to html\n        var /** @type {?} */ url = srcMsg.nodes[0].sourceSpan.start.file.url;\n        var /** @type {?} */ html = new HtmlParser().parse(text, url, true);\n        return {\n            nodes: html.rootNodes,\n            errors: this._errors.concat(html.errors),\n        };\n    };\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitText = function (text, context) { return text.value; };\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        return container.children.map(function (n) { return n.visit(_this); }).join('');\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ cases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        // TODO(vicb): Once all format switch to using expression placeholders\n        // we should throw when the placeholder is not in the source message\n        var /** @type {?} */ exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ?\n            this._srcMsg.placeholders[icu.expression] :\n            icu.expression;\n        return \"{\" + exp + \", \" + icu.type + \", \" + cases.join(' ') + \"}\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitPlaceholder = function (ph, context) {\n        var /** @type {?} */ phName = this._mapper(ph.name);\n        if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n            return this._srcMsg.placeholders[phName];\n        }\n        if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n            return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\n        }\n        this._addError(ph, \"Unknown placeholder \\\"\" + ph.name + \"\\\"\");\n        return '';\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        var /** @type {?} */ tag = \"\" + ph.tag;\n        var /** @type {?} */ attrs = Object.keys(ph.attrs).map(function (name) { return name + \"=\\\"\" + ph.attrs[name] + \"\\\"\"; }).join(' ');\n        if (ph.isVoid) {\n            return \"<\" + tag + \" \" + attrs + \"/>\";\n        }\n        var /** @type {?} */ children = ph.children.map(function (c) { return c.visit(_this); }).join('');\n        return \"<\" + tag + \" \" + attrs + \">\" + children + \"</\" + tag + \">\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        // An ICU placeholder references the source message to be serialized\n        return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n    };\n    /**\n     * Convert a source message to a translated text string:\n     * - text nodes are replaced with their translation,\n     * - placeholders are replaced with their content,\n     * - ICU nodes are converted to ICU expressions.\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype._convertToText = function (srcMsg) {\n        var _this = this;\n        var /** @type {?} */ id = this._digest(srcMsg);\n        var /** @type {?} */ mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n        var /** @type {?} */ nodes;\n        this._contextStack.push({ msg: this._srcMsg, mapper: this._mapper });\n        this._srcMsg = srcMsg;\n        if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n            // When there is a translation use its nodes as the source\n            // And create a mapper to convert serialized placeholder names to internal names\n            nodes = this._i18nNodesByMsgId[id];\n            this._mapper = function (name) { return mapper ? ((mapper.toInternalName(name))) : name; };\n        }\n        else {\n            // When no translation has been found\n            // - report an error / a warning / nothing,\n            // - use the nodes from the original message\n            // - placeholders are already internal and need no mapper\n            if (this._missingTranslationStrategy === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"MissingTranslationStrategy\"].Error) {\n                var /** @type {?} */ ctx = this._locale ? \" for locale \\\"\" + this._locale + \"\\\"\" : '';\n                this._addError(srcMsg.nodes[0], \"Missing translation for message \\\"\" + id + \"\\\"\" + ctx);\n            }\n            else if (this._console &&\n                this._missingTranslationStrategy === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"MissingTranslationStrategy\"].Warning) {\n                var /** @type {?} */ ctx = this._locale ? \" for locale \\\"\" + this._locale + \"\\\"\" : '';\n                this._console.warn(\"Missing translation for message \\\"\" + id + \"\\\"\" + ctx);\n            }\n            nodes = srcMsg.nodes;\n            this._mapper = function (name) { return name; };\n        }\n        var /** @type {?} */ text = nodes.map(function (node) { return node.visit(_this); }).join('');\n        var /** @type {?} */ context = ((this._contextStack.pop()));\n        this._srcMsg = context.msg;\n        this._mapper = context.mapper;\n        return text;\n    };\n    /**\n     * @param {?} el\n     * @param {?} msg\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype._addError = function (el, msg) {\n        this._errors.push(new I18nError(el.sourceSpan, msg));\n    };\n    return I18nToHtmlVisitor;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar I18NHtmlParser = (function () {\n    /**\n     * @param {?} _htmlParser\n     * @param {?=} translations\n     * @param {?=} translationsFormat\n     * @param {?=} missingTranslation\n     * @param {?=} console\n     */\n    function I18NHtmlParser(_htmlParser, translations, translationsFormat, missingTranslation, console) {\n        if (missingTranslation === void 0) { missingTranslation = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"MissingTranslationStrategy\"].Warning; }\n        this._htmlParser = _htmlParser;\n        if (translations) {\n            var serializer = createSerializer(translationsFormat);\n            this._translationBundle =\n                TranslationBundle.load(translations, 'i18n', serializer, missingTranslation, console);\n        }\n    }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    I18NHtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {\n        if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ parseResult = this._htmlParser.parse(source, url, parseExpansionForms, interpolationConfig);\n        if (!this._translationBundle) {\n            // Do not enable i18n when no translation bundle is provided\n            return parseResult;\n        }\n        if (parseResult.errors.length) {\n            return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);\n        }\n        return mergeTranslations(parseResult.rootNodes, this._translationBundle, interpolationConfig, [], {});\n    };\n    return I18NHtmlParser;\n}());\n/**\n * @param {?=} format\n * @return {?}\n */\nfunction createSerializer(format) {\n    format = (format || 'xlf').toLowerCase();\n    switch (format) {\n        case 'xmb':\n            return new Xmb();\n        case 'xtb':\n            return new Xtb();\n        case 'xliff2':\n        case 'xlf2':\n            return new Xliff2();\n        case 'xliff':\n        case 'xlf':\n        default:\n            return new Xliff();\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CORE = assetUrl('core');\nvar Identifiers = (function () {\n    function Identifiers() {\n    }\n    return Identifiers;\n}());\nIdentifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {\n    name: 'ANALYZE_FOR_ENTRY_COMPONENTS',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ANALYZE_FOR_ENTRY_COMPONENTS\"]\n};\nIdentifiers.ElementRef = { name: 'ElementRef', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ElementRef\"] };\nIdentifiers.NgModuleRef = { name: 'NgModuleRef', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"NgModuleRef\"] };\nIdentifiers.ViewContainerRef = { name: 'ViewContainerRef', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewContainerRef\"] };\nIdentifiers.ChangeDetectorRef = { name: 'ChangeDetectorRef', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ChangeDetectorRef\"] };\nIdentifiers.QueryList = { name: 'QueryList', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"QueryList\"] };\nIdentifiers.TemplateRef = { name: 'TemplateRef', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"TemplateRef\"] };\nIdentifiers.CodegenComponentFactoryResolver = {\n    name: 'ɵCodegenComponentFactoryResolver',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵCodegenComponentFactoryResolver\"]\n};\nIdentifiers.ComponentFactoryResolver = {\n    name: 'ComponentFactoryResolver',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ComponentFactoryResolver\"]\n};\nIdentifiers.ComponentFactory = { name: 'ComponentFactory', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ComponentFactory\"] };\nIdentifiers.ComponentRef = { name: 'ComponentRef', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ComponentRef\"] };\nIdentifiers.NgModuleFactory = { name: 'NgModuleFactory', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"NgModuleFactory\"] };\nIdentifiers.NgModuleInjector = {\n    name: 'ɵNgModuleInjector',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵNgModuleInjector\"],\n};\nIdentifiers.RegisterModuleFactoryFn = {\n    name: 'ɵregisterModuleFactory',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵregisterModuleFactory\"],\n};\nIdentifiers.Injector = { name: 'Injector', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Injector\"] };\nIdentifiers.ViewEncapsulation = { name: 'ViewEncapsulation', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewEncapsulation\"] };\nIdentifiers.ChangeDetectionStrategy = {\n    name: 'ChangeDetectionStrategy',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ChangeDetectionStrategy\"]\n};\nIdentifiers.SecurityContext = {\n    name: 'SecurityContext',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"SecurityContext\"],\n};\nIdentifiers.LOCALE_ID = { name: 'LOCALE_ID', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"LOCALE_ID\"] };\nIdentifiers.TRANSLATIONS_FORMAT = { name: 'TRANSLATIONS_FORMAT', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"TRANSLATIONS_FORMAT\"] };\nIdentifiers.inlineInterpolate = { name: 'ɵinlineInterpolate', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵinlineInterpolate\"] };\nIdentifiers.interpolate = { name: 'ɵinterpolate', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵinterpolate\"] };\nIdentifiers.EMPTY_ARRAY = { name: 'ɵEMPTY_ARRAY', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵEMPTY_ARRAY\"] };\nIdentifiers.EMPTY_MAP = { name: 'ɵEMPTY_MAP', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵEMPTY_MAP\"] };\nIdentifiers.Renderer = { name: 'Renderer', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Renderer\"] };\nIdentifiers.viewDef = { name: 'ɵvid', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵvid\"] };\nIdentifiers.elementDef = { name: 'ɵeld', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵeld\"] };\nIdentifiers.anchorDef = { name: 'ɵand', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵand\"] };\nIdentifiers.textDef = { name: 'ɵted', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵted\"] };\nIdentifiers.directiveDef = { name: 'ɵdid', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵdid\"] };\nIdentifiers.providerDef = { name: 'ɵprd', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵprd\"] };\nIdentifiers.queryDef = { name: 'ɵqud', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵqud\"] };\nIdentifiers.pureArrayDef = { name: 'ɵpad', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵpad\"] };\nIdentifiers.pureObjectDef = { name: 'ɵpod', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵpod\"] };\nIdentifiers.purePipeDef = { name: 'ɵppd', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵppd\"] };\nIdentifiers.pipeDef = { name: 'ɵpid', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵpid\"] };\nIdentifiers.nodeValue = { name: 'ɵnov', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵnov\"] };\nIdentifiers.ngContentDef = { name: 'ɵncd', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵncd\"] };\nIdentifiers.unwrapValue = { name: 'ɵunv', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵunv\"] };\nIdentifiers.createRendererType2 = { name: 'ɵcrt', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵcrt\"] };\nIdentifiers.RendererType2 = {\n    name: 'RendererType2',\n    moduleUrl: CORE,\n    // type only\n    runtime: null\n};\nIdentifiers.ViewDefinition = {\n    name: 'ɵViewDefinition',\n    moduleUrl: CORE,\n    // type only\n    runtime: null\n};\nIdentifiers.createComponentFactory = { name: 'ɵccf', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵccf\"] };\n/**\n * @param {?} pkg\n * @param {?=} path\n * @param {?=} type\n * @return {?}\n */\nfunction assetUrl(pkg, path, type) {\n    if (path === void 0) { path = null; }\n    if (type === void 0) { type = 'src'; }\n    if (path == null) {\n        return \"@angular/\" + pkg;\n    }\n    else {\n        return \"@angular/\" + pkg + \"/\" + type + \"/\" + path;\n    }\n}\n/**\n * @param {?} identifier\n * @return {?}\n */\nfunction resolveIdentifier(identifier) {\n    var /** @type {?} */ name = identifier.name;\n    return __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵreflector\"].resolveIdentifier(name, identifier.moduleUrl, null, identifier.runtime);\n}\n/**\n * @param {?} identifier\n * @return {?}\n */\nfunction createIdentifier(identifier) {\n    return { reference: resolveIdentifier(identifier) };\n}\n/**\n * @param {?} identifier\n * @return {?}\n */\nfunction identifierToken(identifier) {\n    return { identifier: identifier };\n}\n/**\n * @param {?} identifier\n * @return {?}\n */\nfunction createIdentifierToken(identifier) {\n    return identifierToken(createIdentifier(identifier));\n}\n/**\n * @param {?} enumType\n * @param {?} name\n * @return {?}\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// http://cldr.unicode.org/index/cldr-spec/plural-rules\nvar PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];\n/**\n * Expands special forms into elements.\n *\n * For example,\n *\n * ```\n * { messages.length, plural,\n *   =0 {zero}\n *   =1 {one}\n *   other {more than one}\n * }\n * ```\n *\n * will be expanded into\n *\n * ```\n * <ng-container [ngPlural]=\"messages.length\">\n *   <ng-template ngPluralCase=\"=0\">zero</ng-template>\n *   <ng-template ngPluralCase=\"=1\">one</ng-template>\n *   <ng-template ngPluralCase=\"other\">more than one</ng-template>\n * </ng-container>\n * ```\n * @param {?} nodes\n * @return {?}\n */\nfunction expandNodes(nodes) {\n    var /** @type {?} */ expander = new _Expander();\n    return new ExpansionResult(visitAll(expander, nodes), expander.isExpanded, expander.errors);\n}\nvar ExpansionResult = (function () {\n    /**\n     * @param {?} nodes\n     * @param {?} expanded\n     * @param {?} errors\n     */\n    function ExpansionResult(nodes, expanded, errors) {\n        this.nodes = nodes;\n        this.expanded = expanded;\n        this.errors = errors;\n    }\n    return ExpansionResult;\n}());\nvar ExpansionError = (function (_super) {\n    __extends(ExpansionError, _super);\n    /**\n     * @param {?} span\n     * @param {?} errorMsg\n     */\n    function ExpansionError(span, errorMsg) {\n        return _super.call(this, span, errorMsg) || this;\n    }\n    return ExpansionError;\n}(ParseError));\n/**\n * Expand expansion forms (plural, select) to directives\n *\n * \\@internal\n */\nvar _Expander = (function () {\n    function _Expander() {\n        this.isExpanded = false;\n        this.errors = [];\n    }\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitElement = function (element, context) {\n        return new Element(element.name, element.attrs, visitAll(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitAttribute = function (attribute, context) { return attribute; };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitText = function (text, context) { return text; };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitComment = function (comment, context) { return comment; };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitExpansion = function (icu, context) {\n        this.isExpanded = true;\n        return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) :\n            _expandDefaultForm(icu, this.errors);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitExpansionCase = function (icuCase, context) {\n        throw new Error('Should not be reached');\n    };\n    return _Expander;\n}());\n/**\n * @param {?} ast\n * @param {?} errors\n * @return {?}\n */\nfunction _expandPluralForm(ast, errors) {\n    var /** @type {?} */ children = ast.cases.map(function (c) {\n        if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\\d+$/)) {\n            errors.push(new ExpansionError(c.valueSourceSpan, \"Plural cases should be \\\"=<number>\\\" or one of \" + PLURAL_CASES.join(\", \")));\n        }\n        var /** @type {?} */ expansionResult = expandNodes(c.expression);\n        errors.push.apply(errors, expansionResult.errors);\n        return new Element(\"ng-template\", [new Attribute$1('ngPluralCase', \"\" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n    });\n    var /** @type {?} */ switchAttr = new Attribute$1('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);\n    return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n}\n/**\n * @param {?} ast\n * @param {?} errors\n * @return {?}\n */\nfunction _expandDefaultForm(ast, errors) {\n    var /** @type {?} */ children = ast.cases.map(function (c) {\n        var /** @type {?} */ expansionResult = expandNodes(c.expression);\n        errors.push.apply(errors, expansionResult.errors);\n        if (c.value === 'other') {\n            // other is the default case when no values match\n            return new Element(\"ng-template\", [new Attribute$1('ngSwitchDefault', '', c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n        }\n        return new Element(\"ng-template\", [new Attribute$1('ngSwitchCase', \"\" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n    });\n    var /** @type {?} */ switchAttr = new Attribute$1('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);\n    return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ProviderError = (function (_super) {\n    __extends(ProviderError, _super);\n    /**\n     * @param {?} message\n     * @param {?} span\n     */\n    function ProviderError(message, span) {\n        return _super.call(this, span, message) || this;\n    }\n    return ProviderError;\n}(ParseError));\nvar ProviderViewContext = (function () {\n    /**\n     * @param {?} component\n     */\n    function ProviderViewContext(component) {\n        var _this = this;\n        this.component = component;\n        this.errors = [];\n        this.viewQueries = _getViewQueries(component);\n        this.viewProviders = new Map();\n        component.viewProviders.forEach(function (provider) {\n            if (_this.viewProviders.get(tokenReference(provider.token)) == null) {\n                _this.viewProviders.set(tokenReference(provider.token), true);\n            }\n        });\n    }\n    return ProviderViewContext;\n}());\nvar ProviderElementContext = (function () {\n    /**\n     * @param {?} viewContext\n     * @param {?} _parent\n     * @param {?} _isViewRoot\n     * @param {?} _directiveAsts\n     * @param {?} attrs\n     * @param {?} refs\n     * @param {?} isTemplate\n     * @param {?} contentQueryStartId\n     * @param {?} _sourceSpan\n     */\n    function ProviderElementContext(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, isTemplate, contentQueryStartId, _sourceSpan) {\n        var _this = this;\n        this.viewContext = viewContext;\n        this._parent = _parent;\n        this._isViewRoot = _isViewRoot;\n        this._directiveAsts = _directiveAsts;\n        this._sourceSpan = _sourceSpan;\n        this._transformedProviders = new Map();\n        this._seenProviders = new Map();\n        this._hasViewContainer = false;\n        this._queriedTokens = new Map();\n        this._attrs = {};\n        attrs.forEach(function (attrAst) { return _this._attrs[attrAst.name] = attrAst.value; });\n        var directivesMeta = _directiveAsts.map(function (directiveAst) { return directiveAst.directive; });\n        this._allProviders =\n            _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);\n        this._contentQueries = _getContentQueries(contentQueryStartId, directivesMeta);\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            _this._addQueryReadsTo(provider.token, provider.token, _this._queriedTokens);\n        });\n        if (isTemplate) {\n            var templateRefId = createIdentifierToken(Identifiers.TemplateRef);\n            this._addQueryReadsTo(templateRefId, templateRefId, this._queriedTokens);\n        }\n        refs.forEach(function (refAst) {\n            var defaultQueryValue = refAst.value || createIdentifierToken(Identifiers.ElementRef);\n            _this._addQueryReadsTo({ value: refAst.name }, defaultQueryValue, _this._queriedTokens);\n        });\n        if (this._queriedTokens.get(resolveIdentifier(Identifiers.ViewContainerRef))) {\n            this._hasViewContainer = true;\n        }\n        // create the providers that we know are eager first\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            var eager = provider.eager || _this._queriedTokens.get(tokenReference(provider.token));\n            if (eager) {\n                _this._getOrCreateLocalProvider(provider.providerType, provider.token, true);\n            }\n        });\n    }\n    /**\n     * @return {?}\n     */\n    ProviderElementContext.prototype.afterElement = function () {\n        var _this = this;\n        // collect lazy providers\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            _this._getOrCreateLocalProvider(provider.providerType, provider.token, false);\n        });\n    };\n    Object.defineProperty(ProviderElementContext.prototype, \"transformProviders\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return Array.from(this._transformedProviders.values());\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ProviderElementContext.prototype, \"transformedDirectiveAsts\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            var /** @type {?} */ sortedProviderTypes = this.transformProviders.map(function (provider) { return provider.token.identifier; });\n            var /** @type {?} */ sortedDirectives = this._directiveAsts.slice();\n            sortedDirectives.sort(function (dir1, dir2) { return sortedProviderTypes.indexOf(dir1.directive.type) -\n                sortedProviderTypes.indexOf(dir2.directive.type); });\n            return sortedDirectives;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ProviderElementContext.prototype, \"transformedHasViewContainer\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this._hasViewContainer; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ProviderElementContext.prototype, \"queryMatches\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            var /** @type {?} */ allMatches = [];\n            this._queriedTokens.forEach(function (matches) { allMatches.push.apply(allMatches, matches); });\n            return allMatches;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} token\n     * @param {?} defaultValue\n     * @param {?} queryReadTokens\n     * @return {?}\n     */\n    ProviderElementContext.prototype._addQueryReadsTo = function (token, defaultValue, queryReadTokens) {\n        this._getQueriesFor(token).forEach(function (query) {\n            var /** @type {?} */ queryValue = query.meta.read || defaultValue;\n            var /** @type {?} */ tokenRef = tokenReference(queryValue);\n            var /** @type {?} */ queryMatches = queryReadTokens.get(tokenRef);\n            if (!queryMatches) {\n                queryMatches = [];\n                queryReadTokens.set(tokenRef, queryMatches);\n            }\n            queryMatches.push({ queryId: query.queryId, value: queryValue });\n        });\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    ProviderElementContext.prototype._getQueriesFor = function (token) {\n        var /** @type {?} */ result = [];\n        var /** @type {?} */ currentEl = this;\n        var /** @type {?} */ distance = 0;\n        var /** @type {?} */ queries;\n        while (currentEl !== null) {\n            queries = currentEl._contentQueries.get(tokenReference(token));\n            if (queries) {\n                result.push.apply(result, queries.filter(function (query) { return query.meta.descendants || distance <= 1; }));\n            }\n            if (currentEl._directiveAsts.length > 0) {\n                distance++;\n            }\n            currentEl = currentEl._parent;\n        }\n        queries = this.viewContext.viewQueries.get(tokenReference(token));\n        if (queries) {\n            result.push.apply(result, queries);\n        }\n        return result;\n    };\n    /**\n     * @param {?} requestingProviderType\n     * @param {?} token\n     * @param {?} eager\n     * @return {?}\n     */\n    ProviderElementContext.prototype._getOrCreateLocalProvider = function (requestingProviderType, token, eager) {\n        var _this = this;\n        var /** @type {?} */ resolvedProvider = this._allProviders.get(tokenReference(token));\n        if (!resolvedProvider || ((requestingProviderType === ProviderAstType.Directive ||\n            requestingProviderType === ProviderAstType.PublicService) &&\n            resolvedProvider.providerType === ProviderAstType.PrivateService) ||\n            ((requestingProviderType === ProviderAstType.PrivateService ||\n                requestingProviderType === ProviderAstType.PublicService) &&\n                resolvedProvider.providerType === ProviderAstType.Builtin)) {\n            return null;\n        }\n        var /** @type {?} */ transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n        if (transformedProviderAst) {\n            return transformedProviderAst;\n        }\n        if (this._seenProviders.get(tokenReference(token)) != null) {\n            this.viewContext.errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \" + tokenName(token), this._sourceSpan));\n            return null;\n        }\n        this._seenProviders.set(tokenReference(token), true);\n        var /** @type {?} */ transformedProviders = resolvedProvider.providers.map(function (provider) {\n            var /** @type {?} */ transformedUseValue = provider.useValue;\n            var /** @type {?} */ transformedUseExisting = ((provider.useExisting));\n            var /** @type {?} */ transformedDeps = ((undefined));\n            if (provider.useExisting != null) {\n                var /** @type {?} */ existingDiDep = ((_this._getDependency(resolvedProvider.providerType, { token: provider.useExisting }, eager)));\n                if (existingDiDep.token != null) {\n                    transformedUseExisting = existingDiDep.token;\n                }\n                else {\n                    transformedUseExisting = ((null));\n                    transformedUseValue = existingDiDep.value;\n                }\n            }\n            else if (provider.useFactory) {\n                var /** @type {?} */ deps = provider.deps || provider.useFactory.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return ((_this._getDependency(resolvedProvider.providerType, dep, eager))); });\n            }\n            else if (provider.useClass) {\n                var /** @type {?} */ deps = provider.deps || provider.useClass.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return ((_this._getDependency(resolvedProvider.providerType, dep, eager))); });\n            }\n            return _transformProvider(provider, {\n                useExisting: transformedUseExisting,\n                useValue: transformedUseValue,\n                deps: transformedDeps\n            });\n        });\n        transformedProviderAst =\n            _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });\n        this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n        return transformedProviderAst;\n    };\n    /**\n     * @param {?} requestingProviderType\n     * @param {?} dep\n     * @param {?=} eager\n     * @return {?}\n     */\n    ProviderElementContext.prototype._getLocalDependency = function (requestingProviderType, dep, eager) {\n        if (eager === void 0) { eager = false; }\n        if (dep.isAttribute) {\n            var /** @type {?} */ attrValue = this._attrs[((dep.token)).value];\n            return { isValue: true, value: attrValue == null ? null : attrValue };\n        }\n        if (dep.token != null) {\n            // access builtints\n            if ((requestingProviderType === ProviderAstType.Directive ||\n                requestingProviderType === ProviderAstType.Component)) {\n                if (tokenReference(dep.token) === resolveIdentifier(Identifiers.Renderer) ||\n                    tokenReference(dep.token) === resolveIdentifier(Identifiers.ElementRef) ||\n                    tokenReference(dep.token) === resolveIdentifier(Identifiers.ChangeDetectorRef) ||\n                    tokenReference(dep.token) === resolveIdentifier(Identifiers.TemplateRef)) {\n                    return dep;\n                }\n                if (tokenReference(dep.token) === resolveIdentifier(Identifiers.ViewContainerRef)) {\n                    this._hasViewContainer = true;\n                }\n            }\n            // access the injector\n            if (tokenReference(dep.token) === resolveIdentifier(Identifiers.Injector)) {\n                return dep;\n            }\n            // access providers\n            if (this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager) != null) {\n                return dep;\n            }\n        }\n        return null;\n    };\n    /**\n     * @param {?} requestingProviderType\n     * @param {?} dep\n     * @param {?=} eager\n     * @return {?}\n     */\n    ProviderElementContext.prototype._getDependency = function (requestingProviderType, dep, eager) {\n        if (eager === void 0) { eager = false; }\n        var /** @type {?} */ currElement = this;\n        var /** @type {?} */ currEager = eager;\n        var /** @type {?} */ result = null;\n        if (!dep.isSkipSelf) {\n            result = this._getLocalDependency(requestingProviderType, dep, eager);\n        }\n        if (dep.isSelf) {\n            if (!result && dep.isOptional) {\n                result = { isValue: true, value: null };\n            }\n        }\n        else {\n            // check parent elements\n            while (!result && currElement._parent) {\n                var /** @type {?} */ prevElement = currElement;\n                currElement = currElement._parent;\n                if (prevElement._isViewRoot) {\n                    currEager = false;\n                }\n                result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);\n            }\n            // check @Host restriction\n            if (!result) {\n                if (!dep.isHost || this.viewContext.component.isHost ||\n                    this.viewContext.component.type.reference === tokenReference(/** @type {?} */ ((dep.token))) ||\n                    this.viewContext.viewProviders.get(tokenReference(/** @type {?} */ ((dep.token)))) != null) {\n                    result = dep;\n                }\n                else {\n                    result = dep.isOptional ? result = { isValue: true, value: null } : null;\n                }\n            }\n        }\n        if (!result) {\n            this.viewContext.errors.push(new ProviderError(\"No provider for \" + tokenName(/** @type {?} */ ((dep.token))), this._sourceSpan));\n        }\n        return result;\n    };\n    return ProviderElementContext;\n}());\nvar NgModuleProviderAnalyzer = (function () {\n    /**\n     * @param {?} ngModule\n     * @param {?} extraProviders\n     * @param {?} sourceSpan\n     */\n    function NgModuleProviderAnalyzer(ngModule, extraProviders, sourceSpan) {\n        var _this = this;\n        this._transformedProviders = new Map();\n        this._seenProviders = new Map();\n        this._errors = [];\n        this._allProviders = new Map();\n        ngModule.transitiveModule.modules.forEach(function (ngModuleType) {\n            var ngModuleProvider = { token: { identifier: ngModuleType }, useClass: ngModuleType };\n            _resolveProviders([ngModuleProvider], ProviderAstType.PublicService, true, sourceSpan, _this._errors, _this._allProviders);\n        });\n        _resolveProviders(ngModule.transitiveModule.providers.map(function (entry) { return entry.provider; }).concat(extraProviders), ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders);\n    }\n    /**\n     * @return {?}\n     */\n    NgModuleProviderAnalyzer.prototype.parse = function () {\n        var _this = this;\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            _this._getOrCreateLocalProvider(provider.token, provider.eager);\n        });\n        if (this._errors.length > 0) {\n            var /** @type {?} */ errorString = this._errors.join('\\n');\n            throw new Error(\"Provider parse errors:\\n\" + errorString);\n        }\n        return Array.from(this._transformedProviders.values());\n    };\n    /**\n     * @param {?} token\n     * @param {?} eager\n     * @return {?}\n     */\n    NgModuleProviderAnalyzer.prototype._getOrCreateLocalProvider = function (token, eager) {\n        var _this = this;\n        var /** @type {?} */ resolvedProvider = this._allProviders.get(tokenReference(token));\n        if (!resolvedProvider) {\n            return null;\n        }\n        var /** @type {?} */ transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n        if (transformedProviderAst) {\n            return transformedProviderAst;\n        }\n        if (this._seenProviders.get(tokenReference(token)) != null) {\n            this._errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \" + tokenName(token), resolvedProvider.sourceSpan));\n            return null;\n        }\n        this._seenProviders.set(tokenReference(token), true);\n        var /** @type {?} */ transformedProviders = resolvedProvider.providers.map(function (provider) {\n            var /** @type {?} */ transformedUseValue = provider.useValue;\n            var /** @type {?} */ transformedUseExisting = ((provider.useExisting));\n            var /** @type {?} */ transformedDeps = ((undefined));\n            if (provider.useExisting != null) {\n                var /** @type {?} */ existingDiDep = _this._getDependency({ token: provider.useExisting }, eager, resolvedProvider.sourceSpan);\n                if (existingDiDep.token != null) {\n                    transformedUseExisting = existingDiDep.token;\n                }\n                else {\n                    transformedUseExisting = ((null));\n                    transformedUseValue = existingDiDep.value;\n                }\n            }\n            else if (provider.useFactory) {\n                var /** @type {?} */ deps = provider.deps || provider.useFactory.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });\n            }\n            else if (provider.useClass) {\n                var /** @type {?} */ deps = provider.deps || provider.useClass.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });\n            }\n            return _transformProvider(provider, {\n                useExisting: transformedUseExisting,\n                useValue: transformedUseValue,\n                deps: transformedDeps\n            });\n        });\n        transformedProviderAst =\n            _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });\n        this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n        return transformedProviderAst;\n    };\n    /**\n     * @param {?} dep\n     * @param {?=} eager\n     * @param {?=} requestorSourceSpan\n     * @return {?}\n     */\n    NgModuleProviderAnalyzer.prototype._getDependency = function (dep, eager, requestorSourceSpan) {\n        if (eager === void 0) { eager = false; }\n        var /** @type {?} */ foundLocal = false;\n        if (!dep.isSkipSelf && dep.token != null) {\n            // access the injector\n            if (tokenReference(dep.token) === resolveIdentifier(Identifiers.Injector) ||\n                tokenReference(dep.token) === resolveIdentifier(Identifiers.ComponentFactoryResolver)) {\n                foundLocal = true;\n            }\n            else if (this._getOrCreateLocalProvider(dep.token, eager) != null) {\n                foundLocal = true;\n            }\n        }\n        var /** @type {?} */ result = dep;\n        if (dep.isSelf && !foundLocal) {\n            if (dep.isOptional) {\n                result = { isValue: true, value: null };\n            }\n            else {\n                this._errors.push(new ProviderError(\"No provider for \" + tokenName(/** @type {?} */ ((dep.token))), requestorSourceSpan));\n            }\n        }\n        return result;\n    };\n    return NgModuleProviderAnalyzer;\n}());\n/**\n * @param {?} provider\n * @param {?} __1\n * @return {?}\n */\nfunction _transformProvider(provider, _a) {\n    var useExisting = _a.useExisting, useValue = _a.useValue, deps = _a.deps;\n    return {\n        token: provider.token,\n        useClass: provider.useClass,\n        useExisting: useExisting,\n        useFactory: provider.useFactory,\n        useValue: useValue,\n        deps: deps,\n        multi: provider.multi\n    };\n}\n/**\n * @param {?} provider\n * @param {?} __1\n * @return {?}\n */\nfunction _transformProviderAst(provider, _a) {\n    var eager = _a.eager, providers = _a.providers;\n    return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan);\n}\n/**\n * @param {?} directives\n * @param {?} sourceSpan\n * @param {?} targetErrors\n * @return {?}\n */\nfunction _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {\n    var /** @type {?} */ providersByToken = new Map();\n    directives.forEach(function (directive) {\n        var /** @type {?} */ dirProvider = { token: { identifier: directive.type }, useClass: directive.type };\n        _resolveProviders([dirProvider], directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken);\n    });\n    // Note: directives need to be able to overwrite providers of a component!\n    var /** @type {?} */ directivesWithComponentFirst = directives.filter(function (dir) { return dir.isComponent; }).concat(directives.filter(function (dir) { return !dir.isComponent; }));\n    directivesWithComponentFirst.forEach(function (directive) {\n        _resolveProviders(directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken);\n        _resolveProviders(directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken);\n    });\n    return providersByToken;\n}\n/**\n * @param {?} providers\n * @param {?} providerType\n * @param {?} eager\n * @param {?} sourceSpan\n * @param {?} targetErrors\n * @param {?} targetProvidersByToken\n * @return {?}\n */\nfunction _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken) {\n    providers.forEach(function (provider) {\n        var /** @type {?} */ resolvedProvider = targetProvidersByToken.get(tokenReference(provider.token));\n        if (resolvedProvider != null && !!resolvedProvider.multiProvider !== !!provider.multi) {\n            targetErrors.push(new ProviderError(\"Mixing multi and non multi provider is not possible for token \" + tokenName(resolvedProvider.token), sourceSpan));\n        }\n        if (!resolvedProvider) {\n            var /** @type {?} */ lifecycleHooks = provider.token.identifier &&\n                ((provider.token.identifier)).lifecycleHooks ?\n                ((provider.token.identifier)).lifecycleHooks :\n                [];\n            var /** @type {?} */ isUseValue = !(provider.useClass || provider.useExisting || provider.useFactory);\n            resolvedProvider = new ProviderAst(provider.token, !!provider.multi, eager || isUseValue, [provider], providerType, lifecycleHooks, sourceSpan);\n            targetProvidersByToken.set(tokenReference(provider.token), resolvedProvider);\n        }\n        else {\n            if (!provider.multi) {\n                resolvedProvider.providers.length = 0;\n            }\n            resolvedProvider.providers.push(provider);\n        }\n    });\n}\n/**\n * @param {?} component\n * @return {?}\n */\nfunction _getViewQueries(component) {\n    // Note: queries start with id 1 so we can use the number in a Bloom filter!\n    var /** @type {?} */ viewQueryId = 1;\n    var /** @type {?} */ viewQueries = new Map();\n    if (component.viewQueries) {\n        component.viewQueries.forEach(function (query) { return _addQueryToTokenMap(viewQueries, { meta: query, queryId: viewQueryId++ }); });\n    }\n    return viewQueries;\n}\n/**\n * @param {?} contentQueryStartId\n * @param {?} directives\n * @return {?}\n */\nfunction _getContentQueries(contentQueryStartId, directives) {\n    var /** @type {?} */ contentQueryId = contentQueryStartId;\n    var /** @type {?} */ contentQueries = new Map();\n    directives.forEach(function (directive, directiveIndex) {\n        if (directive.queries) {\n            directive.queries.forEach(function (query) { return _addQueryToTokenMap(contentQueries, { meta: query, queryId: contentQueryId++ }); });\n        }\n    });\n    return contentQueries;\n}\n/**\n * @param {?} map\n * @param {?} query\n * @return {?}\n */\nfunction _addQueryToTokenMap(map, query) {\n    query.meta.selectors.forEach(function (token) {\n        var /** @type {?} */ entry = map.get(tokenReference(token));\n        if (!entry) {\n            entry = [];\n            map.set(tokenReference(token), entry);\n        }\n        entry.push(query);\n    });\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @abstract\n */\nvar ElementSchemaRegistry = (function () {\n    function ElementSchemaRegistry() {\n    }\n    /**\n     * @abstract\n     * @param {?} tagName\n     * @param {?} propName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.hasProperty = function (tagName, propName, schemaMetas) { };\n    /**\n     * @abstract\n     * @param {?} tagName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.hasElement = function (tagName, schemaMetas) { };\n    /**\n     * @abstract\n     * @param {?} elementName\n     * @param {?} propName\n     * @param {?} isAttribute\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.securityContext = function (elementName, propName, isAttribute) { };\n    /**\n     * @abstract\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.allKnownElementNames = function () { };\n    /**\n     * @abstract\n     * @param {?} propName\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.getMappedPropName = function (propName) { };\n    /**\n     * @abstract\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.getDefaultComponentElementName = function () { };\n    /**\n     * @abstract\n     * @param {?} name\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.validateProperty = function (name) { };\n    /**\n     * @abstract\n     * @param {?} name\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.validateAttribute = function (name) { };\n    /**\n     * @abstract\n     * @param {?} propName\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.normalizeAnimationStyleProperty = function (propName) { };\n    /**\n     * @abstract\n     * @param {?} camelCaseProp\n     * @param {?} userProvidedProp\n     * @param {?} val\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.normalizeAnimationStyleValue = function (camelCaseProp, userProvidedProp, val) { };\n    return ElementSchemaRegistry;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar StyleWithImports = (function () {\n    /**\n     * @param {?} style\n     * @param {?} styleUrls\n     */\n    function StyleWithImports(style$$1, styleUrls) {\n        this.style = style$$1;\n        this.styleUrls = styleUrls;\n    }\n    return StyleWithImports;\n}());\n/**\n * @param {?} url\n * @return {?}\n */\nfunction isStyleUrlResolvable(url) {\n    if (url == null || url.length === 0 || url[0] == '/')\n        return false;\n    var /** @type {?} */ schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n    return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\n/**\n * Rewrites stylesheets by resolving and removing the \\@import urls that\n * are either relative or don't have a `package:` scheme\n * @param {?} resolver\n * @param {?} baseUrl\n * @param {?} cssText\n * @return {?}\n */\nfunction extractStyleUrls(resolver, baseUrl, cssText) {\n    var /** @type {?} */ foundUrls = [];\n    var /** @type {?} */ modifiedCssText = cssText.replace(CSS_COMMENT_REGEXP, '').replace(CSS_IMPORT_REGEXP, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        var /** @type {?} */ url = m[1] || m[2];\n        if (!isStyleUrlResolvable(url)) {\n            // Do not attempt to resolve non-package absolute URLs with URI scheme\n            return m[0];\n        }\n        foundUrls.push(resolver.resolve(baseUrl, url));\n        return '';\n    });\n    return new StyleWithImports(modifiedCssText, foundUrls);\n}\nvar CSS_IMPORT_REGEXP = /@import\\s+(?:url\\()?\\s*(?:(?:['\"]([^'\"]*))|([^;\\)\\s]*))[^;]*;?/g;\nvar CSS_COMMENT_REGEXP = /\\/\\*.+?\\*\\//g;\nvar URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar PROPERTY_PARTS_SEPARATOR = '.';\nvar ATTRIBUTE_PREFIX = 'attr';\nvar CLASS_PREFIX = 'class';\nvar STYLE_PREFIX = 'style';\nvar ANIMATE_PROP_PREFIX = 'animate-';\nvar BoundPropertyType = {};\nBoundPropertyType.DEFAULT = 0;\nBoundPropertyType.LITERAL_ATTR = 1;\nBoundPropertyType.ANIMATION = 2;\nBoundPropertyType[BoundPropertyType.DEFAULT] = \"DEFAULT\";\nBoundPropertyType[BoundPropertyType.LITERAL_ATTR] = \"LITERAL_ATTR\";\nBoundPropertyType[BoundPropertyType.ANIMATION] = \"ANIMATION\";\n/**\n * Represents a parsed property.\n */\nvar BoundProperty = (function () {\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} type\n     * @param {?} sourceSpan\n     */\n    function BoundProperty(name, expression, type, sourceSpan) {\n        this.name = name;\n        this.expression = expression;\n        this.type = type;\n        this.sourceSpan = sourceSpan;\n    }\n    Object.defineProperty(BoundProperty.prototype, \"isLiteral\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.type === BoundPropertyType.LITERAL_ATTR; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BoundProperty.prototype, \"isAnimation\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.type === BoundPropertyType.ANIMATION; },\n        enumerable: true,\n        configurable: true\n    });\n    return BoundProperty;\n}());\n/**\n * Parses bindings in templates and in the directive host area.\n */\nvar BindingParser = (function () {\n    /**\n     * @param {?} _exprParser\n     * @param {?} _interpolationConfig\n     * @param {?} _schemaRegistry\n     * @param {?} pipes\n     * @param {?} _targetErrors\n     */\n    function BindingParser(_exprParser, _interpolationConfig, _schemaRegistry, pipes, _targetErrors) {\n        var _this = this;\n        this._exprParser = _exprParser;\n        this._interpolationConfig = _interpolationConfig;\n        this._schemaRegistry = _schemaRegistry;\n        this._targetErrors = _targetErrors;\n        this.pipesByName = new Map();\n        this._usedPipes = new Map();\n        pipes.forEach(function (pipe) { return _this.pipesByName.set(pipe.name, pipe); });\n    }\n    /**\n     * @return {?}\n     */\n    BindingParser.prototype.getUsedPipes = function () { return Array.from(this._usedPipes.values()); };\n    /**\n     * @param {?} dirMeta\n     * @param {?} elementSelector\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype.createDirectiveHostPropertyAsts = function (dirMeta, elementSelector, sourceSpan) {\n        var _this = this;\n        if (dirMeta.hostProperties) {\n            var /** @type {?} */ boundProps_1 = [];\n            Object.keys(dirMeta.hostProperties).forEach(function (propName) {\n                var /** @type {?} */ expression = dirMeta.hostProperties[propName];\n                if (typeof expression === 'string') {\n                    _this.parsePropertyBinding(propName, expression, true, sourceSpan, [], boundProps_1);\n                }\n                else {\n                    _this._reportError(\"Value of the host property binding \\\"\" + propName + \"\\\" needs to be a string representing an expression but got \\\"\" + expression + \"\\\" (\" + typeof expression + \")\", sourceSpan);\n                }\n            });\n            return boundProps_1.map(function (prop) { return _this.createElementPropertyAst(elementSelector, prop); });\n        }\n        return null;\n    };\n    /**\n     * @param {?} dirMeta\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype.createDirectiveHostEventAsts = function (dirMeta, sourceSpan) {\n        var _this = this;\n        if (dirMeta.hostListeners) {\n            var /** @type {?} */ targetEventAsts_1 = [];\n            Object.keys(dirMeta.hostListeners).forEach(function (propName) {\n                var /** @type {?} */ expression = dirMeta.hostListeners[propName];\n                if (typeof expression === 'string') {\n                    _this.parseEvent(propName, expression, sourceSpan, [], targetEventAsts_1);\n                }\n                else {\n                    _this._reportError(\"Value of the host listener \\\"\" + propName + \"\\\" needs to be a string representing an expression but got \\\"\" + expression + \"\\\" (\" + typeof expression + \")\", sourceSpan);\n                }\n            });\n            return targetEventAsts_1;\n        }\n        return null;\n    };\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype.parseInterpolation = function (value, sourceSpan) {\n        var /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            var /** @type {?} */ ast = ((this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig)));\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n        }\n    };\n    /**\n     * @param {?} prefixToken\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @param {?} targetVars\n     * @return {?}\n     */\n    BindingParser.prototype.parseInlineTemplateBinding = function (prefixToken, value, sourceSpan, targetMatchableAttrs, targetProps, targetVars) {\n        var /** @type {?} */ bindings = this._parseTemplateBindings(prefixToken, value, sourceSpan);\n        for (var /** @type {?} */ i = 0; i < bindings.length; i++) {\n            var /** @type {?} */ binding = bindings[i];\n            if (binding.keyIsVar) {\n                targetVars.push(new VariableAst(binding.key, binding.name, sourceSpan));\n            }\n            else if (binding.expression) {\n                this._parsePropertyAst(binding.key, binding.expression, sourceSpan, targetMatchableAttrs, targetProps);\n            }\n            else {\n                targetMatchableAttrs.push([binding.key, '']);\n                this.parseLiteralAttr(binding.key, null, sourceSpan, targetMatchableAttrs, targetProps);\n            }\n        }\n    };\n    /**\n     * @param {?} prefixToken\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._parseTemplateBindings = function (prefixToken, value, sourceSpan) {\n        var _this = this;\n        var /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            var /** @type {?} */ bindingsResult = this._exprParser.parseTemplateBindings(prefixToken, value, sourceInfo);\n            this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n            bindingsResult.templateBindings.forEach(function (binding) {\n                if (binding.expression) {\n                    _this._checkPipes(binding.expression, sourceSpan);\n                }\n            });\n            bindingsResult.warnings.forEach(function (warning) { _this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING); });\n            return bindingsResult.templateBindings;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return [];\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype.parseLiteralAttr = function (name, value, sourceSpan, targetMatchableAttrs, targetProps) {\n        if (_isAnimationLabel(name)) {\n            name = name.substring(1);\n            if (value) {\n                this._reportError(\"Assigning animation triggers via @prop=\\\"exp\\\" attributes with an expression is invalid.\" +\n                    \" Use property bindings (e.g. [@prop]=\\\"exp\\\") or use an attribute without a value (e.g. @prop) instead.\", sourceSpan, ParseErrorLevel.ERROR);\n            }\n            this._parseAnimation(name, value, sourceSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            targetProps.push(new BoundProperty(name, this._exprParser.wrapLiteralPrimitive(value, ''), BoundPropertyType.LITERAL_ATTR, sourceSpan));\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} isHost\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype.parsePropertyBinding = function (name, expression, isHost, sourceSpan, targetMatchableAttrs, targetProps) {\n        var /** @type {?} */ isAnimationProp = false;\n        if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n            isAnimationProp = true;\n            name = name.substring(ANIMATE_PROP_PREFIX.length);\n        }\n        else if (_isAnimationLabel(name)) {\n            isAnimationProp = true;\n            name = name.substring(1);\n        }\n        if (isAnimationProp) {\n            this._parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            this._parsePropertyAst(name, this._parseBinding(expression, isHost, sourceSpan), sourceSpan, targetMatchableAttrs, targetProps);\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype.parsePropertyInterpolation = function (name, value, sourceSpan, targetMatchableAttrs, targetProps) {\n        var /** @type {?} */ expr = this.parseInterpolation(value, sourceSpan);\n        if (expr) {\n            this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} name\n     * @param {?} ast\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype._parsePropertyAst = function (name, ast, sourceSpan, targetMatchableAttrs, targetProps) {\n        targetMatchableAttrs.push([name, /** @type {?} */ ((ast.source))]);\n        targetProps.push(new BoundProperty(name, ast, BoundPropertyType.DEFAULT, sourceSpan));\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype._parseAnimation = function (name, expression, sourceSpan, targetMatchableAttrs, targetProps) {\n        // This will occur when a @trigger is not paired with an expression.\n        // For animations it is valid to not have an expression since */void\n        // states will be applied by angular when the element is attached/detached\n        var /** @type {?} */ ast = this._parseBinding(expression || 'null', false, sourceSpan);\n        targetMatchableAttrs.push([name, /** @type {?} */ ((ast.source))]);\n        targetProps.push(new BoundProperty(name, ast, BoundPropertyType.ANIMATION, sourceSpan));\n    };\n    /**\n     * @param {?} value\n     * @param {?} isHostBinding\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._parseBinding = function (value, isHostBinding, sourceSpan) {\n        var /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            var /** @type {?} */ ast = isHostBinding ?\n                this._exprParser.parseSimpleBinding(value, sourceInfo, this._interpolationConfig) :\n                this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n        }\n    };\n    /**\n     * @param {?} elementSelector\n     * @param {?} boundProp\n     * @return {?}\n     */\n    BindingParser.prototype.createElementPropertyAst = function (elementSelector, boundProp) {\n        if (boundProp.isAnimation) {\n            return new BoundElementPropertyAst(boundProp.name, PropertyBindingType.Animation, __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"SecurityContext\"].NONE, boundProp.expression, null, boundProp.sourceSpan);\n        }\n        var /** @type {?} */ unit = null;\n        var /** @type {?} */ bindingType = ((undefined));\n        var /** @type {?} */ boundPropertyName = null;\n        var /** @type {?} */ parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n        var /** @type {?} */ securityContexts = ((undefined));\n        // Check check for special cases (prefix style, attr, class)\n        if (parts.length > 1) {\n            if (parts[0] == ATTRIBUTE_PREFIX) {\n                boundPropertyName = parts[1];\n                this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n                securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);\n                var /** @type {?} */ nsSeparatorIdx = boundPropertyName.indexOf(':');\n                if (nsSeparatorIdx > -1) {\n                    var /** @type {?} */ ns = boundPropertyName.substring(0, nsSeparatorIdx);\n                    var /** @type {?} */ name = boundPropertyName.substring(nsSeparatorIdx + 1);\n                    boundPropertyName = mergeNsAndName(ns, name);\n                }\n                bindingType = PropertyBindingType.Attribute;\n            }\n            else if (parts[0] == CLASS_PREFIX) {\n                boundPropertyName = parts[1];\n                bindingType = PropertyBindingType.Class;\n                securityContexts = [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"SecurityContext\"].NONE];\n            }\n            else if (parts[0] == STYLE_PREFIX) {\n                unit = parts.length > 2 ? parts[2] : null;\n                boundPropertyName = parts[1];\n                bindingType = PropertyBindingType.Style;\n                securityContexts = [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"SecurityContext\"].STYLE];\n            }\n        }\n        // If not a special case, use the full property name\n        if (boundPropertyName === null) {\n            boundPropertyName = this._schemaRegistry.getMappedPropName(boundProp.name);\n            securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, false);\n            bindingType = PropertyBindingType.Property;\n            this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, false);\n        }\n        return new BoundElementPropertyAst(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan);\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    BindingParser.prototype.parseEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\n        if (_isAnimationLabel(name)) {\n            name = name.substr(1);\n            this._parseAnimationEvent(name, expression, sourceSpan, targetEvents);\n        }\n        else {\n            this._parseEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents);\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    BindingParser.prototype._parseAnimationEvent = function (name, expression, sourceSpan, targetEvents) {\n        var /** @type {?} */ matches = splitAtPeriod(name, [name, '']);\n        var /** @type {?} */ eventName = matches[0];\n        var /** @type {?} */ phase = matches[1].toLowerCase();\n        if (phase) {\n            switch (phase) {\n                case 'start':\n                case 'done':\n                    var /** @type {?} */ ast = this._parseAction(expression, sourceSpan);\n                    targetEvents.push(new BoundEventAst(eventName, null, phase, ast, sourceSpan));\n                    break;\n                default:\n                    this._reportError(\"The provided animation output phase value \\\"\" + phase + \"\\\" for \\\"@\" + eventName + \"\\\" is not supported (use start or done)\", sourceSpan);\n                    break;\n            }\n        }\n        else {\n            this._reportError(\"The animation trigger output event (@\" + eventName + \") is missing its phase value name (start or done are currently supported)\", sourceSpan);\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    BindingParser.prototype._parseEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\n        // long format: 'target: eventName'\n        var _a = splitAtColon(name, [/** @type {?} */ ((null)), name]), target = _a[0], eventName = _a[1];\n        var /** @type {?} */ ast = this._parseAction(expression, sourceSpan);\n        targetMatchableAttrs.push([/** @type {?} */ ((name)), /** @type {?} */ ((ast.source))]);\n        targetEvents.push(new BoundEventAst(eventName, target, null, ast, sourceSpan));\n        // Don't detect directives for event names for now,\n        // so don't add the event name to the matchableAttrs\n    };\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._parseAction = function (value, sourceSpan) {\n        var /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            var /** @type {?} */ ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);\n            if (ast) {\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            }\n            if (!ast || ast.ast instanceof EmptyExpr) {\n                this._reportError(\"Empty expressions are not allowed\", sourceSpan);\n                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n            }\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n        }\n    };\n    /**\n     * @param {?} message\n     * @param {?} sourceSpan\n     * @param {?=} level\n     * @return {?}\n     */\n    BindingParser.prototype._reportError = function (message, sourceSpan, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this._targetErrors.push(new ParseError(sourceSpan, message, level));\n    };\n    /**\n     * @param {?} errors\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._reportExpressionParserErrors = function (errors, sourceSpan) {\n        for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {\n            var error = errors_1[_i];\n            this._reportError(error.message, sourceSpan);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._checkPipes = function (ast, sourceSpan) {\n        var _this = this;\n        if (ast) {\n            var /** @type {?} */ collector = new PipeCollector();\n            ast.visit(collector);\n            collector.pipes.forEach(function (ast, pipeName) {\n                var /** @type {?} */ pipeMeta = _this.pipesByName.get(pipeName);\n                if (!pipeMeta) {\n                    _this._reportError(\"The pipe '\" + pipeName + \"' could not be found\", new ParseSourceSpan(sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n                }\n                else {\n                    _this._usedPipes.set(pipeName, pipeMeta);\n                }\n            });\n        }\n    };\n    /**\n     * @param {?} propName the name of the property / attribute\n     * @param {?} sourceSpan\n     * @param {?} isAttr true when binding to an attribute\n     * @return {?}\n     */\n    BindingParser.prototype._validatePropertyOrAttributeName = function (propName, sourceSpan, isAttr) {\n        var /** @type {?} */ report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n            this._schemaRegistry.validateProperty(propName);\n        if (report.error) {\n            this._reportError(/** @type {?} */ ((report.msg)), sourceSpan, ParseErrorLevel.ERROR);\n        }\n    };\n    return BindingParser;\n}());\nvar PipeCollector = (function (_super) {\n    __extends(PipeCollector, _super);\n    function PipeCollector() {\n        var _this = _super.apply(this, arguments) || this;\n        _this.pipes = new Map();\n        return _this;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    PipeCollector.prototype.visitPipe = function (ast, context) {\n        this.pipes.set(ast.name, ast);\n        ast.exp.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    };\n    return PipeCollector;\n}(RecursiveAstVisitor));\n/**\n * @param {?} name\n * @return {?}\n */\nfunction _isAnimationLabel(name) {\n    return name[0] == '@';\n}\n/**\n * @param {?} registry\n * @param {?} selector\n * @param {?} propName\n * @param {?} isAttribute\n * @return {?}\n */\nfunction calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {\n    var /** @type {?} */ ctxs = [];\n    CssSelector.parse(selector).forEach(function (selector) {\n        var /** @type {?} */ elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n        var /** @type {?} */ notElementNames = new Set(selector.notSelectors.filter(function (selector) { return selector.isElementSelector(); })\n            .map(function (selector) { return selector.element; }));\n        var /** @type {?} */ possibleElementNames = elementNames.filter(function (elementName) { return !notElementNames.has(elementName); });\n        ctxs.push.apply(ctxs, possibleElementNames.map(function (elementName) { return registry.securityContext(elementName, propName, isAttribute); }));\n    });\n    return ctxs.length === 0 ? [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"SecurityContext\"].NONE] : Array.from(new Set(ctxs)).sort();\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar NG_CONTENT_SELECT_ATTR = 'select';\nvar LINK_ELEMENT = 'link';\nvar LINK_STYLE_REL_ATTR = 'rel';\nvar LINK_STYLE_HREF_ATTR = 'href';\nvar LINK_STYLE_REL_VALUE = 'stylesheet';\nvar STYLE_ELEMENT = 'style';\nvar SCRIPT_ELEMENT = 'script';\nvar NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nvar NG_PROJECT_AS = 'ngProjectAs';\n/**\n * @param {?} ast\n * @return {?}\n */\nfunction preparseElement(ast) {\n    var /** @type {?} */ selectAttr = ((null));\n    var /** @type {?} */ hrefAttr = ((null));\n    var /** @type {?} */ relAttr = ((null));\n    var /** @type {?} */ nonBindable = false;\n    var /** @type {?} */ projectAs = ((null));\n    ast.attrs.forEach(function (attr) {\n        var /** @type {?} */ lcAttrName = attr.name.toLowerCase();\n        if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\n            selectAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n            hrefAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n            relAttr = attr.value;\n        }\n        else if (attr.name == NG_NON_BINDABLE_ATTR) {\n            nonBindable = true;\n        }\n        else if (attr.name == NG_PROJECT_AS) {\n            if (attr.value.length > 0) {\n                projectAs = attr.value;\n            }\n        }\n    });\n    selectAttr = normalizeNgContentSelect(selectAttr);\n    var /** @type {?} */ nodeName = ast.name.toLowerCase();\n    var /** @type {?} */ type = PreparsedElementType.OTHER;\n    if (isNgContent(nodeName)) {\n        type = PreparsedElementType.NG_CONTENT;\n    }\n    else if (nodeName == STYLE_ELEMENT) {\n        type = PreparsedElementType.STYLE;\n    }\n    else if (nodeName == SCRIPT_ELEMENT) {\n        type = PreparsedElementType.SCRIPT;\n    }\n    else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n        type = PreparsedElementType.STYLESHEET;\n    }\n    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n}\nvar PreparsedElementType = {};\nPreparsedElementType.NG_CONTENT = 0;\nPreparsedElementType.STYLE = 1;\nPreparsedElementType.STYLESHEET = 2;\nPreparsedElementType.SCRIPT = 3;\nPreparsedElementType.OTHER = 4;\nPreparsedElementType[PreparsedElementType.NG_CONTENT] = \"NG_CONTENT\";\nPreparsedElementType[PreparsedElementType.STYLE] = \"STYLE\";\nPreparsedElementType[PreparsedElementType.STYLESHEET] = \"STYLESHEET\";\nPreparsedElementType[PreparsedElementType.SCRIPT] = \"SCRIPT\";\nPreparsedElementType[PreparsedElementType.OTHER] = \"OTHER\";\nvar PreparsedElement = (function () {\n    /**\n     * @param {?} type\n     * @param {?} selectAttr\n     * @param {?} hrefAttr\n     * @param {?} nonBindable\n     * @param {?} projectAs\n     */\n    function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {\n        this.type = type;\n        this.selectAttr = selectAttr;\n        this.hrefAttr = hrefAttr;\n        this.nonBindable = nonBindable;\n        this.projectAs = projectAs;\n    }\n    return PreparsedElement;\n}());\n/**\n * @param {?} selectAttr\n * @return {?}\n */\nfunction normalizeNgContentSelect(selectAttr) {\n    if (selectAttr === null || selectAttr.length === 0) {\n        return '*';\n    }\n    return selectAttr;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\n// Group 1 = \"bind-\"\nvar KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nvar KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nvar KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nvar KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nvar KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nvar KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nvar IDENT_KW_IDX = 7;\n// Group 8 = identifier inside [()]\nvar IDENT_BANANA_BOX_IDX = 8;\n// Group 9 = identifier inside []\nvar IDENT_PROPERTY_IDX = 9;\n// Group 10 = identifier inside ()\nvar IDENT_EVENT_IDX = 10;\n// deprecated in 4.x\nvar TEMPLATE_ELEMENT = 'template';\n// deprecated in 4.x\nvar TEMPLATE_ATTR = 'template';\nvar TEMPLATE_ATTR_PREFIX = '*';\nvar CLASS_ATTR = 'class';\nvar TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];\nvar TEMPLATE_ELEMENT_DEPRECATION_WARNING = 'The <template> element is deprecated. Use <ng-template> instead';\nvar TEMPLATE_ATTR_DEPRECATION_WARNING = 'The template attribute is deprecated. Use an ng-template element instead.';\nvar warningCounts = {};\n/**\n * @param {?} warnings\n * @return {?}\n */\nfunction warnOnlyOnce(warnings) {\n    return function (error) {\n        if (warnings.indexOf(error.msg) !== -1) {\n            warningCounts[error.msg] = (warningCounts[error.msg] || 0) + 1;\n            return warningCounts[error.msg] <= 1;\n        }\n        return true;\n    };\n}\n/**\n * Provides an array of {@link TemplateAstVisitor}s which will be used to transform\n * parsed templates before compilation is invoked, allowing custom expression syntax\n * and other advanced transformations.\n *\n * This is currently an internal-only feature and not meant for general use.\n */\nvar TEMPLATE_TRANSFORMS = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"InjectionToken\"]('TemplateTransforms');\nvar TemplateParseError = (function (_super) {\n    __extends(TemplateParseError, _super);\n    /**\n     * @param {?} message\n     * @param {?} span\n     * @param {?} level\n     */\n    function TemplateParseError(message, span, level) {\n        return _super.call(this, span, message, level) || this;\n    }\n    return TemplateParseError;\n}(ParseError));\nvar TemplateParseResult = (function () {\n    /**\n     * @param {?=} templateAst\n     * @param {?=} usedPipes\n     * @param {?=} errors\n     */\n    function TemplateParseResult(templateAst, usedPipes, errors) {\n        this.templateAst = templateAst;\n        this.usedPipes = usedPipes;\n        this.errors = errors;\n    }\n    return TemplateParseResult;\n}());\nvar TemplateParser = (function () {\n    /**\n     * @param {?} _config\n     * @param {?} _exprParser\n     * @param {?} _schemaRegistry\n     * @param {?} _htmlParser\n     * @param {?} _console\n     * @param {?} transforms\n     */\n    function TemplateParser(_config, _exprParser, _schemaRegistry, _htmlParser, _console, transforms) {\n        this._config = _config;\n        this._exprParser = _exprParser;\n        this._schemaRegistry = _schemaRegistry;\n        this._htmlParser = _htmlParser;\n        this._console = _console;\n        this.transforms = transforms;\n    }\n    /**\n     * @param {?} component\n     * @param {?} template\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} schemas\n     * @param {?} templateUrl\n     * @return {?}\n     */\n    TemplateParser.prototype.parse = function (component, template, directives, pipes, schemas, templateUrl) {\n        var /** @type {?} */ result = this.tryParse(component, template, directives, pipes, schemas, templateUrl);\n        var /** @type {?} */ warnings = ((result.errors)).filter(function (error) { return error.level === ParseErrorLevel.WARNING; })\n            .filter(warnOnlyOnce([TEMPLATE_ATTR_DEPRECATION_WARNING, TEMPLATE_ELEMENT_DEPRECATION_WARNING]));\n        var /** @type {?} */ errors = ((result.errors)).filter(function (error) { return error.level === ParseErrorLevel.ERROR; });\n        if (warnings.length > 0) {\n            this._console.warn(\"Template parse warnings:\\n\" + warnings.join('\\n'));\n        }\n        if (errors.length > 0) {\n            var /** @type {?} */ errorString = errors.join('\\n');\n            throw syntaxError(\"Template parse errors:\\n\" + errorString);\n        }\n        return { template: /** @type {?} */ ((result.templateAst)), pipes: /** @type {?} */ ((result.usedPipes)) };\n    };\n    /**\n     * @param {?} component\n     * @param {?} template\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} schemas\n     * @param {?} templateUrl\n     * @return {?}\n     */\n    TemplateParser.prototype.tryParse = function (component, template, directives, pipes, schemas, templateUrl) {\n        return this.tryParseHtml(this.expandHtml(/** @type {?} */ ((this._htmlParser)).parse(template, templateUrl, true, this.getInterpolationConfig(component))), component, directives, pipes, schemas);\n    };\n    /**\n     * @param {?} htmlAstWithErrors\n     * @param {?} component\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} schemas\n     * @return {?}\n     */\n    TemplateParser.prototype.tryParseHtml = function (htmlAstWithErrors, component, directives, pipes, schemas) {\n        var /** @type {?} */ result;\n        var /** @type {?} */ errors = htmlAstWithErrors.errors;\n        var /** @type {?} */ usedPipes = [];\n        if (htmlAstWithErrors.rootNodes.length > 0) {\n            var /** @type {?} */ uniqDirectives = removeSummaryDuplicates(directives);\n            var /** @type {?} */ uniqPipes = removeSummaryDuplicates(pipes);\n            var /** @type {?} */ providerViewContext = new ProviderViewContext(component);\n            var /** @type {?} */ interpolationConfig = ((undefined));\n            if (component.template && component.template.interpolation) {\n                interpolationConfig = {\n                    start: component.template.interpolation[0],\n                    end: component.template.interpolation[1]\n                };\n            }\n            var /** @type {?} */ bindingParser = new BindingParser(this._exprParser, /** @type {?} */ ((interpolationConfig)), this._schemaRegistry, uniqPipes, errors);\n            var /** @type {?} */ parseVisitor = new TemplateParseVisitor(this._config, providerViewContext, uniqDirectives, bindingParser, this._schemaRegistry, schemas, errors);\n            result = visitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);\n            errors.push.apply(errors, providerViewContext.errors);\n            usedPipes.push.apply(usedPipes, bindingParser.getUsedPipes());\n        }\n        else {\n            result = [];\n        }\n        this._assertNoReferenceDuplicationOnTemplate(result, errors);\n        if (errors.length > 0) {\n            return new TemplateParseResult(result, usedPipes, errors);\n        }\n        if (this.transforms) {\n            this.transforms.forEach(function (transform) { result = templateVisitAll(transform, result); });\n        }\n        return new TemplateParseResult(result, usedPipes, errors);\n    };\n    /**\n     * @param {?} htmlAstWithErrors\n     * @param {?=} forced\n     * @return {?}\n     */\n    TemplateParser.prototype.expandHtml = function (htmlAstWithErrors, forced) {\n        if (forced === void 0) { forced = false; }\n        var /** @type {?} */ errors = htmlAstWithErrors.errors;\n        if (errors.length == 0 || forced) {\n            // Transform ICU messages to angular directives\n            var /** @type {?} */ expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);\n            errors.push.apply(errors, expandedHtmlAst.errors);\n            htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);\n        }\n        return htmlAstWithErrors;\n    };\n    /**\n     * @param {?} component\n     * @return {?}\n     */\n    TemplateParser.prototype.getInterpolationConfig = function (component) {\n        if (component.template) {\n            return InterpolationConfig.fromArray(component.template.interpolation);\n        }\n        return undefined;\n    };\n    /**\n     * \\@internal\n     * @param {?} result\n     * @param {?} errors\n     * @return {?}\n     */\n    TemplateParser.prototype._assertNoReferenceDuplicationOnTemplate = function (result, errors) {\n        var /** @type {?} */ existingReferences = [];\n        result.filter(function (element) { return !!((element)).references; })\n            .forEach(function (element) { return ((element)).references.forEach(function (reference) {\n            var /** @type {?} */ name = reference.name;\n            if (existingReferences.indexOf(name) < 0) {\n                existingReferences.push(name);\n            }\n            else {\n                var /** @type {?} */ error = new TemplateParseError(\"Reference \\\"#\" + name + \"\\\" is defined several times\", reference.sourceSpan, ParseErrorLevel.ERROR);\n                errors.push(error);\n            }\n        }); });\n    };\n    return TemplateParser;\n}());\nTemplateParser.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nTemplateParser.ctorParameters = function () { return [\n    { type: CompilerConfig, },\n    { type: Parser, },\n    { type: ElementSchemaRegistry, },\n    { type: I18NHtmlParser, },\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵConsole\"], },\n    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Inject\"], args: [TEMPLATE_TRANSFORMS,] },] },\n]; };\nvar TemplateParseVisitor = (function () {\n    /**\n     * @param {?} config\n     * @param {?} providerViewContext\n     * @param {?} directives\n     * @param {?} _bindingParser\n     * @param {?} _schemaRegistry\n     * @param {?} _schemas\n     * @param {?} _targetErrors\n     */\n    function TemplateParseVisitor(config, providerViewContext, directives, _bindingParser, _schemaRegistry, _schemas, _targetErrors) {\n        var _this = this;\n        this.config = config;\n        this.providerViewContext = providerViewContext;\n        this._bindingParser = _bindingParser;\n        this._schemaRegistry = _schemaRegistry;\n        this._schemas = _schemas;\n        this._targetErrors = _targetErrors;\n        this.selectorMatcher = new SelectorMatcher();\n        this.directivesIndex = new Map();\n        this.ngContentCount = 0;\n        // Note: queries start with id 1 so we can use the number in a Bloom filter!\n        this.contentQueryStartId = providerViewContext.component.viewQueries.length + 1;\n        directives.forEach(function (directive, index) {\n            var selector = CssSelector.parse(directive.selector);\n            _this.selectorMatcher.addSelectables(selector, directive);\n            _this.directivesIndex.set(directive, index);\n        });\n    }\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitExpansion = function (expansion, context) { return null; };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return null; };\n    /**\n     * @param {?} text\n     * @param {?} parent\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitText = function (text, parent) {\n        var /** @type {?} */ ngContentIndex = ((parent.findNgContentIndex(TEXT_CSS_SELECTOR)));\n        var /** @type {?} */ expr = this._bindingParser.parseInterpolation(text.value, /** @type {?} */ ((text.sourceSpan)));\n        return expr ? new BoundTextAst(expr, ngContentIndex, /** @type {?} */ ((text.sourceSpan))) :\n            new TextAst(text.value, ngContentIndex, /** @type {?} */ ((text.sourceSpan)));\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitAttribute = function (attribute, context) {\n        return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitComment = function (comment, context) { return null; };\n    /**\n     * @param {?} element\n     * @param {?} parent\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitElement = function (element, parent) {\n        var _this = this;\n        var /** @type {?} */ queryStartIndex = this.contentQueryStartId;\n        var /** @type {?} */ nodeName = element.name;\n        var /** @type {?} */ preparsedElement = preparseElement(element);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE) {\n            // Skipping <script> for security reasons\n            // Skipping <style> as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\n            isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n            // Skipping stylesheets with either relative urls or package scheme as we already processed\n            // them in the StyleCompiler\n            return null;\n        }\n        var /** @type {?} */ matchableAttrs = [];\n        var /** @type {?} */ elementOrDirectiveProps = [];\n        var /** @type {?} */ elementOrDirectiveRefs = [];\n        var /** @type {?} */ elementVars = [];\n        var /** @type {?} */ events = [];\n        var /** @type {?} */ templateElementOrDirectiveProps = [];\n        var /** @type {?} */ templateMatchableAttrs = [];\n        var /** @type {?} */ templateElementVars = [];\n        var /** @type {?} */ hasInlineTemplates = false;\n        var /** @type {?} */ attrs = [];\n        var /** @type {?} */ isTemplateElement = isTemplate(element, this.config.enableLegacyTemplate, function (m, span) { return _this._reportError(m, span, ParseErrorLevel.WARNING); });\n        element.attrs.forEach(function (attr) {\n            var /** @type {?} */ hasBinding = _this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);\n            var /** @type {?} */ templateBindingsSource;\n            var /** @type {?} */ prefixToken;\n            var /** @type {?} */ normalizedName = _this._normalizeAttributeName(attr.name);\n            if (_this.config.enableLegacyTemplate && normalizedName == TEMPLATE_ATTR) {\n                _this._reportError(TEMPLATE_ATTR_DEPRECATION_WARNING, attr.sourceSpan, ParseErrorLevel.WARNING);\n                templateBindingsSource = attr.value;\n            }\n            else if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n                templateBindingsSource = attr.value;\n                prefixToken = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length) + ':';\n            }\n            var /** @type {?} */ hasTemplateBinding = templateBindingsSource != null;\n            if (hasTemplateBinding) {\n                if (hasInlineTemplates) {\n                    _this._reportError(\"Can't have multiple template bindings on one element. Use only one attribute named 'template' or prefixed with *\", attr.sourceSpan);\n                }\n                hasInlineTemplates = true;\n                _this._bindingParser.parseInlineTemplateBinding(/** @type {?} */ ((prefixToken)), /** @type {?} */ ((templateBindingsSource)), attr.sourceSpan, templateMatchableAttrs, templateElementOrDirectiveProps, templateElementVars);\n            }\n            if (!hasBinding && !hasTemplateBinding) {\n                // don't include the bindings as attributes as well in the AST\n                attrs.push(_this.visitAttribute(attr, null));\n                matchableAttrs.push([attr.name, attr.value]);\n            }\n        });\n        var /** @type {?} */ elementCssSelector = createElementCssSelector(nodeName, matchableAttrs);\n        var _a = this._parseDirectives(this.selectorMatcher, elementCssSelector), directiveMetas = _a.directives, matchElement = _a.matchElement;\n        var /** @type {?} */ references = [];\n        var /** @type {?} */ boundDirectivePropNames = new Set();\n        var /** @type {?} */ directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, /** @type {?} */ ((element.sourceSpan)), references, boundDirectivePropNames);\n        var /** @type {?} */ elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, boundDirectivePropNames);\n        var /** @type {?} */ isViewRoot = parent.isTemplateElement || hasInlineTemplates;\n        var /** @type {?} */ providerContext = new ProviderElementContext(this.providerViewContext, /** @type {?} */ ((parent.providerContext)), isViewRoot, directiveAsts, attrs, references, isTemplateElement, queryStartIndex, /** @type {?} */ ((element.sourceSpan)));\n        var /** @type {?} */ children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? ((parent.providerContext)) : providerContext));\n        providerContext.afterElement();\n        // Override the actual selector when the `ngProjectAs` attribute is provided\n        var /** @type {?} */ projectionSelector = preparsedElement.projectAs != null ?\n            CssSelector.parse(preparsedElement.projectAs)[0] :\n            elementCssSelector;\n        var /** @type {?} */ ngContentIndex = ((parent.findNgContentIndex(projectionSelector)));\n        var /** @type {?} */ parsedElement;\n        if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n            if (element.children && !element.children.every(_isEmptyTextNode)) {\n                this._reportError(\"<ng-content> element cannot have content.\", /** @type {?} */ ((element.sourceSpan)));\n            }\n            parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? ((null)) : ngContentIndex, /** @type {?} */ ((element.sourceSpan)));\n        }\n        else if (isTemplateElement) {\n            this._assertAllEventsPublishedByDirectives(directiveAsts, events);\n            this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, /** @type {?} */ ((element.sourceSpan)));\n            parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? ((null)) : ngContentIndex, /** @type {?} */ ((element.sourceSpan)));\n        }\n        else {\n            this._assertElementExists(matchElement, element);\n            this._assertOnlyOneComponent(directiveAsts, /** @type {?} */ ((element.sourceSpan)));\n            var /** @type {?} */ ngContentIndex_1 = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);\n            parsedElement = new ElementAst(nodeName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex_1, element.sourceSpan, element.endSourceSpan || null);\n        }\n        if (hasInlineTemplates) {\n            var /** @type {?} */ templateQueryStartIndex = this.contentQueryStartId;\n            var /** @type {?} */ templateSelector = createElementCssSelector(TEMPLATE_ELEMENT, templateMatchableAttrs);\n            var templateDirectiveMetas = this._parseDirectives(this.selectorMatcher, templateSelector).directives;\n            var /** @type {?} */ templateBoundDirectivePropNames = new Set();\n            var /** @type {?} */ templateDirectiveAsts = this._createDirectiveAsts(true, element.name, templateDirectiveMetas, templateElementOrDirectiveProps, [], /** @type {?} */ ((element.sourceSpan)), [], templateBoundDirectivePropNames);\n            var /** @type {?} */ templateElementProps = this._createElementPropertyAsts(element.name, templateElementOrDirectiveProps, templateBoundDirectivePropNames);\n            this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, /** @type {?} */ ((element.sourceSpan)));\n            var /** @type {?} */ templateProviderContext = new ProviderElementContext(this.providerViewContext, /** @type {?} */ ((parent.providerContext)), parent.isTemplateElement, templateDirectiveAsts, [], [], true, templateQueryStartIndex, /** @type {?} */ ((element.sourceSpan)));\n            templateProviderContext.afterElement();\n            parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, templateProviderContext.queryMatches, [parsedElement], ngContentIndex, /** @type {?} */ ((element.sourceSpan)));\n        }\n        return parsedElement;\n    };\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} attr\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @param {?} targetEvents\n     * @param {?} targetRefs\n     * @param {?} targetVars\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseAttr = function (isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {\n        var /** @type {?} */ name = this._normalizeAttributeName(attr.name);\n        var /** @type {?} */ value = attr.value;\n        var /** @type {?} */ srcSpan = attr.sourceSpan;\n        var /** @type {?} */ bindParts = name.match(BIND_NAME_REGEXP);\n        var /** @type {?} */ hasBinding = false;\n        if (bindParts !== null) {\n            hasBinding = true;\n            if (bindParts[KW_BIND_IDX] != null) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[KW_LET_IDX]) {\n                if (isTemplateElement) {\n                    var /** @type {?} */ identifier = bindParts[IDENT_KW_IDX];\n                    this._parseVariable(identifier, value, srcSpan, targetVars);\n                }\n                else {\n                    this._reportError(\"\\\"let-\\\" is only supported on template elements.\", srcSpan);\n                }\n            }\n            else if (bindParts[KW_REF_IDX]) {\n                var /** @type {?} */ identifier = bindParts[IDENT_KW_IDX];\n                this._parseReference(identifier, value, srcSpan, targetRefs);\n            }\n            else if (bindParts[KW_ON_IDX]) {\n                this._bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n            else if (bindParts[KW_BINDON_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n                this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n            else if (bindParts[KW_AT_IDX]) {\n                this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n                this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n            else if (bindParts[IDENT_PROPERTY_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[IDENT_EVENT_IDX]) {\n                this._bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n        }\n        else {\n            hasBinding = this._bindingParser.parsePropertyInterpolation(name, value, srcSpan, targetMatchableAttrs, targetProps);\n        }\n        if (!hasBinding) {\n            this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);\n        }\n        return hasBinding;\n    };\n    /**\n     * @param {?} attrName\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._normalizeAttributeName = function (attrName) {\n        return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n    };\n    /**\n     * @param {?} identifier\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetVars\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseVariable = function (identifier, value, sourceSpan, targetVars) {\n        if (identifier.indexOf('-') > -1) {\n            this._reportError(\"\\\"-\\\" is not allowed in variable names\", sourceSpan);\n        }\n        targetVars.push(new VariableAst(identifier, value, sourceSpan));\n    };\n    /**\n     * @param {?} identifier\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetRefs\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseReference = function (identifier, value, sourceSpan, targetRefs) {\n        if (identifier.indexOf('-') > -1) {\n            this._reportError(\"\\\"-\\\" is not allowed in reference names\", sourceSpan);\n        }\n        targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseAssignmentEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\n        this._bindingParser.parseEvent(name + \"Change\", expression + \"=$event\", sourceSpan, targetMatchableAttrs, targetEvents);\n    };\n    /**\n     * @param {?} selectorMatcher\n     * @param {?} elementCssSelector\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseDirectives = function (selectorMatcher, elementCssSelector) {\n        var _this = this;\n        // Need to sort the directives so that we get consistent results throughout,\n        // as selectorMatcher uses Maps inside.\n        // Also deduplicate directives as they might match more than one time!\n        var /** @type {?} */ directives = new Array(this.directivesIndex.size);\n        // Whether any directive selector matches on the element name\n        var /** @type {?} */ matchElement = false;\n        selectorMatcher.match(elementCssSelector, function (selector, directive) {\n            directives[((_this.directivesIndex.get(directive)))] = directive;\n            matchElement = matchElement || selector.hasElementSelector();\n        });\n        return {\n            directives: directives.filter(function (dir) { return !!dir; }),\n            matchElement: matchElement,\n        };\n    };\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} elementName\n     * @param {?} directives\n     * @param {?} props\n     * @param {?} elementOrDirectiveRefs\n     * @param {?} elementSourceSpan\n     * @param {?} targetReferences\n     * @param {?} targetBoundDirectivePropNames\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._createDirectiveAsts = function (isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences, targetBoundDirectivePropNames) {\n        var _this = this;\n        var /** @type {?} */ matchedReferences = new Set();\n        var /** @type {?} */ component = ((null));\n        var /** @type {?} */ directiveAsts = directives.map(function (directive) {\n            var /** @type {?} */ sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, \"Directive \" + identifierName(directive.type));\n            if (directive.isComponent) {\n                component = directive;\n            }\n            var /** @type {?} */ directiveProperties = [];\n            var /** @type {?} */ hostProperties = ((_this._bindingParser.createDirectiveHostPropertyAsts(directive, elementName, sourceSpan)));\n            // Note: We need to check the host properties here as well,\n            // as we don't know the element name in the DirectiveWrapperCompiler yet.\n            hostProperties = _this._checkPropertiesInSchema(elementName, hostProperties);\n            var /** @type {?} */ hostEvents = ((_this._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan)));\n            _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties, targetBoundDirectivePropNames);\n            elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n                if ((elOrDirRef.value.length === 0 && directive.isComponent) ||\n                    (directive.exportAs == elOrDirRef.value)) {\n                    targetReferences.push(new ReferenceAst(elOrDirRef.name, identifierToken(directive.type), elOrDirRef.sourceSpan));\n                    matchedReferences.add(elOrDirRef.name);\n                }\n            });\n            var /** @type {?} */ contentQueryStartId = _this.contentQueryStartId;\n            _this.contentQueryStartId += directive.queries.length;\n            return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, contentQueryStartId, sourceSpan);\n        });\n        elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n            if (elOrDirRef.value.length > 0) {\n                if (!matchedReferences.has(elOrDirRef.name)) {\n                    _this._reportError(\"There is no directive with \\\"exportAs\\\" set to \\\"\" + elOrDirRef.value + \"\\\"\", elOrDirRef.sourceSpan);\n                }\n            }\n            else if (!component) {\n                var /** @type {?} */ refToken = ((null));\n                if (isTemplateElement) {\n                    refToken = createIdentifierToken(Identifiers.TemplateRef);\n                }\n                targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.sourceSpan));\n            }\n        });\n        return directiveAsts;\n    };\n    /**\n     * @param {?} directiveProperties\n     * @param {?} boundProps\n     * @param {?} targetBoundDirectiveProps\n     * @param {?} targetBoundDirectivePropNames\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._createDirectivePropertyAsts = function (directiveProperties, boundProps, targetBoundDirectiveProps, targetBoundDirectivePropNames) {\n        if (directiveProperties) {\n            var /** @type {?} */ boundPropsByName_1 = new Map();\n            boundProps.forEach(function (boundProp) {\n                var /** @type {?} */ prevValue = boundPropsByName_1.get(boundProp.name);\n                if (!prevValue || prevValue.isLiteral) {\n                    // give [a]=\"b\" a higher precedence than a=\"b\" on the same element\n                    boundPropsByName_1.set(boundProp.name, boundProp);\n                }\n            });\n            Object.keys(directiveProperties).forEach(function (dirProp) {\n                var /** @type {?} */ elProp = directiveProperties[dirProp];\n                var /** @type {?} */ boundProp = boundPropsByName_1.get(elProp);\n                // Bindings are optional, so this binding only needs to be set up if an expression is given.\n                if (boundProp) {\n                    targetBoundDirectivePropNames.add(boundProp.name);\n                    if (!isEmptyExpression(boundProp.expression)) {\n                        targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));\n                    }\n                }\n            });\n        }\n    };\n    /**\n     * @param {?} elementName\n     * @param {?} props\n     * @param {?} boundDirectivePropNames\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._createElementPropertyAsts = function (elementName, props, boundDirectivePropNames) {\n        var _this = this;\n        var /** @type {?} */ boundElementProps = [];\n        props.forEach(function (prop) {\n            if (!prop.isLiteral && !boundDirectivePropNames.has(prop.name)) {\n                boundElementProps.push(_this._bindingParser.createElementPropertyAst(elementName, prop));\n            }\n        });\n        return this._checkPropertiesInSchema(elementName, boundElementProps);\n    };\n    /**\n     * @param {?} directives\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._findComponentDirectives = function (directives) {\n        return directives.filter(function (directive) { return directive.directive.isComponent; });\n    };\n    /**\n     * @param {?} directives\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._findComponentDirectiveNames = function (directives) {\n        return this._findComponentDirectives(directives)\n            .map(function (directive) { return ((identifierName(directive.directive.type))); });\n    };\n    /**\n     * @param {?} directives\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._assertOnlyOneComponent = function (directives, sourceSpan) {\n        var /** @type {?} */ componentTypeNames = this._findComponentDirectiveNames(directives);\n        if (componentTypeNames.length > 1) {\n            this._reportError(\"More than one component matched on this element.\\n\" +\n                \"Make sure that only one component's selector can match a given element.\\n\" +\n                (\"Conflicting components: \" + componentTypeNames.join(',')), sourceSpan);\n        }\n    };\n    /**\n     * Make sure that non-angular tags conform to the schemas.\n     *\n     * Note: An element is considered an angular tag when at least one directive selector matches the\n     * tag name.\n     *\n     * @param {?} matchElement Whether any directive has matched on the tag name\n     * @param {?} element the html element\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._assertElementExists = function (matchElement, element) {\n        var /** @type {?} */ elName = element.name.replace(/^:xhtml:/, '');\n        if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {\n            var /** @type {?} */ errorMsg = \"'\" + elName + \"' is not a known element:\\n\";\n            errorMsg +=\n                \"1. If '\" + elName + \"' is an Angular component, then verify that it is part of this module.\\n\";\n            if (elName.indexOf('-') > -1) {\n                errorMsg +=\n                    \"2. If '\" + elName + \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\";\n            }\n            else {\n                errorMsg +=\n                    \"2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n            }\n            this._reportError(errorMsg, /** @type {?} */ ((element.sourceSpan)));\n        }\n    };\n    /**\n     * @param {?} directives\n     * @param {?} elementProps\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function (directives, elementProps, sourceSpan) {\n        var _this = this;\n        var /** @type {?} */ componentTypeNames = this._findComponentDirectiveNames(directives);\n        if (componentTypeNames.length > 0) {\n            this._reportError(\"Components on an embedded template: \" + componentTypeNames.join(','), sourceSpan);\n        }\n        elementProps.forEach(function (prop) {\n            _this._reportError(\"Property binding \" + prop.name + \" not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \\\"@NgModule.declarations\\\".\", sourceSpan);\n        });\n    };\n    /**\n     * @param {?} directives\n     * @param {?} events\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._assertAllEventsPublishedByDirectives = function (directives, events) {\n        var _this = this;\n        var /** @type {?} */ allDirectiveEvents = new Set();\n        directives.forEach(function (directive) {\n            Object.keys(directive.directive.outputs).forEach(function (k) {\n                var /** @type {?} */ eventName = directive.directive.outputs[k];\n                allDirectiveEvents.add(eventName);\n            });\n        });\n        events.forEach(function (event) {\n            if (event.target != null || !allDirectiveEvents.has(event.name)) {\n                _this._reportError(\"Event binding \" + event.fullName + \" not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \\\"@NgModule.declarations\\\".\", event.sourceSpan);\n            }\n        });\n    };\n    /**\n     * @param {?} elementName\n     * @param {?} boundProps\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._checkPropertiesInSchema = function (elementName, boundProps) {\n        var _this = this;\n        // Note: We can't filter out empty expressions before this method,\n        // as we still want to validate them!\n        return boundProps.filter(function (boundProp) {\n            if (boundProp.type === PropertyBindingType.Property &&\n                !_this._schemaRegistry.hasProperty(elementName, boundProp.name, _this._schemas)) {\n                var /** @type {?} */ errorMsg = \"Can't bind to '\" + boundProp.name + \"' since it isn't a known property of '\" + elementName + \"'.\";\n                if (elementName.startsWith('ng-')) {\n                    errorMsg +=\n                        \"\\n1. If '\" + boundProp.name + \"' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.\" +\n                            \"\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n                }\n                else if (elementName.indexOf('-') > -1) {\n                    errorMsg +=\n                        \"\\n1. If '\" + elementName + \"' is an Angular component and it has '\" + boundProp.name + \"' input, then verify that it is part of this module.\" +\n                            (\"\\n2. If '\" + elementName + \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\") +\n                            \"\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n                }\n                _this._reportError(errorMsg, boundProp.sourceSpan);\n            }\n            return !isEmptyExpression(boundProp.value);\n        });\n    };\n    /**\n     * @param {?} message\n     * @param {?} sourceSpan\n     * @param {?=} level\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._reportError = function (message, sourceSpan, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this._targetErrors.push(new ParseError(sourceSpan, message, level));\n    };\n    return TemplateParseVisitor;\n}());\nvar NonBindableVisitor = (function () {\n    function NonBindableVisitor() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} parent\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitElement = function (ast, parent) {\n        var /** @type {?} */ preparsedElement = preparseElement(ast);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE ||\n            preparsedElement.type === PreparsedElementType.STYLESHEET) {\n            // Skipping <script> for security reasons\n            // Skipping <style> and stylesheets as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        var /** @type {?} */ attrNameAndValues = ast.attrs.map(function (attr) { return [attr.name, attr.value]; });\n        var /** @type {?} */ selector = createElementCssSelector(ast.name, attrNameAndValues);\n        var /** @type {?} */ ngContentIndex = parent.findNgContentIndex(selector);\n        var /** @type {?} */ children = visitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);\n        return new ElementAst(ast.name, visitAll(this, ast.attrs), [], [], [], [], [], false, [], children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitComment = function (comment, context) { return null; };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitAttribute = function (attribute, context) {\n        return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    };\n    /**\n     * @param {?} text\n     * @param {?} parent\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitText = function (text, parent) {\n        var /** @type {?} */ ngContentIndex = ((parent.findNgContentIndex(TEXT_CSS_SELECTOR)));\n        return new TextAst(text.value, ngContentIndex, /** @type {?} */ ((text.sourceSpan)));\n    };\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitExpansion = function (expansion, context) { return expansion; };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return expansionCase; };\n    return NonBindableVisitor;\n}());\nvar ElementOrDirectiveRef = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function ElementOrDirectiveRef(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    return ElementOrDirectiveRef;\n}());\n/**\n * @param {?} classAttrValue\n * @return {?}\n */\nfunction splitClasses(classAttrValue) {\n    return classAttrValue.trim().split(/\\s+/g);\n}\nvar ElementContext = (function () {\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} _ngContentIndexMatcher\n     * @param {?} _wildcardNgContentIndex\n     * @param {?} providerContext\n     */\n    function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {\n        this.isTemplateElement = isTemplateElement;\n        this._ngContentIndexMatcher = _ngContentIndexMatcher;\n        this._wildcardNgContentIndex = _wildcardNgContentIndex;\n        this.providerContext = providerContext;\n    }\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} directives\n     * @param {?} providerContext\n     * @return {?}\n     */\n    ElementContext.create = function (isTemplateElement, directives, providerContext) {\n        var /** @type {?} */ matcher = new SelectorMatcher();\n        var /** @type {?} */ wildcardNgContentIndex = ((null));\n        var /** @type {?} */ component = directives.find(function (directive) { return directive.directive.isComponent; });\n        if (component) {\n            var /** @type {?} */ ngContentSelectors = ((component.directive.template)).ngContentSelectors;\n            for (var /** @type {?} */ i = 0; i < ngContentSelectors.length; i++) {\n                var /** @type {?} */ selector = ngContentSelectors[i];\n                if (selector === '*') {\n                    wildcardNgContentIndex = i;\n                }\n                else {\n                    matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);\n                }\n            }\n        }\n        return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);\n    };\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    ElementContext.prototype.findNgContentIndex = function (selector) {\n        var /** @type {?} */ ngContentIndices = [];\n        this._ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) { ngContentIndices.push(ngContentIndex); });\n        ngContentIndices.sort();\n        if (this._wildcardNgContentIndex != null) {\n            ngContentIndices.push(this._wildcardNgContentIndex);\n        }\n        return ngContentIndices.length > 0 ? ngContentIndices[0] : null;\n    };\n    return ElementContext;\n}());\n/**\n * @param {?} elementName\n * @param {?} attributes\n * @return {?}\n */\nfunction createElementCssSelector(elementName, attributes) {\n    var /** @type {?} */ cssSelector = new CssSelector();\n    var /** @type {?} */ elNameNoNs = splitNsName(elementName)[1];\n    cssSelector.setElement(elNameNoNs);\n    for (var /** @type {?} */ i = 0; i < attributes.length; i++) {\n        var /** @type {?} */ attrName = attributes[i][0];\n        var /** @type {?} */ attrNameNoNs = splitNsName(attrName)[1];\n        var /** @type {?} */ attrValue = attributes[i][1];\n        cssSelector.addAttribute(attrNameNoNs, attrValue);\n        if (attrName.toLowerCase() == CLASS_ATTR) {\n            var /** @type {?} */ classes = splitClasses(attrValue);\n            classes.forEach(function (className) { return cssSelector.addClassName(className); });\n        }\n    }\n    return cssSelector;\n}\nvar EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);\nvar NON_BINDABLE_VISITOR = new NonBindableVisitor();\n/**\n * @param {?} node\n * @return {?}\n */\nfunction _isEmptyTextNode(node) {\n    return node instanceof Text && node.value.trim().length == 0;\n}\n/**\n * @template T\n * @param {?} items\n * @return {?}\n */\nfunction removeSummaryDuplicates(items) {\n    var /** @type {?} */ map = new Map();\n    items.forEach(function (item) {\n        if (!map.get(item.type.reference)) {\n            map.set(item.type.reference, item);\n        }\n    });\n    return Array.from(map.values());\n}\n/**\n * @param {?} ast\n * @return {?}\n */\nfunction isEmptyExpression(ast) {\n    if (ast instanceof ASTWithSource) {\n        ast = ast.ast;\n    }\n    return ast instanceof EmptyExpr;\n}\n/**\n * @param {?} el\n * @param {?} enableLegacyTemplate\n * @param {?} reportDeprecation\n * @return {?}\n */\nfunction isTemplate(el, enableLegacyTemplate, reportDeprecation) {\n    if (isNgTemplate(el.name))\n        return true;\n    var /** @type {?} */ tagNoNs = splitNsName(el.name)[1];\n    // `<template>` is HTML and case insensitive\n    if (tagNoNs.toLowerCase() === TEMPLATE_ELEMENT) {\n        if (enableLegacyTemplate && tagNoNs.toLowerCase() === TEMPLATE_ELEMENT) {\n            reportDeprecation(TEMPLATE_ELEMENT_DEPRECATION_WARNING, /** @type {?} */ ((el.sourceSpan)));\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * An interface for retrieving documents by URL that the compiler uses\n * to load templates.\n */\nvar ResourceLoader = (function () {\n    function ResourceLoader() {\n    }\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    ResourceLoader.prototype.get = function (url) { return null; };\n    return ResourceLoader;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Create a {\\@link UrlResolver} with no package prefix.\n * @return {?}\n */\nfunction createUrlResolverWithoutPackagePrefix() {\n    return new UrlResolver();\n}\n/**\n * @return {?}\n */\nfunction createOfflineCompileUrlResolver() {\n    return new UrlResolver('.');\n}\n/**\n * A default provider for {@link PACKAGE_ROOT_URL} that maps to '/'.\n */\nvar DEFAULT_PACKAGE_URL_PROVIDER = {\n    provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"PACKAGE_ROOT_URL\"],\n    useValue: '/'\n};\n/**\n * Used by the {\\@link Compiler} when resolving HTML and CSS template URLs.\n *\n * This class can be overridden by the application developer to create custom behavior.\n *\n * See {\\@link Compiler}\n *\n * ## Example\n *\n * {\\@example compiler/ts/url_resolver/url_resolver.ts region='url_resolver'}\n *\n * \\@security When compiling templates at runtime, you must\n * ensure that the entire template comes from a trusted source.\n * Attacker-controlled data introduced by a template could expose your\n * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).\n */\nvar UrlResolver = (function () {\n    /**\n     * @param {?=} _packagePrefix\n     */\n    function UrlResolver(_packagePrefix) {\n        if (_packagePrefix === void 0) { _packagePrefix = null; }\n        this._packagePrefix = _packagePrefix;\n    }\n    /**\n     * Resolves the `url` given the `baseUrl`:\n     * - when the `url` is null, the `baseUrl` is returned,\n     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of\n     * `baseUrl` and `url`,\n     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is\n     * returned as is (ignoring the `baseUrl`)\n     * @param {?} baseUrl\n     * @param {?} url\n     * @return {?}\n     */\n    UrlResolver.prototype.resolve = function (baseUrl, url) {\n        var /** @type {?} */ resolvedUrl = url;\n        if (baseUrl != null && baseUrl.length > 0) {\n            resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);\n        }\n        var /** @type {?} */ resolvedParts = _split(resolvedUrl);\n        var /** @type {?} */ prefix = this._packagePrefix;\n        if (prefix != null && resolvedParts != null &&\n            resolvedParts[_ComponentIndex.Scheme] == 'package') {\n            var /** @type {?} */ path = resolvedParts[_ComponentIndex.Path];\n            prefix = prefix.replace(/\\/+$/, '');\n            path = path.replace(/^\\/+/, '');\n            return prefix + \"/\" + path;\n        }\n        return resolvedUrl;\n    };\n    return UrlResolver;\n}());\nUrlResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nUrlResolver.ctorParameters = function () { return [\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Inject\"], args: [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"PACKAGE_ROOT_URL\"],] },] },\n]; };\n/**\n * Extract the scheme of a URL.\n * @param {?} url\n * @return {?}\n */\nfunction getUrlScheme(url) {\n    var /** @type {?} */ match = _split(url);\n    return (match && match[_ComponentIndex.Scheme]) || '';\n}\n/**\n * Builds a URI string from already-encoded parts.\n *\n * No encoding is performed.  Any component may be omitted as either null or\n * undefined.\n *\n * @param {?=} opt_scheme The scheme such as 'http'.\n * @param {?=} opt_userInfo The user name before the '\\@'.\n * @param {?=} opt_domain The domain such as 'www.google.com', already\n *     URI-encoded.\n * @param {?=} opt_port The port number.\n * @param {?=} opt_path The path, already URI-encoded.  If it is not\n *     empty, it must begin with a slash.\n * @param {?=} opt_queryData The URI-encoded query data.\n * @param {?=} opt_fragment The URI-encoded fragment identifier.\n * @return {?} The fully combined URI.\n */\nfunction _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n    var /** @type {?} */ out = [];\n    if (opt_scheme != null) {\n        out.push(opt_scheme + ':');\n    }\n    if (opt_domain != null) {\n        out.push('//');\n        if (opt_userInfo != null) {\n            out.push(opt_userInfo + '@');\n        }\n        out.push(opt_domain);\n        if (opt_port != null) {\n            out.push(':' + opt_port);\n        }\n    }\n    if (opt_path != null) {\n        out.push(opt_path);\n    }\n    if (opt_queryData != null) {\n        out.push('?' + opt_queryData);\n    }\n    if (opt_fragment != null) {\n        out.push('#' + opt_fragment);\n    }\n    return out.join('');\n}\n/**\n * A regular expression for breaking a URI into its component parts.\n *\n * {\\@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n * disambiguation method used by POSIX regular expressions, it is natural and\n * commonplace to use a regular expression for parsing the potential five\n * components of a URI reference.\n *\n * The following line is the regular expression for breaking-down a\n * well-formed URI reference into its components.\n *\n * <pre>\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n * </pre>\n *\n * The numbers in the second line above are only to assist readability; they\n * indicate the reference points for each subexpression (i.e., each paired\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n * For example, matching the above expression to\n * <pre>\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n * </pre>\n * results in the following subexpression matches:\n * <pre>\n *    $1 = http:\n *    $2 = http\n *    $3 = //www.ics.uci.edu\n *    $4 = www.ics.uci.edu\n *    $5 = /pub/ietf/uri/\n *    $6 = <undefined>\n *    $7 = <undefined>\n *    $8 = #Related\n *    $9 = Related\n * </pre>\n * where <undefined> indicates that the component is not present, as is the\n * case for the query component in the above example. Therefore, we can\n * determine the value of the five components as\n * <pre>\n *    scheme    = $2\n *    authority = $4\n *    path      = $5\n *    query     = $7\n *    fragment  = $9\n * </pre>\n *\n * The regular expression has been modified slightly to expose the\n * userInfo, domain, and port separately from the authority.\n * The modified version yields\n * <pre>\n *    $1 = http              scheme\n *    $2 = <undefined>       userInfo -\\\n *    $3 = www.ics.uci.edu   domain     | authority\n *    $4 = <undefined>       port     -/\n *    $5 = /pub/ietf/uri/    path\n *    $6 = <undefined>       query without ?\n *    $7 = Related           fragment without #\n * </pre>\n * \\@internal\n */\nvar _splitRe = new RegExp('^' +\n    '(?:' +\n    '([^:/?#.]+)' +\n    // used by other URL parts such as :,\n    // ?, /, #, and .\n    ':)?' +\n    '(?://' +\n    '(?:([^/?#]*)@)?' +\n    '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' +\n    // digits, dashes, dots, percent\n    // escapes, and unicode characters.\n    '(?::([0-9]+))?' +\n    ')?' +\n    '([^?#]+)?' +\n    '(?:\\\\?([^#]*))?' +\n    '(?:#(.*))?' +\n    '$');\nvar _ComponentIndex = {};\n_ComponentIndex.Scheme = 1;\n_ComponentIndex.UserInfo = 2;\n_ComponentIndex.Domain = 3;\n_ComponentIndex.Port = 4;\n_ComponentIndex.Path = 5;\n_ComponentIndex.QueryData = 6;\n_ComponentIndex.Fragment = 7;\n_ComponentIndex[_ComponentIndex.Scheme] = \"Scheme\";\n_ComponentIndex[_ComponentIndex.UserInfo] = \"UserInfo\";\n_ComponentIndex[_ComponentIndex.Domain] = \"Domain\";\n_ComponentIndex[_ComponentIndex.Port] = \"Port\";\n_ComponentIndex[_ComponentIndex.Path] = \"Path\";\n_ComponentIndex[_ComponentIndex.QueryData] = \"QueryData\";\n_ComponentIndex[_ComponentIndex.Fragment] = \"Fragment\";\n/**\n * Splits a URI into its component parts.\n *\n * Each component can be accessed via the component indices; for example:\n * <pre>\n * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];\n * </pre>\n *\n * @param {?} uri The URI string to examine.\n * @return {?} Each component still URI-encoded.\n *     Each component that is present will contain the encoded value, whereas\n *     components that are not present will be undefined or empty, depending\n *     on the browser's regular expression implementation.  Never null, since\n *     arbitrary strings may still look like path names.\n */\nfunction _split(uri) {\n    return ((uri.match(_splitRe)));\n}\n/**\n * Removes dot segments in given path component, as described in\n * RFC 3986, section 5.2.4.\n *\n * @param {?} path A non-empty path component.\n * @return {?} Path component with removed dot segments.\n */\nfunction _removeDotSegments(path) {\n    if (path == '/')\n        return '/';\n    var /** @type {?} */ leadingSlash = path[0] == '/' ? '/' : '';\n    var /** @type {?} */ trailingSlash = path[path.length - 1] === '/' ? '/' : '';\n    var /** @type {?} */ segments = path.split('/');\n    var /** @type {?} */ out = [];\n    var /** @type {?} */ up = 0;\n    for (var /** @type {?} */ pos = 0; pos < segments.length; pos++) {\n        var /** @type {?} */ segment = segments[pos];\n        switch (segment) {\n            case '':\n            case '.':\n                break;\n            case '..':\n                if (out.length > 0) {\n                    out.pop();\n                }\n                else {\n                    up++;\n                }\n                break;\n            default:\n                out.push(segment);\n        }\n    }\n    if (leadingSlash == '') {\n        while (up-- > 0) {\n            out.unshift('..');\n        }\n        if (out.length === 0)\n            out.push('.');\n    }\n    return leadingSlash + out.join('/') + trailingSlash;\n}\n/**\n * Takes an array of the parts from split and canonicalizes the path part\n * and then joins all the parts.\n * @param {?} parts\n * @return {?}\n */\nfunction _joinAndCanonicalizePath(parts) {\n    var /** @type {?} */ path = parts[_ComponentIndex.Path];\n    path = path == null ? '' : _removeDotSegments(path);\n    parts[_ComponentIndex.Path] = path;\n    return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);\n}\n/**\n * Resolves a URL.\n * @param {?} base The URL acting as the base URL.\n * @param {?} url\n * @return {?}\n */\nfunction _resolveUrl(base, url) {\n    var /** @type {?} */ parts = _split(encodeURI(url));\n    var /** @type {?} */ baseParts = _split(base);\n    if (parts[_ComponentIndex.Scheme] != null) {\n        return _joinAndCanonicalizePath(parts);\n    }\n    else {\n        parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];\n    }\n    for (var /** @type {?} */ i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {\n        if (parts[i] == null) {\n            parts[i] = baseParts[i];\n        }\n    }\n    if (parts[_ComponentIndex.Path][0] == '/') {\n        return _joinAndCanonicalizePath(parts);\n    }\n    var /** @type {?} */ path = baseParts[_ComponentIndex.Path];\n    if (path == null)\n        path = '/';\n    var /** @type {?} */ index = path.lastIndexOf('/');\n    path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];\n    parts[_ComponentIndex.Path] = path;\n    return _joinAndCanonicalizePath(parts);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar DirectiveNormalizer = (function () {\n    /**\n     * @param {?} _resourceLoader\n     * @param {?} _urlResolver\n     * @param {?} _htmlParser\n     * @param {?} _config\n     */\n    function DirectiveNormalizer(_resourceLoader, _urlResolver, _htmlParser, _config) {\n        this._resourceLoader = _resourceLoader;\n        this._urlResolver = _urlResolver;\n        this._htmlParser = _htmlParser;\n        this._config = _config;\n        this._resourceLoaderCache = new Map();\n    }\n    /**\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.clearCache = function () { this._resourceLoaderCache.clear(); };\n    /**\n     * @param {?} normalizedDirective\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.clearCacheFor = function (normalizedDirective) {\n        var _this = this;\n        if (!normalizedDirective.isComponent) {\n            return;\n        }\n        var /** @type {?} */ template = ((normalizedDirective.template));\n        this._resourceLoaderCache.delete(/** @type {?} */ ((template.templateUrl)));\n        template.externalStylesheets.forEach(function (stylesheet) { _this._resourceLoaderCache.delete(/** @type {?} */ ((stylesheet.moduleUrl))); });\n    };\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype._fetch = function (url) {\n        var /** @type {?} */ result = this._resourceLoaderCache.get(url);\n        if (!result) {\n            result = ((this._resourceLoader.get(url)));\n            this._resourceLoaderCache.set(url, result);\n        }\n        return result;\n    };\n    /**\n     * @param {?} prenormData\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeTemplate = function (prenormData) {\n        var _this = this;\n        var /** @type {?} */ normalizedTemplateSync = ((null));\n        var /** @type {?} */ normalizedTemplateAsync = ((undefined));\n        if (isDefined(prenormData.template)) {\n            if (isDefined(prenormData.templateUrl)) {\n                throw syntaxError(\"'\" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵstringify\"])(prenormData.componentType) + \"' component cannot define both template and templateUrl\");\n            }\n            if (typeof prenormData.template !== 'string') {\n                throw syntaxError(\"The template specified for component \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵstringify\"])(prenormData.componentType) + \" is not a string\");\n            }\n            normalizedTemplateSync = this.normalizeTemplateSync(prenormData);\n            normalizedTemplateAsync = Promise.resolve(/** @type {?} */ ((normalizedTemplateSync)));\n        }\n        else if (isDefined(prenormData.templateUrl)) {\n            if (typeof prenormData.templateUrl !== 'string') {\n                throw syntaxError(\"The templateUrl specified for component \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵstringify\"])(prenormData.componentType) + \" is not a string\");\n            }\n            normalizedTemplateAsync = this.normalizeTemplateAsync(prenormData);\n        }\n        else {\n            throw syntaxError(\"No template specified for component \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵstringify\"])(prenormData.componentType));\n        }\n        if (normalizedTemplateSync && normalizedTemplateSync.styleUrls.length === 0) {\n            // sync case\n            return new SyncAsyncResult(normalizedTemplateSync);\n        }\n        else {\n            // async case\n            return new SyncAsyncResult(null, normalizedTemplateAsync.then(function (normalizedTemplate) { return _this.normalizeExternalStylesheets(normalizedTemplate); }));\n        }\n    };\n    /**\n     * @param {?} prenomData\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeTemplateSync = function (prenomData) {\n        return this.normalizeLoadedTemplate(prenomData, /** @type {?} */ ((prenomData.template)), prenomData.moduleUrl);\n    };\n    /**\n     * @param {?} prenomData\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeTemplateAsync = function (prenomData) {\n        var _this = this;\n        var /** @type {?} */ templateUrl = this._urlResolver.resolve(prenomData.moduleUrl, /** @type {?} */ ((prenomData.templateUrl)));\n        return this._fetch(templateUrl)\n            .then(function (value) { return _this.normalizeLoadedTemplate(prenomData, value, templateUrl); });\n    };\n    /**\n     * @param {?} prenormData\n     * @param {?} template\n     * @param {?} templateAbsUrl\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeLoadedTemplate = function (prenormData, template, templateAbsUrl) {\n        var /** @type {?} */ isInline = !!prenormData.template;\n        var /** @type {?} */ interpolationConfig = InterpolationConfig.fromArray(/** @type {?} */ ((prenormData.interpolation)));\n        var /** @type {?} */ rootNodesAndErrors = this._htmlParser.parse(template, templateSourceUrl({ reference: prenormData.ngModuleType }, { type: { reference: prenormData.componentType } }, { isInline: isInline, templateUrl: templateAbsUrl }), true, interpolationConfig);\n        if (rootNodesAndErrors.errors.length > 0) {\n            var /** @type {?} */ errorString = rootNodesAndErrors.errors.join('\\n');\n            throw syntaxError(\"Template parse errors:\\n\" + errorString);\n        }\n        var /** @type {?} */ templateMetadataStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({\n            styles: prenormData.styles,\n            styleUrls: prenormData.styleUrls,\n            moduleUrl: prenormData.moduleUrl\n        }));\n        var /** @type {?} */ visitor = new TemplatePreparseVisitor();\n        visitAll(visitor, rootNodesAndErrors.rootNodes);\n        var /** @type {?} */ templateStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: visitor.styles, styleUrls: visitor.styleUrls, moduleUrl: templateAbsUrl }));\n        var /** @type {?} */ encapsulation = prenormData.encapsulation;\n        if (encapsulation == null) {\n            encapsulation = this._config.defaultEncapsulation;\n        }\n        var /** @type {?} */ styles = templateMetadataStyles.styles.concat(templateStyles.styles);\n        var /** @type {?} */ styleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);\n        if (encapsulation === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewEncapsulation\"].Emulated && styles.length === 0 &&\n            styleUrls.length === 0) {\n            encapsulation = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewEncapsulation\"].None;\n        }\n        return new CompileTemplateMetadata({\n            encapsulation: encapsulation,\n            template: template,\n            templateUrl: templateAbsUrl, styles: styles, styleUrls: styleUrls,\n            ngContentSelectors: visitor.ngContentSelectors,\n            animations: prenormData.animations,\n            interpolation: prenormData.interpolation, isInline: isInline,\n            externalStylesheets: []\n        });\n    };\n    /**\n     * @param {?} templateMeta\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeExternalStylesheets = function (templateMeta) {\n        return this._loadMissingExternalStylesheets(templateMeta.styleUrls)\n            .then(function (externalStylesheets) { return new CompileTemplateMetadata({\n            encapsulation: templateMeta.encapsulation,\n            template: templateMeta.template,\n            templateUrl: templateMeta.templateUrl,\n            styles: templateMeta.styles,\n            styleUrls: templateMeta.styleUrls,\n            externalStylesheets: externalStylesheets,\n            ngContentSelectors: templateMeta.ngContentSelectors,\n            animations: templateMeta.animations,\n            interpolation: templateMeta.interpolation,\n            isInline: templateMeta.isInline,\n        }); });\n    };\n    /**\n     * @param {?} styleUrls\n     * @param {?=} loadedStylesheets\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype._loadMissingExternalStylesheets = function (styleUrls, loadedStylesheets) {\n        var _this = this;\n        if (loadedStylesheets === void 0) { loadedStylesheets = new Map(); }\n        return Promise\n            .all(styleUrls.filter(function (styleUrl) { return !loadedStylesheets.has(styleUrl); })\n            .map(function (styleUrl) { return _this._fetch(styleUrl).then(function (loadedStyle) {\n            var /** @type {?} */ stylesheet = _this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: [loadedStyle], moduleUrl: styleUrl }));\n            loadedStylesheets.set(styleUrl, stylesheet);\n            return _this._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);\n        }); }))\n            .then(function (_) { return Array.from(loadedStylesheets.values()); });\n    };\n    /**\n     * @param {?} stylesheet\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeStylesheet = function (stylesheet) {\n        var _this = this;\n        var /** @type {?} */ moduleUrl = ((stylesheet.moduleUrl));\n        var /** @type {?} */ allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable)\n            .map(function (url) { return _this._urlResolver.resolve(moduleUrl, url); });\n        var /** @type {?} */ allStyles = stylesheet.styles.map(function (style$$1) {\n            var /** @type {?} */ styleWithImports = extractStyleUrls(_this._urlResolver, moduleUrl, style$$1);\n            allStyleUrls.push.apply(allStyleUrls, styleWithImports.styleUrls);\n            return styleWithImports.style;\n        });\n        return new CompileStylesheetMetadata({ styles: allStyles, styleUrls: allStyleUrls, moduleUrl: moduleUrl });\n    };\n    return DirectiveNormalizer;\n}());\nDirectiveNormalizer.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nDirectiveNormalizer.ctorParameters = function () { return [\n    { type: ResourceLoader, },\n    { type: UrlResolver, },\n    { type: HtmlParser, },\n    { type: CompilerConfig, },\n]; };\nvar TemplatePreparseVisitor = (function () {\n    function TemplatePreparseVisitor() {\n        this.ngContentSelectors = [];\n        this.styles = [];\n        this.styleUrls = [];\n        this.ngNonBindableStackCount = 0;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitElement = function (ast, context) {\n        var /** @type {?} */ preparsedElement = preparseElement(ast);\n        switch (preparsedElement.type) {\n            case PreparsedElementType.NG_CONTENT:\n                if (this.ngNonBindableStackCount === 0) {\n                    this.ngContentSelectors.push(preparsedElement.selectAttr);\n                }\n                break;\n            case PreparsedElementType.STYLE:\n                var /** @type {?} */ textContent_1 = '';\n                ast.children.forEach(function (child) {\n                    if (child instanceof Text) {\n                        textContent_1 += child.value;\n                    }\n                });\n                this.styles.push(textContent_1);\n                break;\n            case PreparsedElementType.STYLESHEET:\n                this.styleUrls.push(preparsedElement.hrefAttr);\n                break;\n            default:\n                break;\n        }\n        if (preparsedElement.nonBindable) {\n            this.ngNonBindableStackCount++;\n        }\n        visitAll(this, ast.children);\n        if (preparsedElement.nonBindable) {\n            this.ngNonBindableStackCount--;\n        }\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitExpansion = function (ast, context) { visitAll(this, ast.cases); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitExpansionCase = function (ast, context) {\n        visitAll(this, ast.expression);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitComment = function (ast, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitAttribute = function (ast, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitText = function (ast, context) { return null; };\n    return TemplatePreparseVisitor;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __assign = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nvar DirectiveResolver = (function () {\n    /**\n     * @param {?=} _reflector\n     */\n    function DirectiveResolver(_reflector) {\n        if (_reflector === void 0) { _reflector = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵreflector\"]; }\n        this._reflector = _reflector;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    DirectiveResolver.prototype.isDirective = function (type) {\n        var /** @type {?} */ typeMetadata = this._reflector.annotations(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"resolveForwardRef\"])(type));\n        return typeMetadata && typeMetadata.some(isDirectiveMetadata);\n    };\n    /**\n     * @param {?} type\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    DirectiveResolver.prototype.resolve = function (type, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ typeMetadata = this._reflector.annotations(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"resolveForwardRef\"])(type));\n        if (typeMetadata) {\n            var /** @type {?} */ metadata = findLast(typeMetadata, isDirectiveMetadata);\n            if (metadata) {\n                var /** @type {?} */ propertyMetadata = this._reflector.propMetadata(type);\n                return this._mergeWithPropertyMetadata(metadata, propertyMetadata, type);\n            }\n        }\n        if (throwIfNotFound) {\n            throw new Error(\"No Directive annotation found on \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵstringify\"])(type));\n        }\n        return null;\n    };\n    /**\n     * @param {?} dm\n     * @param {?} propertyMetadata\n     * @param {?} directiveType\n     * @return {?}\n     */\n    DirectiveResolver.prototype._mergeWithPropertyMetadata = function (dm, propertyMetadata, directiveType) {\n        var /** @type {?} */ inputs = [];\n        var /** @type {?} */ outputs = [];\n        var /** @type {?} */ host = {};\n        var /** @type {?} */ queries = {};\n        Object.keys(propertyMetadata).forEach(function (propName) {\n            var /** @type {?} */ input = findLast(propertyMetadata[propName], function (a) { return a instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Input\"]; });\n            if (input) {\n                if (input.bindingPropertyName) {\n                    inputs.push(propName + \": \" + input.bindingPropertyName);\n                }\n                else {\n                    inputs.push(propName);\n                }\n            }\n            var /** @type {?} */ output = findLast(propertyMetadata[propName], function (a) { return a instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Output\"]; });\n            if (output) {\n                if (output.bindingPropertyName) {\n                    outputs.push(propName + \": \" + output.bindingPropertyName);\n                }\n                else {\n                    outputs.push(propName);\n                }\n            }\n            var /** @type {?} */ hostBindings = propertyMetadata[propName].filter(function (a) { return a && a instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"HostBinding\"]; });\n            hostBindings.forEach(function (hostBinding) {\n                if (hostBinding.hostPropertyName) {\n                    var /** @type {?} */ startWith = hostBinding.hostPropertyName[0];\n                    if (startWith === '(') {\n                        throw new Error(\"@HostBinding can not bind to events. Use @HostListener instead.\");\n                    }\n                    else if (startWith === '[') {\n                        throw new Error(\"@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.\");\n                    }\n                    host[\"[\" + hostBinding.hostPropertyName + \"]\"] = propName;\n                }\n                else {\n                    host[\"[\" + propName + \"]\"] = propName;\n                }\n            });\n            var /** @type {?} */ hostListeners = propertyMetadata[propName].filter(function (a) { return a && a instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"HostListener\"]; });\n            hostListeners.forEach(function (hostListener) {\n                var /** @type {?} */ args = hostListener.args || [];\n                host[\"(\" + hostListener.eventName + \")\"] = propName + \"(\" + args.join(',') + \")\";\n            });\n            var /** @type {?} */ query = findLast(propertyMetadata[propName], function (a) { return a instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Query\"]; });\n            if (query) {\n                queries[propName] = query;\n            }\n        });\n        return this._merge(dm, inputs, outputs, host, queries, directiveType);\n    };\n    /**\n     * @param {?} def\n     * @return {?}\n     */\n    DirectiveResolver.prototype._extractPublicName = function (def) { return splitAtColon(def, [/** @type {?} */ ((null)), def])[1].trim(); };\n    /**\n     * @param {?} bindings\n     * @return {?}\n     */\n    DirectiveResolver.prototype._dedupeBindings = function (bindings) {\n        var /** @type {?} */ names = new Set();\n        var /** @type {?} */ reversedResult = [];\n        // go last to first to allow later entries to overwrite previous entries\n        for (var /** @type {?} */ i = bindings.length - 1; i >= 0; i--) {\n            var /** @type {?} */ binding = bindings[i];\n            var /** @type {?} */ name = this._extractPublicName(binding);\n            if (!names.has(name)) {\n                names.add(name);\n                reversedResult.push(binding);\n            }\n        }\n        return reversedResult.reverse();\n    };\n    /**\n     * @param {?} directive\n     * @param {?} inputs\n     * @param {?} outputs\n     * @param {?} host\n     * @param {?} queries\n     * @param {?} directiveType\n     * @return {?}\n     */\n    DirectiveResolver.prototype._merge = function (directive, inputs, outputs, host, queries, directiveType) {\n        var /** @type {?} */ mergedInputs = this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);\n        var /** @type {?} */ mergedOutputs = this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);\n        var /** @type {?} */ mergedHost = directive.host ? __assign({}, directive.host, host) : host;\n        var /** @type {?} */ mergedQueries = directive.queries ? __assign({}, directive.queries, queries) : queries;\n        if (directive instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Component\"]) {\n            return new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Component\"]({\n                selector: directive.selector,\n                inputs: mergedInputs,\n                outputs: mergedOutputs,\n                host: mergedHost,\n                exportAs: directive.exportAs,\n                moduleId: directive.moduleId,\n                queries: mergedQueries,\n                changeDetection: directive.changeDetection,\n                providers: directive.providers,\n                viewProviders: directive.viewProviders,\n                entryComponents: directive.entryComponents,\n                template: directive.template,\n                templateUrl: directive.templateUrl,\n                styles: directive.styles,\n                styleUrls: directive.styleUrls,\n                encapsulation: directive.encapsulation,\n                animations: directive.animations,\n                interpolation: directive.interpolation\n            });\n        }\n        else {\n            return new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Directive\"]({\n                selector: directive.selector,\n                inputs: mergedInputs,\n                outputs: mergedOutputs,\n                host: mergedHost,\n                exportAs: directive.exportAs,\n                queries: mergedQueries,\n                providers: directive.providers\n            });\n        }\n    };\n    return DirectiveResolver;\n}());\nDirectiveResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nDirectiveResolver.ctorParameters = function () { return [\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵReflectorReader\"], },\n]; };\n/**\n * @param {?} type\n * @return {?}\n */\nfunction isDirectiveMetadata(type) {\n    return type instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Directive\"];\n}\n/**\n * @template T\n * @param {?} arr\n * @param {?} condition\n * @return {?}\n */\nfunction findLast(arr, condition) {\n    for (var /** @type {?} */ i = arr.length - 1; i >= 0; i--) {\n        if (condition(arr[i])) {\n            return arr[i];\n        }\n    }\n    return null;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar STRIP_SRC_FILE_SUFFIXES = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\nvar NG_FACTORY = /\\.ngfactory\\./;\n/**\n * @param {?} filePath\n * @return {?}\n */\nfunction ngfactoryFilePath(filePath) {\n    var /** @type {?} */ urlWithSuffix = splitTypescriptSuffix(filePath);\n    return urlWithSuffix[0] + \".ngfactory\" + urlWithSuffix[1];\n}\n/**\n * @param {?} filePath\n * @return {?}\n */\nfunction stripNgFactory(filePath) {\n    return filePath.replace(NG_FACTORY, '.');\n}\n/**\n * @param {?} filePath\n * @return {?}\n */\nfunction isNgFactoryFile(filePath) {\n    return NG_FACTORY.test(filePath);\n}\n/**\n * @param {?} path\n * @return {?}\n */\nfunction splitTypescriptSuffix(path) {\n    if (path.endsWith('.d.ts')) {\n        return [path.slice(0, -5), '.ts'];\n    }\n    var /** @type {?} */ lastDot = path.lastIndexOf('.');\n    if (lastDot !== -1) {\n        return [path.substring(0, lastDot), path.substring(lastDot)];\n    }\n    return [path, ''];\n}\n/**\n * @param {?} fileName\n * @return {?}\n */\nfunction summaryFileName(fileName) {\n    var /** @type {?} */ fileNameWithoutSuffix = fileName.replace(STRIP_SRC_FILE_SUFFIXES, '');\n    return fileNameWithoutSuffix + \".ngsummary.json\";\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} hook\n * @param {?} token\n * @return {?}\n */\nfunction hasLifecycleHook(hook, token) {\n    return __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵreflector\"].hasLifecycleHook(token, getHookName(hook));\n}\n/**\n * @param {?} hook\n * @return {?}\n */\nfunction getHookName(hook) {\n    switch (hook) {\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].OnInit:\n            return 'ngOnInit';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].OnDestroy:\n            return 'ngOnDestroy';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].DoCheck:\n            return 'ngDoCheck';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].OnChanges:\n            return 'ngOnChanges';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].AfterContentInit:\n            return 'ngAfterContentInit';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].AfterContentChecked:\n            return 'ngAfterContentChecked';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].AfterViewInit:\n            return 'ngAfterViewInit';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].AfterViewChecked:\n            return 'ngAfterViewChecked';\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction _isNgModuleMetadata(obj) {\n    return obj instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"NgModule\"];\n}\n/**\n * Resolves types to {\\@link NgModule}.\n */\nvar NgModuleResolver = (function () {\n    /**\n     * @param {?=} _reflector\n     */\n    function NgModuleResolver(_reflector) {\n        if (_reflector === void 0) { _reflector = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵreflector\"]; }\n        this._reflector = _reflector;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    NgModuleResolver.prototype.isNgModule = function (type) { return this._reflector.annotations(type).some(_isNgModuleMetadata); };\n    /**\n     * @param {?} type\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    NgModuleResolver.prototype.resolve = function (type, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ ngModuleMeta = findLast(this._reflector.annotations(type), _isNgModuleMetadata);\n        if (ngModuleMeta) {\n            return ngModuleMeta;\n        }\n        else {\n            if (throwIfNotFound) {\n                throw new Error(\"No NgModule metadata found for '\" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵstringify\"])(type) + \"'.\");\n            }\n            return null;\n        }\n    };\n    return NgModuleResolver;\n}());\nNgModuleResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nNgModuleResolver.ctorParameters = function () { return [\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵReflectorReader\"], },\n]; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} type\n * @return {?}\n */\nfunction _isPipeMetadata(type) {\n    return type instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Pipe\"];\n}\n/**\n * Resolve a `Type` for {\\@link Pipe}.\n *\n * This interface can be overridden by the application developer to create custom behavior.\n *\n * See {\\@link Compiler}\n */\nvar PipeResolver = (function () {\n    /**\n     * @param {?=} _reflector\n     */\n    function PipeResolver(_reflector) {\n        if (_reflector === void 0) { _reflector = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵreflector\"]; }\n        this._reflector = _reflector;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    PipeResolver.prototype.isPipe = function (type) {\n        var /** @type {?} */ typeMetadata = this._reflector.annotations(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"resolveForwardRef\"])(type));\n        return typeMetadata && typeMetadata.some(_isPipeMetadata);\n    };\n    /**\n     * Return {\\@link Pipe} for a given `Type`.\n     * @param {?} type\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    PipeResolver.prototype.resolve = function (type, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ metas = this._reflector.annotations(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"resolveForwardRef\"])(type));\n        if (metas) {\n            var /** @type {?} */ annotation = findLast(metas, _isPipeMetadata);\n            if (annotation) {\n                return annotation;\n            }\n        }\n        if (throwIfNotFound) {\n            throw new Error(\"No Pipe decorator found on \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵstringify\"])(type));\n        }\n        return null;\n    };\n    return PipeResolver;\n}());\nPipeResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nPipeResolver.ctorParameters = function () { return [\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵReflectorReader\"], },\n]; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar SummaryResolver = (function () {\n    function SummaryResolver() {\n    }\n    /**\n     * @param {?} fileName\n     * @return {?}\n     */\n    SummaryResolver.prototype.isLibraryFile = function (fileName) { return false; };\n    ;\n    /**\n     * @param {?} fileName\n     * @return {?}\n     */\n    SummaryResolver.prototype.getLibraryFileName = function (fileName) { return null; };\n    /**\n     * @param {?} reference\n     * @return {?}\n     */\n    SummaryResolver.prototype.resolveSummary = function (reference) { return null; };\n    ;\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    SummaryResolver.prototype.getSymbolsOf = function (filePath) { return []; };\n    /**\n     * @param {?} reference\n     * @return {?}\n     */\n    SummaryResolver.prototype.getImportAs = function (reference) { return reference; };\n    return SummaryResolver;\n}());\nSummaryResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nSummaryResolver.ctorParameters = function () { return []; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ERROR_COLLECTOR_TOKEN = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"InjectionToken\"]('ErrorCollector');\nvar CompileMetadataResolver = (function () {\n    /**\n     * @param {?} _config\n     * @param {?} _ngModuleResolver\n     * @param {?} _directiveResolver\n     * @param {?} _pipeResolver\n     * @param {?} _summaryResolver\n     * @param {?} _schemaRegistry\n     * @param {?} _directiveNormalizer\n     * @param {?} _console\n     * @param {?} _staticSymbolCache\n     * @param {?=} _reflector\n     * @param {?=} _errorCollector\n     */\n    function CompileMetadataResolver(_config, _ngModuleResolver, _directiveResolver, _pipeResolver, _summaryResolver, _schemaRegistry, _directiveNormalizer, _console, _staticSymbolCache, _reflector, _errorCollector) {\n        if (_reflector === void 0) { _reflector = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵreflector\"]; }\n        this._config = _config;\n        this._ngModuleResolver = _ngModuleResolver;\n        this._directiveResolver = _directiveResolver;\n        this._pipeResolver = _pipeResolver;\n        this._summaryResolver = _summaryResolver;\n        this._schemaRegistry = _schemaRegistry;\n        this._directiveNormalizer = _directiveNormalizer;\n        this._console = _console;\n        this._staticSymbolCache = _staticSymbolCache;\n        this._reflector = _reflector;\n        this._errorCollector = _errorCollector;\n        this._nonNormalizedDirectiveCache = new Map();\n        this._directiveCache = new Map();\n        this._summaryCache = new Map();\n        this._pipeCache = new Map();\n        this._ngModuleCache = new Map();\n        this._ngModuleOfTypes = new Map();\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.clearCacheFor = function (type) {\n        var /** @type {?} */ dirMeta = this._directiveCache.get(type);\n        this._directiveCache.delete(type);\n        this._nonNormalizedDirectiveCache.delete(type);\n        this._summaryCache.delete(type);\n        this._pipeCache.delete(type);\n        this._ngModuleOfTypes.delete(type);\n        // Clear all of the NgModule as they contain transitive information!\n        this._ngModuleCache.clear();\n        if (dirMeta) {\n            this._directiveNormalizer.clearCacheFor(dirMeta);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.clearCache = function () {\n        this._directiveCache.clear();\n        this._nonNormalizedDirectiveCache.clear();\n        this._summaryCache.clear();\n        this._pipeCache.clear();\n        this._ngModuleCache.clear();\n        this._ngModuleOfTypes.clear();\n        this._directiveNormalizer.clearCache();\n    };\n    /**\n     * @param {?} baseType\n     * @param {?} name\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._createProxyClass = function (baseType, name) {\n        var /** @type {?} */ delegate = null;\n        var /** @type {?} */ proxyClass = (function () {\n            if (!delegate) {\n                throw new Error(\"Illegal state: Class \" + name + \" for type \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵstringify\"])(baseType) + \" is not compiled yet!\");\n            }\n            return delegate.apply(this, arguments);\n        });\n        proxyClass.setDelegate = function (d) {\n            delegate = d;\n            ((proxyClass)).prototype = d.prototype;\n        };\n        // Make stringify work correctly\n        ((proxyClass)).overriddenName = name;\n        return proxyClass;\n    };\n    /**\n     * @param {?} dirType\n     * @param {?} name\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getGeneratedClass = function (dirType, name) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), name);\n        }\n        else {\n            return this._createProxyClass(dirType, name);\n        }\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getComponentViewClass = function (dirType) {\n        return this.getGeneratedClass(dirType, viewClassName(dirType, 0));\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getHostComponentViewClass = function (dirType) {\n        return this.getGeneratedClass(dirType, hostViewClassName(dirType));\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getHostComponentType = function (dirType) {\n        var /** @type {?} */ name = identifierName({ reference: dirType }) + \"_Host\";\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(dirType.filePath, name);\n        }\n        else {\n            var /** @type {?} */ HostClass = (function HostClass() { });\n            HostClass.overriddenName = name;\n            return HostClass;\n        }\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getRendererType = function (dirType) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), rendererTypeName(dirType));\n        }\n        else {\n            // returning an object as proxy,\n            // that we fill later during runtime compilation.\n            return ({});\n        }\n    };\n    /**\n     * @param {?} selector\n     * @param {?} dirType\n     * @param {?} inputs\n     * @param {?} outputs\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getComponentFactory = function (selector, dirType, inputs, outputs) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), componentFactoryName(dirType));\n        }\n        else {\n            var /** @type {?} */ hostView = this.getHostComponentViewClass(dirType);\n            // Note: ngContentSelectors will be filled later once the template is\n            // loaded.\n            return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵccf\"])(selector, dirType, /** @type {?} */ (hostView), inputs, outputs, []);\n        }\n    };\n    /**\n     * @param {?} factory\n     * @param {?} ngContentSelectors\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.initComponentFactory = function (factory, ngContentSelectors) {\n        if (!(factory instanceof StaticSymbol)) {\n            (_a = factory.ngContentSelectors).push.apply(_a, ngContentSelectors);\n        }\n        var _a;\n    };\n    /**\n     * @param {?} type\n     * @param {?} kind\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._loadSummary = function (type, kind) {\n        var /** @type {?} */ typeSummary = this._summaryCache.get(type);\n        if (!typeSummary) {\n            var /** @type {?} */ summary = this._summaryResolver.resolveSummary(type);\n            typeSummary = summary ? summary.type : null;\n            this._summaryCache.set(type, typeSummary || null);\n        }\n        return typeSummary && typeSummary.summaryKind === kind ? typeSummary : null;\n    };\n    /**\n     * @param {?} ngModuleType\n     * @param {?} directiveType\n     * @param {?} isSync\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._loadDirectiveMetadata = function (ngModuleType, directiveType, isSync) {\n        var _this = this;\n        if (this._directiveCache.has(directiveType)) {\n            return null;\n        }\n        directiveType = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"resolveForwardRef\"])(directiveType);\n        var _a = ((this.getNonNormalizedDirectiveMetadata(directiveType))), annotation = _a.annotation, metadata = _a.metadata;\n        var /** @type {?} */ createDirectiveMetadata = function (templateMetadata) {\n            var /** @type {?} */ normalizedDirMeta = new CompileDirectiveMetadata({\n                isHost: false,\n                type: metadata.type,\n                isComponent: metadata.isComponent,\n                selector: metadata.selector,\n                exportAs: metadata.exportAs,\n                changeDetection: metadata.changeDetection,\n                inputs: metadata.inputs,\n                outputs: metadata.outputs,\n                hostListeners: metadata.hostListeners,\n                hostProperties: metadata.hostProperties,\n                hostAttributes: metadata.hostAttributes,\n                providers: metadata.providers,\n                viewProviders: metadata.viewProviders,\n                queries: metadata.queries,\n                viewQueries: metadata.viewQueries,\n                entryComponents: metadata.entryComponents,\n                componentViewType: metadata.componentViewType,\n                rendererType: metadata.rendererType,\n                componentFactory: metadata.componentFactory,\n                template: templateMetadata\n            });\n            if (templateMetadata) {\n                _this.initComponentFactory(/** @type {?} */ ((metadata.componentFactory)), templateMetadata.ngContentSelectors);\n            }\n            _this._directiveCache.set(directiveType, normalizedDirMeta);\n            _this._summaryCache.set(directiveType, normalizedDirMeta.toSummary());\n            return normalizedDirMeta;\n        };\n        if (metadata.isComponent) {\n            var /** @type {?} */ template = ((metadata.template));\n            var /** @type {?} */ templateMeta = this._directiveNormalizer.normalizeTemplate({\n                ngModuleType: ngModuleType,\n                componentType: directiveType,\n                moduleUrl: componentModuleUrl(this._reflector, directiveType, annotation),\n                encapsulation: template.encapsulation,\n                template: template.template,\n                templateUrl: template.templateUrl,\n                styles: template.styles,\n                styleUrls: template.styleUrls,\n                animations: template.animations,\n                interpolation: template.interpolation\n            });\n            if (templateMeta.syncResult) {\n                createDirectiveMetadata(templateMeta.syncResult);\n                return null;\n            }\n            else {\n                if (isSync) {\n                    this._reportError(componentStillLoadingError(directiveType), directiveType);\n                    return null;\n                }\n                return ((templateMeta.asyncResult)).then(createDirectiveMetadata);\n            }\n        }\n        else {\n            // directive\n            createDirectiveMetadata(null);\n            return null;\n        }\n    };\n    /**\n     * @param {?} directiveType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getNonNormalizedDirectiveMetadata = function (directiveType) {\n        var _this = this;\n        directiveType = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"resolveForwardRef\"])(directiveType);\n        if (!directiveType) {\n            return null;\n        }\n        var /** @type {?} */ cacheEntry = this._nonNormalizedDirectiveCache.get(directiveType);\n        if (cacheEntry) {\n            return cacheEntry;\n        }\n        var /** @type {?} */ dirMeta = this._directiveResolver.resolve(directiveType, false);\n        if (!dirMeta) {\n            return null;\n        }\n        var /** @type {?} */ nonNormalizedTemplateMetadata = ((undefined));\n        if (dirMeta instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Component\"]) {\n            // component\n            assertArrayOfStrings('styles', dirMeta.styles);\n            assertArrayOfStrings('styleUrls', dirMeta.styleUrls);\n            assertInterpolationSymbols('interpolation', dirMeta.interpolation);\n            var /** @type {?} */ animations = dirMeta.animations;\n            nonNormalizedTemplateMetadata = new CompileTemplateMetadata({\n                encapsulation: noUndefined(dirMeta.encapsulation),\n                template: noUndefined(dirMeta.template),\n                templateUrl: noUndefined(dirMeta.templateUrl),\n                styles: dirMeta.styles || [],\n                styleUrls: dirMeta.styleUrls || [],\n                animations: animations || [],\n                interpolation: noUndefined(dirMeta.interpolation),\n                isInline: !!dirMeta.template,\n                externalStylesheets: [],\n                ngContentSelectors: []\n            });\n        }\n        var /** @type {?} */ changeDetectionStrategy = ((null));\n        var /** @type {?} */ viewProviders = [];\n        var /** @type {?} */ entryComponentMetadata = [];\n        var /** @type {?} */ selector = dirMeta.selector;\n        if (dirMeta instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Component\"]) {\n            // Component\n            changeDetectionStrategy = ((dirMeta.changeDetection));\n            if (dirMeta.viewProviders) {\n                viewProviders = this._getProvidersMetadata(dirMeta.viewProviders, entryComponentMetadata, \"viewProviders for \\\"\" + stringifyType(directiveType) + \"\\\"\", [], directiveType);\n            }\n            if (dirMeta.entryComponents) {\n                entryComponentMetadata = flattenAndDedupeArray(dirMeta.entryComponents)\n                    .map(function (type) { return ((_this._getEntryComponentMetadata(type))); })\n                    .concat(entryComponentMetadata);\n            }\n            if (!selector) {\n                selector = this._schemaRegistry.getDefaultComponentElementName();\n            }\n        }\n        else {\n            // Directive\n            if (!selector) {\n                this._reportError(syntaxError(\"Directive \" + stringifyType(directiveType) + \" has no selector, please add it!\"), directiveType);\n                selector = 'error';\n            }\n        }\n        var /** @type {?} */ providers = [];\n        if (dirMeta.providers != null) {\n            providers = this._getProvidersMetadata(dirMeta.providers, entryComponentMetadata, \"providers for \\\"\" + stringifyType(directiveType) + \"\\\"\", [], directiveType);\n        }\n        var /** @type {?} */ queries = [];\n        var /** @type {?} */ viewQueries = [];\n        if (dirMeta.queries != null) {\n            queries = this._getQueriesMetadata(dirMeta.queries, false, directiveType);\n            viewQueries = this._getQueriesMetadata(dirMeta.queries, true, directiveType);\n        }\n        var /** @type {?} */ metadata = CompileDirectiveMetadata.create({\n            isHost: false,\n            selector: selector,\n            exportAs: noUndefined(dirMeta.exportAs),\n            isComponent: !!nonNormalizedTemplateMetadata,\n            type: this._getTypeMetadata(directiveType),\n            template: nonNormalizedTemplateMetadata,\n            changeDetection: changeDetectionStrategy,\n            inputs: dirMeta.inputs || [],\n            outputs: dirMeta.outputs || [],\n            host: dirMeta.host || {},\n            providers: providers || [],\n            viewProviders: viewProviders || [],\n            queries: queries || [],\n            viewQueries: viewQueries || [],\n            entryComponents: entryComponentMetadata,\n            componentViewType: nonNormalizedTemplateMetadata ? this.getComponentViewClass(directiveType) :\n                null,\n            rendererType: nonNormalizedTemplateMetadata ? this.getRendererType(directiveType) : null,\n            componentFactory: null\n        });\n        if (nonNormalizedTemplateMetadata) {\n            metadata.componentFactory =\n                this.getComponentFactory(selector, directiveType, metadata.inputs, metadata.outputs);\n        }\n        cacheEntry = { metadata: metadata, annotation: dirMeta };\n        this._nonNormalizedDirectiveCache.set(directiveType, cacheEntry);\n        return cacheEntry;\n    };\n    /**\n     * Gets the metadata for the given directive.\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n     * @param {?} directiveType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getDirectiveMetadata = function (directiveType) {\n        var /** @type {?} */ dirMeta = ((this._directiveCache.get(directiveType)));\n        if (!dirMeta) {\n            this._reportError(syntaxError(\"Illegal state: getDirectiveMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Directive \" + stringifyType(directiveType) + \".\"), directiveType);\n        }\n        return dirMeta;\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getDirectiveSummary = function (dirType) {\n        var /** @type {?} */ dirSummary = (this._loadSummary(dirType, CompileSummaryKind.Directive));\n        if (!dirSummary) {\n            this._reportError(syntaxError(\"Illegal state: Could not load the summary for directive \" + stringifyType(dirType) + \".\"), dirType);\n        }\n        return dirSummary;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.isDirective = function (type) { return this._directiveResolver.isDirective(type); };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.isPipe = function (type) { return this._pipeResolver.isPipe(type); };\n    /**\n     * @param {?} moduleType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getNgModuleSummary = function (moduleType) {\n        var /** @type {?} */ moduleSummary = (this._loadSummary(moduleType, CompileSummaryKind.NgModule));\n        if (!moduleSummary) {\n            var /** @type {?} */ moduleMeta = this.getNgModuleMetadata(moduleType, false);\n            moduleSummary = moduleMeta ? moduleMeta.toSummary() : null;\n            if (moduleSummary) {\n                this._summaryCache.set(moduleType, moduleSummary);\n            }\n        }\n        return moduleSummary;\n    };\n    /**\n     * Loads the declared directives and pipes of an NgModule.\n     * @param {?} moduleType\n     * @param {?} isSync\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.loadNgModuleDirectiveAndPipeMetadata = function (moduleType, isSync, throwIfNotFound) {\n        var _this = this;\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ ngModule = this.getNgModuleMetadata(moduleType, throwIfNotFound);\n        var /** @type {?} */ loading = [];\n        if (ngModule) {\n            ngModule.declaredDirectives.forEach(function (id) {\n                var /** @type {?} */ promise = _this._loadDirectiveMetadata(moduleType, id.reference, isSync);\n                if (promise) {\n                    loading.push(promise);\n                }\n            });\n            ngModule.declaredPipes.forEach(function (id) { return _this._loadPipeMetadata(id.reference); });\n        }\n        return Promise.all(loading);\n    };\n    /**\n     * @param {?} moduleType\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getNgModuleMetadata = function (moduleType, throwIfNotFound) {\n        var _this = this;\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        moduleType = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"resolveForwardRef\"])(moduleType);\n        var /** @type {?} */ compileMeta = this._ngModuleCache.get(moduleType);\n        if (compileMeta) {\n            return compileMeta;\n        }\n        var /** @type {?} */ meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);\n        if (!meta) {\n            return null;\n        }\n        var /** @type {?} */ declaredDirectives = [];\n        var /** @type {?} */ exportedNonModuleIdentifiers = [];\n        var /** @type {?} */ declaredPipes = [];\n        var /** @type {?} */ importedModules = [];\n        var /** @type {?} */ exportedModules = [];\n        var /** @type {?} */ providers = [];\n        var /** @type {?} */ entryComponents = [];\n        var /** @type {?} */ bootstrapComponents = [];\n        var /** @type {?} */ schemas = [];\n        if (meta.imports) {\n            flattenAndDedupeArray(meta.imports).forEach(function (importedType) {\n                var /** @type {?} */ importedModuleType = ((undefined));\n                if (isValidType(importedType)) {\n                    importedModuleType = importedType;\n                }\n                else if (importedType && importedType.ngModule) {\n                    var /** @type {?} */ moduleWithProviders = importedType;\n                    importedModuleType = moduleWithProviders.ngModule;\n                    if (moduleWithProviders.providers) {\n                        providers.push.apply(providers, _this._getProvidersMetadata(moduleWithProviders.providers, entryComponents, \"provider for the NgModule '\" + stringifyType(importedModuleType) + \"'\", [], importedType));\n                    }\n                }\n                if (importedModuleType) {\n                    if (_this._checkSelfImport(moduleType, importedModuleType))\n                        return;\n                    var /** @type {?} */ importedModuleSummary = _this.getNgModuleSummary(importedModuleType);\n                    if (!importedModuleSummary) {\n                        _this._reportError(syntaxError(\"Unexpected \" + _this._getTypeDescriptor(importedType) + \" '\" + stringifyType(importedType) + \"' imported by the module '\" + stringifyType(moduleType) + \"'. Please add a @NgModule annotation.\"), moduleType);\n                        return;\n                    }\n                    importedModules.push(importedModuleSummary);\n                }\n                else {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(importedType) + \"' imported by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n            });\n        }\n        if (meta.exports) {\n            flattenAndDedupeArray(meta.exports).forEach(function (exportedType) {\n                if (!isValidType(exportedType)) {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(exportedType) + \"' exported by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                var /** @type {?} */ exportedModuleSummary = _this.getNgModuleSummary(exportedType);\n                if (exportedModuleSummary) {\n                    exportedModules.push(exportedModuleSummary);\n                }\n                else {\n                    exportedNonModuleIdentifiers.push(_this._getIdentifierMetadata(exportedType));\n                }\n            });\n        }\n        // Note: This will be modified later, so we rely on\n        // getting a new instance every time!\n        var /** @type {?} */ transitiveModule = this._getTransitiveNgModuleMetadata(importedModules, exportedModules);\n        if (meta.declarations) {\n            flattenAndDedupeArray(meta.declarations).forEach(function (declaredType) {\n                if (!isValidType(declaredType)) {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(declaredType) + \"' declared by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                var /** @type {?} */ declaredIdentifier = _this._getIdentifierMetadata(declaredType);\n                if (_this._directiveResolver.isDirective(declaredType)) {\n                    transitiveModule.addDirective(declaredIdentifier);\n                    declaredDirectives.push(declaredIdentifier);\n                    _this._addTypeToModule(declaredType, moduleType);\n                }\n                else if (_this._pipeResolver.isPipe(declaredType)) {\n                    transitiveModule.addPipe(declaredIdentifier);\n                    transitiveModule.pipes.push(declaredIdentifier);\n                    declaredPipes.push(declaredIdentifier);\n                    _this._addTypeToModule(declaredType, moduleType);\n                }\n                else {\n                    _this._reportError(syntaxError(\"Unexpected \" + _this._getTypeDescriptor(declaredType) + \" '\" + stringifyType(declaredType) + \"' declared by the module '\" + stringifyType(moduleType) + \"'. Please add a @Pipe/@Directive/@Component annotation.\"), moduleType);\n                    return;\n                }\n            });\n        }\n        var /** @type {?} */ exportedDirectives = [];\n        var /** @type {?} */ exportedPipes = [];\n        exportedNonModuleIdentifiers.forEach(function (exportedId) {\n            if (transitiveModule.directivesSet.has(exportedId.reference)) {\n                exportedDirectives.push(exportedId);\n                transitiveModule.addExportedDirective(exportedId);\n            }\n            else if (transitiveModule.pipesSet.has(exportedId.reference)) {\n                exportedPipes.push(exportedId);\n                transitiveModule.addExportedPipe(exportedId);\n            }\n            else {\n                _this._reportError(syntaxError(\"Can't export \" + _this._getTypeDescriptor(exportedId.reference) + \" \" + stringifyType(exportedId.reference) + \" from \" + stringifyType(moduleType) + \" as it was neither declared nor imported!\"), moduleType);\n                return;\n            }\n        });\n        // The providers of the module have to go last\n        // so that they overwrite any other provider we already added.\n        if (meta.providers) {\n            providers.push.apply(providers, this._getProvidersMetadata(meta.providers, entryComponents, \"provider for the NgModule '\" + stringifyType(moduleType) + \"'\", [], moduleType));\n        }\n        if (meta.entryComponents) {\n            entryComponents.push.apply(entryComponents, flattenAndDedupeArray(meta.entryComponents)\n                .map(function (type) { return ((_this._getEntryComponentMetadata(type))); }));\n        }\n        if (meta.bootstrap) {\n            flattenAndDedupeArray(meta.bootstrap).forEach(function (type) {\n                if (!isValidType(type)) {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(type) + \"' used in the bootstrap property of module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                bootstrapComponents.push(_this._getIdentifierMetadata(type));\n            });\n        }\n        entryComponents.push.apply(entryComponents, bootstrapComponents.map(function (type) { return ((_this._getEntryComponentMetadata(type.reference))); }));\n        if (meta.schemas) {\n            schemas.push.apply(schemas, flattenAndDedupeArray(meta.schemas));\n        }\n        compileMeta = new CompileNgModuleMetadata({\n            type: this._getTypeMetadata(moduleType),\n            providers: providers,\n            entryComponents: entryComponents,\n            bootstrapComponents: bootstrapComponents,\n            schemas: schemas,\n            declaredDirectives: declaredDirectives,\n            exportedDirectives: exportedDirectives,\n            declaredPipes: declaredPipes,\n            exportedPipes: exportedPipes,\n            importedModules: importedModules,\n            exportedModules: exportedModules,\n            transitiveModule: transitiveModule,\n            id: meta.id || null,\n        });\n        entryComponents.forEach(function (id) { return transitiveModule.addEntryComponent(id); });\n        providers.forEach(function (provider) { return transitiveModule.addProvider(provider, /** @type {?} */ ((compileMeta)).type); });\n        transitiveModule.addModule(compileMeta.type);\n        this._ngModuleCache.set(moduleType, compileMeta);\n        return compileMeta;\n    };\n    /**\n     * @param {?} moduleType\n     * @param {?} importedModuleType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._checkSelfImport = function (moduleType, importedModuleType) {\n        if (moduleType === importedModuleType) {\n            this._reportError(syntaxError(\"'\" + stringifyType(moduleType) + \"' module can't import itself\"), moduleType);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getTypeDescriptor = function (type) {\n        if (this._directiveResolver.isDirective(type)) {\n            return 'directive';\n        }\n        if (this._pipeResolver.isPipe(type)) {\n            return 'pipe';\n        }\n        if (this._ngModuleResolver.isNgModule(type)) {\n            return 'module';\n        }\n        if (((type)).provide) {\n            return 'provider';\n        }\n        return 'value';\n    };\n    /**\n     * @param {?} type\n     * @param {?} moduleType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._addTypeToModule = function (type, moduleType) {\n        var /** @type {?} */ oldModule = this._ngModuleOfTypes.get(type);\n        if (oldModule && oldModule !== moduleType) {\n            this._reportError(syntaxError(\"Type \" + stringifyType(type) + \" is part of the declarations of 2 modules: \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \"! \" +\n                (\"Please consider moving \" + stringifyType(type) + \" to a higher module that imports \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \". \") +\n                (\"You can also create a new NgModule that exports and includes \" + stringifyType(type) + \" then import that NgModule in \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \".\")), moduleType);\n            return;\n        }\n        this._ngModuleOfTypes.set(type, moduleType);\n    };\n    /**\n     * @param {?} importedModules\n     * @param {?} exportedModules\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getTransitiveNgModuleMetadata = function (importedModules, exportedModules) {\n        // collect `providers` / `entryComponents` from all imported and all exported modules\n        var /** @type {?} */ result = new TransitiveCompileNgModuleMetadata();\n        var /** @type {?} */ modulesByToken = new Map();\n        importedModules.concat(exportedModules).forEach(function (modSummary) {\n            modSummary.modules.forEach(function (mod) { return result.addModule(mod); });\n            modSummary.entryComponents.forEach(function (comp) { return result.addEntryComponent(comp); });\n            var /** @type {?} */ addedTokens = new Set();\n            modSummary.providers.forEach(function (entry) {\n                var /** @type {?} */ tokenRef = tokenReference(entry.provider.token);\n                var /** @type {?} */ prevModules = modulesByToken.get(tokenRef);\n                if (!prevModules) {\n                    prevModules = new Set();\n                    modulesByToken.set(tokenRef, prevModules);\n                }\n                var /** @type {?} */ moduleRef = entry.module.reference;\n                // Note: the providers of one module may still contain multiple providers\n                // per token (e.g. for multi providers), and we need to preserve these.\n                if (addedTokens.has(tokenRef) || !prevModules.has(moduleRef)) {\n                    prevModules.add(moduleRef);\n                    addedTokens.add(tokenRef);\n                    result.addProvider(entry.provider, entry.module);\n                }\n            });\n        });\n        exportedModules.forEach(function (modSummary) {\n            modSummary.exportedDirectives.forEach(function (id) { return result.addExportedDirective(id); });\n            modSummary.exportedPipes.forEach(function (id) { return result.addExportedPipe(id); });\n        });\n        importedModules.forEach(function (modSummary) {\n            modSummary.exportedDirectives.forEach(function (id) { return result.addDirective(id); });\n            modSummary.exportedPipes.forEach(function (id) { return result.addPipe(id); });\n        });\n        return result;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getIdentifierMetadata = function (type) {\n        type = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"resolveForwardRef\"])(type);\n        return { reference: type };\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.isInjectable = function (type) {\n        var /** @type {?} */ annotations = this._reflector.annotations(type);\n        // Note: We need an exact check here as @Component / @Directive / ... inherit\n        // from @CompilerInjectable!\n        return annotations.some(function (ann) { return ann.constructor === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Injectable\"]; });\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getInjectableSummary = function (type) {\n        return {\n            summaryKind: CompileSummaryKind.Injectable,\n            type: this._getTypeMetadata(type, null, false)\n        };\n    };\n    /**\n     * @param {?} type\n     * @param {?=} dependencies\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getInjectableMetadata = function (type, dependencies) {\n        if (dependencies === void 0) { dependencies = null; }\n        var /** @type {?} */ typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);\n        if (typeSummary) {\n            return typeSummary.type;\n        }\n        return this._getTypeMetadata(type, dependencies);\n    };\n    /**\n     * @param {?} type\n     * @param {?=} dependencies\n     * @param {?=} throwOnUnknownDeps\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getTypeMetadata = function (type, dependencies, throwOnUnknownDeps) {\n        if (dependencies === void 0) { dependencies = null; }\n        if (throwOnUnknownDeps === void 0) { throwOnUnknownDeps = true; }\n        var /** @type {?} */ identifier = this._getIdentifierMetadata(type);\n        return {\n            reference: identifier.reference,\n            diDeps: this._getDependenciesMetadata(identifier.reference, dependencies, throwOnUnknownDeps),\n            lifecycleHooks: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLIFECYCLE_HOOKS_VALUES\"].filter(function (hook) { return hasLifecycleHook(hook, identifier.reference); }),\n        };\n    };\n    /**\n     * @param {?} factory\n     * @param {?=} dependencies\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getFactoryMetadata = function (factory, dependencies) {\n        if (dependencies === void 0) { dependencies = null; }\n        factory = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"resolveForwardRef\"])(factory);\n        return { reference: factory, diDeps: this._getDependenciesMetadata(factory, dependencies) };\n    };\n    /**\n     * Gets the metadata for the given pipe.\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n     * @param {?} pipeType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getPipeMetadata = function (pipeType) {\n        var /** @type {?} */ pipeMeta = this._pipeCache.get(pipeType);\n        if (!pipeMeta) {\n            this._reportError(syntaxError(\"Illegal state: getPipeMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Pipe \" + stringifyType(pipeType) + \".\"), pipeType);\n        }\n        return pipeMeta || null;\n    };\n    /**\n     * @param {?} pipeType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getPipeSummary = function (pipeType) {\n        var /** @type {?} */ pipeSummary = (this._loadSummary(pipeType, CompileSummaryKind.Pipe));\n        if (!pipeSummary) {\n            this._reportError(syntaxError(\"Illegal state: Could not load the summary for pipe \" + stringifyType(pipeType) + \".\"), pipeType);\n        }\n        return pipeSummary;\n    };\n    /**\n     * @param {?} pipeType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getOrLoadPipeMetadata = function (pipeType) {\n        var /** @type {?} */ pipeMeta = this._pipeCache.get(pipeType);\n        if (!pipeMeta) {\n            pipeMeta = this._loadPipeMetadata(pipeType);\n        }\n        return pipeMeta;\n    };\n    /**\n     * @param {?} pipeType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._loadPipeMetadata = function (pipeType) {\n        pipeType = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"resolveForwardRef\"])(pipeType);\n        var /** @type {?} */ pipeAnnotation = ((this._pipeResolver.resolve(pipeType)));\n        var /** @type {?} */ pipeMeta = new CompilePipeMetadata({\n            type: this._getTypeMetadata(pipeType),\n            name: pipeAnnotation.name,\n            pure: !!pipeAnnotation.pure\n        });\n        this._pipeCache.set(pipeType, pipeMeta);\n        this._summaryCache.set(pipeType, pipeMeta.toSummary());\n        return pipeMeta;\n    };\n    /**\n     * @param {?} typeOrFunc\n     * @param {?} dependencies\n     * @param {?=} throwOnUnknownDeps\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getDependenciesMetadata = function (typeOrFunc, dependencies, throwOnUnknownDeps) {\n        var _this = this;\n        if (throwOnUnknownDeps === void 0) { throwOnUnknownDeps = true; }\n        var /** @type {?} */ hasUnknownDeps = false;\n        var /** @type {?} */ params = dependencies || this._reflector.parameters(typeOrFunc) || [];\n        var /** @type {?} */ dependenciesMetadata = params.map(function (param) {\n            var /** @type {?} */ isAttribute = false;\n            var /** @type {?} */ isHost = false;\n            var /** @type {?} */ isSelf = false;\n            var /** @type {?} */ isSkipSelf = false;\n            var /** @type {?} */ isOptional = false;\n            var /** @type {?} */ token = null;\n            if (Array.isArray(param)) {\n                param.forEach(function (paramEntry) {\n                    if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Host\"]) {\n                        isHost = true;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Self\"]) {\n                        isSelf = true;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"SkipSelf\"]) {\n                        isSkipSelf = true;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Optional\"]) {\n                        isOptional = true;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Attribute\"]) {\n                        isAttribute = true;\n                        token = paramEntry.attributeName;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Inject\"]) {\n                        token = paramEntry.token;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"InjectionToken\"]) {\n                        token = paramEntry;\n                    }\n                    else if (isValidType(paramEntry) && token == null) {\n                        token = paramEntry;\n                    }\n                });\n            }\n            else {\n                token = param;\n            }\n            if (token == null) {\n                hasUnknownDeps = true;\n                return ((null));\n            }\n            return {\n                isAttribute: isAttribute,\n                isHost: isHost,\n                isSelf: isSelf,\n                isSkipSelf: isSkipSelf,\n                isOptional: isOptional,\n                token: _this._getTokenMetadata(token)\n            };\n        });\n        if (hasUnknownDeps) {\n            var /** @type {?} */ depsTokens = dependenciesMetadata.map(function (dep) { return dep ? stringifyType(dep.token) : '?'; }).join(', ');\n            var /** @type {?} */ message = \"Can't resolve all parameters for \" + stringifyType(typeOrFunc) + \": (\" + depsTokens + \").\";\n            if (throwOnUnknownDeps) {\n                this._reportError(syntaxError(message), typeOrFunc);\n            }\n            else {\n                this._console.warn(\"Warning: \" + message + \" This will become an error in Angular v5.x\");\n            }\n        }\n        return dependenciesMetadata;\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getTokenMetadata = function (token) {\n        token = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"resolveForwardRef\"])(token);\n        var /** @type {?} */ compileToken;\n        if (typeof token === 'string') {\n            compileToken = { value: token };\n        }\n        else {\n            compileToken = { identifier: { reference: token } };\n        }\n        return compileToken;\n    };\n    /**\n     * @param {?} providers\n     * @param {?} targetEntryComponents\n     * @param {?=} debugInfo\n     * @param {?=} compileProviders\n     * @param {?=} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getProvidersMetadata = function (providers, targetEntryComponents, debugInfo, compileProviders, type) {\n        var _this = this;\n        if (compileProviders === void 0) { compileProviders = []; }\n        providers.forEach(function (provider, providerIdx) {\n            if (Array.isArray(provider)) {\n                _this._getProvidersMetadata(provider, targetEntryComponents, debugInfo, compileProviders);\n            }\n            else {\n                provider = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"resolveForwardRef\"])(provider);\n                var /** @type {?} */ providerMeta = ((undefined));\n                if (provider && typeof provider === 'object' && provider.hasOwnProperty('provide')) {\n                    _this._validateProvider(provider);\n                    providerMeta = new ProviderMeta(provider.provide, provider);\n                }\n                else if (isValidType(provider)) {\n                    providerMeta = new ProviderMeta(provider, { useClass: provider });\n                }\n                else if (provider === void 0) {\n                    _this._reportError(syntaxError(\"Encountered undefined provider! Usually this means you have a circular dependencies (might be caused by using 'barrel' index.ts files.\"));\n                    return;\n                }\n                else {\n                    var /** @type {?} */ providersInfo = ((providers.reduce(function (soFar, seenProvider, seenProviderIdx) {\n                        if (seenProviderIdx < providerIdx) {\n                            soFar.push(\"\" + stringifyType(seenProvider));\n                        }\n                        else if (seenProviderIdx == providerIdx) {\n                            soFar.push(\"?\" + stringifyType(seenProvider) + \"?\");\n                        }\n                        else if (seenProviderIdx == providerIdx + 1) {\n                            soFar.push('...');\n                        }\n                        return soFar;\n                    }, [])))\n                        .join(', ');\n                    _this._reportError(syntaxError(\"Invalid \" + (debugInfo ? debugInfo : 'provider') + \" - only instances of Provider and Type are allowed, got: [\" + providersInfo + \"]\"), type);\n                    return;\n                }\n                if (providerMeta.token === resolveIdentifier(Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS)) {\n                    targetEntryComponents.push.apply(targetEntryComponents, _this._getEntryComponentsFromProvider(providerMeta, type));\n                }\n                else {\n                    compileProviders.push(_this.getProviderMetadata(providerMeta));\n                }\n            }\n        });\n        return compileProviders;\n    };\n    /**\n     * @param {?} provider\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._validateProvider = function (provider) {\n        if (provider.hasOwnProperty('useClass') && provider.useClass == null) {\n            this._reportError(syntaxError(\"Invalid provider for \" + stringifyType(provider.provide) + \". useClass cannot be \" + provider.useClass + \".\\n           Usually it happens when:\\n           1. There's a circular dependency (might be caused by using index.ts (barrel) files).\\n           2. Class was used before it was declared. Use forwardRef in this case.\"));\n        }\n    };\n    /**\n     * @param {?} provider\n     * @param {?=} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getEntryComponentsFromProvider = function (provider, type) {\n        var _this = this;\n        var /** @type {?} */ components = [];\n        var /** @type {?} */ collectedIdentifiers = [];\n        if (provider.useFactory || provider.useExisting || provider.useClass) {\n            this._reportError(syntaxError(\"The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!\"), type);\n            return [];\n        }\n        if (!provider.multi) {\n            this._reportError(syntaxError(\"The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!\"), type);\n            return [];\n        }\n        extractIdentifiers(provider.useValue, collectedIdentifiers);\n        collectedIdentifiers.forEach(function (identifier) {\n            var /** @type {?} */ entry = _this._getEntryComponentMetadata(identifier.reference, false);\n            if (entry) {\n                components.push(entry);\n            }\n        });\n        return components;\n    };\n    /**\n     * @param {?} dirType\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getEntryComponentMetadata = function (dirType, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ dirMeta = this.getNonNormalizedDirectiveMetadata(dirType);\n        if (dirMeta && dirMeta.metadata.isComponent) {\n            return { componentType: dirType, componentFactory: /** @type {?} */ ((dirMeta.metadata.componentFactory)) };\n        }\n        var /** @type {?} */ dirSummary = (this._loadSummary(dirType, CompileSummaryKind.Directive));\n        if (dirSummary && dirSummary.isComponent) {\n            return { componentType: dirType, componentFactory: /** @type {?} */ ((dirSummary.componentFactory)) };\n        }\n        if (throwIfNotFound) {\n            throw syntaxError(dirType.name + \" cannot be used as an entry component.\");\n        }\n        return null;\n    };\n    /**\n     * @param {?} provider\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getProviderMetadata = function (provider) {\n        var /** @type {?} */ compileDeps = ((undefined));\n        var /** @type {?} */ compileTypeMetadata = ((null));\n        var /** @type {?} */ compileFactoryMetadata = ((null));\n        var /** @type {?} */ token = this._getTokenMetadata(provider.token);\n        if (provider.useClass) {\n            compileTypeMetadata = this._getInjectableMetadata(provider.useClass, provider.dependencies);\n            compileDeps = compileTypeMetadata.diDeps;\n            if (provider.token === provider.useClass) {\n                // use the compileTypeMetadata as it contains information about lifecycleHooks...\n                token = { identifier: compileTypeMetadata };\n            }\n        }\n        else if (provider.useFactory) {\n            compileFactoryMetadata = this._getFactoryMetadata(provider.useFactory, provider.dependencies);\n            compileDeps = compileFactoryMetadata.diDeps;\n        }\n        return {\n            token: token,\n            useClass: compileTypeMetadata,\n            useValue: provider.useValue,\n            useFactory: compileFactoryMetadata,\n            useExisting: provider.useExisting ? this._getTokenMetadata(provider.useExisting) : undefined,\n            deps: compileDeps,\n            multi: provider.multi\n        };\n    };\n    /**\n     * @param {?} queries\n     * @param {?} isViewQuery\n     * @param {?} directiveType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getQueriesMetadata = function (queries, isViewQuery, directiveType) {\n        var _this = this;\n        var /** @type {?} */ res = [];\n        Object.keys(queries).forEach(function (propertyName) {\n            var /** @type {?} */ query = queries[propertyName];\n            if (query.isViewQuery === isViewQuery) {\n                res.push(_this._getQueryMetadata(query, propertyName, directiveType));\n            }\n        });\n        return res;\n    };\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._queryVarBindings = function (selector) { return selector.split(/\\s*,\\s*/); };\n    /**\n     * @param {?} q\n     * @param {?} propertyName\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getQueryMetadata = function (q, propertyName, typeOrFunc) {\n        var _this = this;\n        var /** @type {?} */ selectors;\n        if (typeof q.selector === 'string') {\n            selectors =\n                this._queryVarBindings(q.selector).map(function (varName) { return _this._getTokenMetadata(varName); });\n        }\n        else {\n            if (!q.selector) {\n                this._reportError(syntaxError(\"Can't construct a query for the property \\\"\" + propertyName + \"\\\" of \\\"\" + stringifyType(typeOrFunc) + \"\\\" since the query selector wasn't defined.\"), typeOrFunc);\n                selectors = [];\n            }\n            else {\n                selectors = [this._getTokenMetadata(q.selector)];\n            }\n        }\n        return {\n            selectors: selectors,\n            first: q.first,\n            descendants: q.descendants, propertyName: propertyName,\n            read: q.read ? this._getTokenMetadata(q.read) : ((null))\n        };\n    };\n    /**\n     * @param {?} error\n     * @param {?=} type\n     * @param {?=} otherType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._reportError = function (error, type, otherType) {\n        if (this._errorCollector) {\n            this._errorCollector(error, type);\n            if (otherType) {\n                this._errorCollector(error, otherType);\n            }\n        }\n        else {\n            throw error;\n        }\n    };\n    return CompileMetadataResolver;\n}());\nCompileMetadataResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nCompileMetadataResolver.ctorParameters = function () { return [\n    { type: CompilerConfig, },\n    { type: NgModuleResolver, },\n    { type: DirectiveResolver, },\n    { type: PipeResolver, },\n    { type: SummaryResolver, },\n    { type: ElementSchemaRegistry, },\n    { type: DirectiveNormalizer, },\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵConsole\"], },\n    { type: StaticSymbolCache, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Optional\"] },] },\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵReflectorReader\"], },\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Optional\"] }, { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Inject\"], args: [ERROR_COLLECTOR_TOKEN,] },] },\n]; };\n/**\n * @param {?} tree\n * @param {?=} out\n * @return {?}\n */\nfunction flattenArray(tree, out) {\n    if (out === void 0) { out = []; }\n    if (tree) {\n        for (var /** @type {?} */ i = 0; i < tree.length; i++) {\n            var /** @type {?} */ item = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"resolveForwardRef\"])(tree[i]);\n            if (Array.isArray(item)) {\n                flattenArray(item, out);\n            }\n            else {\n                out.push(item);\n            }\n        }\n    }\n    return out;\n}\n/**\n * @param {?} array\n * @return {?}\n */\nfunction dedupeArray(array) {\n    if (array) {\n        return Array.from(new Set(array));\n    }\n    return [];\n}\n/**\n * @param {?} tree\n * @return {?}\n */\nfunction flattenAndDedupeArray(tree) {\n    return dedupeArray(flattenArray(tree));\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isValidType(value) {\n    return (value instanceof StaticSymbol) || (value instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Type\"]);\n}\n/**\n * @param {?} reflector\n * @param {?} type\n * @param {?} cmpMetadata\n * @return {?}\n */\nfunction componentModuleUrl(reflector, type, cmpMetadata) {\n    if (type instanceof StaticSymbol) {\n        return reflector.resourceUri(type);\n    }\n    var /** @type {?} */ moduleId = cmpMetadata.moduleId;\n    if (typeof moduleId === 'string') {\n        var /** @type {?} */ scheme = getUrlScheme(moduleId);\n        return scheme ? moduleId : \"package:\" + moduleId + MODULE_SUFFIX;\n    }\n    else if (moduleId !== null && moduleId !== void 0) {\n        throw syntaxError(\"moduleId should be a string in \\\"\" + stringifyType(type) + \"\\\". See https://goo.gl/wIDDiL for more information.\\n\" +\n            \"If you're using Webpack you should inline the template and the styles, see https://goo.gl/X2J8zc.\");\n    }\n    return ((reflector.importUri(type)));\n}\n/**\n * @param {?} value\n * @param {?} targetIdentifiers\n * @return {?}\n */\nfunction extractIdentifiers(value, targetIdentifiers) {\n    visitValue(value, new _CompileValueConverter(), targetIdentifiers);\n}\nvar _CompileValueConverter = (function (_super) {\n    __extends(_CompileValueConverter, _super);\n    function _CompileValueConverter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} value\n     * @param {?} targetIdentifiers\n     * @return {?}\n     */\n    _CompileValueConverter.prototype.visitOther = function (value, targetIdentifiers) {\n        targetIdentifiers.push({ reference: value });\n    };\n    return _CompileValueConverter;\n}(ValueTransformer));\n/**\n * @param {?} type\n * @return {?}\n */\nfunction stringifyType(type) {\n    if (type instanceof StaticSymbol) {\n        return type.name + \" in \" + type.filePath;\n    }\n    else {\n        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵstringify\"])(type);\n    }\n}\n/**\n * Indicates that a component is still being loaded in a synchronous compile.\n * @param {?} compType\n * @return {?}\n */\nfunction componentStillLoadingError(compType) {\n    var /** @type {?} */ error = Error(\"Can't compile synchronously as \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵstringify\"])(compType) + \" is still being loaded!\");\n    ((error))[__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵERROR_COMPONENT_TYPE\"]] = compType;\n    return error;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TypeModifier = {};\nTypeModifier.Const = 0;\nTypeModifier[TypeModifier.Const] = \"Const\";\n/**\n * @abstract\n */\nvar Type$1 = (function () {\n    /**\n     * @param {?=} modifiers\n     */\n    function Type$1(modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        this.modifiers = modifiers;\n        if (!modifiers) {\n            this.modifiers = [];\n        }\n    }\n    /**\n     * @abstract\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Type$1.prototype.visitType = function (visitor, context) { };\n    /**\n     * @param {?} modifier\n     * @return {?}\n     */\n    Type$1.prototype.hasModifier = function (modifier) { return ((this.modifiers)).indexOf(modifier) !== -1; };\n    return Type$1;\n}());\nvar BuiltinTypeName = {};\nBuiltinTypeName.Dynamic = 0;\nBuiltinTypeName.Bool = 1;\nBuiltinTypeName.String = 2;\nBuiltinTypeName.Int = 3;\nBuiltinTypeName.Number = 4;\nBuiltinTypeName.Function = 5;\nBuiltinTypeName.Inferred = 6;\nBuiltinTypeName[BuiltinTypeName.Dynamic] = \"Dynamic\";\nBuiltinTypeName[BuiltinTypeName.Bool] = \"Bool\";\nBuiltinTypeName[BuiltinTypeName.String] = \"String\";\nBuiltinTypeName[BuiltinTypeName.Int] = \"Int\";\nBuiltinTypeName[BuiltinTypeName.Number] = \"Number\";\nBuiltinTypeName[BuiltinTypeName.Function] = \"Function\";\nBuiltinTypeName[BuiltinTypeName.Inferred] = \"Inferred\";\nvar BuiltinType = (function (_super) {\n    __extends(BuiltinType, _super);\n    /**\n     * @param {?} name\n     * @param {?=} modifiers\n     */\n    function BuiltinType(name, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.name = name;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BuiltinType.prototype.visitType = function (visitor, context) {\n        return visitor.visitBuiltintType(this, context);\n    };\n    return BuiltinType;\n}(Type$1));\nvar ExpressionType = (function (_super) {\n    __extends(ExpressionType, _super);\n    /**\n     * @param {?} value\n     * @param {?=} modifiers\n     */\n    function ExpressionType(value, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ExpressionType.prototype.visitType = function (visitor, context) {\n        return visitor.visitExpressionType(this, context);\n    };\n    return ExpressionType;\n}(Type$1));\nvar ArrayType = (function (_super) {\n    __extends(ArrayType, _super);\n    /**\n     * @param {?} of\n     * @param {?=} modifiers\n     */\n    function ArrayType(of, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.of = of;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ArrayType.prototype.visitType = function (visitor, context) {\n        return visitor.visitArrayType(this, context);\n    };\n    return ArrayType;\n}(Type$1));\nvar MapType = (function (_super) {\n    __extends(MapType, _super);\n    /**\n     * @param {?} valueType\n     * @param {?=} modifiers\n     */\n    function MapType(valueType, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.valueType = valueType || null;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    MapType.prototype.visitType = function (visitor, context) { return visitor.visitMapType(this, context); };\n    return MapType;\n}(Type$1));\nvar DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nvar INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nvar BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nvar INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nvar NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nvar STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nvar FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nvar BinaryOperator = {};\nBinaryOperator.Equals = 0;\nBinaryOperator.NotEquals = 1;\nBinaryOperator.Identical = 2;\nBinaryOperator.NotIdentical = 3;\nBinaryOperator.Minus = 4;\nBinaryOperator.Plus = 5;\nBinaryOperator.Divide = 6;\nBinaryOperator.Multiply = 7;\nBinaryOperator.Modulo = 8;\nBinaryOperator.And = 9;\nBinaryOperator.Or = 10;\nBinaryOperator.Lower = 11;\nBinaryOperator.LowerEquals = 12;\nBinaryOperator.Bigger = 13;\nBinaryOperator.BiggerEquals = 14;\nBinaryOperator[BinaryOperator.Equals] = \"Equals\";\nBinaryOperator[BinaryOperator.NotEquals] = \"NotEquals\";\nBinaryOperator[BinaryOperator.Identical] = \"Identical\";\nBinaryOperator[BinaryOperator.NotIdentical] = \"NotIdentical\";\nBinaryOperator[BinaryOperator.Minus] = \"Minus\";\nBinaryOperator[BinaryOperator.Plus] = \"Plus\";\nBinaryOperator[BinaryOperator.Divide] = \"Divide\";\nBinaryOperator[BinaryOperator.Multiply] = \"Multiply\";\nBinaryOperator[BinaryOperator.Modulo] = \"Modulo\";\nBinaryOperator[BinaryOperator.And] = \"And\";\nBinaryOperator[BinaryOperator.Or] = \"Or\";\nBinaryOperator[BinaryOperator.Lower] = \"Lower\";\nBinaryOperator[BinaryOperator.LowerEquals] = \"LowerEquals\";\nBinaryOperator[BinaryOperator.Bigger] = \"Bigger\";\nBinaryOperator[BinaryOperator.BiggerEquals] = \"BiggerEquals\";\n/**\n * @abstract\n */\nvar Expression = (function () {\n    /**\n     * @param {?} type\n     * @param {?=} sourceSpan\n     */\n    function Expression(type, sourceSpan) {\n        this.type = type || null;\n        this.sourceSpan = sourceSpan || null;\n    }\n    /**\n     * @abstract\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Expression.prototype.visitExpression = function (visitor, context) { };\n    /**\n     * @param {?} name\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.prop = function (name, sourceSpan) {\n        return new ReadPropExpr(this, name, null, sourceSpan);\n    };\n    /**\n     * @param {?} index\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.key = function (index, type, sourceSpan) {\n        return new ReadKeyExpr(this, index, type, sourceSpan);\n    };\n    /**\n     * @param {?} name\n     * @param {?} params\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.callMethod = function (name, params, sourceSpan) {\n        return new InvokeMethodExpr(this, name, params, null, sourceSpan);\n    };\n    /**\n     * @param {?} params\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.callFn = function (params, sourceSpan) {\n        return new InvokeFunctionExpr(this, params, null, sourceSpan);\n    };\n    /**\n     * @param {?} params\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.instantiate = function (params, type, sourceSpan) {\n        return new InstantiateExpr(this, params, type, sourceSpan);\n    };\n    /**\n     * @param {?} trueCase\n     * @param {?=} falseCase\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.conditional = function (trueCase, falseCase, sourceSpan) {\n        if (falseCase === void 0) { falseCase = null; }\n        return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.equals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.notEquals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.identical = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.notIdentical = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.minus = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.plus = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.divide = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.multiply = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.modulo = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.and = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.or = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.lower = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.lowerEquals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.bigger = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.biggerEquals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.isBlank = function (sourceSpan) {\n        // Note: We use equals by purpose here to compare to null and undefined in JS.\n        // We use the typed null to allow strictNullChecks to narrow types.\n        return this.equals(TYPED_NULL_EXPR, sourceSpan);\n    };\n    /**\n     * @param {?} type\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.cast = function (type, sourceSpan) {\n        return new CastExpr(this, type, sourceSpan);\n    };\n    /**\n     * @return {?}\n     */\n    Expression.prototype.toStmt = function () { return new ExpressionStatement(this, null); };\n    return Expression;\n}());\nvar BuiltinVar = {};\nBuiltinVar.This = 0;\nBuiltinVar.Super = 1;\nBuiltinVar.CatchError = 2;\nBuiltinVar.CatchStack = 3;\nBuiltinVar[BuiltinVar.This] = \"This\";\nBuiltinVar[BuiltinVar.Super] = \"Super\";\nBuiltinVar[BuiltinVar.CatchError] = \"CatchError\";\nBuiltinVar[BuiltinVar.CatchStack] = \"CatchStack\";\nvar ReadVarExpr = (function (_super) {\n    __extends(ReadVarExpr, _super);\n    /**\n     * @param {?} name\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function ReadVarExpr(name, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        if (typeof name === 'string') {\n            _this.name = name;\n            _this.builtin = null;\n        }\n        else {\n            _this.name = null;\n            _this.builtin = name;\n        }\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReadVarExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitReadVarExpr(this, context);\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ReadVarExpr.prototype.set = function (value) {\n        if (!this.name) {\n            throw new Error(\"Built in variable \" + this.builtin + \" can not be assigned to.\");\n        }\n        return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n    };\n    return ReadVarExpr;\n}(Expression));\nvar WriteVarExpr = (function (_super) {\n    __extends(WriteVarExpr, _super);\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function WriteVarExpr(name, value, type, sourceSpan) {\n        var _this = _super.call(this, type || value.type, sourceSpan) || this;\n        _this.name = name;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    WriteVarExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWriteVarExpr(this, context);\n    };\n    /**\n     * @param {?=} type\n     * @param {?=} modifiers\n     * @return {?}\n     */\n    WriteVarExpr.prototype.toDeclStmt = function (type, modifiers) {\n        return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n    };\n    return WriteVarExpr;\n}(Expression));\nvar WriteKeyExpr = (function (_super) {\n    __extends(WriteKeyExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} index\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function WriteKeyExpr(receiver, index, value, type, sourceSpan) {\n        var _this = _super.call(this, type || value.type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.index = index;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    WriteKeyExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWriteKeyExpr(this, context);\n    };\n    return WriteKeyExpr;\n}(Expression));\nvar WritePropExpr = (function (_super) {\n    __extends(WritePropExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function WritePropExpr(receiver, name, value, type, sourceSpan) {\n        var _this = _super.call(this, type || value.type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    WritePropExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWritePropExpr(this, context);\n    };\n    return WritePropExpr;\n}(Expression));\nvar BuiltinMethod = {};\nBuiltinMethod.ConcatArray = 0;\nBuiltinMethod.SubscribeObservable = 1;\nBuiltinMethod.Bind = 2;\nBuiltinMethod[BuiltinMethod.ConcatArray] = \"ConcatArray\";\nBuiltinMethod[BuiltinMethod.SubscribeObservable] = \"SubscribeObservable\";\nBuiltinMethod[BuiltinMethod.Bind] = \"Bind\";\nvar InvokeMethodExpr = (function (_super) {\n    __extends(InvokeMethodExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} method\n     * @param {?} args\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function InvokeMethodExpr(receiver, method, args, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.args = args;\n        if (typeof method === 'string') {\n            _this.name = method;\n            _this.builtin = null;\n        }\n        else {\n            _this.name = null;\n            _this.builtin = method;\n        }\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    InvokeMethodExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitInvokeMethodExpr(this, context);\n    };\n    return InvokeMethodExpr;\n}(Expression));\nvar InvokeFunctionExpr = (function (_super) {\n    __extends(InvokeFunctionExpr, _super);\n    /**\n     * @param {?} fn\n     * @param {?} args\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function InvokeFunctionExpr(fn, args, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.fn = fn;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    InvokeFunctionExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitInvokeFunctionExpr(this, context);\n    };\n    return InvokeFunctionExpr;\n}(Expression));\nvar InstantiateExpr = (function (_super) {\n    __extends(InstantiateExpr, _super);\n    /**\n     * @param {?} classExpr\n     * @param {?} args\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function InstantiateExpr(classExpr, args, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.classExpr = classExpr;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    InstantiateExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitInstantiateExpr(this, context);\n    };\n    return InstantiateExpr;\n}(Expression));\nvar LiteralExpr = (function (_super) {\n    __extends(LiteralExpr, _super);\n    /**\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function LiteralExpr(value, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    LiteralExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLiteralExpr(this, context);\n    };\n    return LiteralExpr;\n}(Expression));\nvar ExternalExpr = (function (_super) {\n    __extends(ExternalExpr, _super);\n    /**\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} typeParams\n     * @param {?=} sourceSpan\n     */\n    function ExternalExpr(value, type, typeParams, sourceSpan) {\n        if (typeParams === void 0) { typeParams = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.value = value;\n        _this.typeParams = typeParams;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ExternalExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitExternalExpr(this, context);\n    };\n    return ExternalExpr;\n}(Expression));\nvar ConditionalExpr = (function (_super) {\n    __extends(ConditionalExpr, _super);\n    /**\n     * @param {?} condition\n     * @param {?} trueCase\n     * @param {?=} falseCase\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function ConditionalExpr(condition, trueCase, falseCase, type, sourceSpan) {\n        if (falseCase === void 0) { falseCase = null; }\n        var _this = _super.call(this, type || trueCase.type, sourceSpan) || this;\n        _this.condition = condition;\n        _this.falseCase = falseCase;\n        _this.trueCase = trueCase;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ConditionalExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitConditionalExpr(this, context);\n    };\n    return ConditionalExpr;\n}(Expression));\nvar NotExpr = (function (_super) {\n    __extends(NotExpr, _super);\n    /**\n     * @param {?} condition\n     * @param {?=} sourceSpan\n     */\n    function NotExpr(condition, sourceSpan) {\n        var _this = _super.call(this, BOOL_TYPE, sourceSpan) || this;\n        _this.condition = condition;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    NotExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitNotExpr(this, context);\n    };\n    return NotExpr;\n}(Expression));\nvar CastExpr = (function (_super) {\n    __extends(CastExpr, _super);\n    /**\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function CastExpr(value, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    CastExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitCastExpr(this, context);\n    };\n    return CastExpr;\n}(Expression));\nvar FnParam = (function () {\n    /**\n     * @param {?} name\n     * @param {?=} type\n     */\n    function FnParam(name, type) {\n        if (type === void 0) { type = null; }\n        this.name = name;\n        this.type = type;\n    }\n    return FnParam;\n}());\nvar FunctionExpr = (function (_super) {\n    __extends(FunctionExpr, _super);\n    /**\n     * @param {?} params\n     * @param {?} statements\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function FunctionExpr(params, statements, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.params = params;\n        _this.statements = statements;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    FunctionExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitFunctionExpr(this, context);\n    };\n    /**\n     * @param {?} name\n     * @param {?=} modifiers\n     * @return {?}\n     */\n    FunctionExpr.prototype.toDeclStmt = function (name, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n    };\n    return FunctionExpr;\n}(Expression));\nvar BinaryOperatorExpr = (function (_super) {\n    __extends(BinaryOperatorExpr, _super);\n    /**\n     * @param {?} operator\n     * @param {?} lhs\n     * @param {?} rhs\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function BinaryOperatorExpr(operator, lhs, rhs, type, sourceSpan) {\n        var _this = _super.call(this, type || lhs.type, sourceSpan) || this;\n        _this.operator = operator;\n        _this.rhs = rhs;\n        _this.lhs = lhs;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BinaryOperatorExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitBinaryOperatorExpr(this, context);\n    };\n    return BinaryOperatorExpr;\n}(Expression));\nvar ReadPropExpr = (function (_super) {\n    __extends(ReadPropExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function ReadPropExpr(receiver, name, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReadPropExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitReadPropExpr(this, context);\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ReadPropExpr.prototype.set = function (value) {\n        return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n    };\n    return ReadPropExpr;\n}(Expression));\nvar ReadKeyExpr = (function (_super) {\n    __extends(ReadKeyExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} index\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function ReadKeyExpr(receiver, index, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.index = index;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReadKeyExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitReadKeyExpr(this, context);\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ReadKeyExpr.prototype.set = function (value) {\n        return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n    };\n    return ReadKeyExpr;\n}(Expression));\nvar LiteralArrayExpr = (function (_super) {\n    __extends(LiteralArrayExpr, _super);\n    /**\n     * @param {?} entries\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function LiteralArrayExpr(entries, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.entries = entries;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    LiteralArrayExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLiteralArrayExpr(this, context);\n    };\n    return LiteralArrayExpr;\n}(Expression));\nvar LiteralMapEntry = (function () {\n    /**\n     * @param {?} key\n     * @param {?} value\n     * @param {?=} quoted\n     */\n    function LiteralMapEntry(key, value, quoted) {\n        if (quoted === void 0) { quoted = false; }\n        this.key = key;\n        this.value = value;\n        this.quoted = quoted;\n    }\n    return LiteralMapEntry;\n}());\nvar LiteralMapExpr = (function (_super) {\n    __extends(LiteralMapExpr, _super);\n    /**\n     * @param {?} entries\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function LiteralMapExpr(entries, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.entries = entries;\n        _this.valueType = null;\n        if (type) {\n            _this.valueType = type.valueType;\n        }\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    LiteralMapExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLiteralMapExpr(this, context);\n    };\n    return LiteralMapExpr;\n}(Expression));\nvar CommaExpr = (function (_super) {\n    __extends(CommaExpr, _super);\n    /**\n     * @param {?} parts\n     * @param {?=} sourceSpan\n     */\n    function CommaExpr(parts, sourceSpan) {\n        var _this = _super.call(this, parts[parts.length - 1].type, sourceSpan) || this;\n        _this.parts = parts;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    CommaExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitCommaExpr(this, context);\n    };\n    return CommaExpr;\n}(Expression));\nvar THIS_EXPR = new ReadVarExpr(BuiltinVar.This, null, null);\nvar SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super, null, null);\nvar CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError, null, null);\nvar CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack, null, null);\nvar NULL_EXPR = new LiteralExpr(null, null, null);\nvar TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\nvar StmtModifier = {};\nStmtModifier.Final = 0;\nStmtModifier.Private = 1;\nStmtModifier[StmtModifier.Final] = \"Final\";\nStmtModifier[StmtModifier.Private] = \"Private\";\n/**\n * @abstract\n */\nvar Statement = (function () {\n    /**\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    function Statement(modifiers, sourceSpan) {\n        this.modifiers = modifiers || [];\n        this.sourceSpan = sourceSpan || null;\n    }\n    /**\n     * @abstract\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Statement.prototype.visitStatement = function (visitor, context) { };\n    /**\n     * @param {?} modifier\n     * @return {?}\n     */\n    Statement.prototype.hasModifier = function (modifier) { return ((this.modifiers)).indexOf(modifier) !== -1; };\n    return Statement;\n}());\nvar DeclareVarStmt = (function (_super) {\n    __extends(DeclareVarStmt, _super);\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    function DeclareVarStmt(name, value, type, modifiers, sourceSpan) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers, sourceSpan) || this;\n        _this.name = name;\n        _this.value = value;\n        _this.type = type || value.type;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    DeclareVarStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitDeclareVarStmt(this, context);\n    };\n    return DeclareVarStmt;\n}(Statement));\nvar DeclareFunctionStmt = (function (_super) {\n    __extends(DeclareFunctionStmt, _super);\n    /**\n     * @param {?} name\n     * @param {?} params\n     * @param {?} statements\n     * @param {?=} type\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    function DeclareFunctionStmt(name, params, statements, type, modifiers, sourceSpan) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers, sourceSpan) || this;\n        _this.name = name;\n        _this.params = params;\n        _this.statements = statements;\n        _this.type = type || null;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    DeclareFunctionStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitDeclareFunctionStmt(this, context);\n    };\n    return DeclareFunctionStmt;\n}(Statement));\nvar ExpressionStatement = (function (_super) {\n    __extends(ExpressionStatement, _super);\n    /**\n     * @param {?} expr\n     * @param {?=} sourceSpan\n     */\n    function ExpressionStatement(expr, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.expr = expr;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ExpressionStatement.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitExpressionStmt(this, context);\n    };\n    return ExpressionStatement;\n}(Statement));\nvar ReturnStatement = (function (_super) {\n    __extends(ReturnStatement, _super);\n    /**\n     * @param {?} value\n     * @param {?=} sourceSpan\n     */\n    function ReturnStatement(value, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReturnStatement.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitReturnStmt(this, context);\n    };\n    return ReturnStatement;\n}(Statement));\nvar AbstractClassPart = (function () {\n    /**\n     * @param {?} type\n     * @param {?} modifiers\n     */\n    function AbstractClassPart(type, modifiers) {\n        this.modifiers = modifiers;\n        if (!modifiers) {\n            this.modifiers = [];\n        }\n        this.type = type || null;\n    }\n    /**\n     * @param {?} modifier\n     * @return {?}\n     */\n    AbstractClassPart.prototype.hasModifier = function (modifier) { return ((this.modifiers)).indexOf(modifier) !== -1; };\n    return AbstractClassPart;\n}());\nvar ClassField = (function (_super) {\n    __extends(ClassField, _super);\n    /**\n     * @param {?} name\n     * @param {?=} type\n     * @param {?=} modifiers\n     */\n    function ClassField(name, type, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, type, modifiers) || this;\n        _this.name = name;\n        return _this;\n    }\n    return ClassField;\n}(AbstractClassPart));\nvar ClassMethod = (function (_super) {\n    __extends(ClassMethod, _super);\n    /**\n     * @param {?} name\n     * @param {?} params\n     * @param {?} body\n     * @param {?=} type\n     * @param {?=} modifiers\n     */\n    function ClassMethod(name, params, body, type, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, type, modifiers) || this;\n        _this.name = name;\n        _this.params = params;\n        _this.body = body;\n        return _this;\n    }\n    return ClassMethod;\n}(AbstractClassPart));\nvar ClassGetter = (function (_super) {\n    __extends(ClassGetter, _super);\n    /**\n     * @param {?} name\n     * @param {?} body\n     * @param {?=} type\n     * @param {?=} modifiers\n     */\n    function ClassGetter(name, body, type, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, type, modifiers) || this;\n        _this.name = name;\n        _this.body = body;\n        return _this;\n    }\n    return ClassGetter;\n}(AbstractClassPart));\nvar ClassStmt = (function (_super) {\n    __extends(ClassStmt, _super);\n    /**\n     * @param {?} name\n     * @param {?} parent\n     * @param {?} fields\n     * @param {?} getters\n     * @param {?} constructorMethod\n     * @param {?} methods\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    function ClassStmt(name, parent, fields, getters, constructorMethod, methods, modifiers, sourceSpan) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers, sourceSpan) || this;\n        _this.name = name;\n        _this.parent = parent;\n        _this.fields = fields;\n        _this.getters = getters;\n        _this.constructorMethod = constructorMethod;\n        _this.methods = methods;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ClassStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitDeclareClassStmt(this, context);\n    };\n    return ClassStmt;\n}(Statement));\nvar IfStmt = (function (_super) {\n    __extends(IfStmt, _super);\n    /**\n     * @param {?} condition\n     * @param {?} trueCase\n     * @param {?=} falseCase\n     * @param {?=} sourceSpan\n     */\n    function IfStmt(condition, trueCase, falseCase, sourceSpan) {\n        if (falseCase === void 0) { falseCase = []; }\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.condition = condition;\n        _this.trueCase = trueCase;\n        _this.falseCase = falseCase;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    IfStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitIfStmt(this, context);\n    };\n    return IfStmt;\n}(Statement));\nvar TryCatchStmt = (function (_super) {\n    __extends(TryCatchStmt, _super);\n    /**\n     * @param {?} bodyStmts\n     * @param {?} catchStmts\n     * @param {?=} sourceSpan\n     */\n    function TryCatchStmt(bodyStmts, catchStmts, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.bodyStmts = bodyStmts;\n        _this.catchStmts = catchStmts;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    TryCatchStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitTryCatchStmt(this, context);\n    };\n    return TryCatchStmt;\n}(Statement));\nvar ThrowStmt = (function (_super) {\n    __extends(ThrowStmt, _super);\n    /**\n     * @param {?} error\n     * @param {?=} sourceSpan\n     */\n    function ThrowStmt(error, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.error = error;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ThrowStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitThrowStmt(this, context);\n    };\n    return ThrowStmt;\n}(Statement));\nvar AstTransformer$1 = (function () {\n    function AstTransformer$1() {\n    }\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.transformExpr = function (expr, context) { return expr; };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.transformStmt = function (stmt, context) { return stmt; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitReadVarExpr = function (ast, context) { return this.transformExpr(ast, context); };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitWriteVarExpr = function (expr, context) {\n        return this.transformExpr(new WriteVarExpr(expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitWriteKeyExpr = function (expr, context) {\n        return this.transformExpr(new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitWritePropExpr = function (expr, context) {\n        return this.transformExpr(new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitInvokeMethodExpr = function (ast, context) {\n        var /** @type {?} */ method = ast.builtin || ast.name;\n        return this.transformExpr(new InvokeMethodExpr(ast.receiver.visitExpression(this, context), /** @type {?} */ ((method)), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitInvokeFunctionExpr = function (ast, context) {\n        return this.transformExpr(new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitInstantiateExpr = function (ast, context) {\n        return this.transformExpr(new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitLiteralExpr = function (ast, context) { return this.transformExpr(ast, context); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitExternalExpr = function (ast, context) {\n        return this.transformExpr(ast, context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitConditionalExpr = function (ast, context) {\n        return this.transformExpr(new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), /** @type {?} */ ((ast.falseCase)).visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitNotExpr = function (ast, context) {\n        return this.transformExpr(new NotExpr(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitCastExpr = function (ast, context) {\n        return this.transformExpr(new CastExpr(ast.value.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitFunctionExpr = function (ast, context) {\n        return this.transformExpr(new FunctionExpr(ast.params, this.visitAllStatements(ast.statements, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitBinaryOperatorExpr = function (ast, context) {\n        return this.transformExpr(new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitReadPropExpr = function (ast, context) {\n        return this.transformExpr(new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitReadKeyExpr = function (ast, context) {\n        return this.transformExpr(new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitLiteralArrayExpr = function (ast, context) {\n        return this.transformExpr(new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitLiteralMapExpr = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ entries = ast.entries.map(function (entry) { return new LiteralMapEntry(entry.key, entry.value.visitExpression(_this, context), entry.quoted); });\n        var /** @type {?} */ mapType = new MapType(ast.valueType, null);\n        return this.transformExpr(new LiteralMapExpr(entries, mapType, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitCommaExpr = function (ast, context) {\n        return this.transformExpr(new CommaExpr(this.visitAllExpressions(ast.parts, context), ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} exprs\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitAllExpressions = function (exprs, context) {\n        var _this = this;\n        return exprs.map(function (expr) { return expr.visitExpression(_this, context); });\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitDeclareVarStmt = function (stmt, context) {\n        return this.transformStmt(new DeclareVarStmt(stmt.name, stmt.value.visitExpression(this, context), stmt.type, stmt.modifiers, stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n        return this.transformStmt(new DeclareFunctionStmt(stmt.name, stmt.params, this.visitAllStatements(stmt.statements, context), stmt.type, stmt.modifiers, stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitExpressionStmt = function (stmt, context) {\n        return this.transformStmt(new ExpressionStatement(stmt.expr.visitExpression(this, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitReturnStmt = function (stmt, context) {\n        return this.transformStmt(new ReturnStatement(stmt.value.visitExpression(this, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitDeclareClassStmt = function (stmt, context) {\n        var _this = this;\n        var /** @type {?} */ parent = ((stmt.parent)).visitExpression(this, context);\n        var /** @type {?} */ getters = stmt.getters.map(function (getter) { return new ClassGetter(getter.name, _this.visitAllStatements(getter.body, context), getter.type, getter.modifiers); });\n        var /** @type {?} */ ctorMethod = stmt.constructorMethod &&\n            new ClassMethod(stmt.constructorMethod.name, stmt.constructorMethod.params, this.visitAllStatements(stmt.constructorMethod.body, context), stmt.constructorMethod.type, stmt.constructorMethod.modifiers);\n        var /** @type {?} */ methods = stmt.methods.map(function (method) { return new ClassMethod(method.name, method.params, _this.visitAllStatements(method.body, context), method.type, method.modifiers); });\n        return this.transformStmt(new ClassStmt(stmt.name, parent, stmt.fields, getters, ctorMethod, methods, stmt.modifiers, stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitIfStmt = function (stmt, context) {\n        return this.transformStmt(new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitTryCatchStmt = function (stmt, context) {\n        return this.transformStmt(new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitThrowStmt = function (stmt, context) {\n        return this.transformStmt(new ThrowStmt(stmt.error.visitExpression(this, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitCommentStmt = function (stmt, context) {\n        return this.transformStmt(stmt, context);\n    };\n    /**\n     * @param {?} stmts\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitAllStatements = function (stmts, context) {\n        var _this = this;\n        return stmts.map(function (stmt) { return stmt.visitStatement(_this, context); });\n    };\n    return AstTransformer$1;\n}());\nvar RecursiveAstVisitor$1 = (function () {\n    function RecursiveAstVisitor$1() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitReadVarExpr = function (ast, context) { return ast; };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitWriteVarExpr = function (expr, context) {\n        expr.value.visitExpression(this, context);\n        return expr;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitWriteKeyExpr = function (expr, context) {\n        expr.receiver.visitExpression(this, context);\n        expr.index.visitExpression(this, context);\n        expr.value.visitExpression(this, context);\n        return expr;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitWritePropExpr = function (expr, context) {\n        expr.receiver.visitExpression(this, context);\n        expr.value.visitExpression(this, context);\n        return expr;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitInvokeMethodExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitInvokeFunctionExpr = function (ast, context) {\n        ast.fn.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitInstantiateExpr = function (ast, context) {\n        ast.classExpr.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitLiteralExpr = function (ast, context) { return ast; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitExternalExpr = function (ast, context) { return ast; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitConditionalExpr = function (ast, context) {\n        ast.condition.visitExpression(this, context);\n        ast.trueCase.visitExpression(this, context); /** @type {?} */\n        ((ast.falseCase)).visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitNotExpr = function (ast, context) {\n        ast.condition.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitCastExpr = function (ast, context) {\n        ast.value.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitFunctionExpr = function (ast, context) {\n        this.visitAllStatements(ast.statements, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitBinaryOperatorExpr = function (ast, context) {\n        ast.lhs.visitExpression(this, context);\n        ast.rhs.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitReadPropExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitReadKeyExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.index.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitLiteralArrayExpr = function (ast, context) {\n        this.visitAllExpressions(ast.entries, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitLiteralMapExpr = function (ast, context) {\n        var _this = this;\n        ast.entries.forEach(function (entry) { return entry.value.visitExpression(_this, context); });\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitCommaExpr = function (ast, context) {\n        this.visitAllExpressions(ast.parts, context);\n    };\n    /**\n     * @param {?} exprs\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitAllExpressions = function (exprs, context) {\n        var _this = this;\n        exprs.forEach(function (expr) { return expr.visitExpression(_this, context); });\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitDeclareVarStmt = function (stmt, context) {\n        stmt.value.visitExpression(this, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n        this.visitAllStatements(stmt.statements, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitExpressionStmt = function (stmt, context) {\n        stmt.expr.visitExpression(this, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitReturnStmt = function (stmt, context) {\n        stmt.value.visitExpression(this, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitDeclareClassStmt = function (stmt, context) {\n        var _this = this;\n        ((stmt.parent)).visitExpression(this, context);\n        stmt.getters.forEach(function (getter) { return _this.visitAllStatements(getter.body, context); });\n        if (stmt.constructorMethod) {\n            this.visitAllStatements(stmt.constructorMethod.body, context);\n        }\n        stmt.methods.forEach(function (method) { return _this.visitAllStatements(method.body, context); });\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitIfStmt = function (stmt, context) {\n        stmt.condition.visitExpression(this, context);\n        this.visitAllStatements(stmt.trueCase, context);\n        this.visitAllStatements(stmt.falseCase, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitTryCatchStmt = function (stmt, context) {\n        this.visitAllStatements(stmt.bodyStmts, context);\n        this.visitAllStatements(stmt.catchStmts, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitThrowStmt = function (stmt, context) {\n        stmt.error.visitExpression(this, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitCommentStmt = function (stmt, context) { return stmt; };\n    /**\n     * @param {?} stmts\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitAllStatements = function (stmts, context) {\n        var _this = this;\n        stmts.forEach(function (stmt) { return stmt.visitStatement(_this, context); });\n    };\n    return RecursiveAstVisitor$1;\n}());\n/**\n * @param {?} stmts\n * @return {?}\n */\nfunction findReadVarNames(stmts) {\n    var /** @type {?} */ visitor = new _ReadVarVisitor();\n    visitor.visitAllStatements(stmts, null);\n    return visitor.varNames;\n}\nvar _ReadVarVisitor = (function (_super) {\n    __extends(_ReadVarVisitor, _super);\n    function _ReadVarVisitor() {\n        var _this = _super.apply(this, arguments) || this;\n        _this.varNames = new Set();\n        return _this;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    _ReadVarVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n        // Don't descend into nested functions\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    _ReadVarVisitor.prototype.visitDeclareClassStmt = function (stmt, context) {\n        // Don't descend into nested classes\n        return stmt;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    _ReadVarVisitor.prototype.visitReadVarExpr = function (ast, context) {\n        if (ast.name) {\n            this.varNames.add(ast.name);\n        }\n        return null;\n    };\n    return _ReadVarVisitor;\n}(RecursiveAstVisitor$1));\n/**\n * @param {?} stmt\n * @param {?} sourceSpan\n * @return {?}\n */\nfunction applySourceSpanToStatementIfNeeded(stmt, sourceSpan) {\n    if (!sourceSpan) {\n        return stmt;\n    }\n    var /** @type {?} */ transformer = new _ApplySourceSpanTransformer(sourceSpan);\n    return stmt.visitStatement(transformer, null);\n}\n/**\n * @param {?} expr\n * @param {?} sourceSpan\n * @return {?}\n */\nfunction applySourceSpanToExpressionIfNeeded(expr, sourceSpan) {\n    if (!sourceSpan) {\n        return expr;\n    }\n    var /** @type {?} */ transformer = new _ApplySourceSpanTransformer(sourceSpan);\n    return expr.visitExpression(transformer, null);\n}\nvar _ApplySourceSpanTransformer = (function (_super) {\n    __extends(_ApplySourceSpanTransformer, _super);\n    /**\n     * @param {?} sourceSpan\n     */\n    function _ApplySourceSpanTransformer(sourceSpan) {\n        var _this = _super.call(this) || this;\n        _this.sourceSpan = sourceSpan;\n        return _this;\n    }\n    /**\n     * @param {?} obj\n     * @return {?}\n     */\n    _ApplySourceSpanTransformer.prototype._clone = function (obj) {\n        var /** @type {?} */ clone = Object.create(obj.constructor.prototype);\n        for (var /** @type {?} */ prop in obj) {\n            clone[prop] = obj[prop];\n        }\n        return clone;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    _ApplySourceSpanTransformer.prototype.transformExpr = function (expr, context) {\n        if (!expr.sourceSpan) {\n            expr = this._clone(expr);\n            expr.sourceSpan = this.sourceSpan;\n        }\n        return expr;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    _ApplySourceSpanTransformer.prototype.transformStmt = function (stmt, context) {\n        if (!stmt.sourceSpan) {\n            stmt = this._clone(stmt);\n            stmt.sourceSpan = this.sourceSpan;\n        }\n        return stmt;\n    };\n    return _ApplySourceSpanTransformer;\n}(AstTransformer$1));\n/**\n * @param {?} name\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction variable(name, type, sourceSpan) {\n    return new ReadVarExpr(name, type, sourceSpan);\n}\n/**\n * @param {?} id\n * @param {?=} typeParams\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction importExpr(id, typeParams, sourceSpan) {\n    if (typeParams === void 0) { typeParams = null; }\n    return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\n/**\n * @param {?} id\n * @param {?=} typeParams\n * @param {?=} typeModifiers\n * @return {?}\n */\nfunction importType(id, typeParams, typeModifiers) {\n    if (typeParams === void 0) { typeParams = null; }\n    if (typeModifiers === void 0) { typeModifiers = null; }\n    return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\n/**\n * @param {?} expr\n * @param {?=} typeModifiers\n * @return {?}\n */\nfunction expressionType(expr, typeModifiers) {\n    if (typeModifiers === void 0) { typeModifiers = null; }\n    return expr != null ? ((new ExpressionType(expr, typeModifiers))) : null;\n}\n/**\n * @param {?} values\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction literalArr(values, type, sourceSpan) {\n    return new LiteralArrayExpr(values, type, sourceSpan);\n}\n/**\n * @param {?} values\n * @param {?=} type\n * @param {?=} quoted\n * @return {?}\n */\nfunction literalMap(values, type, quoted) {\n    if (type === void 0) { type = null; }\n    if (quoted === void 0) { quoted = false; }\n    return new LiteralMapExpr(values.map(function (entry) { return new LiteralMapEntry(entry[0], entry[1], quoted); }), type, null);\n}\n/**\n * @param {?} expr\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction not(expr, sourceSpan) {\n    return new NotExpr(expr, sourceSpan);\n}\n/**\n * @param {?} params\n * @param {?} body\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction fn(params, body, type, sourceSpan) {\n    return new FunctionExpr(params, body, type, sourceSpan);\n}\n/**\n * @param {?} value\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction literal(value, type, sourceSpan) {\n    return new LiteralExpr(value, type, sourceSpan);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Create a new class stmts based on the given data.\n * @param {?} config\n * @return {?}\n */\nfunction createClassStmt(config) {\n    var /** @type {?} */ parentArgs = config.parentArgs || [];\n    var /** @type {?} */ superCtorStmts = config.parent ? [SUPER_EXPR.callFn(parentArgs).toStmt()] : [];\n    var /** @type {?} */ builder = concatClassBuilderParts(Array.isArray(config.builders) ? config.builders : [config.builders]);\n    var /** @type {?} */ ctor = new ClassMethod(null, config.ctorParams || [], superCtorStmts.concat(builder.ctorStmts));\n    return new ClassStmt(config.name, config.parent || null, builder.fields, builder.getters, ctor, builder.methods, config.modifiers || [], config.sourceSpan);\n}\n/**\n * @param {?} builders\n * @return {?}\n */\nfunction concatClassBuilderParts(builders) {\n    return {\n        fields: [].concat.apply([], ((builders.map((function (builder) { return builder.fields || []; }))))),\n        methods: [].concat.apply([], ((builders.map(function (builder) { return builder.methods || []; })))),\n        getters: [].concat.apply([], ((builders.map(function (builder) { return builder.getters || []; })))),\n        ctorStmts: [].concat.apply([], ((builders.map(function (builder) { return builder.ctorStmts || []; })))),\n    };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar QUOTED_KEYS = '$quoted$';\n/**\n * @param {?} value\n * @param {?=} type\n * @return {?}\n */\nfunction convertValueToOutputAst(value, type) {\n    if (type === void 0) { type = null; }\n    return visitValue(value, new _ValueOutputAstTransformer(), type);\n}\nvar _ValueOutputAstTransformer = (function () {\n    function _ValueOutputAstTransformer() {\n    }\n    /**\n     * @param {?} arr\n     * @param {?} type\n     * @return {?}\n     */\n    _ValueOutputAstTransformer.prototype.visitArray = function (arr, type) {\n        var _this = this;\n        return literalArr(arr.map(function (value) { return visitValue(value, _this, null); }), type);\n    };\n    /**\n     * @param {?} map\n     * @param {?} type\n     * @return {?}\n     */\n    _ValueOutputAstTransformer.prototype.visitStringMap = function (map, type) {\n        var _this = this;\n        var /** @type {?} */ entries = [];\n        var /** @type {?} */ quotedSet = new Set(map && map[QUOTED_KEYS]);\n        Object.keys(map).forEach(function (key) {\n            entries.push(new LiteralMapEntry(key, visitValue(map[key], _this, null), quotedSet.has(key)));\n        });\n        return new LiteralMapExpr(entries, type);\n    };\n    /**\n     * @param {?} value\n     * @param {?} type\n     * @return {?}\n     */\n    _ValueOutputAstTransformer.prototype.visitPrimitive = function (value, type) { return literal(value, type); };\n    /**\n     * @param {?} value\n     * @param {?} type\n     * @return {?}\n     */\n    _ValueOutputAstTransformer.prototype.visitOther = function (value, type) {\n        if (value instanceof Expression) {\n            return value;\n        }\n        else {\n            return importExpr({ reference: value });\n        }\n    };\n    return _ValueOutputAstTransformer;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This is currently not read, but will probably be used in the future.\n * We keep it as we already pass it through all the rigth places...\n */\nvar ComponentFactoryDependency = (function () {\n    /**\n     * @param {?} compType\n     */\n    function ComponentFactoryDependency(compType) {\n        this.compType = compType;\n    }\n    return ComponentFactoryDependency;\n}());\nvar NgModuleCompileResult = (function () {\n    /**\n     * @param {?} statements\n     * @param {?} ngModuleFactoryVar\n     * @param {?} dependencies\n     */\n    function NgModuleCompileResult(statements, ngModuleFactoryVar, dependencies) {\n        this.statements = statements;\n        this.ngModuleFactoryVar = ngModuleFactoryVar;\n        this.dependencies = dependencies;\n    }\n    return NgModuleCompileResult;\n}());\nvar NgModuleCompiler = (function () {\n    function NgModuleCompiler() {\n    }\n    /**\n     * @param {?} ngModuleMeta\n     * @param {?} extraProviders\n     * @return {?}\n     */\n    NgModuleCompiler.prototype.compile = function (ngModuleMeta, extraProviders) {\n        var /** @type {?} */ sourceSpan = typeSourceSpan('NgModule', ngModuleMeta.type);\n        var /** @type {?} */ deps = [];\n        var /** @type {?} */ bootstrapComponentFactories = [];\n        var /** @type {?} */ entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents.map(function (entryComponent) {\n            if (ngModuleMeta.bootstrapComponents.some(function (id) { return id.reference === entryComponent.componentType; })) {\n                bootstrapComponentFactories.push({ reference: entryComponent.componentFactory });\n            }\n            deps.push(new ComponentFactoryDependency(entryComponent.componentType));\n            return { reference: entryComponent.componentFactory };\n        });\n        var /** @type {?} */ builder = new _InjectorBuilder(ngModuleMeta, entryComponentFactories, bootstrapComponentFactories, sourceSpan);\n        var /** @type {?} */ providerParser = new NgModuleProviderAnalyzer(ngModuleMeta, extraProviders, sourceSpan);\n        providerParser.parse().forEach(function (provider) { return builder.addProvider(provider); });\n        var /** @type {?} */ injectorClass = builder.build();\n        var /** @type {?} */ ngModuleFactoryVar = identifierName(ngModuleMeta.type) + \"NgFactory\";\n        var /** @type {?} */ ngModuleFactoryStmt = variable(ngModuleFactoryVar)\n            .set(importExpr(createIdentifier(Identifiers.NgModuleFactory))\n            .instantiate([variable(injectorClass.name), importExpr(ngModuleMeta.type)], importType(createIdentifier(Identifiers.NgModuleFactory), [/** @type {?} */ ((importType(ngModuleMeta.type)))], [TypeModifier.Const])))\n            .toDeclStmt(null, [StmtModifier.Final]);\n        var /** @type {?} */ stmts = [injectorClass, ngModuleFactoryStmt];\n        if (ngModuleMeta.id) {\n            var /** @type {?} */ registerFactoryStmt = importExpr(createIdentifier(Identifiers.RegisterModuleFactoryFn))\n                .callFn([literal(ngModuleMeta.id), variable(ngModuleFactoryVar)])\n                .toStmt();\n            stmts.push(registerFactoryStmt);\n        }\n        return new NgModuleCompileResult(stmts, ngModuleFactoryVar, deps);\n    };\n    return NgModuleCompiler;\n}());\nNgModuleCompiler.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nNgModuleCompiler.ctorParameters = function () { return []; };\nvar _InjectorBuilder = (function () {\n    /**\n     * @param {?} _ngModuleMeta\n     * @param {?} _entryComponentFactories\n     * @param {?} _bootstrapComponentFactories\n     * @param {?} _sourceSpan\n     */\n    function _InjectorBuilder(_ngModuleMeta, _entryComponentFactories, _bootstrapComponentFactories, _sourceSpan) {\n        this._ngModuleMeta = _ngModuleMeta;\n        this._entryComponentFactories = _entryComponentFactories;\n        this._bootstrapComponentFactories = _bootstrapComponentFactories;\n        this._sourceSpan = _sourceSpan;\n        this.fields = [];\n        this.getters = [];\n        this.methods = [];\n        this.ctorStmts = [];\n        this._lazyProps = new Map();\n        this._tokens = [];\n        this._instances = new Map();\n        this._createStmts = [];\n        this._destroyStmts = [];\n    }\n    /**\n     * @param {?} resolvedProvider\n     * @return {?}\n     */\n    _InjectorBuilder.prototype.addProvider = function (resolvedProvider) {\n        var _this = this;\n        var /** @type {?} */ providerValueExpressions = resolvedProvider.providers.map(function (provider) { return _this._getProviderValue(provider); });\n        var /** @type {?} */ propName = \"_\" + tokenName(resolvedProvider.token) + \"_\" + this._instances.size;\n        var /** @type {?} */ instance = this._createProviderProperty(propName, resolvedProvider, providerValueExpressions, resolvedProvider.multiProvider, resolvedProvider.eager);\n        if (resolvedProvider.lifecycleHooks.indexOf(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].OnDestroy) !== -1) {\n            var /** @type {?} */ callNgOnDestroy = instance.callMethod('ngOnDestroy', []);\n            if (!resolvedProvider.eager) {\n                callNgOnDestroy = ((this._lazyProps.get(instance.name))).and(callNgOnDestroy);\n            }\n            this._destroyStmts.push(callNgOnDestroy.toStmt());\n        }\n        this._tokens.push(resolvedProvider.token);\n        this._instances.set(tokenReference(resolvedProvider.token), instance);\n    };\n    /**\n     * @return {?}\n     */\n    _InjectorBuilder.prototype.build = function () {\n        var _this = this;\n        var /** @type {?} */ getMethodStmts = this._tokens.map(function (token) {\n            var /** @type {?} */ providerExpr = ((_this._instances.get(tokenReference(token))));\n            return new IfStmt(InjectMethodVars.token.identical(createDiTokenExpression(token)), [new ReturnStatement(providerExpr)]);\n        });\n        var /** @type {?} */ methods = [\n            new ClassMethod('createInternal', [], this._createStmts.concat(new ReturnStatement(/** @type {?} */ ((this._instances.get(this._ngModuleMeta.type.reference))))), importType(this._ngModuleMeta.type)),\n            new ClassMethod('getInternal', [\n                new FnParam(/** @type {?} */ ((InjectMethodVars.token.name)), DYNAMIC_TYPE),\n                new FnParam(/** @type {?} */ ((InjectMethodVars.notFoundResult.name)), DYNAMIC_TYPE)\n            ], getMethodStmts.concat([new ReturnStatement(InjectMethodVars.notFoundResult)]), DYNAMIC_TYPE),\n            new ClassMethod('destroyInternal', [], this._destroyStmts),\n        ];\n        var /** @type {?} */ parentArgs = [\n            variable(InjectorProps.parent.name),\n            literalArr(this._entryComponentFactories.map(function (componentFactory) { return importExpr(componentFactory); })),\n            literalArr(this._bootstrapComponentFactories.map(function (componentFactory) { return importExpr(componentFactory); }))\n        ];\n        var /** @type {?} */ injClassName = identifierName(this._ngModuleMeta.type) + \"Injector\";\n        return createClassStmt({\n            name: injClassName,\n            ctorParams: [new FnParam(InjectorProps.parent.name, importType(createIdentifier(Identifiers.Injector)))],\n            parent: importExpr(createIdentifier(Identifiers.NgModuleInjector), [/** @type {?} */ ((importType(this._ngModuleMeta.type)))]),\n            parentArgs: parentArgs,\n            builders: [{ methods: methods }, this]\n        });\n    };\n    /**\n     * @param {?} provider\n     * @return {?}\n     */\n    _InjectorBuilder.prototype._getProviderValue = function (provider) {\n        var _this = this;\n        var /** @type {?} */ result;\n        if (provider.useExisting != null) {\n            result = this._getDependency({ token: provider.useExisting });\n        }\n        else if (provider.useFactory != null) {\n            var /** @type {?} */ deps = provider.deps || provider.useFactory.diDeps;\n            var /** @type {?} */ depsExpr = deps.map(function (dep) { return _this._getDependency(dep); });\n            result = importExpr(provider.useFactory).callFn(depsExpr);\n        }\n        else if (provider.useClass != null) {\n            var /** @type {?} */ deps = provider.deps || provider.useClass.diDeps;\n            var /** @type {?} */ depsExpr = deps.map(function (dep) { return _this._getDependency(dep); });\n            result =\n                importExpr(provider.useClass).instantiate(depsExpr, importType(provider.useClass));\n        }\n        else {\n            result = convertValueToOutputAst(provider.useValue);\n        }\n        return result;\n    };\n    /**\n     * @param {?} propName\n     * @param {?} provider\n     * @param {?} providerValueExpressions\n     * @param {?} isMulti\n     * @param {?} isEager\n     * @return {?}\n     */\n    _InjectorBuilder.prototype._createProviderProperty = function (propName, provider, providerValueExpressions, isMulti, isEager) {\n        var /** @type {?} */ resolvedProviderValueExpr;\n        var /** @type {?} */ type;\n        if (isMulti) {\n            resolvedProviderValueExpr = literalArr(providerValueExpressions);\n            type = new ArrayType(DYNAMIC_TYPE);\n        }\n        else {\n            resolvedProviderValueExpr = providerValueExpressions[0];\n            type = ((providerValueExpressions[0].type));\n        }\n        if (!type) {\n            type = DYNAMIC_TYPE;\n        }\n        if (isEager) {\n            this.fields.push(new ClassField(propName, type));\n            this._createStmts.push(THIS_EXPR.prop(propName).set(resolvedProviderValueExpr).toStmt());\n        }\n        else {\n            var /** @type {?} */ internalFieldProp = THIS_EXPR.prop(\"_\" + propName);\n            this.fields.push(new ClassField(internalFieldProp.name, type));\n            // Note: Equals is important for JS so that it also checks the undefined case!\n            var /** @type {?} */ getterStmts = [\n                new IfStmt(internalFieldProp.isBlank(), [internalFieldProp.set(resolvedProviderValueExpr).toStmt()]),\n                new ReturnStatement(internalFieldProp)\n            ];\n            this.getters.push(new ClassGetter(propName, getterStmts, type));\n            this._lazyProps.set(propName, internalFieldProp);\n        }\n        return THIS_EXPR.prop(propName);\n    };\n    /**\n     * @param {?} dep\n     * @return {?}\n     */\n    _InjectorBuilder.prototype._getDependency = function (dep) {\n        var /** @type {?} */ result = ((null));\n        if (dep.isValue) {\n            result = literal(dep.value);\n        }\n        if (!dep.isSkipSelf) {\n            if (dep.token) {\n                if (tokenReference(dep.token) === resolveIdentifier(Identifiers.Injector)) {\n                    result = THIS_EXPR;\n                }\n                else if (tokenReference(dep.token) === resolveIdentifier(Identifiers.ComponentFactoryResolver)) {\n                    result = THIS_EXPR.prop('componentFactoryResolver');\n                }\n            }\n            if (!result) {\n                result = ((this._instances.get(tokenReference(/** @type {?} */ ((dep.token))))));\n            }\n        }\n        if (!result) {\n            var /** @type {?} */ args = [createDiTokenExpression(/** @type {?} */ ((dep.token)))];\n            if (dep.isOptional) {\n                args.push(NULL_EXPR);\n            }\n            result = InjectorProps.parent.callMethod('get', args);\n        }\n        return result;\n    };\n    return _InjectorBuilder;\n}());\n/**\n * @param {?} token\n * @return {?}\n */\nfunction createDiTokenExpression(token) {\n    if (token.value != null) {\n        return literal(token.value);\n    }\n    else {\n        return importExpr(/** @type {?} */ ((token.identifier)));\n    }\n}\nvar InjectorProps = (function () {\n    function InjectorProps() {\n    }\n    return InjectorProps;\n}());\nInjectorProps.parent = THIS_EXPR.prop('parent');\nvar InjectMethodVars = (function () {\n    function InjectMethodVars() {\n    }\n    return InjectMethodVars;\n}());\nInjectMethodVars.token = variable('token');\nInjectMethodVars.notFoundResult = variable('notFoundResult');\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\nvar VERSION$1 = 3;\nvar JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\nvar SourceMapGenerator = (function () {\n    /**\n     * @param {?=} file\n     */\n    function SourceMapGenerator(file) {\n        if (file === void 0) { file = null; }\n        this.file = file;\n        this.sourcesContent = new Map();\n        this.lines = [];\n        this.lastCol0 = 0;\n        this.hasMappings = false;\n    }\n    /**\n     * @param {?} url\n     * @param {?=} content\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.addSource = function (url, content) {\n        if (content === void 0) { content = null; }\n        if (!this.sourcesContent.has(url)) {\n            this.sourcesContent.set(url, content);\n        }\n        return this;\n    };\n    /**\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.addLine = function () {\n        this.lines.push([]);\n        this.lastCol0 = 0;\n        return this;\n    };\n    /**\n     * @param {?} col0\n     * @param {?=} sourceUrl\n     * @param {?=} sourceLine0\n     * @param {?=} sourceCol0\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.addMapping = function (col0, sourceUrl, sourceLine0, sourceCol0) {\n        if (!this.currentLine) {\n            throw new Error(\"A line must be added before mappings can be added\");\n        }\n        if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n            throw new Error(\"Unknown source file \\\"\" + sourceUrl + \"\\\"\");\n        }\n        if (col0 == null) {\n            throw new Error(\"The column in the generated code must be provided\");\n        }\n        if (col0 < this.lastCol0) {\n            throw new Error(\"Mapping should be added in output order\");\n        }\n        if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n            throw new Error(\"The source location must be provided when a source url is provided\");\n        }\n        this.hasMappings = true;\n        this.lastCol0 = col0;\n        this.currentLine.push({ col0: col0, sourceUrl: sourceUrl, sourceLine0: sourceLine0, sourceCol0: sourceCol0 });\n        return this;\n    };\n    Object.defineProperty(SourceMapGenerator.prototype, \"currentLine\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.lines.slice(-1)[0]; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.toJSON = function () {\n        var _this = this;\n        if (!this.hasMappings) {\n            return null;\n        }\n        var /** @type {?} */ sourcesIndex = new Map();\n        var /** @type {?} */ sources = [];\n        var /** @type {?} */ sourcesContent = [];\n        Array.from(this.sourcesContent.keys()).forEach(function (url, i) {\n            sourcesIndex.set(url, i);\n            sources.push(url);\n            sourcesContent.push(_this.sourcesContent.get(url) || null);\n        });\n        var /** @type {?} */ mappings = '';\n        var /** @type {?} */ lastCol0 = 0;\n        var /** @type {?} */ lastSourceIndex = 0;\n        var /** @type {?} */ lastSourceLine0 = 0;\n        var /** @type {?} */ lastSourceCol0 = 0;\n        this.lines.forEach(function (segments) {\n            lastCol0 = 0;\n            mappings += segments\n                .map(function (segment) {\n                // zero-based starting column of the line in the generated code\n                var /** @type {?} */ segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n                lastCol0 = segment.col0;\n                if (segment.sourceUrl != null) {\n                    // zero-based index into the “sources” list\n                    segAsStr +=\n                        toBase64VLQ(/** @type {?} */ ((sourcesIndex.get(segment.sourceUrl))) - lastSourceIndex);\n                    lastSourceIndex = ((sourcesIndex.get(segment.sourceUrl)));\n                    // the zero-based starting line in the original source\n                    segAsStr += toBase64VLQ(/** @type {?} */ ((segment.sourceLine0)) - lastSourceLine0);\n                    lastSourceLine0 = ((segment.sourceLine0));\n                    // the zero-based starting column in the original source\n                    segAsStr += toBase64VLQ(/** @type {?} */ ((segment.sourceCol0)) - lastSourceCol0);\n                    lastSourceCol0 = ((segment.sourceCol0));\n                }\n                return segAsStr;\n            })\n                .join(',');\n            mappings += ';';\n        });\n        mappings = mappings.slice(0, -1);\n        return {\n            'file': this.file || '',\n            'version': VERSION$1,\n            'sourceRoot': '',\n            'sources': sources,\n            'sourcesContent': sourcesContent,\n            'mappings': mappings,\n        };\n    };\n    /**\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.toJsComment = function () {\n        return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :\n            '';\n    };\n    return SourceMapGenerator;\n}());\n/**\n * @param {?} value\n * @return {?}\n */\nfunction toBase64String(value) {\n    var /** @type {?} */ b64 = '';\n    value = utf8Encode(value);\n    for (var /** @type {?} */ i = 0; i < value.length;) {\n        var /** @type {?} */ i1 = value.charCodeAt(i++);\n        var /** @type {?} */ i2 = value.charCodeAt(i++);\n        var /** @type {?} */ i3 = value.charCodeAt(i++);\n        b64 += toBase64Digit(i1 >> 2);\n        b64 += toBase64Digit(((i1 & 3) << 4) | (isNaN(i2) ? 0 : i2 >> 4));\n        b64 += isNaN(i2) ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 >> 6));\n        b64 += isNaN(i2) || isNaN(i3) ? '=' : toBase64Digit(i3 & 63);\n    }\n    return b64;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction toBase64VLQ(value) {\n    value = value < 0 ? ((-value) << 1) + 1 : value << 1;\n    var /** @type {?} */ out = '';\n    do {\n        var /** @type {?} */ digit = value & 31;\n        value = value >> 5;\n        if (value > 0) {\n            digit = digit | 32;\n        }\n        out += toBase64Digit(digit);\n    } while (value > 0);\n    return out;\n}\nvar B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n/**\n * @param {?} value\n * @return {?}\n */\nfunction toBase64Digit(value) {\n    if (value < 0 || value >= 64) {\n        throw new Error(\"Can only encode value in the range [0, 63]\");\n    }\n    return B64_DIGITS[value];\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nvar _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nvar _INDENT_WITH = '  ';\nvar CATCH_ERROR_VAR$1 = variable('error', null, null);\nvar CATCH_STACK_VAR$1 = variable('stack', null, null);\n/**\n * @abstract\n */\nvar _EmittedLine = (function () {\n    /**\n     * @param {?} indent\n     */\n    function _EmittedLine(indent) {\n        this.indent = indent;\n        this.parts = [];\n        this.srcSpans = [];\n    }\n    return _EmittedLine;\n}());\nvar EmitterVisitorContext = (function () {\n    /**\n     * @param {?} _exportedVars\n     * @param {?} _indent\n     */\n    function EmitterVisitorContext(_exportedVars, _indent) {\n        this._exportedVars = _exportedVars;\n        this._indent = _indent;\n        this._classes = [];\n        this._lines = [new _EmittedLine(_indent)];\n    }\n    /**\n     * @param {?} exportedVars\n     * @return {?}\n     */\n    EmitterVisitorContext.createRoot = function (exportedVars) {\n        return new EmitterVisitorContext(exportedVars, 0);\n    };\n    Object.defineProperty(EmitterVisitorContext.prototype, \"_currentLine\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this._lines[this._lines.length - 1]; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} varName\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.isExportedVar = function (varName) { return this._exportedVars.indexOf(varName) !== -1; };\n    /**\n     * @param {?=} from\n     * @param {?=} lastPart\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.println = function (from, lastPart) {\n        if (lastPart === void 0) { lastPart = ''; }\n        this.print(from || null, lastPart, true);\n    };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.lineIsEmpty = function () { return this._currentLine.parts.length === 0; };\n    /**\n     * @param {?} from\n     * @param {?} part\n     * @param {?=} newLine\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.print = function (from, part, newLine) {\n        if (newLine === void 0) { newLine = false; }\n        if (part.length > 0) {\n            this._currentLine.parts.push(part);\n            this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n        }\n        if (newLine) {\n            this._lines.push(new _EmittedLine(this._indent));\n        }\n    };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.removeEmptyLastLine = function () {\n        if (this.lineIsEmpty()) {\n            this._lines.pop();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.incIndent = function () {\n        this._indent++;\n        this._currentLine.indent = this._indent;\n    };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.decIndent = function () {\n        this._indent--;\n        this._currentLine.indent = this._indent;\n    };\n    /**\n     * @param {?} clazz\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.pushClass = function (clazz) { this._classes.push(clazz); };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.popClass = function () { return ((this._classes.pop())); };\n    Object.defineProperty(EmitterVisitorContext.prototype, \"currentClass\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.toSource = function () {\n        return this.sourceLines\n            .map(function (l) { return l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : ''; })\n            .join('\\n');\n    };\n    /**\n     * @param {?} sourceFilePath\n     * @param {?} genFilePath\n     * @param {?=} startsAtLine\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.toSourceMapGenerator = function (sourceFilePath, genFilePath, startsAtLine) {\n        if (startsAtLine === void 0) { startsAtLine = 0; }\n        var /** @type {?} */ map = new SourceMapGenerator(genFilePath);\n        var /** @type {?} */ firstOffsetMapped = false;\n        var /** @type {?} */ mapFirstOffsetIfNeeded = function () {\n            if (!firstOffsetMapped) {\n                // Add a single space so that tools won't try to load the file from disk.\n                // Note: We are using virtual urls like `ng:///`, so we have to\n                // provide a content here.\n                map.addSource(sourceFilePath, ' ').addMapping(0, sourceFilePath, 0, 0);\n                firstOffsetMapped = true;\n            }\n        };\n        for (var /** @type {?} */ i = 0; i < startsAtLine; i++) {\n            map.addLine();\n            mapFirstOffsetIfNeeded();\n        }\n        this.sourceLines.forEach(function (line, lineIdx) {\n            map.addLine();\n            var /** @type {?} */ spans = line.srcSpans;\n            var /** @type {?} */ parts = line.parts;\n            var /** @type {?} */ col0 = line.indent * _INDENT_WITH.length;\n            var /** @type {?} */ spanIdx = 0;\n            // skip leading parts without source spans\n            while (spanIdx < spans.length && !spans[spanIdx]) {\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n            }\n            if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n                firstOffsetMapped = true;\n            }\n            else {\n                mapFirstOffsetIfNeeded();\n            }\n            while (spanIdx < spans.length) {\n                var /** @type {?} */ span = ((spans[spanIdx]));\n                var /** @type {?} */ source = span.start.file;\n                var /** @type {?} */ sourceLine = span.start.line;\n                var /** @type {?} */ sourceCol = span.start.col;\n                map.addSource(source.url, source.content)\n                    .addMapping(col0, source.url, sourceLine, sourceCol);\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n                // assign parts without span or the same span to the previous segment\n                while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n                    col0 += parts[spanIdx].length;\n                    spanIdx++;\n                }\n            }\n        });\n        return map;\n    };\n    Object.defineProperty(EmitterVisitorContext.prototype, \"sourceLines\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n                return this._lines.slice(0, -1);\n            }\n            return this._lines;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return EmitterVisitorContext;\n}());\n/**\n * @abstract\n */\nvar AbstractEmitterVisitor = (function () {\n    /**\n     * @param {?} _escapeDollarInStrings\n     */\n    function AbstractEmitterVisitor(_escapeDollarInStrings) {\n        this._escapeDollarInStrings = _escapeDollarInStrings;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitExpressionStmt = function (stmt, ctx) {\n        stmt.expr.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitReturnStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"return \");\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitCastExpr = function (ast, context) { };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) { };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitIfStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"if (\");\n        stmt.condition.visitExpression(this, ctx);\n        ctx.print(stmt, \") {\");\n        var /** @type {?} */ hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n        if (stmt.trueCase.length <= 1 && !hasElseCase) {\n            ctx.print(stmt, \" \");\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.removeEmptyLastLine();\n            ctx.print(stmt, \" \");\n        }\n        else {\n            ctx.println();\n            ctx.incIndent();\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.decIndent();\n            if (hasElseCase) {\n                ctx.println(stmt, \"} else {\");\n                ctx.incIndent();\n                this.visitAllStatements(stmt.falseCase, ctx);\n                ctx.decIndent();\n            }\n        }\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) { };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitThrowStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"throw \");\n        stmt.error.visitExpression(this, ctx);\n        ctx.println(stmt, \";\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitCommentStmt = function (stmt, ctx) {\n        var /** @type {?} */ lines = stmt.comment.split('\\n');\n        lines.forEach(function (line) { ctx.println(stmt, \"// \" + line); });\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) { };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitWriteVarExpr = function (expr, ctx) {\n        var /** @type {?} */ lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        ctx.print(expr, expr.name + \" = \");\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitWriteKeyExpr = function (expr, ctx) {\n        var /** @type {?} */ lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, \"[\");\n        expr.index.visitExpression(this, ctx);\n        ctx.print(expr, \"] = \");\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitWritePropExpr = function (expr, ctx) {\n        var /** @type {?} */ lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, \".\" + expr.name + \" = \");\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitInvokeMethodExpr = function (expr, ctx) {\n        expr.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ name = expr.name;\n        if (expr.builtin != null) {\n            name = this.getBuiltinMethodName(expr.builtin);\n            if (name == null) {\n                // some builtins just mean to skip the call.\n                return null;\n            }\n        }\n        ctx.print(expr, \".\" + name + \"(\");\n        this.visitAllExpressions(expr.args, ctx, \",\");\n        ctx.print(expr, \")\");\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} method\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.getBuiltinMethodName = function (method) { };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {\n        expr.fn.visitExpression(this, ctx);\n        ctx.print(expr, \"(\");\n        this.visitAllExpressions(expr.args, ctx, ',');\n        ctx.print(expr, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {\n        var /** @type {?} */ varName = ((ast.name));\n        if (ast.builtin != null) {\n            switch (ast.builtin) {\n                case BuiltinVar.Super:\n                    varName = 'super';\n                    break;\n                case BuiltinVar.This:\n                    varName = 'this';\n                    break;\n                case BuiltinVar.CatchError:\n                    varName = ((CATCH_ERROR_VAR$1.name));\n                    break;\n                case BuiltinVar.CatchStack:\n                    varName = ((CATCH_STACK_VAR$1.name));\n                    break;\n                default:\n                    throw new Error(\"Unknown builtin variable \" + ast.builtin);\n            }\n        }\n        ctx.print(ast, varName);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {\n        ctx.print(ast, \"new \");\n        ast.classExpr.visitExpression(this, ctx);\n        ctx.print(ast, \"(\");\n        this.visitAllExpressions(ast.args, ctx, ',');\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {\n        var /** @type {?} */ value = ast.value;\n        if (typeof value === 'string') {\n            ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n        }\n        else {\n            ctx.print(ast, \"\" + value);\n        }\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) { };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitConditionalExpr = function (ast, ctx) {\n        ctx.print(ast, \"(\");\n        ast.condition.visitExpression(this, ctx);\n        ctx.print(ast, '? ');\n        ast.trueCase.visitExpression(this, ctx);\n        ctx.print(ast, ': '); /** @type {?} */\n        ((ast.falseCase)).visitExpression(this, ctx);\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitNotExpr = function (ast, ctx) {\n        ctx.print(ast, '!');\n        ast.condition.visitExpression(this, ctx);\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) { };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitBinaryOperatorExpr = function (ast, ctx) {\n        var /** @type {?} */ opStr;\n        switch (ast.operator) {\n            case BinaryOperator.Equals:\n                opStr = '==';\n                break;\n            case BinaryOperator.Identical:\n                opStr = '===';\n                break;\n            case BinaryOperator.NotEquals:\n                opStr = '!=';\n                break;\n            case BinaryOperator.NotIdentical:\n                opStr = '!==';\n                break;\n            case BinaryOperator.And:\n                opStr = '&&';\n                break;\n            case BinaryOperator.Or:\n                opStr = '||';\n                break;\n            case BinaryOperator.Plus:\n                opStr = '+';\n                break;\n            case BinaryOperator.Minus:\n                opStr = '-';\n                break;\n            case BinaryOperator.Divide:\n                opStr = '/';\n                break;\n            case BinaryOperator.Multiply:\n                opStr = '*';\n                break;\n            case BinaryOperator.Modulo:\n                opStr = '%';\n                break;\n            case BinaryOperator.Lower:\n                opStr = '<';\n                break;\n            case BinaryOperator.LowerEquals:\n                opStr = '<=';\n                break;\n            case BinaryOperator.Bigger:\n                opStr = '>';\n                break;\n            case BinaryOperator.BiggerEquals:\n                opStr = '>=';\n                break;\n            default:\n                throw new Error(\"Unknown operator \" + ast.operator);\n        }\n        ctx.print(ast, \"(\");\n        ast.lhs.visitExpression(this, ctx);\n        ctx.print(ast, \" \" + opStr + \" \");\n        ast.rhs.visitExpression(this, ctx);\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitReadPropExpr = function (ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, \".\");\n        ctx.print(ast, ast.name);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitReadKeyExpr = function (ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, \"[\");\n        ast.index.visitExpression(this, ctx);\n        ctx.print(ast, \"]\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n        var /** @type {?} */ useNewLine = ast.entries.length > 1;\n        ctx.print(ast, \"[\", useNewLine);\n        ctx.incIndent();\n        this.visitAllExpressions(ast.entries, ctx, ',', useNewLine);\n        ctx.decIndent();\n        ctx.print(ast, \"]\", useNewLine);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitLiteralMapExpr = function (ast, ctx) {\n        var _this = this;\n        var /** @type {?} */ useNewLine = ast.entries.length > 1;\n        ctx.print(ast, \"{\", useNewLine);\n        ctx.incIndent();\n        this.visitAllObjects(function (entry) {\n            ctx.print(ast, escapeIdentifier(entry.key, _this._escapeDollarInStrings, entry.quoted) + \": \");\n            entry.value.visitExpression(_this, ctx);\n        }, ast.entries, ctx, ',', useNewLine);\n        ctx.decIndent();\n        ctx.print(ast, \"}\", useNewLine);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitCommaExpr = function (ast, ctx) {\n        ctx.print(ast, '(');\n        this.visitAllExpressions(ast.parts, ctx, ',');\n        ctx.print(ast, ')');\n        return null;\n    };\n    /**\n     * @param {?} expressions\n     * @param {?} ctx\n     * @param {?} separator\n     * @param {?=} newLine\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitAllExpressions = function (expressions, ctx, separator, newLine) {\n        var _this = this;\n        if (newLine === void 0) { newLine = false; }\n        this.visitAllObjects(function (expr) { return expr.visitExpression(_this, ctx); }, expressions, ctx, separator, newLine);\n    };\n    /**\n     * @template T\n     * @param {?} handler\n     * @param {?} expressions\n     * @param {?} ctx\n     * @param {?} separator\n     * @param {?=} newLine\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitAllObjects = function (handler, expressions, ctx, separator, newLine) {\n        if (newLine === void 0) { newLine = false; }\n        for (var /** @type {?} */ i = 0; i < expressions.length; i++) {\n            if (i > 0) {\n                ctx.print(null, separator, newLine);\n            }\n            handler(expressions[i]);\n        }\n        if (newLine) {\n            ctx.println();\n        }\n    };\n    /**\n     * @param {?} statements\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitAllStatements = function (statements, ctx) {\n        var _this = this;\n        statements.forEach(function (stmt) { return stmt.visitStatement(_this, ctx); });\n    };\n    return AbstractEmitterVisitor;\n}());\n/**\n * @param {?} input\n * @param {?} escapeDollar\n * @param {?=} alwaysQuote\n * @return {?}\n */\nfunction escapeIdentifier(input, escapeDollar, alwaysQuote) {\n    if (alwaysQuote === void 0) { alwaysQuote = true; }\n    if (input == null) {\n        return null;\n    }\n    var /** @type {?} */ body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, function () {\n        var match = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            match[_i] = arguments[_i];\n        }\n        if (match[0] == '$') {\n            return escapeDollar ? '\\\\$' : '$';\n        }\n        else if (match[0] == '\\n') {\n            return '\\\\n';\n        }\n        else if (match[0] == '\\r') {\n            return '\\\\r';\n        }\n        else {\n            return \"\\\\\" + match[0];\n        }\n    });\n    var /** @type {?} */ requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n    return requiresQuotes ? \"'\" + body + \"'\" : body;\n}\n/**\n * @param {?} count\n * @return {?}\n */\nfunction _createIndent(count) {\n    var /** @type {?} */ res = '';\n    for (var /** @type {?} */ i = 0; i < count; i++) {\n        res += _INDENT_WITH;\n    }\n    return res;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _debugFilePath = '/debug/lib';\n/**\n * @param {?} ast\n * @return {?}\n */\nfunction debugOutputAstAsTypeScript(ast) {\n    var /** @type {?} */ converter = new _TsEmitterVisitor(_debugFilePath, {\n        /**\n         * @param {?} filePath\n         * @param {?} containingFilePath\n         * @return {?}\n         */\n        fileNameToModuleName: function (filePath, containingFilePath) { return filePath; },\n        /**\n         * @param {?} symbol\n         * @return {?}\n         */\n        getImportAs: function (symbol) { return null; },\n        getTypeArity: function (symbol) { return null; }\n    });\n    var /** @type {?} */ ctx = EmitterVisitorContext.createRoot([]);\n    var /** @type {?} */ asts = Array.isArray(ast) ? ast : [ast];\n    asts.forEach(function (ast) {\n        if (ast instanceof Statement) {\n            ast.visitStatement(converter, ctx);\n        }\n        else if (ast instanceof Expression) {\n            ast.visitExpression(converter, ctx);\n        }\n        else if (ast instanceof Type$1) {\n            ast.visitType(converter, ctx);\n        }\n        else {\n            throw new Error(\"Don't know how to print debug info for \" + ast);\n        }\n    });\n    return ctx.toSource();\n}\nvar TypeScriptEmitter = (function () {\n    /**\n     * @param {?} _importResolver\n     */\n    function TypeScriptEmitter(_importResolver) {\n        this._importResolver = _importResolver;\n    }\n    /**\n     * @param {?} srcFilePath\n     * @param {?} genFilePath\n     * @param {?} stmts\n     * @param {?} exportedVars\n     * @param {?=} preamble\n     * @return {?}\n     */\n    TypeScriptEmitter.prototype.emitStatements = function (srcFilePath, genFilePath, stmts, exportedVars, preamble) {\n        var _this = this;\n        if (preamble === void 0) { preamble = ''; }\n        var /** @type {?} */ converter = new _TsEmitterVisitor(genFilePath, this._importResolver);\n        var /** @type {?} */ ctx = EmitterVisitorContext.createRoot(exportedVars);\n        converter.visitAllStatements(stmts, ctx);\n        var /** @type {?} */ preambleLines = preamble ? preamble.split('\\n') : [];\n        converter.reexports.forEach(function (reexports, exportedFilePath) {\n            var /** @type {?} */ reexportsCode = reexports.map(function (reexport) { return reexport.name + \" as \" + reexport.as; }).join(',');\n            preambleLines.push(\"export {\" + reexportsCode + \"} from '\" + _this._importResolver.fileNameToModuleName(exportedFilePath, genFilePath) + \"';\");\n        });\n        converter.importsWithPrefixes.forEach(function (prefix, importedFilePath) {\n            // Note: can't write the real word for import as it screws up system.js auto detection...\n            preambleLines.push(\"imp\" +\n                (\"ort * as \" + prefix + \" from '\" + _this._importResolver.fileNameToModuleName(importedFilePath, genFilePath) + \"';\"));\n        });\n        var /** @type {?} */ sm = ctx.toSourceMapGenerator(srcFilePath, genFilePath, preambleLines.length).toJsComment();\n        var /** @type {?} */ lines = preambleLines.concat([ctx.toSource(), sm]);\n        if (sm) {\n            // always add a newline at the end, as some tools have bugs without it.\n            lines.push('');\n        }\n        return lines.join('\\n');\n    };\n    return TypeScriptEmitter;\n}());\nvar _TsEmitterVisitor = (function (_super) {\n    __extends(_TsEmitterVisitor, _super);\n    /**\n     * @param {?} _genFilePath\n     * @param {?} _importResolver\n     */\n    function _TsEmitterVisitor(_genFilePath, _importResolver) {\n        var _this = _super.call(this, false) || this;\n        _this._genFilePath = _genFilePath;\n        _this._importResolver = _importResolver;\n        _this.typeExpression = 0;\n        _this.importsWithPrefixes = new Map();\n        _this.reexports = new Map();\n        return _this;\n    }\n    /**\n     * @param {?} t\n     * @param {?} ctx\n     * @param {?=} defaultType\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitType = function (t, ctx, defaultType) {\n        if (defaultType === void 0) { defaultType = 'any'; }\n        if (t) {\n            this.typeExpression++;\n            t.visitType(this, ctx);\n            this.typeExpression--;\n        }\n        else {\n            ctx.print(null, defaultType);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {\n        var /** @type {?} */ value = ast.value;\n        if (value == null && ast.type != INFERRED_TYPE) {\n            ctx.print(ast, \"(\" + value + \" as any)\");\n            return null;\n        }\n        return _super.prototype.visitLiteralExpr.call(this, ast, ctx);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n        if (ast.entries.length === 0) {\n            ctx.print(ast, '(');\n        }\n        var /** @type {?} */ result = _super.prototype.visitLiteralArrayExpr.call(this, ast, ctx);\n        if (ast.entries.length === 0) {\n            ctx.print(ast, ' as any[])');\n        }\n        return result;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {\n        this._visitIdentifier(ast.value, ast.typeParams, ctx);\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        if (ctx.isExportedVar(stmt.name) && stmt.value instanceof ExternalExpr && !stmt.type) {\n            // check for a reexport\n            var _a = this._resolveStaticSymbol(stmt.value.value), name = _a.name, filePath = _a.filePath, members = _a.members;\n            if (((members)).length === 0 && filePath !== this._genFilePath) {\n                var /** @type {?} */ reexports = this.reexports.get(filePath);\n                if (!reexports) {\n                    reexports = [];\n                    this.reexports.set(filePath, reexports);\n                }\n                reexports.push({ name: name, as: stmt.name });\n                return null;\n            }\n        }\n        if (ctx.isExportedVar(stmt.name)) {\n            ctx.print(stmt, \"export \");\n        }\n        if (stmt.hasModifier(StmtModifier.Final)) {\n            ctx.print(stmt, \"const\");\n        }\n        else {\n            ctx.print(stmt, \"var\");\n        }\n        ctx.print(stmt, \" \" + stmt.name);\n        this._printColonType(stmt.type, ctx);\n        ctx.print(stmt, \" = \");\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, \";\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {\n        ctx.print(ast, \"(<\"); /** @type {?} */\n        ((ast.type)).visitType(this, ctx);\n        ctx.print(ast, \">\");\n        ast.value.visitExpression(this, ctx);\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {\n        ctx.print(ast, \"new \");\n        this.typeExpression++;\n        ast.classExpr.visitExpression(this, ctx);\n        this.typeExpression--;\n        ctx.print(ast, \"(\");\n        this.visitAllExpressions(ast.args, ctx, ',');\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        var _this = this;\n        ctx.pushClass(stmt);\n        if (ctx.isExportedVar(stmt.name)) {\n            ctx.print(stmt, \"export \");\n        }\n        ctx.print(stmt, \"class \" + stmt.name);\n        if (stmt.parent != null) {\n            ctx.print(stmt, \" extends \");\n            this.typeExpression++;\n            stmt.parent.visitExpression(this, ctx);\n            this.typeExpression--;\n        }\n        ctx.println(stmt, \" {\");\n        ctx.incIndent();\n        stmt.fields.forEach(function (field) { return _this._visitClassField(field, ctx); });\n        if (stmt.constructorMethod != null) {\n            this._visitClassConstructor(stmt, ctx);\n        }\n        stmt.getters.forEach(function (getter) { return _this._visitClassGetter(getter, ctx); });\n        stmt.methods.forEach(function (method) { return _this._visitClassMethod(method, ctx); });\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        ctx.popClass();\n        return null;\n    };\n    /**\n     * @param {?} field\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitClassField = function (field, ctx) {\n        if (field.hasModifier(StmtModifier.Private)) {\n            // comment out as a workaround for #10967\n            ctx.print(null, \"/*private*/ \");\n        }\n        ctx.print(null, field.name);\n        this._printColonType(field.type, ctx);\n        ctx.println(null, \";\");\n    };\n    /**\n     * @param {?} getter\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitClassGetter = function (getter, ctx) {\n        if (getter.hasModifier(StmtModifier.Private)) {\n            ctx.print(null, \"private \");\n        }\n        ctx.print(null, \"get \" + getter.name + \"()\");\n        this._printColonType(getter.type, ctx);\n        ctx.println(null, \" {\");\n        ctx.incIndent();\n        this.visitAllStatements(getter.body, ctx);\n        ctx.decIndent();\n        ctx.println(null, \"}\");\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {\n        ctx.print(stmt, \"constructor(\");\n        this._visitParams(stmt.constructorMethod.params, ctx);\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.constructorMethod.body, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n    };\n    /**\n     * @param {?} method\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitClassMethod = function (method, ctx) {\n        if (method.hasModifier(StmtModifier.Private)) {\n            ctx.print(null, \"private \");\n        }\n        ctx.print(null, method.name + \"(\");\n        this._visitParams(method.params, ctx);\n        ctx.print(null, \")\");\n        this._printColonType(method.type, ctx, 'void');\n        ctx.println(null, \" {\");\n        ctx.incIndent();\n        this.visitAllStatements(method.body, ctx);\n        ctx.decIndent();\n        ctx.println(null, \"}\");\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {\n        ctx.print(ast, \"(\");\n        this._visitParams(ast.params, ctx);\n        ctx.print(ast, \")\");\n        this._printColonType(ast.type, ctx, 'void');\n        ctx.println(ast, \" => {\");\n        ctx.incIndent();\n        this.visitAllStatements(ast.statements, ctx);\n        ctx.decIndent();\n        ctx.print(ast, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        if (ctx.isExportedVar(stmt.name)) {\n            ctx.print(stmt, \"export \");\n        }\n        ctx.print(stmt, \"function \" + stmt.name + \"(\");\n        this._visitParams(stmt.params, ctx);\n        ctx.print(stmt, \")\");\n        this._printColonType(stmt.type, ctx, 'void');\n        ctx.println(stmt, \" {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.statements, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {\n        ctx.println(stmt, \"try {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.bodyStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"} catch (\" + CATCH_ERROR_VAR$1.name + \") {\");\n        ctx.incIndent();\n        var /** @type {?} */ catchStmts = [/** @type {?} */ (CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack', null)).toDeclStmt(null, [\n                StmtModifier.Final\n            ]))].concat(stmt.catchStmts);\n        this.visitAllStatements(catchStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitBuiltintType = function (type, ctx) {\n        var /** @type {?} */ typeStr;\n        switch (type.name) {\n            case BuiltinTypeName.Bool:\n                typeStr = 'boolean';\n                break;\n            case BuiltinTypeName.Dynamic:\n                typeStr = 'any';\n                break;\n            case BuiltinTypeName.Function:\n                typeStr = 'Function';\n                break;\n            case BuiltinTypeName.Number:\n                typeStr = 'number';\n                break;\n            case BuiltinTypeName.Int:\n                typeStr = 'number';\n                break;\n            case BuiltinTypeName.String:\n                typeStr = 'string';\n                break;\n            default:\n                throw new Error(\"Unsupported builtin type \" + type.name);\n        }\n        ctx.print(null, typeStr);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitExpressionType = function (ast, ctx) {\n        ast.value.visitExpression(this, ctx);\n        return null;\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitArrayType = function (type, ctx) {\n        this.visitType(type.of, ctx);\n        ctx.print(null, \"[]\");\n        return null;\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitMapType = function (type, ctx) {\n        ctx.print(null, \"{[key: string]:\");\n        this.visitType(type.valueType, ctx);\n        ctx.print(null, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} method\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {\n        var /** @type {?} */ name;\n        switch (method) {\n            case BuiltinMethod.ConcatArray:\n                name = 'concat';\n                break;\n            case BuiltinMethod.SubscribeObservable:\n                name = 'subscribe';\n                break;\n            case BuiltinMethod.Bind:\n                name = 'bind';\n                break;\n            default:\n                throw new Error(\"Unknown builtin method: \" + method);\n        }\n        return name;\n    };\n    /**\n     * @param {?} params\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitParams = function (params, ctx) {\n        var _this = this;\n        this.visitAllObjects(function (param) {\n            ctx.print(null, param.name);\n            _this._printColonType(param.type, ctx);\n        }, params, ctx, ',');\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._resolveStaticSymbol = function (value) {\n        var /** @type {?} */ reference = value.reference;\n        if (!(reference instanceof StaticSymbol)) {\n            throw new Error(\"Internal error: unknown identifier \" + JSON.stringify(value));\n        }\n        var /** @type {?} */ arity = this._importResolver.getTypeArity(reference) || undefined;\n        var /** @type {?} */ importReference = this._importResolver.getImportAs(reference) || reference;\n        return {\n            name: importReference.name,\n            filePath: importReference.filePath,\n            members: importReference.members, arity: arity\n        };\n    };\n    /**\n     * @param {?} value\n     * @param {?} typeParams\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitIdentifier = function (value, typeParams, ctx) {\n        var _this = this;\n        var _a = this._resolveStaticSymbol(value), name = _a.name, filePath = _a.filePath, members = _a.members, arity = _a.arity;\n        if (filePath != this._genFilePath) {\n            var /** @type {?} */ prefix = this.importsWithPrefixes.get(filePath);\n            if (prefix == null) {\n                prefix = \"import\" + this.importsWithPrefixes.size;\n                this.importsWithPrefixes.set(filePath, prefix);\n            }\n            ctx.print(null, prefix + \".\");\n        }\n        if (((members)).length) {\n            ctx.print(null, name);\n            ctx.print(null, '.');\n            ctx.print(null, /** @type {?} */ ((members)).join('.'));\n        }\n        else {\n            ctx.print(null, name);\n        }\n        if (this.typeExpression > 0) {\n            // If we are in a type expression that refers to a generic type then supply\n            // the required type parameters. If there were not enough type parameters\n            // supplied, supply any as the type. Outside a type expression the reference\n            // should not supply type parameters and be treated as a simple value reference\n            // to the constructor function itself.\n            var /** @type {?} */ suppliedParameters = (typeParams && typeParams.length) || 0;\n            var /** @type {?} */ additionalParameters = (arity || 0) - suppliedParameters;\n            if (suppliedParameters > 0 || additionalParameters > 0) {\n                ctx.print(null, \"<\");\n                if (suppliedParameters > 0) {\n                    this.visitAllObjects(function (type) { return type.visitType(_this, ctx); }, /** @type {?} */ ((typeParams)), ctx, ',');\n                }\n                if (additionalParameters > 0) {\n                    for (var /** @type {?} */ i = 0; i < additionalParameters; i++) {\n                        if (i > 0 || suppliedParameters > 0)\n                            ctx.print(null, ',');\n                        ctx.print(null, 'any');\n                    }\n                }\n                ctx.print(null, \">\");\n            }\n        }\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @param {?=} defaultType\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._printColonType = function (type, ctx, defaultType) {\n        if (type !== INFERRED_TYPE) {\n            ctx.print(null, ':');\n            this.visitType(type, ctx, defaultType);\n        }\n    };\n    return _TsEmitterVisitor;\n}(AbstractEmitterVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!\n//                               Reach out to mprobst for details.\n//\n// =================================================================================================\n/** Map from tagName|propertyName SecurityContext. Properties applying to all tags use '*'. */\nvar SECURITY_SCHEMA = {};\n/**\n * @param {?} ctx\n * @param {?} specs\n * @return {?}\n */\nfunction registerContext(ctx, specs) {\n    for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {\n        var spec = specs_1[_i];\n        SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n    }\n}\n// Case is insignificant below, all element and attribute names are lower-cased for lookup.\nregisterContext(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"SecurityContext\"].HTML, [\n    'iframe|srcdoc',\n    '*|innerHTML',\n    '*|outerHTML',\n]);\nregisterContext(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"SecurityContext\"].STYLE, ['*|style']);\n// NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.\nregisterContext(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"SecurityContext\"].URL, [\n    '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',\n    'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',\n    'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',\n    'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',\n]);\nregisterContext(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"SecurityContext\"].RESOURCE_URL, [\n    'applet|code',\n    'applet|codebase',\n    'base|href',\n    'embed|src',\n    'frame|src',\n    'head|profile',\n    'html|manifest',\n    'iframe|src',\n    'link|href',\n    'media|src',\n    'object|codebase',\n    'object|data',\n    'script|src',\n]);\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar BOOLEAN = 'boolean';\nvar NUMBER = 'number';\nvar STRING = 'string';\nvar OBJECT = 'object';\n/**\n * This array represents the DOM schema. It encodes inheritance, properties, and events.\n *\n * ## Overview\n *\n * Each line represents one kind of element. The `element_inheritance` and properties are joined\n * using `element_inheritance|properties` syntax.\n *\n * ## Element Inheritance\n *\n * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.\n * Here the individual elements are separated by `,` (commas). Every element in the list\n * has identical properties.\n *\n * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is\n * specified then `\"\"` (blank) element is assumed.\n *\n * NOTE: The blank element inherits from root `[Element]` element, the super element of all\n * elements.\n *\n * NOTE an element prefix such as `:svg:` has no special meaning to the schema.\n *\n * ## Properties\n *\n * Each element has a set of properties separated by `,` (commas). Each property can be prefixed\n * by a special character designating its type:\n *\n * - (no prefix): property is a string.\n * - `*`: property represents an event.\n * - `!`: property is a boolean.\n * - `#`: property is a number.\n * - `%`: property is an object.\n *\n * ## Query\n *\n * The class creates an internal squas representation which allows to easily answer the query of\n * if a given property exist on a given element.\n *\n * NOTE: We don't yet support querying for types or events.\n * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,\n *       see dom_element_schema_registry_spec.ts\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!\n//\n// Newly added properties must be security reviewed and assigned an appropriate SecurityContext in\n// dom_security_schema.ts. Reach out to mprobst & rjamet for details.\n//\n// =================================================================================================\nvar SCHEMA = [\n    '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop',\n    '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n    'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n    'media^[HTMLElement]|!autoplay,!controls,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,#playbackRate,preload,src,%srcObject,#volume',\n    ':svg:^[HTMLElement]|*abort,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',\n    ':svg:graphics^:svg:|',\n    ':svg:animation^:svg:|*begin,*end,*repeat',\n    ':svg:geometry^:svg:|',\n    ':svg:componentTransferFunction^:svg:|',\n    ':svg:gradient^:svg:|',\n    ':svg:textContent^:svg:graphics|',\n    ':svg:textPositioning^:svg:textContent|',\n    'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',\n    'area^[HTMLElement]|alt,coords,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,search,shape,target,username',\n    'audio^media|',\n    'br^[HTMLElement]|clear',\n    'base^[HTMLElement]|href,target',\n    'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',\n    'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',\n    'canvas^[HTMLElement]|#height,#width',\n    'content^[HTMLElement]|select',\n    'dl^[HTMLElement]|!compact',\n    'datalist^[HTMLElement]|',\n    'details^[HTMLElement]|!open',\n    'dialog^[HTMLElement]|!open,returnValue',\n    'dir^[HTMLElement]|!compact',\n    'div^[HTMLElement]|align',\n    'embed^[HTMLElement]|align,height,name,src,type,width',\n    'fieldset^[HTMLElement]|!disabled,name',\n    'font^[HTMLElement]|color,face,size',\n    'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',\n    'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',\n    'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',\n    'hr^[HTMLElement]|align,color,!noShade,size,width',\n    'head^[HTMLElement]|',\n    'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',\n    'html^[HTMLElement]|version',\n    'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',\n    'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',\n    'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',\n    'keygen^[HTMLElement]|!autofocus,challenge,!disabled,keytype,name',\n    'li^[HTMLElement]|type,#value',\n    'label^[HTMLElement]|htmlFor',\n    'legend^[HTMLElement]|align',\n    'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,rel,%relList,rev,%sizes,target,type',\n    'map^[HTMLElement]|name',\n    'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',\n    'menu^[HTMLElement]|!compact',\n    'meta^[HTMLElement]|content,httpEquiv,name,scheme',\n    'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',\n    'ins,del^[HTMLElement]|cite,dateTime',\n    'ol^[HTMLElement]|!compact,!reversed,#start,type',\n    'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',\n    'optgroup^[HTMLElement]|!disabled,label',\n    'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',\n    'output^[HTMLElement]|defaultValue,%htmlFor,name,value',\n    'p^[HTMLElement]|align',\n    'param^[HTMLElement]|name,type,value,valueType',\n    'picture^[HTMLElement]|',\n    'pre^[HTMLElement]|#width',\n    'progress^[HTMLElement]|#max,#value',\n    'q,blockquote,cite^[HTMLElement]|',\n    'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',\n    'select^[HTMLElement]|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',\n    'shadow^[HTMLElement]|',\n    'source^[HTMLElement]|media,sizes,src,srcset,type',\n    'span^[HTMLElement]|',\n    'style^[HTMLElement]|!disabled,media,type',\n    'caption^[HTMLElement]|align',\n    'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',\n    'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',\n    'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',\n    'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',\n    'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',\n    'template^[HTMLElement]|',\n    'textarea^[HTMLElement]|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',\n    'title^[HTMLElement]|text',\n    'track^[HTMLElement]|!default,kind,label,src,srclang',\n    'ul^[HTMLElement]|!compact,type',\n    'unknown^[HTMLElement]|',\n    'video^media|#height,poster,#width',\n    ':svg:a^:svg:graphics|',\n    ':svg:animate^:svg:animation|',\n    ':svg:animateMotion^:svg:animation|',\n    ':svg:animateTransform^:svg:animation|',\n    ':svg:circle^:svg:geometry|',\n    ':svg:clipPath^:svg:graphics|',\n    ':svg:cursor^:svg:|',\n    ':svg:defs^:svg:graphics|',\n    ':svg:desc^:svg:|',\n    ':svg:discard^:svg:|',\n    ':svg:ellipse^:svg:geometry|',\n    ':svg:feBlend^:svg:|',\n    ':svg:feColorMatrix^:svg:|',\n    ':svg:feComponentTransfer^:svg:|',\n    ':svg:feComposite^:svg:|',\n    ':svg:feConvolveMatrix^:svg:|',\n    ':svg:feDiffuseLighting^:svg:|',\n    ':svg:feDisplacementMap^:svg:|',\n    ':svg:feDistantLight^:svg:|',\n    ':svg:feDropShadow^:svg:|',\n    ':svg:feFlood^:svg:|',\n    ':svg:feFuncA^:svg:componentTransferFunction|',\n    ':svg:feFuncB^:svg:componentTransferFunction|',\n    ':svg:feFuncG^:svg:componentTransferFunction|',\n    ':svg:feFuncR^:svg:componentTransferFunction|',\n    ':svg:feGaussianBlur^:svg:|',\n    ':svg:feImage^:svg:|',\n    ':svg:feMerge^:svg:|',\n    ':svg:feMergeNode^:svg:|',\n    ':svg:feMorphology^:svg:|',\n    ':svg:feOffset^:svg:|',\n    ':svg:fePointLight^:svg:|',\n    ':svg:feSpecularLighting^:svg:|',\n    ':svg:feSpotLight^:svg:|',\n    ':svg:feTile^:svg:|',\n    ':svg:feTurbulence^:svg:|',\n    ':svg:filter^:svg:|',\n    ':svg:foreignObject^:svg:graphics|',\n    ':svg:g^:svg:graphics|',\n    ':svg:image^:svg:graphics|',\n    ':svg:line^:svg:geometry|',\n    ':svg:linearGradient^:svg:gradient|',\n    ':svg:mpath^:svg:|',\n    ':svg:marker^:svg:|',\n    ':svg:mask^:svg:|',\n    ':svg:metadata^:svg:|',\n    ':svg:path^:svg:geometry|',\n    ':svg:pattern^:svg:|',\n    ':svg:polygon^:svg:geometry|',\n    ':svg:polyline^:svg:geometry|',\n    ':svg:radialGradient^:svg:gradient|',\n    ':svg:rect^:svg:geometry|',\n    ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',\n    ':svg:script^:svg:|type',\n    ':svg:set^:svg:animation|',\n    ':svg:stop^:svg:|',\n    ':svg:style^:svg:|!disabled,media,title,type',\n    ':svg:switch^:svg:graphics|',\n    ':svg:symbol^:svg:|',\n    ':svg:tspan^:svg:textPositioning|',\n    ':svg:text^:svg:textPositioning|',\n    ':svg:textPath^:svg:textContent|',\n    ':svg:title^:svg:|',\n    ':svg:use^:svg:graphics|',\n    ':svg:view^:svg:|#zoomAndPan',\n    'data^[HTMLElement]|value',\n    'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',\n    'summary^[HTMLElement]|',\n    'time^[HTMLElement]|dateTime',\n];\nvar _ATTR_TO_PROP = {\n    'class': 'className',\n    'for': 'htmlFor',\n    'formaction': 'formAction',\n    'innerHtml': 'innerHTML',\n    'readonly': 'readOnly',\n    'tabindex': 'tabIndex',\n};\nvar DomElementSchemaRegistry = (function (_super) {\n    __extends(DomElementSchemaRegistry, _super);\n    function DomElementSchemaRegistry() {\n        var _this = _super.call(this) || this;\n        _this._schema = {};\n        SCHEMA.forEach(function (encodedType) {\n            var type = {};\n            var _a = encodedType.split('|'), strType = _a[0], strProperties = _a[1];\n            var properties = strProperties.split(',');\n            var _b = strType.split('^'), typeNames = _b[0], superName = _b[1];\n            typeNames.split(',').forEach(function (tag) { return _this._schema[tag.toLowerCase()] = type; });\n            var superType = superName && _this._schema[superName.toLowerCase()];\n            if (superType) {\n                Object.keys(superType).forEach(function (prop) { type[prop] = superType[prop]; });\n            }\n            properties.forEach(function (property) {\n                if (property.length > 0) {\n                    switch (property[0]) {\n                        case '*':\n                            // We don't yet support events.\n                            // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events\n                            // will\n                            // almost certainly introduce bad XSS vulnerabilities.\n                            // type[property.substring(1)] = EVENT;\n                            break;\n                        case '!':\n                            type[property.substring(1)] = BOOLEAN;\n                            break;\n                        case '#':\n                            type[property.substring(1)] = NUMBER;\n                            break;\n                        case '%':\n                            type[property.substring(1)] = OBJECT;\n                            break;\n                        default:\n                            type[property] = STRING;\n                    }\n                }\n            });\n        });\n        return _this;\n    }\n    /**\n     * @param {?} tagName\n     * @param {?} propName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.hasProperty = function (tagName, propName, schemaMetas) {\n        if (schemaMetas.some(function (schema) { return schema.name === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"NO_ERRORS_SCHEMA\"].name; })) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (isNgContainer(tagName) || isNgContent(tagName)) {\n                return false;\n            }\n            if (schemaMetas.some(function (schema) { return schema.name === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"CUSTOM_ELEMENTS_SCHEMA\"].name; })) {\n                // Can't tell now as we don't know which properties a custom element will get\n                // once it is instantiated\n                return true;\n            }\n        }\n        var /** @type {?} */ elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];\n        return !!elementProperties[propName];\n    };\n    /**\n     * @param {?} tagName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.hasElement = function (tagName, schemaMetas) {\n        if (schemaMetas.some(function (schema) { return schema.name === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"NO_ERRORS_SCHEMA\"].name; })) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (isNgContainer(tagName) || isNgContent(tagName)) {\n                return true;\n            }\n            if (schemaMetas.some(function (schema) { return schema.name === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"CUSTOM_ELEMENTS_SCHEMA\"].name; })) {\n                // Allow any custom elements\n                return true;\n            }\n        }\n        return !!this._schema[tagName.toLowerCase()];\n    };\n    /**\n     * securityContext returns the security context for the given property on the given DOM tag.\n     *\n     * Tag and property name are statically known and cannot change at runtime, i.e. it is not\n     * possible to bind a value into a changing attribute or tag name.\n     *\n     * The filtering is white list based. All attributes in the schema above are assumed to have the\n     * 'NONE' security context, i.e. that they are safe inert string values. Only specific well known\n     * attack vectors are assigned their appropriate context.\n     * @param {?} tagName\n     * @param {?} propName\n     * @param {?} isAttribute\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.securityContext = function (tagName, propName, isAttribute) {\n        if (isAttribute) {\n            // NB: For security purposes, use the mapped property name, not the attribute name.\n            propName = this.getMappedPropName(propName);\n        }\n        // Make sure comparisons are case insensitive, so that case differences between attribute and\n        // property names do not have a security impact.\n        tagName = tagName.toLowerCase();\n        propName = propName.toLowerCase();\n        var /** @type {?} */ ctx = SECURITY_SCHEMA[tagName + '|' + propName];\n        if (ctx) {\n            return ctx;\n        }\n        ctx = SECURITY_SCHEMA['*|' + propName];\n        return ctx ? ctx : __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"SecurityContext\"].NONE;\n    };\n    /**\n     * @param {?} propName\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.getMappedPropName = function (propName) { return _ATTR_TO_PROP[propName] || propName; };\n    /**\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.getDefaultComponentElementName = function () { return 'ng-component'; };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.validateProperty = function (name) {\n        if (name.toLowerCase().startsWith('on')) {\n            var /** @type {?} */ msg = \"Binding to event property '\" + name + \"' is disallowed for security reasons, \" +\n                (\"please use (\" + name.slice(2) + \")=...\") +\n                (\"\\nIf '\" + name + \"' is a directive input, make sure the directive is imported by the\") +\n                \" current module.\";\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.validateAttribute = function (name) {\n        if (name.toLowerCase().startsWith('on')) {\n            var /** @type {?} */ msg = \"Binding to event attribute '\" + name + \"' is disallowed for security reasons, \" +\n                (\"please use (\" + name.slice(2) + \")=...\");\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    };\n    /**\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.allKnownElementNames = function () { return Object.keys(this._schema); };\n    /**\n     * @param {?} propName\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.normalizeAnimationStyleProperty = function (propName) {\n        return dashCaseToCamelCase(propName);\n    };\n    /**\n     * @param {?} camelCaseProp\n     * @param {?} userProvidedProp\n     * @param {?} val\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.normalizeAnimationStyleValue = function (camelCaseProp, userProvidedProp, val) {\n        var /** @type {?} */ unit = '';\n        var /** @type {?} */ strVal = val.toString().trim();\n        var /** @type {?} */ errorMsg = ((null));\n        if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n            if (typeof val === 'number') {\n                unit = 'px';\n            }\n            else {\n                var /** @type {?} */ valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n                    errorMsg = \"Please provide a CSS unit value for \" + userProvidedProp + \":\" + val;\n                }\n            }\n        }\n        return { error: errorMsg, value: strVal + unit };\n    };\n    return DomElementSchemaRegistry;\n}(ElementSchemaRegistry));\nDomElementSchemaRegistry.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nDomElementSchemaRegistry.ctorParameters = function () { return []; };\n/**\n * @param {?} prop\n * @return {?}\n */\nfunction _isPixelDimensionStyle(prop) {\n    switch (prop) {\n        case 'width':\n        case 'height':\n        case 'minWidth':\n        case 'minHeight':\n        case 'maxWidth':\n        case 'maxHeight':\n        case 'left':\n        case 'top':\n        case 'bottom':\n        case 'right':\n        case 'fontSize':\n        case 'outlineWidth':\n        case 'outlineOffset':\n        case 'paddingTop':\n        case 'paddingLeft':\n        case 'paddingBottom':\n        case 'paddingRight':\n        case 'marginTop':\n        case 'marginLeft':\n        case 'marginBottom':\n        case 'marginRight':\n        case 'borderRadius':\n        case 'borderWidth':\n        case 'borderTopWidth':\n        case 'borderLeftWidth':\n        case 'borderRightWidth':\n        case 'borderBottomWidth':\n        case 'textIndent':\n            return true;\n        default:\n            return false;\n    }\n}\nvar ShadowCss = (function () {\n    function ShadowCss() {\n        this.strictStyling = true;\n    }\n    /**\n     * @param {?} cssText\n     * @param {?} selector\n     * @param {?=} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype.shimCssText = function (cssText, selector, hostSelector) {\n        if (hostSelector === void 0) { hostSelector = ''; }\n        var /** @type {?} */ sourceMappingUrl = extractSourceMappingUrl(cssText);\n        cssText = stripComments(cssText);\n        cssText = this._insertDirectives(cssText);\n        return this._scopeCssText(cssText, selector, hostSelector) + sourceMappingUrl;\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._insertDirectives = function (cssText) {\n        cssText = this._insertPolyfillDirectivesInCssText(cssText);\n        return this._insertPolyfillRulesInCssText(cssText);\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._insertPolyfillDirectivesInCssText = function (cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        return cssText.replace(_cssContentNextSelectorRe, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            return m[2] + '{';\n        });\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._insertPolyfillRulesInCssText = function (cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        return cssText.replace(_cssContentRuleRe, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            var /** @type {?} */ rule = m[0].replace(m[1], '').replace(m[2], '');\n            return m[4] + rule;\n        });\n    };\n    /**\n     * @param {?} cssText\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._scopeCssText = function (cssText, scopeSelector, hostSelector) {\n        var /** @type {?} */ unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n        // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n        cssText = this._insertPolyfillHostInCssText(cssText);\n        cssText = this._convertColonHost(cssText);\n        cssText = this._convertColonHostContext(cssText);\n        cssText = this._convertShadowDOMSelectors(cssText);\n        if (scopeSelector) {\n            cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n        }\n        cssText = cssText + '\\n' + unscopedRules;\n        return cssText.trim();\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._extractUnscopedRulesFromCssText = function (cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        var /** @type {?} */ r = '';\n        var /** @type {?} */ m;\n        _cssContentUnscopedRuleRe.lastIndex = 0;\n        while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n            var /** @type {?} */ rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n            r += rule + '\\n\\n';\n        }\n        return r;\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._convertColonHost = function (cssText) {\n        return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._convertColonHostContext = function (cssText) {\n        return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);\n    };\n    /**\n     * @param {?} cssText\n     * @param {?} regExp\n     * @param {?} partReplacer\n     * @return {?}\n     */\n    ShadowCss.prototype._convertColonRule = function (cssText, regExp, partReplacer) {\n        // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule\n        return cssText.replace(regExp, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            if (m[2]) {\n                var /** @type {?} */ parts = m[2].split(',');\n                var /** @type {?} */ r = [];\n                for (var /** @type {?} */ i = 0; i < parts.length; i++) {\n                    var /** @type {?} */ p = parts[i].trim();\n                    if (!p)\n                        break;\n                    r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));\n                }\n                return r.join(',');\n            }\n            else {\n                return _polyfillHostNoCombinator + m[3];\n            }\n        });\n    };\n    /**\n     * @param {?} host\n     * @param {?} part\n     * @param {?} suffix\n     * @return {?}\n     */\n    ShadowCss.prototype._colonHostContextPartReplacer = function (host, part, suffix) {\n        if (part.indexOf(_polyfillHost) > -1) {\n            return this._colonHostPartReplacer(host, part, suffix);\n        }\n        else {\n            return host + part + suffix + ', ' + part + ' ' + host + suffix;\n        }\n    };\n    /**\n     * @param {?} host\n     * @param {?} part\n     * @param {?} suffix\n     * @return {?}\n     */\n    ShadowCss.prototype._colonHostPartReplacer = function (host, part, suffix) {\n        return host + part.replace(_polyfillHost, '') + suffix;\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._convertShadowDOMSelectors = function (cssText) {\n        return _shadowDOMSelectorsRe.reduce(function (result, pattern) { return result.replace(pattern, ' '); }, cssText);\n    };\n    /**\n     * @param {?} cssText\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._scopeSelectors = function (cssText, scopeSelector, hostSelector) {\n        var _this = this;\n        return processRules(cssText, function (rule) {\n            var /** @type {?} */ selector = rule.selector;\n            var /** @type {?} */ content = rule.content;\n            if (rule.selector[0] != '@') {\n                selector =\n                    _this._scopeSelector(rule.selector, scopeSelector, hostSelector, _this.strictStyling);\n            }\n            else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\n                rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {\n                content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n            }\n            return new CssRule(selector, content);\n        });\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @param {?} strict\n     * @return {?}\n     */\n    ShadowCss.prototype._scopeSelector = function (selector, scopeSelector, hostSelector, strict) {\n        var _this = this;\n        return selector.split(',')\n            .map(function (part) { return part.trim().split(_shadowDeepSelectors); })\n            .map(function (deepParts) {\n            var shallowPart = deepParts[0], otherParts = deepParts.slice(1);\n            var /** @type {?} */ applyScope = function (shallowPart) {\n                if (_this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n                    return strict ?\n                        _this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :\n                        _this._applySelectorScope(shallowPart, scopeSelector, hostSelector);\n                }\n                else {\n                    return shallowPart;\n                }\n            };\n            return [applyScope(shallowPart)].concat(otherParts).join(' ');\n        })\n            .join(', ');\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._selectorNeedsScoping = function (selector, scopeSelector) {\n        var /** @type {?} */ re = this._makeScopeMatcher(scopeSelector);\n        return !re.test(selector);\n    };\n    /**\n     * @param {?} scopeSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._makeScopeMatcher = function (scopeSelector) {\n        var /** @type {?} */ lre = /\\[/g;\n        var /** @type {?} */ rre = /\\]/g;\n        scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n        return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._applySelectorScope = function (selector, scopeSelector, hostSelector) {\n        // Difference from webcomponents.js: scopeSelector could not be an array\n        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._applySimpleSelectorScope = function (selector, scopeSelector, hostSelector) {\n        // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n        _polyfillHostRe.lastIndex = 0;\n        if (_polyfillHostRe.test(selector)) {\n            var /** @type {?} */ replaceBy_1 = this.strictStyling ? \"[\" + hostSelector + \"]\" : scopeSelector;\n            return selector\n                .replace(_polyfillHostNoCombinatorRe, function (hnc, selector) {\n                return selector.replace(/([^:]*)(:*)(.*)/, function (_, before, colon, after) {\n                    return before + replaceBy_1 + colon + after;\n                });\n            })\n                .replace(_polyfillHostRe, replaceBy_1 + ' ');\n        }\n        return scopeSelector + ' ' + selector;\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._applyStrictSelectorScope = function (selector, scopeSelector, hostSelector) {\n        var _this = this;\n        var /** @type {?} */ isRe = /\\[is=([^\\]]*)\\]/g;\n        scopeSelector = scopeSelector.replace(isRe, function (_) {\n            var parts = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                parts[_i - 1] = arguments[_i];\n            }\n            return parts[0];\n        });\n        var /** @type {?} */ attrName = '[' + scopeSelector + ']';\n        var /** @type {?} */ _scopeSelectorPart = function (p) {\n            var /** @type {?} */ scopedP = p.trim();\n            if (!scopedP) {\n                return '';\n            }\n            if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n                scopedP = _this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n            }\n            else {\n                // remove :host since it should be unnecessary\n                var /** @type {?} */ t = p.replace(_polyfillHostRe, '');\n                if (t.length > 0) {\n                    var /** @type {?} */ matches = t.match(/([^:]*)(:*)(.*)/);\n                    if (matches) {\n                        scopedP = matches[1] + attrName + matches[2] + matches[3];\n                    }\n                }\n            }\n            return scopedP;\n        };\n        var /** @type {?} */ safeContent = new SafeSelector(selector);\n        selector = safeContent.content();\n        var /** @type {?} */ scopedSelector = '';\n        var /** @type {?} */ startIndex = 0;\n        var /** @type {?} */ res;\n        var /** @type {?} */ sep = /( |>|\\+|~(?!=))\\s*/g;\n        var /** @type {?} */ scopeAfter = selector.indexOf(_polyfillHostNoCombinator);\n        while ((res = sep.exec(selector)) !== null) {\n            var /** @type {?} */ separator = res[1];\n            var /** @type {?} */ part = selector.slice(startIndex, res.index).trim();\n            // if a selector appears before :host-context it should not be shimmed as it\n            // matches on ancestor elements and not on elements in the host's shadow\n            var /** @type {?} */ scopedPart = startIndex >= scopeAfter ? _scopeSelectorPart(part) : part;\n            scopedSelector += scopedPart + \" \" + separator + \" \";\n            startIndex = sep.lastIndex;\n        }\n        scopedSelector += _scopeSelectorPart(selector.substring(startIndex));\n        // replace the placeholders with their original values\n        return safeContent.restore(scopedSelector);\n    };\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    ShadowCss.prototype._insertPolyfillHostInCssText = function (selector) {\n        return selector.replace(_colonHostContextRe, _polyfillHostContext)\n            .replace(_colonHostRe, _polyfillHost);\n    };\n    return ShadowCss;\n}());\nvar SafeSelector = (function () {\n    /**\n     * @param {?} selector\n     */\n    function SafeSelector(selector) {\n        var _this = this;\n        this.placeholders = [];\n        this.index = 0;\n        // Replaces attribute selectors with placeholders.\n        // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n        selector = selector.replace(/(\\[[^\\]]*\\])/g, function (_, keep) {\n            var replaceBy = \"__ph-\" + _this.index + \"__\";\n            _this.placeholders.push(keep);\n            _this.index++;\n            return replaceBy;\n        });\n        // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n        // WS and \"+\" would otherwise be interpreted as selector separators.\n        this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, function (_, pseudo, exp) {\n            var replaceBy = \"__ph-\" + _this.index + \"__\";\n            _this.placeholders.push(exp);\n            _this.index++;\n            return pseudo + replaceBy;\n        });\n    }\n    ;\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n    SafeSelector.prototype.restore = function (content) {\n        var _this = this;\n        return content.replace(/__ph-(\\d+)__/g, function (ph, index) { return _this.placeholders[+index]; });\n    };\n    /**\n     * @return {?}\n     */\n    SafeSelector.prototype.content = function () { return this._content; };\n    return SafeSelector;\n}());\nvar _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nvar _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nvar _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nvar _polyfillHost = '-shadowcsshost';\n// note: :host-context pre-processed to -shadowcsshostcontext.\nvar _polyfillHostContext = '-shadowcsscontext';\nvar _parenSuffix = ')(?:\\\\((' +\n    '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n    ')\\\\))?([^,{]*)';\nvar _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');\nvar _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');\nvar _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nvar _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nvar _shadowDOMSelectorsRe = [\n    /::shadow/g,\n    /::content/g,\n    // Deprecated selectors\n    /\\/shadow-deep\\//g,\n    /\\/shadow\\//g,\n];\nvar _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)/g;\nvar _selectorReSuffix = '([>\\\\s~+\\[.,{:][\\\\s\\\\S]*)?$';\nvar _polyfillHostRe = /-shadowcsshost/gim;\nvar _colonHostRe = /:host/gim;\nvar _colonHostContextRe = /:host-context/gim;\nvar _commentRe = /\\/\\*\\s*[\\s\\S]*?\\*\\//g;\n/**\n * @param {?} input\n * @return {?}\n */\nfunction stripComments(input) {\n    return input.replace(_commentRe, '');\n}\n// all comments except inline source mapping\nvar _sourceMappingUrlRe = /\\/\\*\\s*#\\s*sourceMappingURL=[\\s\\S]+?\\*\\//;\n/**\n * @param {?} input\n * @return {?}\n */\nfunction extractSourceMappingUrl(input) {\n    var /** @type {?} */ matcher = input.match(_sourceMappingUrlRe);\n    return matcher ? matcher[0] : '';\n}\nvar _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nvar _curlyRe = /([{}])/g;\nvar OPEN_CURLY = '{';\nvar CLOSE_CURLY = '}';\nvar BLOCK_PLACEHOLDER = '%BLOCK%';\nvar CssRule = (function () {\n    /**\n     * @param {?} selector\n     * @param {?} content\n     */\n    function CssRule(selector, content) {\n        this.selector = selector;\n        this.content = content;\n    }\n    return CssRule;\n}());\n/**\n * @param {?} input\n * @param {?} ruleCallback\n * @return {?}\n */\nfunction processRules(input, ruleCallback) {\n    var /** @type {?} */ inputWithEscapedBlocks = escapeBlocks(input);\n    var /** @type {?} */ nextBlockIndex = 0;\n    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        var /** @type {?} */ selector = m[2];\n        var /** @type {?} */ content = '';\n        var /** @type {?} */ suffix = m[4];\n        var /** @type {?} */ contentPrefix = '';\n        if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n            suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n            contentPrefix = '{';\n        }\n        var /** @type {?} */ rule = ruleCallback(new CssRule(selector, content));\n        return \"\" + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;\n    });\n}\nvar StringWithEscapedBlocks = (function () {\n    /**\n     * @param {?} escapedString\n     * @param {?} blocks\n     */\n    function StringWithEscapedBlocks(escapedString, blocks) {\n        this.escapedString = escapedString;\n        this.blocks = blocks;\n    }\n    return StringWithEscapedBlocks;\n}());\n/**\n * @param {?} input\n * @return {?}\n */\nfunction escapeBlocks(input) {\n    var /** @type {?} */ inputParts = input.split(_curlyRe);\n    var /** @type {?} */ resultParts = [];\n    var /** @type {?} */ escapedBlocks = [];\n    var /** @type {?} */ bracketCount = 0;\n    var /** @type {?} */ currentBlockParts = [];\n    for (var /** @type {?} */ partIndex = 0; partIndex < inputParts.length; partIndex++) {\n        var /** @type {?} */ part = inputParts[partIndex];\n        if (part == CLOSE_CURLY) {\n            bracketCount--;\n        }\n        if (bracketCount > 0) {\n            currentBlockParts.push(part);\n        }\n        else {\n            if (currentBlockParts.length > 0) {\n                escapedBlocks.push(currentBlockParts.join(''));\n                resultParts.push(BLOCK_PLACEHOLDER);\n                currentBlockParts = [];\n            }\n            resultParts.push(part);\n        }\n        if (part == OPEN_CURLY) {\n            bracketCount++;\n        }\n    }\n    if (currentBlockParts.length > 0) {\n        escapedBlocks.push(currentBlockParts.join(''));\n        resultParts.push(BLOCK_PLACEHOLDER);\n    }\n    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar COMPONENT_VARIABLE = '%COMP%';\nvar HOST_ATTR = \"_nghost-\" + COMPONENT_VARIABLE;\nvar CONTENT_ATTR = \"_ngcontent-\" + COMPONENT_VARIABLE;\nvar StylesCompileDependency = (function () {\n    /**\n     * @param {?} name\n     * @param {?} moduleUrl\n     * @param {?} isShimmed\n     * @param {?} valuePlaceholder\n     */\n    function StylesCompileDependency(name, moduleUrl, isShimmed, valuePlaceholder) {\n        this.name = name;\n        this.moduleUrl = moduleUrl;\n        this.isShimmed = isShimmed;\n        this.valuePlaceholder = valuePlaceholder;\n    }\n    return StylesCompileDependency;\n}());\nvar StylesCompileResult = (function () {\n    /**\n     * @param {?} componentStylesheet\n     * @param {?} externalStylesheets\n     */\n    function StylesCompileResult(componentStylesheet, externalStylesheets) {\n        this.componentStylesheet = componentStylesheet;\n        this.externalStylesheets = externalStylesheets;\n    }\n    return StylesCompileResult;\n}());\nvar CompiledStylesheet = (function () {\n    /**\n     * @param {?} statements\n     * @param {?} stylesVar\n     * @param {?} dependencies\n     * @param {?} isShimmed\n     * @param {?} meta\n     */\n    function CompiledStylesheet(statements, stylesVar, dependencies, isShimmed, meta) {\n        this.statements = statements;\n        this.stylesVar = stylesVar;\n        this.dependencies = dependencies;\n        this.isShimmed = isShimmed;\n        this.meta = meta;\n    }\n    return CompiledStylesheet;\n}());\nvar StyleCompiler = (function () {\n    /**\n     * @param {?} _urlResolver\n     */\n    function StyleCompiler(_urlResolver) {\n        this._urlResolver = _urlResolver;\n        this._shadowCss = new ShadowCss();\n    }\n    /**\n     * @param {?} comp\n     * @return {?}\n     */\n    StyleCompiler.prototype.compileComponent = function (comp) {\n        var _this = this;\n        var /** @type {?} */ template = ((comp.template));\n        var /** @type {?} */ externalStylesheets = [];\n        var /** @type {?} */ componentStylesheet = this._compileStyles(comp, new CompileStylesheetMetadata({\n            styles: template.styles,\n            styleUrls: template.styleUrls,\n            moduleUrl: identifierModuleUrl(comp.type)\n        }), true);\n        template.externalStylesheets.forEach(function (stylesheetMeta) {\n            var /** @type {?} */ compiledStylesheet = _this._compileStyles(comp, stylesheetMeta, false);\n            externalStylesheets.push(compiledStylesheet);\n        });\n        return new StylesCompileResult(componentStylesheet, externalStylesheets);\n    };\n    /**\n     * @param {?} comp\n     * @param {?} stylesheet\n     * @param {?} isComponentStylesheet\n     * @return {?}\n     */\n    StyleCompiler.prototype._compileStyles = function (comp, stylesheet, isComponentStylesheet) {\n        var _this = this;\n        var /** @type {?} */ shim = ((comp.template)).encapsulation === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewEncapsulation\"].Emulated;\n        var /** @type {?} */ styleExpressions = stylesheet.styles.map(function (plainStyle) { return literal(_this._shimIfNeeded(plainStyle, shim)); });\n        var /** @type {?} */ dependencies = [];\n        for (var /** @type {?} */ i = 0; i < stylesheet.styleUrls.length; i++) {\n            var /** @type {?} */ identifier = { reference: null };\n            dependencies.push(new StylesCompileDependency(getStylesVarName(null), stylesheet.styleUrls[i], shim, identifier));\n            styleExpressions.push(new ExternalExpr(identifier));\n        }\n        // styles variable contains plain strings and arrays of other styles arrays (recursive),\n        // so we set its type to dynamic.\n        var /** @type {?} */ stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);\n        var /** @type {?} */ stmt = variable(stylesVar)\n            .set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])))\n            .toDeclStmt(null, [StmtModifier.Final]);\n        return new CompiledStylesheet([stmt], stylesVar, dependencies, shim, stylesheet);\n    };\n    /**\n     * @param {?} style\n     * @param {?} shim\n     * @return {?}\n     */\n    StyleCompiler.prototype._shimIfNeeded = function (style$$1, shim) {\n        return shim ? this._shadowCss.shimCssText(style$$1, CONTENT_ATTR, HOST_ATTR) : style$$1;\n    };\n    return StyleCompiler;\n}());\nStyleCompiler.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nStyleCompiler.ctorParameters = function () { return [\n    { type: UrlResolver, },\n]; };\n/**\n * @param {?} component\n * @return {?}\n */\nfunction getStylesVarName(component) {\n    var /** @type {?} */ result = \"styles\";\n    if (component) {\n        result += \"_\" + identifierName(component.type);\n    }\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar EventHandlerVars = (function () {\n    function EventHandlerVars() {\n    }\n    return EventHandlerVars;\n}());\nEventHandlerVars.event = variable('$event');\nvar ConvertActionBindingResult = (function () {\n    /**\n     * @param {?} stmts\n     * @param {?} allowDefault\n     */\n    function ConvertActionBindingResult(stmts, allowDefault) {\n        this.stmts = stmts;\n        this.allowDefault = allowDefault;\n    }\n    return ConvertActionBindingResult;\n}());\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n * @param {?} localResolver\n * @param {?} implicitReceiver\n * @param {?} action\n * @param {?} bindingId\n * @return {?}\n */\nfunction convertActionBinding(localResolver, implicitReceiver, action, bindingId) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver();\n    }\n    var /** @type {?} */ actionWithoutBuiltins = convertPropertyBindingBuiltins({\n        createLiteralArrayConverter: function (argCount) {\n            // Note: no caching for literal arrays in actions.\n            return function (args) { return literalArr(args); };\n        },\n        createLiteralMapConverter: function (keys) {\n            // Note: no caching for literal maps in actions.\n            return function (args) { return literalMap(/** @type {?} */ (keys.map(function (key, i) { return [key, args[i]]; }))); };\n        },\n        createPipeConverter: function (name) {\n            throw new Error(\"Illegal State: Actions are not allowed to contain pipes. Pipe: \" + name);\n        }\n    }, action);\n    var /** @type {?} */ visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId);\n    var /** @type {?} */ actionStmts = [];\n    flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n    prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n    var /** @type {?} */ lastIndex = actionStmts.length - 1;\n    var /** @type {?} */ preventDefaultVar = ((null));\n    if (lastIndex >= 0) {\n        var /** @type {?} */ lastStatement = actionStmts[lastIndex];\n        var /** @type {?} */ returnExpr = convertStmtIntoExpression(lastStatement);\n        if (returnExpr) {\n            // Note: We need to cast the result of the method call to dynamic,\n            // as it might be a void method!\n            preventDefaultVar = createPreventDefaultVar(bindingId);\n            actionStmts[lastIndex] =\n                preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false)))\n                    .toDeclStmt(null, [StmtModifier.Final]);\n        }\n    }\n    return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n}\n/**\n * @param {?} converterFactory\n * @param {?} ast\n * @return {?}\n */\nfunction convertPropertyBindingBuiltins(converterFactory, ast) {\n    return convertBuiltins(converterFactory, ast);\n}\nvar ConvertPropertyBindingResult = (function () {\n    /**\n     * @param {?} stmts\n     * @param {?} currValExpr\n     */\n    function ConvertPropertyBindingResult(stmts, currValExpr) {\n        this.stmts = stmts;\n        this.currValExpr = currValExpr;\n    }\n    return ConvertPropertyBindingResult;\n}());\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n * @param {?} localResolver\n * @param {?} implicitReceiver\n * @param {?} expressionWithoutBuiltins\n * @param {?} bindingId\n * @return {?}\n */\nfunction convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver();\n    }\n    var /** @type {?} */ currValExpr = createCurrValueExpr(bindingId);\n    var /** @type {?} */ stmts = [];\n    var /** @type {?} */ visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId);\n    var /** @type {?} */ outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n    if (visitor.temporaryCount) {\n        for (var /** @type {?} */ i = 0; i < visitor.temporaryCount; i++) {\n            stmts.push(temporaryDeclaration(bindingId, i));\n        }\n    }\n    stmts.push(currValExpr.set(outputExpr).toDeclStmt(null, [StmtModifier.Final]));\n    return new ConvertPropertyBindingResult(stmts, currValExpr);\n}\n/**\n * @param {?} converterFactory\n * @param {?} ast\n * @return {?}\n */\nfunction convertBuiltins(converterFactory, ast) {\n    var /** @type {?} */ visitor = new _BuiltinAstConverter(converterFactory);\n    return ast.visit(visitor);\n}\n/**\n * @param {?} bindingId\n * @param {?} temporaryNumber\n * @return {?}\n */\nfunction temporaryName(bindingId, temporaryNumber) {\n    return \"tmp_\" + bindingId + \"_\" + temporaryNumber;\n}\n/**\n * @param {?} bindingId\n * @param {?} temporaryNumber\n * @return {?}\n */\nfunction temporaryDeclaration(bindingId, temporaryNumber) {\n    return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber), NULL_EXPR);\n}\n/**\n * @param {?} temporaryCount\n * @param {?} bindingId\n * @param {?} statements\n * @return {?}\n */\nfunction prependTemporaryDecls(temporaryCount, bindingId, statements) {\n    for (var /** @type {?} */ i = temporaryCount - 1; i >= 0; i--) {\n        statements.unshift(temporaryDeclaration(bindingId, i));\n    }\n}\nvar _Mode = {};\n_Mode.Statement = 0;\n_Mode.Expression = 1;\n_Mode[_Mode.Statement] = \"Statement\";\n_Mode[_Mode.Expression] = \"Expression\";\n/**\n * @param {?} mode\n * @param {?} ast\n * @return {?}\n */\nfunction ensureStatementMode(mode, ast) {\n    if (mode !== _Mode.Statement) {\n        throw new Error(\"Expected a statement, but saw \" + ast);\n    }\n}\n/**\n * @param {?} mode\n * @param {?} ast\n * @return {?}\n */\nfunction ensureExpressionMode(mode, ast) {\n    if (mode !== _Mode.Expression) {\n        throw new Error(\"Expected an expression, but saw \" + ast);\n    }\n}\n/**\n * @param {?} mode\n * @param {?} expr\n * @return {?}\n */\nfunction convertToStatementIfNeeded(mode, expr) {\n    if (mode === _Mode.Statement) {\n        return expr.toStmt();\n    }\n    else {\n        return expr;\n    }\n}\nvar _BuiltinAstConverter = (function (_super) {\n    __extends(_BuiltinAstConverter, _super);\n    /**\n     * @param {?} _converterFactory\n     */\n    function _BuiltinAstConverter(_converterFactory) {\n        var _this = _super.call(this) || this;\n        _this._converterFactory = _converterFactory;\n        return _this;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    _BuiltinAstConverter.prototype.visitPipe = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ args = [ast.exp].concat(ast.args).map(function (ast) { return ast.visit(_this, context); });\n        return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createPipeConverter(ast.name, args.length));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    _BuiltinAstConverter.prototype.visitLiteralArray = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ args = ast.expressions.map(function (ast) { return ast.visit(_this, context); });\n        return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    _BuiltinAstConverter.prototype.visitLiteralMap = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ args = ast.values.map(function (ast) { return ast.visit(_this, context); });\n        return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n    };\n    return _BuiltinAstConverter;\n}(AstTransformer));\nvar _AstToIrVisitor = (function () {\n    /**\n     * @param {?} _localResolver\n     * @param {?} _implicitReceiver\n     * @param {?} bindingId\n     */\n    function _AstToIrVisitor(_localResolver, _implicitReceiver, bindingId) {\n        this._localResolver = _localResolver;\n        this._implicitReceiver = _implicitReceiver;\n        this.bindingId = bindingId;\n        this._nodeMap = new Map();\n        this._resultMap = new Map();\n        this._currentTemporary = 0;\n        this.temporaryCount = 0;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitBinary = function (ast, mode) {\n        var /** @type {?} */ op;\n        switch (ast.operation) {\n            case '+':\n                op = BinaryOperator.Plus;\n                break;\n            case '-':\n                op = BinaryOperator.Minus;\n                break;\n            case '*':\n                op = BinaryOperator.Multiply;\n                break;\n            case '/':\n                op = BinaryOperator.Divide;\n                break;\n            case '%':\n                op = BinaryOperator.Modulo;\n                break;\n            case '&&':\n                op = BinaryOperator.And;\n                break;\n            case '||':\n                op = BinaryOperator.Or;\n                break;\n            case '==':\n                op = BinaryOperator.Equals;\n                break;\n            case '!=':\n                op = BinaryOperator.NotEquals;\n                break;\n            case '===':\n                op = BinaryOperator.Identical;\n                break;\n            case '!==':\n                op = BinaryOperator.NotIdentical;\n                break;\n            case '<':\n                op = BinaryOperator.Lower;\n                break;\n            case '>':\n                op = BinaryOperator.Bigger;\n                break;\n            case '<=':\n                op = BinaryOperator.LowerEquals;\n                break;\n            case '>=':\n                op = BinaryOperator.BiggerEquals;\n                break;\n            default:\n                throw new Error(\"Unsupported operation \" + ast.operation);\n        }\n        return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this.visit(ast.left, _Mode.Expression), this.visit(ast.right, _Mode.Expression)));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitChain = function (ast, mode) {\n        ensureStatementMode(mode, ast);\n        return this.visitAll(ast.expressions, mode);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitConditional = function (ast, mode) {\n        var /** @type {?} */ value = this.visit(ast.condition, _Mode.Expression);\n        return convertToStatementIfNeeded(mode, value.conditional(this.visit(ast.trueExp, _Mode.Expression), this.visit(ast.falseExp, _Mode.Expression)));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitPipe = function (ast, mode) {\n        throw new Error(\"Illegal state: Pipes should have been converted into functions. Pipe: \" + ast.name);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitFunctionCall = function (ast, mode) {\n        var /** @type {?} */ convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n        var /** @type {?} */ fnResult;\n        if (ast instanceof BuiltinFunctionCall) {\n            fnResult = ast.converter(convertedArgs);\n        }\n        else {\n            fnResult = this.visit(/** @type {?} */ ((ast.target)), _Mode.Expression).callFn(convertedArgs);\n        }\n        return convertToStatementIfNeeded(mode, fnResult);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitImplicitReceiver = function (ast, mode) {\n        ensureExpressionMode(mode, ast);\n        return this._implicitReceiver;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitInterpolation = function (ast, mode) {\n        ensureExpressionMode(mode, ast);\n        var /** @type {?} */ args = [literal(ast.expressions.length)];\n        for (var /** @type {?} */ i = 0; i < ast.strings.length - 1; i++) {\n            args.push(literal(ast.strings[i]));\n            args.push(this.visit(ast.expressions[i], _Mode.Expression));\n        }\n        args.push(literal(ast.strings[ast.strings.length - 1]));\n        return ast.expressions.length <= 9 ?\n            importExpr(createIdentifier(Identifiers.inlineInterpolate)).callFn(args) :\n            importExpr(createIdentifier(Identifiers.interpolate)).callFn([\n                args[0], literalArr(args.slice(1))\n            ]);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitKeyedRead = function (ast, mode) {\n        var /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            return convertToStatementIfNeeded(mode, this.visit(ast.obj, _Mode.Expression).key(this.visit(ast.key, _Mode.Expression)));\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitKeyedWrite = function (ast, mode) {\n        var /** @type {?} */ obj = this.visit(ast.obj, _Mode.Expression);\n        var /** @type {?} */ key = this.visit(ast.key, _Mode.Expression);\n        var /** @type {?} */ value = this.visit(ast.value, _Mode.Expression);\n        return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitLiteralArray = function (ast, mode) {\n        throw new Error(\"Illegal State: literal arrays should have been converted into functions\");\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitLiteralMap = function (ast, mode) {\n        throw new Error(\"Illegal State: literal maps should have been converted into functions\");\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitLiteralPrimitive = function (ast, mode) {\n        return convertToStatementIfNeeded(mode, literal(ast.value));\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype._getLocal = function (name) { return this._localResolver.getLocal(name); };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitMethodCall = function (ast, mode) {\n        var /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            var /** @type {?} */ args = this.visitAll(ast.args, _Mode.Expression);\n            var /** @type {?} */ result = null;\n            var /** @type {?} */ receiver = this.visit(ast.receiver, _Mode.Expression);\n            if (receiver === this._implicitReceiver) {\n                var /** @type {?} */ varExpr = this._getLocal(ast.name);\n                if (varExpr) {\n                    result = varExpr.callFn(args);\n                }\n            }\n            if (result == null) {\n                result = receiver.callMethod(ast.name, args);\n            }\n            return convertToStatementIfNeeded(mode, result);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitPrefixNot = function (ast, mode) {\n        return convertToStatementIfNeeded(mode, not(this.visit(ast.expression, _Mode.Expression)));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitPropertyRead = function (ast, mode) {\n        var /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            var /** @type {?} */ result = null;\n            var /** @type {?} */ receiver = this.visit(ast.receiver, _Mode.Expression);\n            if (receiver === this._implicitReceiver) {\n                result = this._getLocal(ast.name);\n            }\n            if (result == null) {\n                result = receiver.prop(ast.name);\n            }\n            return convertToStatementIfNeeded(mode, result);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitPropertyWrite = function (ast, mode) {\n        var /** @type {?} */ receiver = this.visit(ast.receiver, _Mode.Expression);\n        if (receiver === this._implicitReceiver) {\n            var /** @type {?} */ varExpr = this._getLocal(ast.name);\n            if (varExpr) {\n                throw new Error('Cannot assign to a reference or variable!');\n            }\n        }\n        return convertToStatementIfNeeded(mode, receiver.prop(ast.name).set(this.visit(ast.value, _Mode.Expression)));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitSafePropertyRead = function (ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitSafeMethodCall = function (ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    };\n    /**\n     * @param {?} asts\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitAll = function (asts, mode) {\n        var _this = this;\n        return asts.map(function (ast) { return _this.visit(ast, mode); });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitQuote = function (ast, mode) {\n        throw new Error(\"Quotes are not supported for evaluation!\\n        Statement: \" + ast.uninterpretedExpression + \" located at \" + ast.location);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visit = function (ast, mode) {\n        var /** @type {?} */ result = this._resultMap.get(ast);\n        if (result)\n            return result;\n        return (this._nodeMap.get(ast) || ast).visit(this, mode);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} leftMostSafe\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.convertSafeAccess = function (ast, leftMostSafe, mode) {\n        // If the expression contains a safe access node on the left it needs to be converted to\n        // an expression that guards the access to the member by checking the receiver for blank. As\n        // execution proceeds from left to right, the left most part of the expression must be guarded\n        // first but, because member access is left associative, the right side of the expression is at\n        // the top of the AST. The desired result requires lifting a copy of the the left part of the\n        // expression up to test it for blank before generating the unguarded version.\n        // Consider, for example the following expression: a?.b.c?.d.e\n        // This results in the ast:\n        //         .\n        //        / \\\n        //       ?.   e\n        //      /  \\\n        //     .    d\n        //    / \\\n        //   ?.  c\n        //  /  \\\n        // a    b\n        // The following tree should be generated:\n        //\n        //        /---- ? ----\\\n        //       /      |      \\\n        //     a   /--- ? ---\\  null\n        //        /     |     \\\n        //       .      .     null\n        //      / \\    / \\\n        //     .  c   .   e\n        //    / \\    / \\\n        //   a   b  ,   d\n        //         / \\\n        //        .   c\n        //       / \\\n        //      a   b\n        //\n        // Notice that the first guard condition is the left hand of the left most safe access node\n        // which comes in as leftMostSafe to this routine.\n        var /** @type {?} */ guardedExpression = this.visit(leftMostSafe.receiver, _Mode.Expression);\n        var /** @type {?} */ temporary = ((undefined));\n        if (this.needsTemporary(leftMostSafe.receiver)) {\n            // If the expression has method calls or pipes then we need to save the result into a\n            // temporary variable to avoid calling stateful or impure code more than once.\n            temporary = this.allocateTemporary();\n            // Preserve the result in the temporary variable\n            guardedExpression = temporary.set(guardedExpression);\n            // Ensure all further references to the guarded expression refer to the temporary instead.\n            this._resultMap.set(leftMostSafe.receiver, temporary);\n        }\n        var /** @type {?} */ condition = guardedExpression.isBlank();\n        // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n        // leftMostNode with its unguarded version in the call to `this.visit()`.\n        if (leftMostSafe instanceof SafeMethodCall) {\n            this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));\n        }\n        else {\n            this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));\n        }\n        // Recursively convert the node now without the guarded member access.\n        var /** @type {?} */ access = this.visit(ast, _Mode.Expression);\n        // Remove the mapping. This is not strictly required as the converter only traverses each node\n        // once but is safer if the conversion is changed to traverse the nodes more than once.\n        this._nodeMap.delete(leftMostSafe);\n        // If we allocated a temporary, release it.\n        if (temporary) {\n            this.releaseTemporary(temporary);\n        }\n        // Produce the conditional\n        return convertToStatementIfNeeded(mode, condition.conditional(literal(null), access));\n    };\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.leftMostSafeNode = function (ast) {\n        var _this = this;\n        var /** @type {?} */ visit = function (visitor, ast) {\n            return (_this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        return ast.visit({\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitBinary: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitChain: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitConditional: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitFunctionCall: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitImplicitReceiver: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitInterpolation: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedRead: function (ast) { return visit(this, ast.obj); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedWrite: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralArray: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralMap: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralPrimitive: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitMethodCall: function (ast) { return visit(this, ast.receiver); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPipe: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPrefixNot: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyRead: function (ast) { return visit(this, ast.receiver); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyWrite: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitQuote: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafeMethodCall: function (ast) { return visit(this, ast.receiver) || ast; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafePropertyRead: function (ast) {\n                return visit(this, ast.receiver) || ast;\n            }\n        });\n    };\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.needsTemporary = function (ast) {\n        var _this = this;\n        var /** @type {?} */ visit = function (visitor, ast) {\n            return ast && (_this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        var /** @type {?} */ visitSome = function (visitor, ast) {\n            return ast.some(function (ast) { return visit(visitor, ast); });\n        };\n        return ast.visit({\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitBinary: function (ast) { return visit(this, ast.left) || visit(this, ast.right); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitChain: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitConditional: function (ast) {\n                return visit(this, ast.condition) || visit(this, ast.trueExp) ||\n                    visit(this, ast.falseExp);\n            },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitFunctionCall: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitImplicitReceiver: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitInterpolation: function (ast) { return visitSome(this, ast.expressions); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedRead: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedWrite: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralArray: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralMap: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralPrimitive: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitMethodCall: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPipe: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPrefixNot: function (ast) { return visit(this, ast.expression); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyRead: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyWrite: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitQuote: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafeMethodCall: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafePropertyRead: function (ast) { return false; }\n        });\n    };\n    /**\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.allocateTemporary = function () {\n        var /** @type {?} */ tempNumber = this._currentTemporary++;\n        this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n        return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n    };\n    /**\n     * @param {?} temporary\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.releaseTemporary = function (temporary) {\n        this._currentTemporary--;\n        if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n            throw new Error(\"Temporary \" + temporary.name + \" released out of order\");\n        }\n    };\n    return _AstToIrVisitor;\n}());\n/**\n * @param {?} arg\n * @param {?} output\n * @return {?}\n */\nfunction flattenStatements(arg, output) {\n    if (Array.isArray(arg)) {\n        ((arg)).forEach(function (entry) { return flattenStatements(entry, output); });\n    }\n    else {\n        output.push(arg);\n    }\n}\nvar DefaultLocalResolver = (function () {\n    function DefaultLocalResolver() {\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    DefaultLocalResolver.prototype.getLocal = function (name) {\n        if (name === EventHandlerVars.event.name) {\n            return EventHandlerVars.event;\n        }\n        return null;\n    };\n    return DefaultLocalResolver;\n}());\n/**\n * @param {?} bindingId\n * @return {?}\n */\nfunction createCurrValueExpr(bindingId) {\n    return variable(\"currVal_\" + bindingId); // fix syntax highlighting: `\n}\n/**\n * @param {?} bindingId\n * @return {?}\n */\nfunction createPreventDefaultVar(bindingId) {\n    return variable(\"pd_\" + bindingId);\n}\n/**\n * @param {?} stmt\n * @return {?}\n */\nfunction convertStmtIntoExpression(stmt) {\n    if (stmt instanceof ExpressionStatement) {\n        return stmt.expr;\n    }\n    else if (stmt instanceof ReturnStatement) {\n        return stmt.value;\n    }\n    return null;\n}\nvar BuiltinFunctionCall = (function (_super) {\n    __extends(BuiltinFunctionCall, _super);\n    /**\n     * @param {?} span\n     * @param {?} args\n     * @param {?} converter\n     */\n    function BuiltinFunctionCall(span, args, converter) {\n        var _this = _super.call(this, span, null, args) || this;\n        _this.args = args;\n        _this.converter = converter;\n        return _this;\n    }\n    return BuiltinFunctionCall;\n}(FunctionCall));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CLASS_ATTR$1 = 'class';\nvar STYLE_ATTR = 'style';\nvar IMPLICIT_TEMPLATE_VAR = '\\$implicit';\nvar ViewCompileResult = (function () {\n    /**\n     * @param {?} statements\n     * @param {?} viewClassVar\n     * @param {?} rendererTypeVar\n     */\n    function ViewCompileResult(statements, viewClassVar, rendererTypeVar) {\n        this.statements = statements;\n        this.viewClassVar = viewClassVar;\n        this.rendererTypeVar = rendererTypeVar;\n    }\n    return ViewCompileResult;\n}());\nvar ViewCompiler = (function () {\n    /**\n     * @param {?} _genConfigNext\n     * @param {?} _schemaRegistry\n     */\n    function ViewCompiler(_genConfigNext, _schemaRegistry) {\n        this._genConfigNext = _genConfigNext;\n        this._schemaRegistry = _schemaRegistry;\n    }\n    /**\n     * @param {?} component\n     * @param {?} template\n     * @param {?} styles\n     * @param {?} usedPipes\n     * @return {?}\n     */\n    ViewCompiler.prototype.compileComponent = function (component, template, styles, usedPipes) {\n        var /** @type {?} */ embeddedViewCount = 0;\n        var /** @type {?} */ staticQueryIds = findStaticQueryIds(template);\n        var /** @type {?} */ statements = [];\n        var /** @type {?} */ renderComponentVarName = ((undefined));\n        if (!component.isHost) {\n            var /** @type {?} */ template_1 = ((component.template));\n            var /** @type {?} */ customRenderData = [];\n            if (template_1.animations && template_1.animations.length) {\n                customRenderData.push(new LiteralMapEntry('animation', convertValueToOutputAst(template_1.animations), true));\n            }\n            var /** @type {?} */ renderComponentVar = variable(rendererTypeName(component.type.reference));\n            renderComponentVarName = ((renderComponentVar.name));\n            statements.push(renderComponentVar\n                .set(importExpr(createIdentifier(Identifiers.createRendererType2))\n                .callFn([new LiteralMapExpr([\n                    new LiteralMapEntry('encapsulation', literal(template_1.encapsulation)),\n                    new LiteralMapEntry('styles', styles),\n                    new LiteralMapEntry('data', new LiteralMapExpr(customRenderData))\n                ])]))\n                .toDeclStmt(importType(createIdentifier(Identifiers.RendererType2)), [StmtModifier.Final]));\n        }\n        var /** @type {?} */ viewBuilderFactory = function (parent) {\n            var /** @type {?} */ embeddedViewIndex = embeddedViewCount++;\n            return new ViewBuilder(parent, component, embeddedViewIndex, usedPipes, staticQueryIds, viewBuilderFactory);\n        };\n        var /** @type {?} */ visitor = viewBuilderFactory(null);\n        visitor.visitAll([], template);\n        statements.push.apply(statements, visitor.build());\n        return new ViewCompileResult(statements, visitor.viewName, renderComponentVarName);\n    };\n    return ViewCompiler;\n}());\nViewCompiler.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nViewCompiler.ctorParameters = function () { return [\n    { type: CompilerConfig, },\n    { type: ElementSchemaRegistry, },\n]; };\nvar LOG_VAR = variable('l');\nvar VIEW_VAR = variable('v');\nvar CHECK_VAR = variable('ck');\nvar COMP_VAR = variable('co');\nvar EVENT_NAME_VAR = variable('en');\nvar ALLOW_DEFAULT_VAR = variable(\"ad\");\nvar ViewBuilder = (function () {\n    /**\n     * @param {?} parent\n     * @param {?} component\n     * @param {?} embeddedViewIndex\n     * @param {?} usedPipes\n     * @param {?} staticQueryIds\n     * @param {?} viewBuilderFactory\n     */\n    function ViewBuilder(parent, component, embeddedViewIndex, usedPipes, staticQueryIds, viewBuilderFactory) {\n        this.parent = parent;\n        this.component = component;\n        this.embeddedViewIndex = embeddedViewIndex;\n        this.usedPipes = usedPipes;\n        this.staticQueryIds = staticQueryIds;\n        this.viewBuilderFactory = viewBuilderFactory;\n        this.nodes = [];\n        this.purePipeNodeIndices = Object.create(null);\n        this.refNodeIndices = Object.create(null);\n        this.variables = [];\n        this.children = [];\n        // TODO(tbosch): The old view compiler used to use an `any` type\n        // for the context in any embedded view. We keep this behaivor for now\n        // to be able to introduce the new view compiler without too many errors.\n        this.compType =\n            this.embeddedViewIndex > 0 ? DYNAMIC_TYPE : importType(this.component.type);\n    }\n    Object.defineProperty(ViewBuilder.prototype, \"viewName\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return viewClassName(this.component.type.reference, this.embeddedViewIndex);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} variables\n     * @param {?} astNodes\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitAll = function (variables, astNodes) {\n        var _this = this;\n        this.variables = variables;\n        // create the pipes for the pure pipes immediately, so that we know their indices.\n        if (!this.parent) {\n            this.usedPipes.forEach(function (pipe) {\n                if (pipe.pure) {\n                    _this.purePipeNodeIndices[pipe.name] = _this._createPipe(null, pipe);\n                }\n            });\n        }\n        if (!this.parent) {\n            var /** @type {?} */ queryIds_1 = staticViewQueryIds(this.staticQueryIds);\n            this.component.viewQueries.forEach(function (query, queryIndex) {\n                // Note: queries start with id 1 so we can use the number in a Bloom filter!\n                var /** @type {?} */ queryId = queryIndex + 1;\n                var /** @type {?} */ bindingType = query.first ? 0 /* First */ : 1;\n                var /** @type {?} */ flags = 67108864 /* TypeViewQuery */ | calcStaticDynamicQueryFlags(queryIds_1, queryId, query.first);\n                _this.nodes.push(function () { return ({\n                    sourceSpan: null,\n                    nodeFlags: flags,\n                    nodeDef: importExpr(createIdentifier(Identifiers.queryDef)).callFn([\n                        literal(flags), literal(queryId),\n                        new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType))])\n                    ])\n                }); });\n            });\n        }\n        templateVisitAll(this, astNodes);\n        if (this.parent && (astNodes.length === 0 || needsAdditionalRootNode(astNodes))) {\n            // if the view is an embedded view, then we need to add an additional root node in some cases\n            this.nodes.push(function () { return ({\n                sourceSpan: null,\n                nodeFlags: 1 /* TypeElement */,\n                nodeDef: importExpr(createIdentifier(Identifiers.anchorDef)).callFn([\n                    literal(0 /* None */), NULL_EXPR, NULL_EXPR, literal(0)\n                ])\n            }); });\n        }\n    };\n    /**\n     * @param {?=} targetStatements\n     * @return {?}\n     */\n    ViewBuilder.prototype.build = function (targetStatements) {\n        if (targetStatements === void 0) { targetStatements = []; }\n        this.children.forEach(function (child) { return child.build(targetStatements); });\n        var _a = this._createNodeExpressions(), updateRendererStmts = _a.updateRendererStmts, updateDirectivesStmts = _a.updateDirectivesStmts, nodeDefExprs = _a.nodeDefExprs;\n        var /** @type {?} */ updateRendererFn = this._createUpdateFn(updateRendererStmts);\n        var /** @type {?} */ updateDirectivesFn = this._createUpdateFn(updateDirectivesStmts);\n        var /** @type {?} */ viewFlags = 0;\n        if (!this.parent && this.component.changeDetection === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ChangeDetectionStrategy\"].OnPush) {\n            viewFlags |= 2 /* OnPush */;\n        }\n        var /** @type {?} */ viewFactory = new DeclareFunctionStmt(this.viewName, [new FnParam(/** @type {?} */ ((LOG_VAR.name)))], [new ReturnStatement(importExpr(createIdentifier(Identifiers.viewDef)).callFn([\n                literal(viewFlags),\n                literalArr(nodeDefExprs),\n                updateDirectivesFn,\n                updateRendererFn,\n            ]))], importType(createIdentifier(Identifiers.ViewDefinition)));\n        targetStatements.push(viewFactory);\n        return targetStatements;\n    };\n    /**\n     * @param {?} updateStmts\n     * @return {?}\n     */\n    ViewBuilder.prototype._createUpdateFn = function (updateStmts) {\n        var /** @type {?} */ updateFn;\n        if (updateStmts.length > 0) {\n            var /** @type {?} */ preStmts = [];\n            if (!this.component.isHost && findReadVarNames(updateStmts).has(/** @type {?} */ ((COMP_VAR.name)))) {\n                preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n            }\n            updateFn = fn([\n                new FnParam(/** @type {?} */ ((CHECK_VAR.name)), INFERRED_TYPE),\n                new FnParam(/** @type {?} */ ((VIEW_VAR.name)), INFERRED_TYPE)\n            ], preStmts.concat(updateStmts), INFERRED_TYPE);\n        }\n        else {\n            updateFn = NULL_EXPR;\n        }\n        return updateFn;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitNgContent = function (ast, context) {\n        // ngContentDef(ngContentIndex: number, index: number): NodeDef;\n        this.nodes.push(function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 4 /* TypeNgContent */,\n            nodeDef: importExpr(createIdentifier(Identifiers.ngContentDef)).callFn([\n                literal(ast.ngContentIndex), literal(ast.index)\n            ])\n        }); });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitText = function (ast, context) {\n        // textDef(ngContentIndex: number, constants: string[]): NodeDef;\n        this.nodes.push(function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 2 /* TypeText */,\n            nodeDef: importExpr(createIdentifier(Identifiers.textDef)).callFn([\n                literal(ast.ngContentIndex), literalArr([literal(ast.value)])\n            ])\n        }); });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitBoundText = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array\n        this.nodes.push(/** @type {?} */ ((null)));\n        var /** @type {?} */ astWithSource = (ast.value);\n        var /** @type {?} */ inter = (astWithSource.ast);\n        var /** @type {?} */ updateRendererExpressions = inter.expressions.map(function (expr, bindingIndex) { return _this._preprocessUpdateExpression({ nodeIndex: nodeIndex, bindingIndex: bindingIndex, sourceSpan: ast.sourceSpan, context: COMP_VAR, value: expr }); });\n        // textDef(ngContentIndex: number, constants: string[]): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 2 /* TypeText */,\n            nodeDef: importExpr(createIdentifier(Identifiers.textDef)).callFn([\n                literal(ast.ngContentIndex), literalArr(inter.strings.map(function (s) { return literal(s); }))\n            ]),\n            updateRenderer: updateRendererExpressions\n        }); };\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitEmbeddedTemplate = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array\n        this.nodes.push(/** @type {?} */ ((null)));\n        var _a = this._visitElementOrTemplate(nodeIndex, ast), flags = _a.flags, queryMatchesExpr = _a.queryMatchesExpr, hostEvents = _a.hostEvents;\n        var /** @type {?} */ childVisitor = this.viewBuilderFactory(this);\n        this.children.push(childVisitor);\n        childVisitor.visitAll(ast.variables, ast.children);\n        var /** @type {?} */ childCount = this.nodes.length - nodeIndex - 1;\n        // anchorDef(\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], ngContentIndex: number,\n        //   childCount: number, handleEventFn?: ElementHandleEventFn, templateFactory?:\n        //   ViewDefinitionFactory): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 1 /* TypeElement */ | flags,\n            nodeDef: importExpr(createIdentifier(Identifiers.anchorDef)).callFn([\n                literal(flags),\n                queryMatchesExpr,\n                literal(ast.ngContentIndex),\n                literal(childCount),\n                _this._createElementHandleEventFn(nodeIndex, hostEvents),\n                variable(childVisitor.viewName),\n            ])\n        }); };\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitElement = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array so we can add children\n        this.nodes.push(/** @type {?} */ ((null)));\n        // Using a null element name creates an anchor.\n        var /** @type {?} */ elName = isNgContainer(ast.name) ? null : ast.name;\n        var _a = this._visitElementOrTemplate(nodeIndex, ast), flags = _a.flags, usedEvents = _a.usedEvents, queryMatchesExpr = _a.queryMatchesExpr, dirHostBindings = _a.hostBindings, hostEvents = _a.hostEvents;\n        var /** @type {?} */ inputDefs = [];\n        var /** @type {?} */ updateRendererExpressions = [];\n        var /** @type {?} */ outputDefs = [];\n        if (elName) {\n            var /** @type {?} */ hostBindings = ast.inputs\n                .map(function (inputAst) { return ({\n                context: /** @type {?} */ (COMP_VAR),\n                inputAst: inputAst,\n                dirAst: /** @type {?} */ (null),\n            }); })\n                .concat(dirHostBindings);\n            if (hostBindings.length) {\n                updateRendererExpressions =\n                    hostBindings.map(function (hostBinding, bindingIndex) { return _this._preprocessUpdateExpression({\n                        context: hostBinding.context,\n                        nodeIndex: nodeIndex,\n                        bindingIndex: bindingIndex,\n                        sourceSpan: hostBinding.inputAst.sourceSpan,\n                        value: hostBinding.inputAst.value\n                    }); });\n                inputDefs = hostBindings.map(function (hostBinding) { return elementBindingDef(hostBinding.inputAst, hostBinding.dirAst); });\n            }\n            outputDefs = usedEvents.map(function (_a) {\n                var target = _a[0], eventName = _a[1];\n                return literalArr([literal(target), literal(eventName)]);\n            });\n        }\n        templateVisitAll(this, ast.children);\n        var /** @type {?} */ childCount = this.nodes.length - nodeIndex - 1;\n        var /** @type {?} */ compAst = ast.directives.find(function (dirAst) { return dirAst.directive.isComponent; });\n        var /** @type {?} */ compRendererType = NULL_EXPR;\n        var /** @type {?} */ compView = NULL_EXPR;\n        if (compAst) {\n            compView = importExpr({ reference: compAst.directive.componentViewType });\n            compRendererType = importExpr({ reference: compAst.directive.rendererType });\n        }\n        // elementDef(\n        //   flags: NodeFlags, matchedQueriesDsl: [string | number, QueryValueType][],\n        //   ngContentIndex: number, childCount: number, namespaceAndName: string,\n        //   fixedAttrs: [string, string][] = [],\n        //   bindings?: [BindingFlags, string, string | SecurityContext][],\n        //   outputs?: ([OutputType.ElementOutput | OutputType.DirectiveHostOutput, string, string])[],\n        //   handleEvent?: ElementHandleEventFn,\n        //   componentView?: () => ViewDefinition, componentRendererType?: RendererType2): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 1 /* TypeElement */ | flags,\n            nodeDef: importExpr(createIdentifier(Identifiers.elementDef)).callFn([\n                literal(flags),\n                queryMatchesExpr,\n                literal(ast.ngContentIndex),\n                literal(childCount),\n                literal(elName),\n                elName ? fixedAttrsDef(ast) : NULL_EXPR,\n                inputDefs.length ? literalArr(inputDefs) : NULL_EXPR,\n                outputDefs.length ? literalArr(outputDefs) : NULL_EXPR,\n                _this._createElementHandleEventFn(nodeIndex, hostEvents),\n                compView,\n                compRendererType,\n            ]),\n            updateRenderer: updateRendererExpressions\n        }); };\n    };\n    /**\n     * @param {?} nodeIndex\n     * @param {?} ast\n     * @return {?}\n     */\n    ViewBuilder.prototype._visitElementOrTemplate = function (nodeIndex, ast) {\n        var _this = this;\n        var /** @type {?} */ flags = 0;\n        if (ast.hasViewContainer) {\n            flags |= 8388608 /* EmbeddedViews */;\n        }\n        var /** @type {?} */ usedEvents = new Map();\n        ast.outputs.forEach(function (event) {\n            var _a = elementEventNameAndTarget(event, null), name = _a.name, target = _a.target;\n            usedEvents.set(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵelementEventFullName\"])(target, name), [target, name]);\n        });\n        ast.directives.forEach(function (dirAst) {\n            dirAst.hostEvents.forEach(function (event) {\n                var _a = elementEventNameAndTarget(event, dirAst), name = _a.name, target = _a.target;\n                usedEvents.set(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵelementEventFullName\"])(target, name), [target, name]);\n            });\n        });\n        var /** @type {?} */ hostBindings = [];\n        var /** @type {?} */ hostEvents = [];\n        var /** @type {?} */ componentFactoryResolverProvider = createComponentFactoryResolver(ast.directives);\n        if (componentFactoryResolverProvider) {\n            this._visitProvider(componentFactoryResolverProvider, ast.queryMatches);\n        }\n        ast.providers.forEach(function (providerAst, providerIndex) {\n            var /** @type {?} */ dirAst = ((undefined));\n            var /** @type {?} */ dirIndex = ((undefined));\n            ast.directives.forEach(function (localDirAst, i) {\n                if (localDirAst.directive.type.reference === tokenReference(providerAst.token)) {\n                    dirAst = localDirAst;\n                    dirIndex = i;\n                }\n            });\n            if (dirAst) {\n                var _a = _this._visitDirective(providerAst, dirAst, dirIndex, nodeIndex, ast.references, ast.queryMatches, usedEvents, /** @type {?} */ ((_this.staticQueryIds.get(/** @type {?} */ (ast))))), dirHostBindings = _a.hostBindings, dirHostEvents = _a.hostEvents;\n                hostBindings.push.apply(hostBindings, dirHostBindings);\n                hostEvents.push.apply(hostEvents, dirHostEvents);\n            }\n            else {\n                _this._visitProvider(providerAst, ast.queryMatches);\n            }\n        });\n        var /** @type {?} */ queryMatchExprs = [];\n        ast.queryMatches.forEach(function (match) {\n            var /** @type {?} */ valueType = ((undefined));\n            if (tokenReference(match.value) === resolveIdentifier(Identifiers.ElementRef)) {\n                valueType = 0 /* ElementRef */;\n            }\n            else if (tokenReference(match.value) === resolveIdentifier(Identifiers.ViewContainerRef)) {\n                valueType = 3 /* ViewContainerRef */;\n            }\n            else if (tokenReference(match.value) === resolveIdentifier(Identifiers.TemplateRef)) {\n                valueType = 2 /* TemplateRef */;\n            }\n            if (valueType != null) {\n                queryMatchExprs.push(literalArr([literal(match.queryId), literal(valueType)]));\n            }\n        });\n        ast.references.forEach(function (ref) {\n            var /** @type {?} */ valueType = ((undefined));\n            if (!ref.value) {\n                valueType = 1 /* RenderElement */;\n            }\n            else if (tokenReference(ref.value) === resolveIdentifier(Identifiers.TemplateRef)) {\n                valueType = 2 /* TemplateRef */;\n            }\n            if (valueType != null) {\n                _this.refNodeIndices[ref.name] = nodeIndex;\n                queryMatchExprs.push(literalArr([literal(ref.name), literal(valueType)]));\n            }\n        });\n        ast.outputs.forEach(function (outputAst) {\n            hostEvents.push({ context: COMP_VAR, eventAst: outputAst, dirAst: /** @type {?} */ ((null)) });\n        });\n        return {\n            flags: flags,\n            usedEvents: Array.from(usedEvents.values()),\n            queryMatchesExpr: queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,\n            hostBindings: hostBindings,\n            hostEvents: hostEvents\n        };\n    };\n    /**\n     * @param {?} providerAst\n     * @param {?} dirAst\n     * @param {?} directiveIndex\n     * @param {?} elementNodeIndex\n     * @param {?} refs\n     * @param {?} queryMatches\n     * @param {?} usedEvents\n     * @param {?} queryIds\n     * @return {?}\n     */\n    ViewBuilder.prototype._visitDirective = function (providerAst, dirAst, directiveIndex, elementNodeIndex, refs, queryMatches, usedEvents, queryIds) {\n        var _this = this;\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array so we can add children\n        this.nodes.push(/** @type {?} */ ((null)));\n        dirAst.directive.queries.forEach(function (query, queryIndex) {\n            var /** @type {?} */ queryId = dirAst.contentQueryStartId + queryIndex;\n            var /** @type {?} */ flags = 33554432 /* TypeContentQuery */ | calcStaticDynamicQueryFlags(queryIds, queryId, query.first);\n            var /** @type {?} */ bindingType = query.first ? 0 /* First */ : 1;\n            _this.nodes.push(function () { return ({\n                sourceSpan: dirAst.sourceSpan,\n                nodeFlags: flags,\n                nodeDef: importExpr(createIdentifier(Identifiers.queryDef)).callFn([\n                    literal(flags), literal(queryId),\n                    new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType))])\n                ]),\n            }); });\n        });\n        // Note: the operation below might also create new nodeDefs,\n        // but we don't want them to be a child of a directive,\n        // as they might be a provider/pipe on their own.\n        // I.e. we only allow queries as children of directives nodes.\n        var /** @type {?} */ childCount = this.nodes.length - nodeIndex - 1;\n        var _a = this._visitProviderOrDirective(providerAst, queryMatches), flags = _a.flags, queryMatchExprs = _a.queryMatchExprs, providerExpr = _a.providerExpr, depsExpr = _a.depsExpr;\n        refs.forEach(function (ref) {\n            if (ref.value && tokenReference(ref.value) === tokenReference(providerAst.token)) {\n                _this.refNodeIndices[ref.name] = nodeIndex;\n                queryMatchExprs.push(literalArr([literal(ref.name), literal(4 /* Provider */)]));\n            }\n        });\n        if (dirAst.directive.isComponent) {\n            flags |= 16384 /* Component */;\n        }\n        var /** @type {?} */ inputDefs = dirAst.inputs.map(function (inputAst, inputIndex) {\n            var /** @type {?} */ mapValue = literalArr([literal(inputIndex), literal(inputAst.directiveName)]);\n            // Note: it's important to not quote the key so that we can capture renames by minifiers!\n            return new LiteralMapEntry(inputAst.directiveName, mapValue, false);\n        });\n        var /** @type {?} */ outputDefs = [];\n        var /** @type {?} */ dirMeta = dirAst.directive;\n        Object.keys(dirMeta.outputs).forEach(function (propName) {\n            var /** @type {?} */ eventName = dirMeta.outputs[propName];\n            if (usedEvents.has(eventName)) {\n                // Note: it's important to not quote the key so that we can capture renames by minifiers!\n                outputDefs.push(new LiteralMapEntry(propName, literal(eventName), false));\n            }\n        });\n        var /** @type {?} */ updateDirectiveExpressions = [];\n        if (dirAst.inputs.length || (flags & (131072 /* DoCheck */ | 32768 /* OnInit */)) > 0) {\n            updateDirectiveExpressions =\n                dirAst.inputs.map(function (input, bindingIndex) { return _this._preprocessUpdateExpression({\n                    nodeIndex: nodeIndex,\n                    bindingIndex: bindingIndex,\n                    sourceSpan: input.sourceSpan,\n                    context: COMP_VAR,\n                    value: input.value\n                }); });\n        }\n        var /** @type {?} */ dirContextExpr = importExpr(createIdentifier(Identifiers.nodeValue)).callFn([\n            VIEW_VAR, literal(nodeIndex)\n        ]);\n        var /** @type {?} */ hostBindings = dirAst.hostProperties.map(function (inputAst) { return ({\n            context: dirContextExpr,\n            dirAst: dirAst,\n            inputAst: inputAst,\n        }); });\n        var /** @type {?} */ hostEvents = dirAst.hostEvents.map(function (hostEventAst) { return ({\n            context: dirContextExpr,\n            eventAst: hostEventAst, dirAst: dirAst,\n        }); });\n        // directiveDef(\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], childCount: number, ctor:\n        //   any,\n        //   deps: ([DepFlags, any] | any)[], props?: {[name: string]: [number, string]},\n        //   outputs?: {[name: string]: string}, component?: () => ViewDefinition): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: dirAst.sourceSpan,\n            nodeFlags: 8192 /* TypeDirective */ | flags,\n            nodeDef: importExpr(createIdentifier(Identifiers.directiveDef)).callFn([\n                literal(flags), queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,\n                literal(childCount), providerExpr, depsExpr,\n                inputDefs.length ? new LiteralMapExpr(inputDefs) : NULL_EXPR,\n                outputDefs.length ? new LiteralMapExpr(outputDefs) : NULL_EXPR\n            ]),\n            updateDirectives: updateDirectiveExpressions,\n            directive: dirAst.directive.type,\n        }); };\n        return { hostBindings: hostBindings, hostEvents: hostEvents };\n    };\n    /**\n     * @param {?} providerAst\n     * @param {?} queryMatches\n     * @return {?}\n     */\n    ViewBuilder.prototype._visitProvider = function (providerAst, queryMatches) {\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array so we can add children\n        this.nodes.push(/** @type {?} */ ((null)));\n        var _a = this._visitProviderOrDirective(providerAst, queryMatches), flags = _a.flags, queryMatchExprs = _a.queryMatchExprs, providerExpr = _a.providerExpr, depsExpr = _a.depsExpr;\n        // providerDef(\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], token:any,\n        //   value: any, deps: ([DepFlags, any] | any)[]): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: providerAst.sourceSpan,\n            nodeFlags: flags,\n            nodeDef: importExpr(createIdentifier(Identifiers.providerDef)).callFn([\n                literal(flags), queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,\n                tokenExpr(providerAst.token), providerExpr, depsExpr\n            ])\n        }); };\n    };\n    /**\n     * @param {?} providerAst\n     * @param {?} queryMatches\n     * @return {?}\n     */\n    ViewBuilder.prototype._visitProviderOrDirective = function (providerAst, queryMatches) {\n        var /** @type {?} */ flags = 0;\n        if (!providerAst.eager) {\n            flags |= 2048 /* LazyProvider */;\n        }\n        if (providerAst.providerType === ProviderAstType.PrivateService) {\n            flags |= 4096 /* PrivateProvider */;\n        }\n        providerAst.lifecycleHooks.forEach(function (lifecycleHook) {\n            // for regular providers, we only support ngOnDestroy\n            if (lifecycleHook === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].OnDestroy ||\n                providerAst.providerType === ProviderAstType.Directive ||\n                providerAst.providerType === ProviderAstType.Component) {\n                flags |= lifecycleHookToNodeFlag(lifecycleHook);\n            }\n        });\n        var /** @type {?} */ queryMatchExprs = [];\n        queryMatches.forEach(function (match) {\n            if (tokenReference(match.value) === tokenReference(providerAst.token)) {\n                queryMatchExprs.push(literalArr([literal(match.queryId), literal(4 /* Provider */)]));\n            }\n        });\n        var _a = providerDef(providerAst), providerExpr = _a.providerExpr, depsExpr = _a.depsExpr, providerType = _a.flags;\n        return { flags: flags | providerType, queryMatchExprs: queryMatchExprs, providerExpr: providerExpr, depsExpr: depsExpr };\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    ViewBuilder.prototype.getLocal = function (name) {\n        if (name == EventHandlerVars.event.name) {\n            return EventHandlerVars.event;\n        }\n        var /** @type {?} */ currViewExpr = VIEW_VAR;\n        for (var /** @type {?} */ currBuilder = this; currBuilder; currBuilder = currBuilder.parent,\n            currViewExpr = currViewExpr.prop('parent').cast(DYNAMIC_TYPE)) {\n            // check references\n            var /** @type {?} */ refNodeIndex = currBuilder.refNodeIndices[name];\n            if (refNodeIndex != null) {\n                return importExpr(createIdentifier(Identifiers.nodeValue)).callFn([\n                    currViewExpr, literal(refNodeIndex)\n                ]);\n            }\n            // check variables\n            var /** @type {?} */ varAst = currBuilder.variables.find(function (varAst) { return varAst.name === name; });\n            if (varAst) {\n                var /** @type {?} */ varValue = varAst.value || IMPLICIT_TEMPLATE_VAR;\n                return currViewExpr.prop('context').prop(varValue);\n            }\n        }\n        return null;\n    };\n    /**\n     * @param {?} sourceSpan\n     * @param {?} argCount\n     * @return {?}\n     */\n    ViewBuilder.prototype.createLiteralArrayConverter = function (sourceSpan, argCount) {\n        if (argCount === 0) {\n            var /** @type {?} */ valueExpr_1 = importExpr(createIdentifier(Identifiers.EMPTY_ARRAY));\n            return function () { return valueExpr_1; };\n        }\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // pureArrayDef(argCount: number): NodeDef;\n        this.nodes.push(function () { return ({\n            sourceSpan: sourceSpan,\n            nodeFlags: 16 /* TypePureArray */,\n            nodeDef: importExpr(createIdentifier(Identifiers.pureArrayDef)).callFn([literal(argCount)])\n        }); });\n        return function (args) { return callCheckStmt(nodeIndex, args); };\n    };\n    /**\n     * @param {?} sourceSpan\n     * @param {?} keys\n     * @return {?}\n     */\n    ViewBuilder.prototype.createLiteralMapConverter = function (sourceSpan, keys) {\n        if (keys.length === 0) {\n            var /** @type {?} */ valueExpr_2 = importExpr(createIdentifier(Identifiers.EMPTY_MAP));\n            return function () { return valueExpr_2; };\n        }\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // function pureObjectDef(propertyNames: string[]): NodeDef\n        this.nodes.push(function () { return ({\n            sourceSpan: sourceSpan,\n            nodeFlags: 32 /* TypePureObject */,\n            nodeDef: importExpr(createIdentifier(Identifiers.pureObjectDef))\n                .callFn([literalArr(keys.map(function (key) { return literal(key); }))])\n        }); });\n        return function (args) { return callCheckStmt(nodeIndex, args); };\n    };\n    /**\n     * @param {?} expression\n     * @param {?} name\n     * @param {?} argCount\n     * @return {?}\n     */\n    ViewBuilder.prototype.createPipeConverter = function (expression, name, argCount) {\n        var /** @type {?} */ pipe = ((this.usedPipes.find(function (pipeSummary) { return pipeSummary.name === name; })));\n        if (pipe.pure) {\n            var /** @type {?} */ nodeIndex_1 = this.nodes.length;\n            // function purePipeDef(argCount: number): NodeDef;\n            this.nodes.push(function () { return ({\n                sourceSpan: expression.sourceSpan,\n                nodeFlags: 64 /* TypePurePipe */,\n                nodeDef: importExpr(createIdentifier(Identifiers.purePipeDef))\n                    .callFn([literal(argCount)])\n            }); });\n            // find underlying pipe in the component view\n            var /** @type {?} */ compViewExpr = VIEW_VAR;\n            var /** @type {?} */ compBuilder = this;\n            while (compBuilder.parent) {\n                compBuilder = compBuilder.parent;\n                compViewExpr = compViewExpr.prop('parent').cast(DYNAMIC_TYPE);\n            }\n            var /** @type {?} */ pipeNodeIndex = compBuilder.purePipeNodeIndices[name];\n            var /** @type {?} */ pipeValueExpr_1 = importExpr(createIdentifier(Identifiers.nodeValue)).callFn([\n                compViewExpr, literal(pipeNodeIndex)\n            ]);\n            return function (args) { return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, callCheckStmt(nodeIndex_1, [pipeValueExpr_1].concat(args))); };\n        }\n        else {\n            var /** @type {?} */ nodeIndex = this._createPipe(expression.sourceSpan, pipe);\n            var /** @type {?} */ nodeValueExpr_1 = importExpr(createIdentifier(Identifiers.nodeValue)).callFn([\n                VIEW_VAR, literal(nodeIndex)\n            ]);\n            return function (args) { return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, nodeValueExpr_1.callMethod('transform', args)); };\n        }\n    };\n    /**\n     * @param {?} sourceSpan\n     * @param {?} pipe\n     * @return {?}\n     */\n    ViewBuilder.prototype._createPipe = function (sourceSpan, pipe) {\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        var /** @type {?} */ flags = 0;\n        pipe.type.lifecycleHooks.forEach(function (lifecycleHook) {\n            // for pipes, we only support ngOnDestroy\n            if (lifecycleHook === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].OnDestroy) {\n                flags |= lifecycleHookToNodeFlag(lifecycleHook);\n            }\n        });\n        var /** @type {?} */ depExprs = pipe.type.diDeps.map(depDef);\n        // function pipeDef(\n        //   flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef\n        this.nodes.push(function () { return ({\n            sourceSpan: sourceSpan,\n            nodeFlags: 8 /* TypePipe */,\n            nodeDef: importExpr(createIdentifier(Identifiers.pipeDef)).callFn([\n                literal(flags), importExpr(pipe.type), literalArr(depExprs)\n            ])\n        }); });\n        return nodeIndex;\n    };\n    /**\n     * @param {?} expression\n     * @return {?}\n     */\n    ViewBuilder.prototype._preprocessUpdateExpression = function (expression) {\n        var _this = this;\n        return {\n            nodeIndex: expression.nodeIndex,\n            bindingIndex: expression.bindingIndex,\n            sourceSpan: expression.sourceSpan,\n            context: expression.context,\n            value: convertPropertyBindingBuiltins({\n                createLiteralArrayConverter: function (argCount) { return _this.createLiteralArrayConverter(expression.sourceSpan, argCount); },\n                createLiteralMapConverter: function (keys) { return _this.createLiteralMapConverter(expression.sourceSpan, keys); },\n                createPipeConverter: function (name, argCount) { return _this.createPipeConverter(expression, name, argCount); }\n            }, expression.value)\n        };\n    };\n    /**\n     * @return {?}\n     */\n    ViewBuilder.prototype._createNodeExpressions = function () {\n        var /** @type {?} */ self = this;\n        var /** @type {?} */ updateBindingCount = 0;\n        var /** @type {?} */ updateRendererStmts = [];\n        var /** @type {?} */ updateDirectivesStmts = [];\n        var /** @type {?} */ nodeDefExprs = this.nodes.map(function (factory, nodeIndex) {\n            var _a = factory(), nodeDef = _a.nodeDef, nodeFlags = _a.nodeFlags, updateDirectives = _a.updateDirectives, updateRenderer = _a.updateRenderer, sourceSpan = _a.sourceSpan;\n            if (updateRenderer) {\n                updateRendererStmts.push.apply(updateRendererStmts, createUpdateStatements(nodeIndex, sourceSpan, updateRenderer, false));\n            }\n            if (updateDirectives) {\n                updateDirectivesStmts.push.apply(updateDirectivesStmts, createUpdateStatements(nodeIndex, sourceSpan, updateDirectives, (nodeFlags & (131072 /* DoCheck */ | 32768 /* OnInit */)) > 0));\n            }\n            // We use a comma expression to call the log function before\n            // the nodeDef function, but still use the result of the nodeDef function\n            // as the value.\n            // Note: We only add the logger to elements / text nodes,\n            // so we don't generate too much code.\n            var /** @type {?} */ logWithNodeDef = nodeFlags & 3 /* CatRenderNode */ ?\n                new CommaExpr([LOG_VAR.callFn([]).callFn([]), nodeDef]) :\n                nodeDef;\n            return applySourceSpanToExpressionIfNeeded(logWithNodeDef, sourceSpan);\n        });\n        return { updateRendererStmts: updateRendererStmts, updateDirectivesStmts: updateDirectivesStmts, nodeDefExprs: nodeDefExprs };\n        /**\n         * @param {?} nodeIndex\n         * @param {?} sourceSpan\n         * @param {?} expressions\n         * @param {?} allowEmptyExprs\n         * @return {?}\n         */\n        function createUpdateStatements(nodeIndex, sourceSpan, expressions, allowEmptyExprs) {\n            var /** @type {?} */ updateStmts = [];\n            var /** @type {?} */ exprs = expressions.map(function (_a) {\n                var sourceSpan = _a.sourceSpan, context = _a.context, value = _a.value;\n                var /** @type {?} */ bindingId = \"\" + updateBindingCount++;\n                var /** @type {?} */ nameResolver = context === COMP_VAR ? self : null;\n                var _b = convertPropertyBinding(nameResolver, context, value, bindingId), stmts = _b.stmts, currValExpr = _b.currValExpr;\n                updateStmts.push.apply(updateStmts, stmts.map(function (stmt) { return applySourceSpanToStatementIfNeeded(stmt, sourceSpan); }));\n                return applySourceSpanToExpressionIfNeeded(currValExpr, sourceSpan);\n            });\n            if (expressions.length || allowEmptyExprs) {\n                updateStmts.push(applySourceSpanToStatementIfNeeded(callCheckStmt(nodeIndex, exprs).toStmt(), sourceSpan));\n            }\n            return updateStmts;\n        }\n    };\n    /**\n     * @param {?} nodeIndex\n     * @param {?} handlers\n     * @return {?}\n     */\n    ViewBuilder.prototype._createElementHandleEventFn = function (nodeIndex, handlers) {\n        var _this = this;\n        var /** @type {?} */ handleEventStmts = [];\n        var /** @type {?} */ handleEventBindingCount = 0;\n        handlers.forEach(function (_a) {\n            var context = _a.context, eventAst = _a.eventAst, dirAst = _a.dirAst;\n            var /** @type {?} */ bindingId = \"\" + handleEventBindingCount++;\n            var /** @type {?} */ nameResolver = context === COMP_VAR ? _this : null;\n            var _b = convertActionBinding(nameResolver, context, eventAst.handler, bindingId), stmts = _b.stmts, allowDefault = _b.allowDefault;\n            var /** @type {?} */ trueStmts = stmts;\n            if (allowDefault) {\n                trueStmts.push(ALLOW_DEFAULT_VAR.set(allowDefault.and(ALLOW_DEFAULT_VAR)).toStmt());\n            }\n            var _c = elementEventNameAndTarget(eventAst, dirAst), eventTarget = _c.target, eventName = _c.name;\n            var /** @type {?} */ fullEventName = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵelementEventFullName\"])(eventTarget, eventName);\n            handleEventStmts.push(applySourceSpanToStatementIfNeeded(new IfStmt(literal(fullEventName).identical(EVENT_NAME_VAR), trueStmts), eventAst.sourceSpan));\n        });\n        var /** @type {?} */ handleEventFn;\n        if (handleEventStmts.length > 0) {\n            var /** @type {?} */ preStmts = [ALLOW_DEFAULT_VAR.set(literal(true)).toDeclStmt(BOOL_TYPE)];\n            if (!this.component.isHost && findReadVarNames(handleEventStmts).has(/** @type {?} */ ((COMP_VAR.name)))) {\n                preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n            }\n            handleEventFn = fn([\n                new FnParam(/** @type {?} */ ((VIEW_VAR.name)), INFERRED_TYPE),\n                new FnParam(/** @type {?} */ ((EVENT_NAME_VAR.name)), INFERRED_TYPE),\n                new FnParam(/** @type {?} */ ((EventHandlerVars.event.name)), INFERRED_TYPE)\n            ], preStmts.concat(handleEventStmts, [new ReturnStatement(ALLOW_DEFAULT_VAR)]), INFERRED_TYPE);\n        }\n        else {\n            handleEventFn = NULL_EXPR;\n        }\n        return handleEventFn;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitDirective = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitDirectiveProperty = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitReference = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitVariable = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitEvent = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitElementProperty = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitAttr = function (ast, context) { };\n    return ViewBuilder;\n}());\n/**\n * @param {?} providerAst\n * @return {?}\n */\nfunction providerDef(providerAst) {\n    return providerAst.multiProvider ?\n        multiProviderDef(providerAst.providers) :\n        singleProviderDef(providerAst.providerType, providerAst.providers[0]);\n}\n/**\n * @param {?} providers\n * @return {?}\n */\nfunction multiProviderDef(providers) {\n    var /** @type {?} */ allDepDefs = [];\n    var /** @type {?} */ allParams = [];\n    var /** @type {?} */ exprs = providers.map(function (provider, providerIndex) {\n        var /** @type {?} */ expr;\n        if (provider.useClass) {\n            var /** @type {?} */ depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);\n            expr = importExpr(provider.useClass).instantiate(depExprs);\n        }\n        else if (provider.useFactory) {\n            var /** @type {?} */ depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);\n            expr = importExpr(provider.useFactory).callFn(depExprs);\n        }\n        else if (provider.useExisting) {\n            var /** @type {?} */ depExprs = convertDeps(providerIndex, [{ token: provider.useExisting }]);\n            expr = depExprs[0];\n        }\n        else {\n            expr = convertValueToOutputAst(provider.useValue);\n        }\n        return expr;\n    });\n    var /** @type {?} */ providerExpr = fn(allParams, [new ReturnStatement(literalArr(exprs))], INFERRED_TYPE);\n    return { providerExpr: providerExpr, flags: 512 /* TypeFactoryProvider */, depsExpr: literalArr(allDepDefs) };\n    /**\n     * @param {?} providerIndex\n     * @param {?} deps\n     * @return {?}\n     */\n    function convertDeps(providerIndex, deps) {\n        return deps.map(function (dep, depIndex) {\n            var /** @type {?} */ paramName = \"p\" + providerIndex + \"_\" + depIndex;\n            allParams.push(new FnParam(paramName, DYNAMIC_TYPE));\n            allDepDefs.push(depDef(dep));\n            return variable(paramName);\n        });\n    }\n}\n/**\n * @param {?} providerType\n * @param {?} providerMeta\n * @return {?}\n */\nfunction singleProviderDef(providerType, providerMeta) {\n    var /** @type {?} */ providerExpr;\n    var /** @type {?} */ flags;\n    var /** @type {?} */ deps;\n    if (providerType === ProviderAstType.Directive || providerType === ProviderAstType.Component) {\n        providerExpr = importExpr(/** @type {?} */ ((providerMeta.useClass)));\n        flags = 8192 /* TypeDirective */;\n        deps = providerMeta.deps || ((providerMeta.useClass)).diDeps;\n    }\n    else {\n        if (providerMeta.useClass) {\n            providerExpr = importExpr(providerMeta.useClass);\n            flags = 256 /* TypeClassProvider */;\n            deps = providerMeta.deps || providerMeta.useClass.diDeps;\n        }\n        else if (providerMeta.useFactory) {\n            providerExpr = importExpr(providerMeta.useFactory);\n            flags = 512 /* TypeFactoryProvider */;\n            deps = providerMeta.deps || providerMeta.useFactory.diDeps;\n        }\n        else if (providerMeta.useExisting) {\n            providerExpr = NULL_EXPR;\n            flags = 1024 /* TypeUseExistingProvider */;\n            deps = [{ token: providerMeta.useExisting }];\n        }\n        else {\n            providerExpr = convertValueToOutputAst(providerMeta.useValue);\n            flags = 128 /* TypeValueProvider */;\n            deps = [];\n        }\n    }\n    var /** @type {?} */ depsExpr = literalArr(deps.map(function (dep) { return depDef(dep); }));\n    return { providerExpr: providerExpr, flags: flags, depsExpr: depsExpr };\n}\n/**\n * @param {?} tokenMeta\n * @return {?}\n */\nfunction tokenExpr(tokenMeta) {\n    return tokenMeta.identifier ? importExpr(tokenMeta.identifier) : literal(tokenMeta.value);\n}\n/**\n * @param {?} dep\n * @return {?}\n */\nfunction depDef(dep) {\n    // Note: the following fields have already been normalized out by provider_analyzer:\n    // - isAttribute, isSelf, isHost\n    var /** @type {?} */ expr = dep.isValue ? convertValueToOutputAst(dep.value) : tokenExpr(/** @type {?} */ ((dep.token)));\n    var /** @type {?} */ flags = 0;\n    if (dep.isSkipSelf) {\n        flags |= 1 /* SkipSelf */;\n    }\n    if (dep.isOptional) {\n        flags |= 2 /* Optional */;\n    }\n    if (dep.isValue) {\n        flags |= 8 /* Value */;\n    }\n    return flags === 0 /* None */ ? expr : literalArr([literal(flags), expr]);\n}\n/**\n * @param {?} astNodes\n * @return {?}\n */\nfunction needsAdditionalRootNode(astNodes) {\n    var /** @type {?} */ lastAstNode = astNodes[astNodes.length - 1];\n    if (lastAstNode instanceof EmbeddedTemplateAst) {\n        return lastAstNode.hasViewContainer;\n    }\n    if (lastAstNode instanceof ElementAst) {\n        if (isNgContainer(lastAstNode.name) && lastAstNode.children.length) {\n            return needsAdditionalRootNode(lastAstNode.children);\n        }\n        return lastAstNode.hasViewContainer;\n    }\n    return lastAstNode instanceof NgContentAst;\n}\n/**\n * @param {?} lifecycleHook\n * @return {?}\n */\nfunction lifecycleHookToNodeFlag(lifecycleHook) {\n    var /** @type {?} */ nodeFlag = 0;\n    switch (lifecycleHook) {\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].AfterContentChecked:\n            nodeFlag = 1048576 /* AfterContentChecked */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].AfterContentInit:\n            nodeFlag = 524288 /* AfterContentInit */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].AfterViewChecked:\n            nodeFlag = 4194304 /* AfterViewChecked */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].AfterViewInit:\n            nodeFlag = 2097152 /* AfterViewInit */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].DoCheck:\n            nodeFlag = 131072 /* DoCheck */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].OnChanges:\n            nodeFlag = 262144 /* OnChanges */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].OnDestroy:\n            nodeFlag = 65536 /* OnDestroy */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵLifecycleHooks\"].OnInit:\n            nodeFlag = 32768 /* OnInit */;\n            break;\n    }\n    return nodeFlag;\n}\n/**\n * @param {?} inputAst\n * @param {?} dirAst\n * @return {?}\n */\nfunction elementBindingDef(inputAst, dirAst) {\n    switch (inputAst.type) {\n        case PropertyBindingType.Attribute:\n            return literalArr([\n                literal(1 /* TypeElementAttribute */), literal(inputAst.name),\n                literal(inputAst.securityContext)\n            ]);\n        case PropertyBindingType.Property:\n            return literalArr([\n                literal(8 /* TypeProperty */), literal(inputAst.name),\n                literal(inputAst.securityContext)\n            ]);\n        case PropertyBindingType.Animation:\n            var /** @type {?} */ bindingType = 8 /* TypeProperty */ |\n                (dirAst && dirAst.directive.isComponent ? 32 /* SyntheticHostProperty */ :\n                    16 /* SyntheticProperty */);\n            return literalArr([\n                literal(bindingType), literal('@' + inputAst.name), literal(inputAst.securityContext)\n            ]);\n        case PropertyBindingType.Class:\n            return literalArr([literal(2 /* TypeElementClass */), literal(inputAst.name), NULL_EXPR]);\n        case PropertyBindingType.Style:\n            return literalArr([\n                literal(4 /* TypeElementStyle */), literal(inputAst.name), literal(inputAst.unit)\n            ]);\n    }\n}\n/**\n * @param {?} elementAst\n * @return {?}\n */\nfunction fixedAttrsDef(elementAst) {\n    var /** @type {?} */ mapResult = Object.create(null);\n    elementAst.attrs.forEach(function (attrAst) { mapResult[attrAst.name] = attrAst.value; });\n    elementAst.directives.forEach(function (dirAst) {\n        Object.keys(dirAst.directive.hostAttributes).forEach(function (name) {\n            var /** @type {?} */ value = dirAst.directive.hostAttributes[name];\n            var /** @type {?} */ prevValue = mapResult[name];\n            mapResult[name] = prevValue != null ? mergeAttributeValue(name, prevValue, value) : value;\n        });\n    });\n    // Note: We need to sort to get a defined output order\n    // for tests and for caching generated artifacts...\n    return literalArr(Object.keys(mapResult).sort().map(function (attrName) { return literalArr([literal(attrName), literal(mapResult[attrName])]); }));\n}\n/**\n * @param {?} attrName\n * @param {?} attrValue1\n * @param {?} attrValue2\n * @return {?}\n */\nfunction mergeAttributeValue(attrName, attrValue1, attrValue2) {\n    if (attrName == CLASS_ATTR$1 || attrName == STYLE_ATTR) {\n        return attrValue1 + \" \" + attrValue2;\n    }\n    else {\n        return attrValue2;\n    }\n}\n/**\n * @param {?} nodeIndex\n * @param {?} exprs\n * @return {?}\n */\nfunction callCheckStmt(nodeIndex, exprs) {\n    if (exprs.length > 10) {\n        return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(1 /* Dynamic */), literalArr(exprs)]);\n    }\n    else {\n        return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(0 /* Inline */)].concat(exprs));\n    }\n}\n/**\n * @param {?} nodeIndex\n * @param {?} bindingIdx\n * @param {?} expr\n * @return {?}\n */\nfunction callUnwrapValue(nodeIndex, bindingIdx, expr) {\n    return importExpr(createIdentifier(Identifiers.unwrapValue)).callFn([\n        VIEW_VAR, literal(nodeIndex), literal(bindingIdx), expr\n    ]);\n}\n/**\n * @param {?} nodes\n * @param {?=} result\n * @return {?}\n */\nfunction findStaticQueryIds(nodes, result) {\n    if (result === void 0) { result = new Map(); }\n    nodes.forEach(function (node) {\n        var /** @type {?} */ staticQueryIds = new Set();\n        var /** @type {?} */ dynamicQueryIds = new Set();\n        var /** @type {?} */ queryMatches = ((undefined));\n        if (node instanceof ElementAst) {\n            findStaticQueryIds(node.children, result);\n            node.children.forEach(function (child) {\n                var /** @type {?} */ childData = ((result.get(child)));\n                childData.staticQueryIds.forEach(function (queryId) { return staticQueryIds.add(queryId); });\n                childData.dynamicQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n            });\n            queryMatches = node.queryMatches;\n        }\n        else if (node instanceof EmbeddedTemplateAst) {\n            findStaticQueryIds(node.children, result);\n            node.children.forEach(function (child) {\n                var /** @type {?} */ childData = ((result.get(child)));\n                childData.staticQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n                childData.dynamicQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n            });\n            queryMatches = node.queryMatches;\n        }\n        if (queryMatches) {\n            queryMatches.forEach(function (match) { return staticQueryIds.add(match.queryId); });\n        }\n        dynamicQueryIds.forEach(function (queryId) { return staticQueryIds.delete(queryId); });\n        result.set(node, { staticQueryIds: staticQueryIds, dynamicQueryIds: dynamicQueryIds });\n    });\n    return result;\n}\n/**\n * @param {?} nodeStaticQueryIds\n * @return {?}\n */\nfunction staticViewQueryIds(nodeStaticQueryIds) {\n    var /** @type {?} */ staticQueryIds = new Set();\n    var /** @type {?} */ dynamicQueryIds = new Set();\n    Array.from(nodeStaticQueryIds.values()).forEach(function (entry) {\n        entry.staticQueryIds.forEach(function (queryId) { return staticQueryIds.add(queryId); });\n        entry.dynamicQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n    });\n    dynamicQueryIds.forEach(function (queryId) { return staticQueryIds.delete(queryId); });\n    return { staticQueryIds: staticQueryIds, dynamicQueryIds: dynamicQueryIds };\n}\n/**\n * @param {?} directives\n * @return {?}\n */\nfunction createComponentFactoryResolver(directives) {\n    var /** @type {?} */ componentDirMeta = directives.find(function (dirAst) { return dirAst.directive.isComponent; });\n    if (componentDirMeta && componentDirMeta.directive.entryComponents.length) {\n        var /** @type {?} */ entryComponentFactories = componentDirMeta.directive.entryComponents.map(function (entryComponent) { return importExpr({ reference: entryComponent.componentFactory }); });\n        var /** @type {?} */ token = createIdentifierToken(Identifiers.ComponentFactoryResolver);\n        var /** @type {?} */ classMeta = {\n            diDeps: [\n                { isValue: true, value: literalArr(entryComponentFactories) },\n                { token: token, isSkipSelf: true, isOptional: true },\n                { token: createIdentifierToken(Identifiers.NgModuleRef) },\n            ],\n            lifecycleHooks: [],\n            reference: resolveIdentifier(Identifiers.CodegenComponentFactoryResolver)\n        };\n        return new ProviderAst(token, false, true, [{ token: token, multi: false, useClass: classMeta }], ProviderAstType.PrivateService, [], componentDirMeta.sourceSpan);\n    }\n    return null;\n}\n/**\n * @param {?} eventAst\n * @param {?} dirAst\n * @return {?}\n */\nfunction elementEventNameAndTarget(eventAst, dirAst) {\n    if (eventAst.isAnimation) {\n        return {\n            name: \"@\" + eventAst.name + \".\" + eventAst.phase,\n            target: dirAst && dirAst.directive.isComponent ? 'component' : null\n        };\n    }\n    else {\n        return eventAst;\n    }\n}\n/**\n * @param {?} queryIds\n * @param {?} queryId\n * @param {?} isFirst\n * @return {?}\n */\nfunction calcStaticDynamicQueryFlags(queryIds, queryId, isFirst) {\n    var /** @type {?} */ flags = 0;\n    // Note: We only make queries static that query for a single item.\n    // This is because of backwards compatibility with the old view compiler...\n    if (isFirst && (queryIds.staticQueryIds.has(queryId) || !queryIds.dynamicQueryIds.has(queryId))) {\n        flags |= 134217728 /* StaticQuery */;\n    }\n    else {\n        flags |= 268435456 /* DynamicQuery */;\n    }\n    return flags;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar GeneratedFile = (function () {\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} genFileUrl\n     * @param {?} source\n     */\n    function GeneratedFile(srcFileUrl, genFileUrl, source) {\n        this.srcFileUrl = srcFileUrl;\n        this.genFileUrl = genFileUrl;\n        this.source = source;\n    }\n    return GeneratedFile;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} summaryResolver\n * @param {?} symbolResolver\n * @param {?} symbols\n * @param {?} types\n * @return {?}\n */\nfunction serializeSummaries(summaryResolver, symbolResolver, symbols, types) {\n    var /** @type {?} */ serializer = new Serializer$1(symbolResolver, summaryResolver);\n    // for symbols, we use everything except for the class metadata itself\n    // (we keep the statics though), as the class metadata is contained in the\n    // CompileTypeSummary.\n    symbols.forEach(function (resolvedSymbol) { return serializer.addOrMergeSummary({ symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata }); });\n    // Add summaries that are referenced by the given symbols (transitively)\n    // Note: the serializer.symbols array might be growing while\n    // we execute the loop!\n    for (var /** @type {?} */ processedIndex = 0; processedIndex < serializer.symbols.length; processedIndex++) {\n        var /** @type {?} */ symbol = serializer.symbols[processedIndex];\n        if (summaryResolver.isLibraryFile(symbol.filePath)) {\n            var /** @type {?} */ summary = summaryResolver.resolveSummary(symbol);\n            if (!summary) {\n                // some symbols might originate from a plain typescript library\n                // that just exported .d.ts and .metadata.json files, i.e. where no summary\n                // files were created.\n                var /** @type {?} */ resolvedSymbol = symbolResolver.resolveSymbol(symbol);\n                if (resolvedSymbol) {\n                    summary = { symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata };\n                }\n            }\n            if (summary) {\n                serializer.addOrMergeSummary(summary);\n            }\n        }\n    }\n    // Add type summaries.\n    // Note: We don't add the summaries of all referenced symbols as for the ResolvedSymbols,\n    // as the type summaries already contain the transitive data that they require\n    // (in a minimal way).\n    types.forEach(function (typeSummary) {\n        serializer.addOrMergeSummary({ symbol: typeSummary.type.reference, metadata: null, type: typeSummary });\n        if (typeSummary.summaryKind === CompileSummaryKind.NgModule) {\n            var /** @type {?} */ ngModuleSummary = (typeSummary);\n            ngModuleSummary.exportedDirectives.concat(ngModuleSummary.exportedPipes).forEach(function (id) {\n                var /** @type {?} */ symbol = id.reference;\n                if (summaryResolver.isLibraryFile(symbol.filePath)) {\n                    var /** @type {?} */ summary = summaryResolver.resolveSummary(symbol);\n                    if (summary) {\n                        serializer.addOrMergeSummary(summary);\n                    }\n                }\n            });\n        }\n    });\n    return serializer.serialize();\n}\n/**\n * @param {?} symbolCache\n * @param {?} json\n * @return {?}\n */\nfunction deserializeSummaries(symbolCache, json) {\n    var /** @type {?} */ deserializer = new Deserializer(symbolCache);\n    return deserializer.deserialize(json);\n}\nvar Serializer$1 = (function (_super) {\n    __extends(Serializer$1, _super);\n    /**\n     * @param {?} symbolResolver\n     * @param {?} summaryResolver\n     */\n    function Serializer$1(symbolResolver, summaryResolver) {\n        var _this = _super.call(this) || this;\n        _this.symbolResolver = symbolResolver;\n        _this.summaryResolver = summaryResolver;\n        // Note: This only contains symbols without members.\n        _this.symbols = [];\n        _this.indexBySymbol = new Map();\n        _this.processedSummaryBySymbol = new Map();\n        _this.processedSummaries = [];\n        return _this;\n    }\n    /**\n     * @param {?} summary\n     * @return {?}\n     */\n    Serializer$1.prototype.addOrMergeSummary = function (summary) {\n        var /** @type {?} */ symbolMeta = summary.metadata;\n        if (symbolMeta && symbolMeta.__symbolic === 'class') {\n            // For classes, we keep everything except their class decorators.\n            // We need to keep e.g. the ctor args, method names, method decorators\n            // so that the class can be extended in another compilation unit.\n            // We don't keep the class decorators as\n            // 1) they refer to data\n            //   that should not cause a rebuild of downstream compilation units\n            //   (e.g. inline templates of @Component, or @NgModule.declarations)\n            // 2) their data is already captured in TypeSummaries, e.g. DirectiveSummary.\n            var /** @type {?} */ clone_1 = {};\n            Object.keys(symbolMeta).forEach(function (propName) {\n                if (propName !== 'decorators') {\n                    clone_1[propName] = symbolMeta[propName];\n                }\n            });\n            symbolMeta = clone_1;\n        }\n        var /** @type {?} */ processedSummary = this.processedSummaryBySymbol.get(summary.symbol);\n        if (!processedSummary) {\n            processedSummary = this.processValue({ symbol: summary.symbol });\n            this.processedSummaries.push(processedSummary);\n            this.processedSummaryBySymbol.set(summary.symbol, processedSummary);\n        }\n        // Note: == on purpose to compare with undefined!\n        if (processedSummary.metadata == null && symbolMeta != null) {\n            processedSummary.metadata = this.processValue(symbolMeta);\n        }\n        // Note: == on purpose to compare with undefined!\n        if (processedSummary.type == null && summary.type != null) {\n            processedSummary.type = this.processValue(summary.type);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    Serializer$1.prototype.serialize = function () {\n        var _this = this;\n        var /** @type {?} */ exportAs = [];\n        var /** @type {?} */ json = JSON.stringify({\n            summaries: this.processedSummaries,\n            symbols: this.symbols.map(function (symbol, index) {\n                symbol.assertNoMembers();\n                var /** @type {?} */ importAs = ((undefined));\n                if (_this.summaryResolver.isLibraryFile(symbol.filePath)) {\n                    importAs = symbol.name + \"_\" + index;\n                    exportAs.push({ symbol: symbol, exportAs: importAs });\n                }\n                return {\n                    __symbol: index,\n                    name: symbol.name,\n                    // We convert the source filenames tinto output filenames,\n                    // as the generated summary file will be used when teh current\n                    // compilation unit is used as a library\n                    filePath: _this.summaryResolver.getLibraryFileName(symbol.filePath),\n                    importAs: importAs\n                };\n            })\n        });\n        return { json: json, exportAs: exportAs };\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    Serializer$1.prototype.processValue = function (value) { return visitValue(value, this, null); };\n    /**\n     * @param {?} value\n     * @param {?} context\n     * @return {?}\n     */\n    Serializer$1.prototype.visitOther = function (value, context) {\n        if (value instanceof StaticSymbol) {\n            var /** @type {?} */ baseSymbol = this.symbolResolver.getStaticSymbol(value.filePath, value.name);\n            var /** @type {?} */ index = this.indexBySymbol.get(baseSymbol);\n            // Note: == on purpose to compare with undefined!\n            if (index == null) {\n                index = this.indexBySymbol.size;\n                this.indexBySymbol.set(baseSymbol, index);\n                this.symbols.push(baseSymbol);\n            }\n            return { __symbol: index, members: value.members };\n        }\n    };\n    return Serializer$1;\n}(ValueTransformer));\nvar Deserializer = (function (_super) {\n    __extends(Deserializer, _super);\n    /**\n     * @param {?} symbolCache\n     */\n    function Deserializer(symbolCache) {\n        var _this = _super.call(this) || this;\n        _this.symbolCache = symbolCache;\n        return _this;\n    }\n    /**\n     * @param {?} json\n     * @return {?}\n     */\n    Deserializer.prototype.deserialize = function (json) {\n        var _this = this;\n        var /** @type {?} */ data = JSON.parse(json);\n        var /** @type {?} */ importAs = [];\n        this.symbols = [];\n        data.symbols.forEach(function (serializedSymbol) {\n            var /** @type {?} */ symbol = _this.symbolCache.get(serializedSymbol.filePath, serializedSymbol.name);\n            _this.symbols.push(symbol);\n            if (serializedSymbol.importAs) {\n                importAs.push({ symbol: symbol, importAs: serializedSymbol.importAs });\n            }\n        });\n        var /** @type {?} */ summaries = visitValue(data.summaries, this, null);\n        return { summaries: summaries, importAs: importAs };\n    };\n    /**\n     * @param {?} map\n     * @param {?} context\n     * @return {?}\n     */\n    Deserializer.prototype.visitStringMap = function (map, context) {\n        if ('__symbol' in map) {\n            var /** @type {?} */ baseSymbol = this.symbols[map['__symbol']];\n            var /** @type {?} */ members = map['members'];\n            return members.length ? this.symbolCache.get(baseSymbol.filePath, baseSymbol.name, members) :\n                baseSymbol;\n        }\n        else {\n            return _super.prototype.visitStringMap.call(this, map, context);\n        }\n    };\n    return Deserializer;\n}(ValueTransformer));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar AotCompiler = (function () {\n    /**\n     * @param {?} _config\n     * @param {?} _host\n     * @param {?} _metadataResolver\n     * @param {?} _templateParser\n     * @param {?} _styleCompiler\n     * @param {?} _viewCompiler\n     * @param {?} _ngModuleCompiler\n     * @param {?} _outputEmitter\n     * @param {?} _summaryResolver\n     * @param {?} _localeId\n     * @param {?} _translationFormat\n     * @param {?} _genFilePreamble\n     * @param {?} _symbolResolver\n     */\n    function AotCompiler(_config, _host, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _outputEmitter, _summaryResolver, _localeId, _translationFormat, _genFilePreamble, _symbolResolver) {\n        this._config = _config;\n        this._host = _host;\n        this._metadataResolver = _metadataResolver;\n        this._templateParser = _templateParser;\n        this._styleCompiler = _styleCompiler;\n        this._viewCompiler = _viewCompiler;\n        this._ngModuleCompiler = _ngModuleCompiler;\n        this._outputEmitter = _outputEmitter;\n        this._summaryResolver = _summaryResolver;\n        this._localeId = _localeId;\n        this._translationFormat = _translationFormat;\n        this._genFilePreamble = _genFilePreamble;\n        this._symbolResolver = _symbolResolver;\n    }\n    /**\n     * @return {?}\n     */\n    AotCompiler.prototype.clearCache = function () { this._metadataResolver.clearCache(); };\n    /**\n     * @param {?} rootFiles\n     * @return {?}\n     */\n    AotCompiler.prototype.compileAll = function (rootFiles) {\n        var _this = this;\n        var /** @type {?} */ programSymbols = extractProgramSymbols(this._symbolResolver, rootFiles, this._host);\n        var _a = analyzeAndValidateNgModules(programSymbols, this._host, this._metadataResolver), ngModuleByPipeOrDirective = _a.ngModuleByPipeOrDirective, files = _a.files, ngModules = _a.ngModules;\n        return Promise\n            .all(ngModules.map(function (ngModule) { return _this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false); }))\n            .then(function () {\n            var /** @type {?} */ sourceModules = files.map(function (file) { return _this._compileSrcFile(file.srcUrl, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules, file.injectables); });\n            return flatten(sourceModules);\n        });\n    };\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} ngModuleByPipeOrDirective\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} ngModules\n     * @param {?} injectables\n     * @return {?}\n     */\n    AotCompiler.prototype._compileSrcFile = function (srcFileUrl, ngModuleByPipeOrDirective, directives, pipes, ngModules, injectables) {\n        var _this = this;\n        var /** @type {?} */ fileSuffix = splitTypescriptSuffix(srcFileUrl)[1];\n        var /** @type {?} */ statements = [];\n        var /** @type {?} */ exportedVars = [];\n        var /** @type {?} */ generatedFiles = [];\n        generatedFiles.push(this._createSummary(srcFileUrl, directives, pipes, ngModules, injectables, statements, exportedVars));\n        // compile all ng modules\n        exportedVars.push.apply(exportedVars, ngModules.map(function (ngModuleType) { return _this._compileModule(ngModuleType, statements); }));\n        // compile components\n        directives.forEach(function (dirType) {\n            var /** @type {?} */ compMeta = _this._metadataResolver.getDirectiveMetadata(/** @type {?} */ (dirType));\n            if (!compMeta.isComponent) {\n                return Promise.resolve(null);\n            }\n            var /** @type {?} */ ngModule = ngModuleByPipeOrDirective.get(dirType);\n            if (!ngModule) {\n                throw new Error(\"Internal Error: cannot determine the module for component \" + identifierName(compMeta.type) + \"!\");\n            }\n            _assertComponent(compMeta);\n            // compile styles\n            var /** @type {?} */ stylesCompileResults = _this._styleCompiler.compileComponent(compMeta);\n            stylesCompileResults.externalStylesheets.forEach(function (compiledStyleSheet) {\n                generatedFiles.push(_this._codgenStyles(srcFileUrl, compiledStyleSheet, fileSuffix));\n            });\n            // compile components\n            var /** @type {?} */ compViewVars = _this._compileComponent(compMeta, ngModule, ngModule.transitiveModule.directives, stylesCompileResults.componentStylesheet, fileSuffix, statements);\n            exportedVars.push(_this._compileComponentFactory(compMeta, ngModule, fileSuffix, statements), compViewVars.viewClassVar, compViewVars.compRenderTypeVar);\n        });\n        if (statements.length > 0) {\n            var /** @type {?} */ srcModule = this._codegenSourceModule(srcFileUrl, ngfactoryFilePath(srcFileUrl), statements, exportedVars);\n            generatedFiles.unshift(srcModule);\n        }\n        return generatedFiles;\n    };\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} ngModules\n     * @param {?} injectables\n     * @param {?} targetStatements\n     * @param {?} targetExportedVars\n     * @return {?}\n     */\n    AotCompiler.prototype._createSummary = function (srcFileUrl, directives, pipes, ngModules, injectables, targetStatements, targetExportedVars) {\n        var _this = this;\n        var /** @type {?} */ symbolSummaries = this._symbolResolver.getSymbolsOf(srcFileUrl)\n            .map(function (symbol) { return _this._symbolResolver.resolveSymbol(symbol); });\n        var /** @type {?} */ typeSummaries = ngModules.map(function (ref) { return ((_this._metadataResolver.getNgModuleSummary(ref))); }).concat(directives.map(function (ref) { return ((_this._metadataResolver.getDirectiveSummary(ref))); }), pipes.map(function (ref) { return ((_this._metadataResolver.getPipeSummary(ref))); }), injectables.map(function (ref) { return ((_this._metadataResolver.getInjectableSummary(ref))); }));\n        var _a = serializeSummaries(this._summaryResolver, this._symbolResolver, symbolSummaries, typeSummaries), json = _a.json, exportAs = _a.exportAs;\n        exportAs.forEach(function (entry) {\n            targetStatements.push(variable(entry.exportAs).set(importExpr({ reference: entry.symbol })).toDeclStmt());\n            targetExportedVars.push(entry.exportAs);\n        });\n        return new GeneratedFile(srcFileUrl, summaryFileName(srcFileUrl), json);\n    };\n    /**\n     * @param {?} ngModuleType\n     * @param {?} targetStatements\n     * @return {?}\n     */\n    AotCompiler.prototype._compileModule = function (ngModuleType, targetStatements) {\n        var /** @type {?} */ ngModule = ((this._metadataResolver.getNgModuleMetadata(ngModuleType)));\n        var /** @type {?} */ providers = [];\n        if (this._localeId) {\n            providers.push({\n                token: createIdentifierToken(Identifiers.LOCALE_ID),\n                useValue: this._localeId,\n            });\n        }\n        if (this._translationFormat) {\n            providers.push({\n                token: createIdentifierToken(Identifiers.TRANSLATIONS_FORMAT),\n                useValue: this._translationFormat\n            });\n        }\n        var /** @type {?} */ appCompileResult = this._ngModuleCompiler.compile(ngModule, providers);\n        targetStatements.push.apply(targetStatements, appCompileResult.statements);\n        return appCompileResult.ngModuleFactoryVar;\n    };\n    /**\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @param {?} fileSuffix\n     * @param {?} targetStatements\n     * @return {?}\n     */\n    AotCompiler.prototype._compileComponentFactory = function (compMeta, ngModule, fileSuffix, targetStatements) {\n        var /** @type {?} */ hostType = this._metadataResolver.getHostComponentType(compMeta.type.reference);\n        var /** @type {?} */ hostMeta = createHostComponentMeta(hostType, compMeta, this._metadataResolver.getHostComponentViewClass(hostType));\n        var /** @type {?} */ hostViewFactoryVar = this._compileComponent(hostMeta, ngModule, [compMeta.type], null, fileSuffix, targetStatements)\n            .viewClassVar;\n        var /** @type {?} */ compFactoryVar = componentFactoryName(compMeta.type.reference);\n        var /** @type {?} */ inputsExprs = [];\n        for (var /** @type {?} */ propName in compMeta.inputs) {\n            var /** @type {?} */ templateName = compMeta.inputs[propName];\n            // Don't quote so that the key gets minified...\n            inputsExprs.push(new LiteralMapEntry(propName, literal(templateName), false));\n        }\n        var /** @type {?} */ outputsExprs = [];\n        for (var /** @type {?} */ propName in compMeta.outputs) {\n            var /** @type {?} */ templateName = compMeta.outputs[propName];\n            // Don't quote so that the key gets minified...\n            outputsExprs.push(new LiteralMapEntry(propName, literal(templateName), false));\n        }\n        targetStatements.push(variable(compFactoryVar)\n            .set(importExpr(createIdentifier(Identifiers.createComponentFactory)).callFn([\n            literal(compMeta.selector), importExpr(compMeta.type),\n            variable(hostViewFactoryVar), new LiteralMapExpr(inputsExprs),\n            new LiteralMapExpr(outputsExprs),\n            literalArr(/** @type {?} */ ((compMeta.template)).ngContentSelectors.map(function (selector) { return literal(selector); }))\n        ]))\n            .toDeclStmt(importType(createIdentifier(Identifiers.ComponentFactory), [/** @type {?} */ ((importType(compMeta.type)))], [TypeModifier.Const]), [StmtModifier.Final]));\n        return compFactoryVar;\n    };\n    /**\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @param {?} directiveIdentifiers\n     * @param {?} componentStyles\n     * @param {?} fileSuffix\n     * @param {?} targetStatements\n     * @return {?}\n     */\n    AotCompiler.prototype._compileComponent = function (compMeta, ngModule, directiveIdentifiers, componentStyles, fileSuffix, targetStatements) {\n        var _this = this;\n        var /** @type {?} */ directives = directiveIdentifiers.map(function (dir) { return _this._metadataResolver.getDirectiveSummary(dir.reference); });\n        var /** @type {?} */ pipes = ngModule.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });\n        var _a = this._templateParser.parse(compMeta, /** @type {?} */ ((((compMeta.template)).template)), directives, pipes, ngModule.schemas, templateSourceUrl(ngModule.type, compMeta, /** @type {?} */ ((compMeta.template)))), parsedTemplate = _a.template, usedPipes = _a.pipes;\n        var /** @type {?} */ stylesExpr = componentStyles ? variable(componentStyles.stylesVar) : literalArr([]);\n        var /** @type {?} */ viewResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, stylesExpr, usedPipes);\n        if (componentStyles) {\n            targetStatements.push.apply(targetStatements, _resolveStyleStatements(this._symbolResolver, componentStyles, fileSuffix));\n        }\n        targetStatements.push.apply(targetStatements, viewResult.statements);\n        return { viewClassVar: viewResult.viewClassVar, compRenderTypeVar: viewResult.rendererTypeVar };\n    };\n    /**\n     * @param {?} fileUrl\n     * @param {?} stylesCompileResult\n     * @param {?} fileSuffix\n     * @return {?}\n     */\n    AotCompiler.prototype._codgenStyles = function (fileUrl, stylesCompileResult, fileSuffix) {\n        _resolveStyleStatements(this._symbolResolver, stylesCompileResult, fileSuffix);\n        return this._codegenSourceModule(fileUrl, _stylesModuleUrl(/** @type {?} */ ((stylesCompileResult.meta.moduleUrl)), stylesCompileResult.isShimmed, fileSuffix), stylesCompileResult.statements, [stylesCompileResult.stylesVar]);\n    };\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} genFileUrl\n     * @param {?} statements\n     * @param {?} exportedVars\n     * @return {?}\n     */\n    AotCompiler.prototype._codegenSourceModule = function (srcFileUrl, genFileUrl, statements, exportedVars) {\n        return new GeneratedFile(srcFileUrl, genFileUrl, this._outputEmitter.emitStatements(sourceUrl(srcFileUrl), genFileUrl, statements, exportedVars, this._genFilePreamble));\n    };\n    return AotCompiler;\n}());\n/**\n * @param {?} reflector\n * @param {?} compileResult\n * @param {?} fileSuffix\n * @return {?}\n */\nfunction _resolveStyleStatements(reflector, compileResult, fileSuffix) {\n    compileResult.dependencies.forEach(function (dep) {\n        dep.valuePlaceholder.reference = reflector.getStaticSymbol(_stylesModuleUrl(dep.moduleUrl, dep.isShimmed, fileSuffix), dep.name);\n    });\n    return compileResult.statements;\n}\n/**\n * @param {?} stylesheetUrl\n * @param {?} shim\n * @param {?} suffix\n * @return {?}\n */\nfunction _stylesModuleUrl(stylesheetUrl, shim, suffix) {\n    return \"\" + stylesheetUrl + (shim ? '.shim' : '') + \".ngstyle\" + suffix;\n}\n/**\n * @param {?} meta\n * @return {?}\n */\nfunction _assertComponent(meta) {\n    if (!meta.isComponent) {\n        throw new Error(\"Could not compile '\" + identifierName(meta.type) + \"' because it is not a component.\");\n    }\n}\n/**\n * @param {?} programStaticSymbols\n * @param {?} host\n * @param {?} metadataResolver\n * @return {?}\n */\nfunction analyzeNgModules(programStaticSymbols, host, metadataResolver) {\n    var _a = _createNgModules(programStaticSymbols, host, metadataResolver), ngModules = _a.ngModules, symbolsMissingModule = _a.symbolsMissingModule;\n    return _analyzeNgModules(programStaticSymbols, ngModules, symbolsMissingModule, metadataResolver);\n}\n/**\n * @param {?} programStaticSymbols\n * @param {?} host\n * @param {?} metadataResolver\n * @return {?}\n */\nfunction analyzeAndValidateNgModules(programStaticSymbols, host, metadataResolver) {\n    var /** @type {?} */ result = analyzeNgModules(programStaticSymbols, host, metadataResolver);\n    if (result.symbolsMissingModule && result.symbolsMissingModule.length) {\n        var /** @type {?} */ messages = result.symbolsMissingModule.map(function (s) { return \"Cannot determine the module for class \" + s.name + \" in \" + s.filePath + \"! Add \" + s.name + \" to the NgModule to fix it.\"; });\n        throw syntaxError(messages.join('\\n'));\n    }\n    return result;\n}\n/**\n * @param {?} programSymbols\n * @param {?} ngModuleMetas\n * @param {?} symbolsMissingModule\n * @param {?} metadataResolver\n * @return {?}\n */\nfunction _analyzeNgModules(programSymbols, ngModuleMetas, symbolsMissingModule, metadataResolver) {\n    var /** @type {?} */ moduleMetasByRef = new Map();\n    ngModuleMetas.forEach(function (ngModule) { return moduleMetasByRef.set(ngModule.type.reference, ngModule); });\n    var /** @type {?} */ ngModuleByPipeOrDirective = new Map();\n    var /** @type {?} */ ngModulesByFile = new Map();\n    var /** @type {?} */ ngDirectivesByFile = new Map();\n    var /** @type {?} */ ngPipesByFile = new Map();\n    var /** @type {?} */ ngInjectablesByFile = new Map();\n    var /** @type {?} */ filePaths = new Set();\n    // Make sure we produce an analyzed file for each input file\n    programSymbols.forEach(function (symbol) {\n        var /** @type {?} */ filePath = symbol.filePath;\n        filePaths.add(filePath);\n        if (metadataResolver.isInjectable(symbol)) {\n            ngInjectablesByFile.set(filePath, (ngInjectablesByFile.get(filePath) || []).concat(symbol));\n        }\n    });\n    // Looping over all modules to construct:\n    // - a map from file to modules `ngModulesByFile`,\n    // - a map from file to directives `ngDirectivesByFile`,\n    // - a map from file to pipes `ngPipesByFile`,\n    // - a map from directive/pipe to module `ngModuleByPipeOrDirective`.\n    ngModuleMetas.forEach(function (ngModuleMeta) {\n        var /** @type {?} */ srcFileUrl = ngModuleMeta.type.reference.filePath;\n        filePaths.add(srcFileUrl);\n        ngModulesByFile.set(srcFileUrl, (ngModulesByFile.get(srcFileUrl) || []).concat(ngModuleMeta.type.reference));\n        ngModuleMeta.declaredDirectives.forEach(function (dirIdentifier) {\n            var /** @type {?} */ fileUrl = dirIdentifier.reference.filePath;\n            filePaths.add(fileUrl);\n            ngDirectivesByFile.set(fileUrl, (ngDirectivesByFile.get(fileUrl) || []).concat(dirIdentifier.reference));\n            ngModuleByPipeOrDirective.set(dirIdentifier.reference, ngModuleMeta);\n        });\n        ngModuleMeta.declaredPipes.forEach(function (pipeIdentifier) {\n            var /** @type {?} */ fileUrl = pipeIdentifier.reference.filePath;\n            filePaths.add(fileUrl);\n            ngPipesByFile.set(fileUrl, (ngPipesByFile.get(fileUrl) || []).concat(pipeIdentifier.reference));\n            ngModuleByPipeOrDirective.set(pipeIdentifier.reference, ngModuleMeta);\n        });\n    });\n    var /** @type {?} */ files = [];\n    filePaths.forEach(function (srcUrl) {\n        var /** @type {?} */ directives = ngDirectivesByFile.get(srcUrl) || [];\n        var /** @type {?} */ pipes = ngPipesByFile.get(srcUrl) || [];\n        var /** @type {?} */ ngModules = ngModulesByFile.get(srcUrl) || [];\n        var /** @type {?} */ injectables = ngInjectablesByFile.get(srcUrl) || [];\n        files.push({ srcUrl: srcUrl, directives: directives, pipes: pipes, ngModules: ngModules, injectables: injectables });\n    });\n    return {\n        // map directive/pipe to module\n        ngModuleByPipeOrDirective: ngModuleByPipeOrDirective,\n        // list modules and directives for every source file\n        files: files,\n        ngModules: ngModuleMetas, symbolsMissingModule: symbolsMissingModule\n    };\n}\n/**\n * @param {?} staticSymbolResolver\n * @param {?} files\n * @param {?} host\n * @return {?}\n */\nfunction extractProgramSymbols(staticSymbolResolver, files, host) {\n    var /** @type {?} */ staticSymbols = [];\n    files.filter(function (fileName) { return host.isSourceFile(fileName); }).forEach(function (sourceFile) {\n        staticSymbolResolver.getSymbolsOf(sourceFile).forEach(function (symbol) {\n            var /** @type {?} */ resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n            var /** @type {?} */ symbolMeta = resolvedSymbol.metadata;\n            if (symbolMeta) {\n                if (symbolMeta.__symbolic != 'error') {\n                    // Ignore symbols that are only included to record error information.\n                    staticSymbols.push(resolvedSymbol.symbol);\n                }\n            }\n        });\n    });\n    return staticSymbols;\n}\n/**\n * @param {?} programStaticSymbols\n * @param {?} host\n * @param {?} metadataResolver\n * @return {?}\n */\nfunction _createNgModules(programStaticSymbols, host, metadataResolver) {\n    var /** @type {?} */ ngModules = new Map();\n    var /** @type {?} */ programPipesAndDirectives = [];\n    var /** @type {?} */ ngModulePipesAndDirective = new Set();\n    var /** @type {?} */ addNgModule = function (staticSymbol) {\n        if (ngModules.has(staticSymbol) || !host.isSourceFile(staticSymbol.filePath)) {\n            return false;\n        }\n        var /** @type {?} */ ngModule = metadataResolver.getNgModuleMetadata(staticSymbol, false);\n        if (ngModule) {\n            ngModules.set(ngModule.type.reference, ngModule);\n            ngModule.declaredDirectives.forEach(function (dir) { return ngModulePipesAndDirective.add(dir.reference); });\n            ngModule.declaredPipes.forEach(function (pipe) { return ngModulePipesAndDirective.add(pipe.reference); });\n            // For every input module add the list of transitively included modules\n            ngModule.transitiveModule.modules.forEach(function (modMeta) { return addNgModule(modMeta.reference); });\n        }\n        return !!ngModule;\n    };\n    programStaticSymbols.forEach(function (staticSymbol) {\n        if (!addNgModule(staticSymbol) &&\n            (metadataResolver.isDirective(staticSymbol) || metadataResolver.isPipe(staticSymbol))) {\n            programPipesAndDirectives.push(staticSymbol);\n        }\n    });\n    // Throw an error if any of the program pipe or directives is not declared by a module\n    var /** @type {?} */ symbolsMissingModule = programPipesAndDirectives.filter(function (s) { return !ngModulePipesAndDirective.has(s); });\n    return { ngModules: Array.from(ngModules.values()), symbolsMissingModule: symbolsMissingModule };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar StaticAndDynamicReflectionCapabilities = (function () {\n    /**\n     * @param {?} staticDelegate\n     */\n    function StaticAndDynamicReflectionCapabilities(staticDelegate) {\n        this.staticDelegate = staticDelegate;\n        this.dynamicDelegate = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵReflectionCapabilities\"]();\n    }\n    /**\n     * @param {?} staticDelegate\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.install = function (staticDelegate) {\n        __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵreflector\"].updateCapabilities(new StaticAndDynamicReflectionCapabilities(staticDelegate));\n    };\n    /**\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.factory = function (type) { return this.dynamicDelegate.factory(type); };\n    /**\n     * @param {?} type\n     * @param {?} lcProperty\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.hasLifecycleHook = function (type, lcProperty) {\n        return isStaticType(type) ? this.staticDelegate.hasLifecycleHook(type, lcProperty) :\n            this.dynamicDelegate.hasLifecycleHook(type, lcProperty);\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.parameters = function (type) {\n        return isStaticType(type) ? this.staticDelegate.parameters(type) :\n            this.dynamicDelegate.parameters(type);\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.annotations = function (type) {\n        return isStaticType(type) ? this.staticDelegate.annotations(type) :\n            this.dynamicDelegate.annotations(type);\n    };\n    /**\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {\n        return isStaticType(typeOrFunc) ? this.staticDelegate.propMetadata(typeOrFunc) :\n            this.dynamicDelegate.propMetadata(typeOrFunc);\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.getter = function (name) { return this.dynamicDelegate.getter(name); };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.setter = function (name) { return this.dynamicDelegate.setter(name); };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.method = function (name) { return this.dynamicDelegate.method(name); };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.importUri = function (type) { return ((this.staticDelegate.importUri(type))); };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.resourceUri = function (type) { return this.staticDelegate.resourceUri(type); };\n    /**\n     * @param {?} name\n     * @param {?} moduleUrl\n     * @param {?} members\n     * @param {?} runtime\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.resolveIdentifier = function (name, moduleUrl, members, runtime) {\n        return this.staticDelegate.resolveIdentifier(name, moduleUrl, members);\n    };\n    /**\n     * @param {?} enumIdentifier\n     * @param {?} name\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.resolveEnum = function (enumIdentifier, name) {\n        if (isStaticType(enumIdentifier)) {\n            return this.staticDelegate.resolveEnum(enumIdentifier, name);\n        }\n        else {\n            return null;\n        }\n    };\n    return StaticAndDynamicReflectionCapabilities;\n}());\n/**\n * @param {?} type\n * @return {?}\n */\nfunction isStaticType(type) {\n    return typeof type === 'object' && type.name && type.filePath;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ANGULAR_CORE = '@angular/core';\nvar HIDDEN_KEY = /^\\$.*\\$$/;\nvar IGNORE = {\n    __symbolic: 'ignore'\n};\n/**\n * @param {?} value\n * @return {?}\n */\nfunction shouldIgnore(value) {\n    return value && value.__symbolic == 'ignore';\n}\n/**\n * A static reflector implements enough of the Reflector API that is necessary to compile\n * templates statically.\n */\nvar StaticReflector = (function () {\n    /**\n     * @param {?} summaryResolver\n     * @param {?} symbolResolver\n     * @param {?=} knownMetadataClasses\n     * @param {?=} knownMetadataFunctions\n     * @param {?=} errorRecorder\n     */\n    function StaticReflector(summaryResolver, symbolResolver, knownMetadataClasses, knownMetadataFunctions, errorRecorder) {\n        if (knownMetadataClasses === void 0) { knownMetadataClasses = []; }\n        if (knownMetadataFunctions === void 0) { knownMetadataFunctions = []; }\n        var _this = this;\n        this.summaryResolver = summaryResolver;\n        this.symbolResolver = symbolResolver;\n        this.errorRecorder = errorRecorder;\n        this.annotationCache = new Map();\n        this.propertyCache = new Map();\n        this.parameterCache = new Map();\n        this.methodCache = new Map();\n        this.conversionMap = new Map();\n        this.annotationForParentClassWithSummaryKind = new Map();\n        this.annotationNames = new Map();\n        this.initializeConversionMap();\n        knownMetadataClasses.forEach(function (kc) { return _this._registerDecoratorOrConstructor(_this.getStaticSymbol(kc.filePath, kc.name), kc.ctor); });\n        knownMetadataFunctions.forEach(function (kf) { return _this._registerFunction(_this.getStaticSymbol(kf.filePath, kf.name), kf.fn); });\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Directive, [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Directive\"], __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Component\"]]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Pipe, [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Pipe\"]]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.NgModule, [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"NgModule\"]]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Injectable, [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Injectable\"], __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Pipe\"], __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Directive\"], __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Component\"], __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"NgModule\"]]);\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Directive\"], 'Directive');\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Component\"], 'Component');\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Pipe\"], 'Pipe');\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"NgModule\"], 'NgModule');\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Injectable\"], 'Injectable');\n    }\n    /**\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    StaticReflector.prototype.importUri = function (typeOrFunc) {\n        var /** @type {?} */ staticSymbol = this.findSymbolDeclaration(typeOrFunc);\n        return staticSymbol ? staticSymbol.filePath : null;\n    };\n    /**\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    StaticReflector.prototype.resourceUri = function (typeOrFunc) {\n        var /** @type {?} */ staticSymbol = this.findSymbolDeclaration(typeOrFunc);\n        return this.symbolResolver.getResourcePath(staticSymbol);\n    };\n    /**\n     * @param {?} name\n     * @param {?} moduleUrl\n     * @param {?} members\n     * @return {?}\n     */\n    StaticReflector.prototype.resolveIdentifier = function (name, moduleUrl, members) {\n        var /** @type {?} */ importSymbol = this.getStaticSymbol(moduleUrl, name);\n        var /** @type {?} */ rootSymbol = this.findDeclaration(moduleUrl, name);\n        if (importSymbol != rootSymbol) {\n            this.symbolResolver.recordImportAs(rootSymbol, importSymbol);\n        }\n        if (members && members.length) {\n            return this.getStaticSymbol(rootSymbol.filePath, rootSymbol.name, members);\n        }\n        return rootSymbol;\n    };\n    /**\n     * @param {?} moduleUrl\n     * @param {?} name\n     * @param {?=} containingFile\n     * @return {?}\n     */\n    StaticReflector.prototype.findDeclaration = function (moduleUrl, name, containingFile) {\n        return this.findSymbolDeclaration(this.symbolResolver.getSymbolByModule(moduleUrl, name, containingFile));\n    };\n    /**\n     * @param {?} symbol\n     * @return {?}\n     */\n    StaticReflector.prototype.findSymbolDeclaration = function (symbol) {\n        var /** @type {?} */ resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\n        if (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n            return this.findSymbolDeclaration(resolvedSymbol.metadata);\n        }\n        else {\n            return symbol;\n        }\n    };\n    /**\n     * @param {?} enumIdentifier\n     * @param {?} name\n     * @return {?}\n     */\n    StaticReflector.prototype.resolveEnum = function (enumIdentifier, name) {\n        var /** @type {?} */ staticSymbol = enumIdentifier;\n        var /** @type {?} */ members = (staticSymbol.members || []).concat(name);\n        return this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name, members);\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype.annotations = function (type) {\n        var _this = this;\n        var /** @type {?} */ annotations = this.annotationCache.get(type);\n        if (!annotations) {\n            annotations = [];\n            var /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n            var /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                var /** @type {?} */ parentAnnotations = this.annotations(parentType);\n                annotations.push.apply(annotations, parentAnnotations);\n            }\n            var /** @type {?} */ ownAnnotations_1 = [];\n            if (classMetadata['decorators']) {\n                ownAnnotations_1 = this.simplify(type, classMetadata['decorators']);\n                annotations.push.apply(annotations, ownAnnotations_1);\n            }\n            if (parentType && !this.summaryResolver.isLibraryFile(type.filePath) &&\n                this.summaryResolver.isLibraryFile(parentType.filePath)) {\n                var /** @type {?} */ summary = this.summaryResolver.resolveSummary(parentType);\n                if (summary && summary.type) {\n                    var /** @type {?} */ requiredAnnotationTypes = ((this.annotationForParentClassWithSummaryKind.get(/** @type {?} */ ((summary.type.summaryKind)))));\n                    var /** @type {?} */ typeHasRequiredAnnotation = requiredAnnotationTypes.some(function (requiredType) { return ownAnnotations_1.some(function (ann) { return ann instanceof requiredType; }); });\n                    if (!typeHasRequiredAnnotation) {\n                        this.reportError(syntaxError(\"Class \" + type.name + \" in \" + type.filePath + \" extends from a \" + CompileSummaryKind[((summary.type.summaryKind))] + \" in another compilation unit without duplicating the decorator. \" +\n                            (\"Please add a \" + requiredAnnotationTypes.map(function (type) { return _this.annotationNames.get(type); }).join(' or ') + \" decorator to the class.\")), type);\n                    }\n                }\n            }\n            this.annotationCache.set(type, annotations.filter(function (ann) { return !!ann; }));\n        }\n        return annotations;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype.propMetadata = function (type) {\n        var _this = this;\n        var /** @type {?} */ propMetadata = this.propertyCache.get(type);\n        if (!propMetadata) {\n            var /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n            propMetadata = {};\n            var /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                var /** @type {?} */ parentPropMetadata_1 = this.propMetadata(parentType);\n                Object.keys(parentPropMetadata_1).forEach(function (parentProp) {\n                    ((propMetadata))[parentProp] = parentPropMetadata_1[parentProp];\n                });\n            }\n            var /** @type {?} */ members_1 = classMetadata['members'] || {};\n            Object.keys(members_1).forEach(function (propName) {\n                var /** @type {?} */ propData = members_1[propName];\n                var /** @type {?} */ prop = ((propData))\n                    .find(function (a) { return a['__symbolic'] == 'property' || a['__symbolic'] == 'method'; });\n                var /** @type {?} */ decorators = [];\n                if (((propMetadata))[propName]) {\n                    decorators.push.apply(decorators, ((propMetadata))[propName]);\n                } /** @type {?} */\n                ((propMetadata))[propName] = decorators;\n                if (prop && prop['decorators']) {\n                    decorators.push.apply(decorators, _this.simplify(type, prop['decorators']));\n                }\n            });\n            this.propertyCache.set(type, propMetadata);\n        }\n        return propMetadata;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype.parameters = function (type) {\n        if (!(type instanceof StaticSymbol)) {\n            this.reportError(new Error(\"parameters received \" + JSON.stringify(type) + \" which is not a StaticSymbol\"), type);\n            return [];\n        }\n        try {\n            var /** @type {?} */ parameters_1 = this.parameterCache.get(type);\n            if (!parameters_1) {\n                var /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n                var /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n                var /** @type {?} */ members = classMetadata ? classMetadata['members'] : null;\n                var /** @type {?} */ ctorData = members ? members['__ctor__'] : null;\n                if (ctorData) {\n                    var /** @type {?} */ ctor = ((ctorData)).find(function (a) { return a['__symbolic'] == 'constructor'; });\n                    var /** @type {?} */ parameterTypes = (this.simplify(type, ctor['parameters'] || []));\n                    var /** @type {?} */ parameterDecorators_1 = (this.simplify(type, ctor['parameterDecorators'] || []));\n                    parameters_1 = [];\n                    parameterTypes.forEach(function (paramType, index) {\n                        var /** @type {?} */ nestedResult = [];\n                        if (paramType) {\n                            nestedResult.push(paramType);\n                        }\n                        var /** @type {?} */ decorators = parameterDecorators_1 ? parameterDecorators_1[index] : null;\n                        if (decorators) {\n                            nestedResult.push.apply(nestedResult, decorators);\n                        } /** @type {?} */\n                        ((parameters_1)).push(nestedResult);\n                    });\n                }\n                else if (parentType) {\n                    parameters_1 = this.parameters(parentType);\n                }\n                if (!parameters_1) {\n                    parameters_1 = [];\n                }\n                this.parameterCache.set(type, parameters_1);\n            }\n            return parameters_1;\n        }\n        catch (e) {\n            console.error(\"Failed on type \" + JSON.stringify(type) + \" with error \" + e);\n            throw e;\n        }\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype._methodNames = function (type) {\n        var /** @type {?} */ methodNames = this.methodCache.get(type);\n        if (!methodNames) {\n            var /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n            methodNames = {};\n            var /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                var /** @type {?} */ parentMethodNames_1 = this._methodNames(parentType);\n                Object.keys(parentMethodNames_1).forEach(function (parentProp) {\n                    ((methodNames))[parentProp] = parentMethodNames_1[parentProp];\n                });\n            }\n            var /** @type {?} */ members_2 = classMetadata['members'] || {};\n            Object.keys(members_2).forEach(function (propName) {\n                var /** @type {?} */ propData = members_2[propName];\n                var /** @type {?} */ isMethod = ((propData)).some(function (a) { return a['__symbolic'] == 'method'; }); /** @type {?} */\n                ((methodNames))[propName] = ((methodNames))[propName] || isMethod;\n            });\n            this.methodCache.set(type, methodNames);\n        }\n        return methodNames;\n    };\n    /**\n     * @param {?} type\n     * @param {?} classMetadata\n     * @return {?}\n     */\n    StaticReflector.prototype.findParentType = function (type, classMetadata) {\n        var /** @type {?} */ parentType = this.trySimplify(type, classMetadata['extends']);\n        if (parentType instanceof StaticSymbol) {\n            return parentType;\n        }\n    };\n    /**\n     * @param {?} type\n     * @param {?} lcProperty\n     * @return {?}\n     */\n    StaticReflector.prototype.hasLifecycleHook = function (type, lcProperty) {\n        if (!(type instanceof StaticSymbol)) {\n            this.reportError(new Error(\"hasLifecycleHook received \" + JSON.stringify(type) + \" which is not a StaticSymbol\"), type);\n        }\n        try {\n            return !!this._methodNames(type)[lcProperty];\n        }\n        catch (e) {\n            console.error(\"Failed on type \" + JSON.stringify(type) + \" with error \" + e);\n            throw e;\n        }\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctor\n     * @return {?}\n     */\n    StaticReflector.prototype._registerDecoratorOrConstructor = function (type, ctor) {\n        this.conversionMap.set(type, function (context, args) { return new (ctor.bind.apply(ctor, [void 0].concat(args)))(); });\n    };\n    /**\n     * @param {?} type\n     * @param {?} fn\n     * @return {?}\n     */\n    StaticReflector.prototype._registerFunction = function (type, fn) {\n        this.conversionMap.set(type, function (context, args) { return fn.apply(undefined, args); });\n    };\n    /**\n     * @return {?}\n     */\n    StaticReflector.prototype.initializeConversionMap = function () {\n        this.injectionToken = this.findDeclaration(ANGULAR_CORE, 'InjectionToken');\n        this.opaqueToken = this.findDeclaration(ANGULAR_CORE, 'OpaqueToken');\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Host\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Injectable'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Injectable\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Self\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"SkipSelf\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Inject'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Inject\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Optional\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Attribute'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Attribute\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChild'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ContentChild\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChildren'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ContentChildren\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChild'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewChild\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChildren'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewChildren\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Input'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Input\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Output'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Output\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Pipe'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Pipe\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostBinding'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"HostBinding\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostListener'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"HostListener\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Directive'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Directive\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Component'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Component\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'NgModule'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"NgModule\"]);\n        // Note: Some metadata classes can be used directly with Provider.deps.\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Host\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Self\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"SkipSelf\"]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Optional\"]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'trigger'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"trigger\"]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'state'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"state\"]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'transition'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"transition\"]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'style'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"style\"]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'animate'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"animate\"]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'keyframes'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"keyframes\"]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'sequence'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"sequence\"]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'group'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"group\"]);\n    };\n    /**\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\n     *\n     * @param {?} declarationFile the absolute path of the file where the symbol is declared\n     * @param {?} name the name of the type.\n     * @param {?=} members\n     * @return {?}\n     */\n    StaticReflector.prototype.getStaticSymbol = function (declarationFile, name, members) {\n        return this.symbolResolver.getStaticSymbol(declarationFile, name, members);\n    };\n    /**\n     * @param {?} error\n     * @param {?} context\n     * @param {?=} path\n     * @return {?}\n     */\n    StaticReflector.prototype.reportError = function (error, context, path) {\n        if (this.errorRecorder) {\n            this.errorRecorder(error, (context && context.filePath) || path);\n        }\n        else {\n            throw error;\n        }\n    };\n    /**\n     * Simplify but discard any errors\n     * @param {?} context\n     * @param {?} value\n     * @return {?}\n     */\n    StaticReflector.prototype.trySimplify = function (context, value) {\n        var /** @type {?} */ originalRecorder = this.errorRecorder;\n        this.errorRecorder = function (error, fileName) { };\n        var /** @type {?} */ result = this.simplify(context, value);\n        this.errorRecorder = originalRecorder;\n        return result;\n    };\n    /**\n     * \\@internal\n     * @param {?} context\n     * @param {?} value\n     * @return {?}\n     */\n    StaticReflector.prototype.simplify = function (context, value) {\n        var _this = this;\n        var /** @type {?} */ self = this;\n        var /** @type {?} */ scope = BindingScope.empty;\n        var /** @type {?} */ calling = new Map();\n        /**\n         * @param {?} context\n         * @param {?} value\n         * @param {?} depth\n         * @return {?}\n         */\n        function simplifyInContext(context, value, depth) {\n            /**\n             * @param {?} staticSymbol\n             * @return {?}\n             */\n            function resolveReferenceValue(staticSymbol) {\n                var /** @type {?} */ resolvedSymbol = self.symbolResolver.resolveSymbol(staticSymbol);\n                return resolvedSymbol ? resolvedSymbol.metadata : null;\n            }\n            /**\n             * @param {?} functionSymbol\n             * @param {?} targetFunction\n             * @param {?} args\n             * @return {?}\n             */\n            function simplifyCall(functionSymbol, targetFunction, args) {\n                if (targetFunction && targetFunction['__symbolic'] == 'function') {\n                    if (calling.get(functionSymbol)) {\n                        throw new Error('Recursion not supported');\n                    }\n                    calling.set(functionSymbol, true);\n                    try {\n                        var /** @type {?} */ value_1 = targetFunction['value'];\n                        if (value_1 && (depth != 0 || value_1.__symbolic != 'error')) {\n                            var /** @type {?} */ parameters = targetFunction['parameters'];\n                            var /** @type {?} */ defaults = targetFunction.defaults;\n                            args = args.map(function (arg) { return simplifyInContext(context, arg, depth + 1); })\n                                .map(function (arg) { return shouldIgnore(arg) ? undefined : arg; });\n                            if (defaults && defaults.length > args.length) {\n                                args.push.apply(args, defaults.slice(args.length).map(function (value) { return simplify(value); }));\n                            }\n                            var /** @type {?} */ functionScope = BindingScope.build();\n                            for (var /** @type {?} */ i = 0; i < parameters.length; i++) {\n                                functionScope.define(parameters[i], args[i]);\n                            }\n                            var /** @type {?} */ oldScope = scope;\n                            var /** @type {?} */ result_1;\n                            try {\n                                scope = functionScope.done();\n                                result_1 = simplifyInContext(functionSymbol, value_1, depth + 1);\n                            }\n                            finally {\n                                scope = oldScope;\n                            }\n                            return result_1;\n                        }\n                    }\n                    finally {\n                        calling.delete(functionSymbol);\n                    }\n                }\n                if (depth === 0) {\n                    // If depth is 0 we are evaluating the top level expression that is describing element\n                    // decorator. In this case, it is a decorator we don't understand, such as a custom\n                    // non-angular decorator, and we should just ignore it.\n                    return IGNORE;\n                }\n                return simplify({ __symbolic: 'error', message: 'Function call not supported', context: functionSymbol });\n            }\n            /**\n             * @param {?} expression\n             * @return {?}\n             */\n            function simplify(expression) {\n                if (isPrimitive(expression)) {\n                    return expression;\n                }\n                if (expression instanceof Array) {\n                    var /** @type {?} */ result_2 = [];\n                    for (var _i = 0, _a = ((expression)); _i < _a.length; _i++) {\n                        var item = _a[_i];\n                        // Check for a spread expression\n                        if (item && item.__symbolic === 'spread') {\n                            var /** @type {?} */ spreadArray = simplify(item.expression);\n                            if (Array.isArray(spreadArray)) {\n                                for (var _b = 0, spreadArray_1 = spreadArray; _b < spreadArray_1.length; _b++) {\n                                    var spreadItem = spreadArray_1[_b];\n                                    result_2.push(spreadItem);\n                                }\n                                continue;\n                            }\n                        }\n                        var /** @type {?} */ value_2 = simplify(item);\n                        if (shouldIgnore(value_2)) {\n                            continue;\n                        }\n                        result_2.push(value_2);\n                    }\n                    return result_2;\n                }\n                if (expression instanceof StaticSymbol) {\n                    // Stop simplification at builtin symbols\n                    if (expression === self.injectionToken || expression === self.opaqueToken ||\n                        self.conversionMap.has(expression)) {\n                        return expression;\n                    }\n                    else {\n                        var /** @type {?} */ staticSymbol = expression;\n                        var /** @type {?} */ declarationValue = resolveReferenceValue(staticSymbol);\n                        if (declarationValue) {\n                            return simplifyInContext(staticSymbol, declarationValue, depth + 1);\n                        }\n                        else {\n                            return staticSymbol;\n                        }\n                    }\n                }\n                if (expression) {\n                    if (expression['__symbolic']) {\n                        var /** @type {?} */ staticSymbol = void 0;\n                        switch (expression['__symbolic']) {\n                            case 'binop':\n                                var /** @type {?} */ left = simplify(expression['left']);\n                                if (shouldIgnore(left))\n                                    return left;\n                                var /** @type {?} */ right = simplify(expression['right']);\n                                if (shouldIgnore(right))\n                                    return right;\n                                switch (expression['operator']) {\n                                    case '&&':\n                                        return left && right;\n                                    case '||':\n                                        return left || right;\n                                    case '|':\n                                        return left | right;\n                                    case '^':\n                                        return left ^ right;\n                                    case '&':\n                                        return left & right;\n                                    case '==':\n                                        return left == right;\n                                    case '!=':\n                                        return left != right;\n                                    case '===':\n                                        return left === right;\n                                    case '!==':\n                                        return left !== right;\n                                    case '<':\n                                        return left < right;\n                                    case '>':\n                                        return left > right;\n                                    case '<=':\n                                        return left <= right;\n                                    case '>=':\n                                        return left >= right;\n                                    case '<<':\n                                        return left << right;\n                                    case '>>':\n                                        return left >> right;\n                                    case '+':\n                                        return left + right;\n                                    case '-':\n                                        return left - right;\n                                    case '*':\n                                        return left * right;\n                                    case '/':\n                                        return left / right;\n                                    case '%':\n                                        return left % right;\n                                }\n                                return null;\n                            case 'if':\n                                var /** @type {?} */ condition = simplify(expression['condition']);\n                                return condition ? simplify(expression['thenExpression']) :\n                                    simplify(expression['elseExpression']);\n                            case 'pre':\n                                var /** @type {?} */ operand = simplify(expression['operand']);\n                                if (shouldIgnore(operand))\n                                    return operand;\n                                switch (expression['operator']) {\n                                    case '+':\n                                        return operand;\n                                    case '-':\n                                        return -operand;\n                                    case '!':\n                                        return !operand;\n                                    case '~':\n                                        return ~operand;\n                                }\n                                return null;\n                            case 'index':\n                                var /** @type {?} */ indexTarget = simplify(expression['expression']);\n                                var /** @type {?} */ index = simplify(expression['index']);\n                                if (indexTarget && isPrimitive(index))\n                                    return indexTarget[index];\n                                return null;\n                            case 'select':\n                                var /** @type {?} */ member = expression['member'];\n                                var /** @type {?} */ selectContext = context;\n                                var /** @type {?} */ selectTarget = simplify(expression['expression']);\n                                if (selectTarget instanceof StaticSymbol) {\n                                    var /** @type {?} */ members = selectTarget.members.concat(member);\n                                    selectContext =\n                                        self.getStaticSymbol(selectTarget.filePath, selectTarget.name, members);\n                                    var /** @type {?} */ declarationValue = resolveReferenceValue(selectContext);\n                                    if (declarationValue) {\n                                        return simplifyInContext(selectContext, declarationValue, depth + 1);\n                                    }\n                                    else {\n                                        return selectContext;\n                                    }\n                                }\n                                if (selectTarget && isPrimitive(member))\n                                    return simplifyInContext(selectContext, selectTarget[member], depth + 1);\n                                return null;\n                            case 'reference':\n                                // Note: This only has to deal with variable references,\n                                // as symbol references have been converted into StaticSymbols already\n                                // in the StaticSymbolResolver!\n                                var /** @type {?} */ name = expression['name'];\n                                var /** @type {?} */ localValue = scope.resolve(name);\n                                if (localValue != BindingScope.missing) {\n                                    return localValue;\n                                }\n                                break;\n                            case 'class':\n                                return context;\n                            case 'function':\n                                return context;\n                            case 'new':\n                            case 'call':\n                                // Determine if the function is a built-in conversion\n                                staticSymbol = simplifyInContext(context, expression['expression'], depth + 1);\n                                if (staticSymbol instanceof StaticSymbol) {\n                                    if (staticSymbol === self.injectionToken || staticSymbol === self.opaqueToken) {\n                                        // if somebody calls new InjectionToken, don't create an InjectionToken,\n                                        // but rather return the symbol to which the InjectionToken is assigned to.\n                                        return context;\n                                    }\n                                    var /** @type {?} */ argExpressions = expression['arguments'] || [];\n                                    var /** @type {?} */ converter = self.conversionMap.get(staticSymbol);\n                                    if (converter) {\n                                        var /** @type {?} */ args = argExpressions.map(function (arg) { return simplifyInContext(context, arg, depth + 1); })\n                                            .map(function (arg) { return shouldIgnore(arg) ? undefined : arg; });\n                                        return converter(context, args);\n                                    }\n                                    else {\n                                        // Determine if the function is one we can simplify.\n                                        var /** @type {?} */ targetFunction = resolveReferenceValue(staticSymbol);\n                                        return simplifyCall(staticSymbol, targetFunction, argExpressions);\n                                    }\n                                }\n                                return IGNORE;\n                            case 'error':\n                                var /** @type {?} */ message = produceErrorMessage(expression);\n                                if (expression['line']) {\n                                    message =\n                                        message + \" (position \" + (expression['line'] + 1) + \":\" + (expression['character'] + 1) + \" in the original .ts file)\";\n                                    self.reportError(positionalError(message, context.filePath, expression['line'], expression['character']), context);\n                                }\n                                else {\n                                    self.reportError(new Error(message), context);\n                                }\n                                return IGNORE;\n                            case 'ignore':\n                                return expression;\n                        }\n                        return null;\n                    }\n                    return mapStringMap(expression, function (value, name) { return simplify(value); });\n                }\n                return IGNORE;\n            }\n            try {\n                return simplify(value);\n            }\n            catch (e) {\n                var /** @type {?} */ members = context.members.length ? \".\" + context.members.join('.') : '';\n                var /** @type {?} */ message = e.message + \", resolving symbol \" + context.name + members + \" in \" + context.filePath;\n                if (e.fileName) {\n                    throw positionalError(message, e.fileName, e.line, e.column);\n                }\n                throw syntaxError(message);\n            }\n        }\n        var /** @type {?} */ recordedSimplifyInContext = function (context, value, depth) {\n            try {\n                return simplifyInContext(context, value, depth);\n            }\n            catch (e) {\n                _this.reportError(e, context);\n            }\n        };\n        var /** @type {?} */ result = this.errorRecorder ? recordedSimplifyInContext(context, value, 0) :\n            simplifyInContext(context, value, 0);\n        if (shouldIgnore(result)) {\n            return undefined;\n        }\n        return result;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype.getTypeMetadata = function (type) {\n        var /** @type {?} */ resolvedSymbol = this.symbolResolver.resolveSymbol(type);\n        return resolvedSymbol && resolvedSymbol.metadata ? resolvedSymbol.metadata :\n            { __symbolic: 'class' };\n    };\n    return StaticReflector;\n}());\n/**\n * @param {?} error\n * @return {?}\n */\nfunction expandedMessage(error) {\n    switch (error.message) {\n        case 'Reference to non-exported class':\n            if (error.context && error.context.className) {\n                return \"Reference to a non-exported class \" + error.context.className + \". Consider exporting the class\";\n            }\n            break;\n        case 'Variable not initialized':\n            return 'Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler';\n        case 'Destructuring not supported':\n            return 'Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring';\n        case 'Could not resolve type':\n            if (error.context && error.context.typeName) {\n                return \"Could not resolve type \" + error.context.typeName;\n            }\n            break;\n        case 'Function call not supported':\n            var /** @type {?} */ prefix = error.context && error.context.name ? \"Calling function '\" + error.context.name + \"', f\" : 'F';\n            return prefix +\n                'unction calls are not supported. Consider replacing the function or lambda with a reference to an exported function';\n        case 'Reference to a local symbol':\n            if (error.context && error.context.name) {\n                return \"Reference to a local (non-exported) symbol '\" + error.context.name + \"'. Consider exporting the symbol\";\n            }\n            break;\n    }\n    return error.message;\n}\n/**\n * @param {?} error\n * @return {?}\n */\nfunction produceErrorMessage(error) {\n    return \"Error encountered resolving symbol values statically. \" + expandedMessage(error);\n}\n/**\n * @param {?} input\n * @param {?} transform\n * @return {?}\n */\nfunction mapStringMap(input, transform) {\n    if (!input)\n        return {};\n    var /** @type {?} */ result = {};\n    Object.keys(input).forEach(function (key) {\n        var /** @type {?} */ value = transform(input[key], key);\n        if (!shouldIgnore(value)) {\n            if (HIDDEN_KEY.test(key)) {\n                Object.defineProperty(result, key, { enumerable: false, configurable: true, value: value });\n            }\n            else {\n                result[key] = value;\n            }\n        }\n    });\n    return result;\n}\n/**\n * @param {?} o\n * @return {?}\n */\nfunction isPrimitive(o) {\n    return o === null || (typeof o !== 'function' && typeof o !== 'object');\n}\n/**\n * @abstract\n */\nvar BindingScope = (function () {\n    function BindingScope() {\n    }\n    /**\n     * @abstract\n     * @param {?} name\n     * @return {?}\n     */\n    BindingScope.prototype.resolve = function (name) { };\n    /**\n     * @return {?}\n     */\n    BindingScope.build = function () {\n        var /** @type {?} */ current = new Map();\n        return {\n            define: function (name, value) {\n                current.set(name, value);\n                return this;\n            },\n            done: function () {\n                return current.size > 0 ? new PopulatedScope(current) : BindingScope.empty;\n            }\n        };\n    };\n    return BindingScope;\n}());\nBindingScope.missing = {};\nBindingScope.empty = { resolve: function (name) { return BindingScope.missing; } };\nvar PopulatedScope = (function (_super) {\n    __extends(PopulatedScope, _super);\n    /**\n     * @param {?} bindings\n     */\n    function PopulatedScope(bindings) {\n        var _this = _super.call(this) || this;\n        _this.bindings = bindings;\n        return _this;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    PopulatedScope.prototype.resolve = function (name) {\n        return this.bindings.has(name) ? this.bindings.get(name) : BindingScope.missing;\n    };\n    return PopulatedScope;\n}(BindingScope));\n/**\n * @param {?} message\n * @param {?} fileName\n * @param {?} line\n * @param {?} column\n * @return {?}\n */\nfunction positionalError(message, fileName, line, column) {\n    var /** @type {?} */ result = new Error(message);\n    ((result)).fileName = fileName;\n    ((result)).line = line;\n    ((result)).column = column;\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ResolvedStaticSymbol = (function () {\n    /**\n     * @param {?} symbol\n     * @param {?} metadata\n     */\n    function ResolvedStaticSymbol(symbol, metadata) {\n        this.symbol = symbol;\n        this.metadata = metadata;\n    }\n    return ResolvedStaticSymbol;\n}());\nvar SUPPORTED_SCHEMA_VERSION = 3;\n/**\n * This class is responsible for loading metadata per symbol,\n * and normalizing references between symbols.\n *\n * Internally, it only uses symbols without members,\n * and deduces the values for symbols with members based\n * on these symbols.\n */\nvar StaticSymbolResolver = (function () {\n    /**\n     * @param {?} host\n     * @param {?} staticSymbolCache\n     * @param {?} summaryResolver\n     * @param {?=} errorRecorder\n     */\n    function StaticSymbolResolver(host, staticSymbolCache, summaryResolver, errorRecorder) {\n        this.host = host;\n        this.staticSymbolCache = staticSymbolCache;\n        this.summaryResolver = summaryResolver;\n        this.errorRecorder = errorRecorder;\n        this.metadataCache = new Map();\n        this.resolvedSymbols = new Map();\n        this.resolvedFilePaths = new Set();\n        this.importAs = new Map();\n        this.symbolResourcePaths = new Map();\n        this.symbolFromFile = new Map();\n    }\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.resolveSymbol = function (staticSymbol) {\n        if (staticSymbol.members.length > 0) {\n            return ((this._resolveSymbolMembers(staticSymbol)));\n        }\n        var /** @type {?} */ result = this.resolvedSymbols.get(staticSymbol);\n        if (result) {\n            return result;\n        }\n        result = ((this._resolveSymbolFromSummary(staticSymbol)));\n        if (result) {\n            return result;\n        }\n        // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n        // have summaries, only .d.ts files. So we always need to check both, the summary\n        // and metadata.\n        this._createSymbolsOf(staticSymbol.filePath);\n        result = ((this.resolvedSymbols.get(staticSymbol)));\n        return result;\n    };\n    /**\n     * getImportAs produces a symbol that can be used to import the given symbol.\n     * The import might be different than the symbol if the symbol is exported from\n     * a library with a summary; in which case we want to import the symbol from the\n     * ngfactory re-export instead of directly to avoid introducing a direct dependency\n     * on an otherwise indirect dependency.\n     *\n     * @param {?} staticSymbol the symbol for which to generate a import symbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getImportAs = function (staticSymbol) {\n        if (staticSymbol.members.length) {\n            var /** @type {?} */ baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);\n            var /** @type {?} */ baseImportAs = this.getImportAs(baseSymbol);\n            return baseImportAs ?\n                this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) :\n                null;\n        }\n        var /** @type {?} */ result = this.summaryResolver.getImportAs(staticSymbol);\n        if (!result) {\n            result = ((this.importAs.get(staticSymbol)));\n        }\n        return result;\n    };\n    /**\n     * getResourcePath produces the path to the original location of the symbol and should\n     * be used to determine the relative location of resource references recorded in\n     * symbol metadata.\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getResourcePath = function (staticSymbol) {\n        return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;\n    };\n    /**\n     * getTypeArity returns the number of generic type parameters the given symbol\n     * has. If the symbol is not a type the result is null.\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getTypeArity = function (staticSymbol) {\n        // If the file is a factory file, don't resolve the symbol as doing so would\n        // cause the metadata for an factory file to be loaded which doesn't exist.\n        // All references to generated classes must include the correct arity whenever\n        // generating code.\n        if (isNgFactoryFile(staticSymbol.filePath)) {\n            return null;\n        }\n        var /** @type {?} */ resolvedSymbol = this.resolveSymbol(staticSymbol);\n        while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n            resolvedSymbol = this.resolveSymbol(resolvedSymbol.metadata);\n        }\n        return (resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity) || null;\n    };\n    /**\n     * @param {?} sourceSymbol\n     * @param {?} targetSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.recordImportAs = function (sourceSymbol, targetSymbol) {\n        sourceSymbol.assertNoMembers();\n        targetSymbol.assertNoMembers();\n        this.importAs.set(sourceSymbol, targetSymbol);\n    };\n    /**\n     * Invalidate all information derived from the given file.\n     *\n     * @param {?} fileName the file to invalidate\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.invalidateFile = function (fileName) {\n        this.metadataCache.delete(fileName);\n        this.resolvedFilePaths.delete(fileName);\n        var /** @type {?} */ symbols = this.symbolFromFile.get(fileName);\n        if (symbols) {\n            this.symbolFromFile.delete(fileName);\n            for (var _i = 0, symbols_1 = symbols; _i < symbols_1.length; _i++) {\n                var symbol = symbols_1[_i];\n                this.resolvedSymbols.delete(symbol);\n                this.importAs.delete(symbol);\n                this.symbolResourcePaths.delete(symbol);\n            }\n        }\n    };\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype._resolveSymbolMembers = function (staticSymbol) {\n        var /** @type {?} */ members = staticSymbol.members;\n        var /** @type {?} */ baseResolvedSymbol = this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\n        if (!baseResolvedSymbol) {\n            return null;\n        }\n        var /** @type {?} */ baseMetadata = baseResolvedSymbol.metadata;\n        if (baseMetadata instanceof StaticSymbol) {\n            return new ResolvedStaticSymbol(staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\n        }\n        else if (baseMetadata && baseMetadata.__symbolic === 'class') {\n            if (baseMetadata.statics && members.length === 1) {\n                return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\n            }\n        }\n        else {\n            var /** @type {?} */ value = baseMetadata;\n            for (var /** @type {?} */ i = 0; i < members.length && value; i++) {\n                value = value[members[i]];\n            }\n            return new ResolvedStaticSymbol(staticSymbol, value);\n        }\n        return null;\n    };\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype._resolveSymbolFromSummary = function (staticSymbol) {\n        var /** @type {?} */ summary = this.summaryResolver.resolveSummary(staticSymbol);\n        return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\n    };\n    /**\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\n     *\n     * @param {?} declarationFile the absolute path of the file where the symbol is declared\n     * @param {?} name the name of the type.\n     * @param {?=} members a symbol for a static member of the named type\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getStaticSymbol = function (declarationFile, name, members) {\n        return this.staticSymbolCache.get(declarationFile, name, members);\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getSymbolsOf = function (filePath) {\n        // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n        // have summaries, only .d.ts files. So we always need to check both, the summary\n        // and metadata.\n        var /** @type {?} */ symbols = new Set(this.summaryResolver.getSymbolsOf(filePath));\n        this._createSymbolsOf(filePath);\n        this.resolvedSymbols.forEach(function (resolvedSymbol) {\n            if (resolvedSymbol.symbol.filePath === filePath) {\n                symbols.add(resolvedSymbol.symbol);\n            }\n        });\n        return Array.from(symbols);\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype._createSymbolsOf = function (filePath) {\n        var _this = this;\n        if (this.resolvedFilePaths.has(filePath)) {\n            return;\n        }\n        this.resolvedFilePaths.add(filePath);\n        var /** @type {?} */ resolvedSymbols = [];\n        var /** @type {?} */ metadata = this.getModuleMetadata(filePath);\n        if (metadata['metadata']) {\n            // handle direct declarations of the symbol\n            var /** @type {?} */ topLevelSymbolNames_1 = new Set(Object.keys(metadata['metadata']).map(unescapeIdentifier));\n            var /** @type {?} */ origins_1 = metadata['origins'] || {};\n            Object.keys(metadata['metadata']).forEach(function (metadataKey) {\n                var /** @type {?} */ symbolMeta = metadata['metadata'][metadataKey];\n                var /** @type {?} */ name = unescapeIdentifier(metadataKey);\n                var /** @type {?} */ symbol = _this.getStaticSymbol(filePath, name);\n                var /** @type {?} */ importSymbol = undefined;\n                if (metadata['importAs']) {\n                    // Index bundle indexes should use the importAs module name instead of a reference\n                    // to the .d.ts file directly.\n                    importSymbol = _this.getStaticSymbol(metadata['importAs'], name);\n                    _this.recordImportAs(symbol, importSymbol);\n                }\n                var /** @type {?} */ origin = origins_1.hasOwnProperty(metadataKey) && origins_1[metadataKey];\n                if (origin) {\n                    // If the symbol is from a bundled index, use the declaration location of the\n                    // symbol so relative references (such as './my.html') will be calculated\n                    // correctly.\n                    var /** @type {?} */ originFilePath = _this.resolveModule(origin, filePath);\n                    if (!originFilePath) {\n                        _this.reportError(new Error(\"Couldn't resolve original symbol for \" + origin + \" from \" + filePath));\n                    }\n                    else {\n                        _this.symbolResourcePaths.set(symbol, originFilePath);\n                    }\n                }\n                resolvedSymbols.push(_this.createResolvedSymbol(symbol, filePath, topLevelSymbolNames_1, symbolMeta));\n            });\n        }\n        // handle the symbols in one of the re-export location\n        if (metadata['exports']) {\n            var _loop_1 = function (moduleExport) {\n                // handle the symbols in the list of explicitly re-exported symbols.\n                if (moduleExport.export) {\n                    moduleExport.export.forEach(function (exportSymbol) {\n                        var /** @type {?} */ symbolName;\n                        if (typeof exportSymbol === 'string') {\n                            symbolName = exportSymbol;\n                        }\n                        else {\n                            symbolName = exportSymbol.as;\n                        }\n                        symbolName = unescapeIdentifier(symbolName);\n                        var /** @type {?} */ symName = symbolName;\n                        if (typeof exportSymbol !== 'string') {\n                            symName = unescapeIdentifier(exportSymbol.name);\n                        }\n                        var /** @type {?} */ resolvedModule = _this.resolveModule(moduleExport.from, filePath);\n                        if (resolvedModule) {\n                            var /** @type {?} */ targetSymbol = _this.getStaticSymbol(resolvedModule, symName);\n                            var /** @type {?} */ sourceSymbol = _this.getStaticSymbol(filePath, symbolName);\n                            resolvedSymbols.push(_this.createExport(sourceSymbol, targetSymbol));\n                        }\n                    });\n                }\n                else {\n                    // handle the symbols via export * directives.\n                    var /** @type {?} */ resolvedModule = this_1.resolveModule(moduleExport.from, filePath);\n                    if (resolvedModule) {\n                        var /** @type {?} */ nestedExports = this_1.getSymbolsOf(resolvedModule);\n                        nestedExports.forEach(function (targetSymbol) {\n                            var /** @type {?} */ sourceSymbol = _this.getStaticSymbol(filePath, targetSymbol.name);\n                            resolvedSymbols.push(_this.createExport(sourceSymbol, targetSymbol));\n                        });\n                    }\n                }\n            };\n            var this_1 = this;\n            for (var _i = 0, _a = metadata['exports']; _i < _a.length; _i++) {\n                var moduleExport = _a[_i];\n                _loop_1(/** @type {?} */ moduleExport);\n            }\n        }\n        resolvedSymbols.forEach(function (resolvedSymbol) { return _this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol); });\n        this.symbolFromFile.set(filePath, resolvedSymbols.map(function (resolvedSymbol) { return resolvedSymbol.symbol; }));\n    };\n    /**\n     * @param {?} sourceSymbol\n     * @param {?} topLevelPath\n     * @param {?} topLevelSymbolNames\n     * @param {?} metadata\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.createResolvedSymbol = function (sourceSymbol, topLevelPath, topLevelSymbolNames, metadata) {\n        // For classes that don't have Angular summaries / metadata,\n        // we only keep their arity, but nothing else\n        // (e.g. their constructor parameters).\n        // We do this to prevent introducing deep imports\n        // as we didn't generate .ngfactory.ts files with proper reexports.\n        if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && metadata &&\n            metadata['__symbolic'] === 'class') {\n            var /** @type {?} */ transformedMeta_1 = { __symbolic: 'class', arity: metadata.arity };\n            return new ResolvedStaticSymbol(sourceSymbol, transformedMeta_1);\n        }\n        var /** @type {?} */ self = this;\n        var ReferenceTransformer = (function (_super) {\n            __extends(ReferenceTransformer, _super);\n            function ReferenceTransformer() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            /**\n             * @param {?} map\n             * @param {?} functionParams\n             * @return {?}\n             */\n            ReferenceTransformer.prototype.visitStringMap = function (map, functionParams) {\n                var /** @type {?} */ symbolic = map['__symbolic'];\n                if (symbolic === 'function') {\n                    var /** @type {?} */ oldLen = functionParams.length;\n                    functionParams.push.apply(functionParams, (map['parameters'] || []));\n                    var /** @type {?} */ result = _super.prototype.visitStringMap.call(this, map, functionParams);\n                    functionParams.length = oldLen;\n                    return result;\n                }\n                else if (symbolic === 'reference') {\n                    var /** @type {?} */ module_1 = map['module'];\n                    var /** @type {?} */ name = map['name'] ? unescapeIdentifier(map['name']) : map['name'];\n                    if (!name) {\n                        return null;\n                    }\n                    var /** @type {?} */ filePath = void 0;\n                    if (module_1) {\n                        filePath = ((self.resolveModule(module_1, sourceSymbol.filePath)));\n                        if (!filePath) {\n                            return {\n                                __symbolic: 'error',\n                                message: \"Could not resolve \" + module_1 + \" relative to \" + sourceSymbol.filePath + \".\"\n                            };\n                        }\n                        return self.getStaticSymbol(filePath, name);\n                    }\n                    else if (functionParams.indexOf(name) >= 0) {\n                        // reference to a function parameter\n                        return { __symbolic: 'reference', name: name };\n                    }\n                    else {\n                        if (topLevelSymbolNames.has(name)) {\n                            return self.getStaticSymbol(topLevelPath, name);\n                        }\n                        // ambient value\n                        null;\n                    }\n                }\n                else {\n                    return _super.prototype.visitStringMap.call(this, map, functionParams);\n                }\n            };\n            return ReferenceTransformer;\n        }(ValueTransformer));\n        var /** @type {?} */ transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);\n        if (transformedMeta instanceof StaticSymbol) {\n            return this.createExport(sourceSymbol, transformedMeta);\n        }\n        return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n    };\n    /**\n     * @param {?} sourceSymbol\n     * @param {?} targetSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.createExport = function (sourceSymbol, targetSymbol) {\n        sourceSymbol.assertNoMembers();\n        targetSymbol.assertNoMembers();\n        if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath)) {\n            // This case is for an ng library importing symbols from a plain ts library\n            // transitively.\n            // Note: We rely on the fact that we discover symbols in the direction\n            // from source files to library files\n            this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);\n        }\n        return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);\n    };\n    /**\n     * @param {?} error\n     * @param {?=} context\n     * @param {?=} path\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.reportError = function (error, context, path) {\n        if (this.errorRecorder) {\n            this.errorRecorder(error, (context && context.filePath) || path);\n        }\n        else {\n            throw error;\n        }\n    };\n    /**\n     * @param {?} module an absolute path to a module file.\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getModuleMetadata = function (module) {\n        var /** @type {?} */ moduleMetadata = this.metadataCache.get(module);\n        if (!moduleMetadata) {\n            var /** @type {?} */ moduleMetadatas = this.host.getMetadataFor(module);\n            if (moduleMetadatas) {\n                var /** @type {?} */ maxVersion_1 = -1;\n                moduleMetadatas.forEach(function (md) {\n                    if (md['version'] > maxVersion_1) {\n                        maxVersion_1 = md['version'];\n                        moduleMetadata = md;\n                    }\n                });\n            }\n            if (!moduleMetadata) {\n                moduleMetadata =\n                    { __symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {} };\n            }\n            if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\n                var /** @type {?} */ errorMessage = moduleMetadata['version'] == 2 ?\n                    \"Unsupported metadata version \" + moduleMetadata['version'] + \" for module \" + module + \". This module should be compiled with a newer version of ngc\" :\n                    \"Metadata version mismatch for module \" + module + \", found version \" + moduleMetadata['version'] + \", expected \" + SUPPORTED_SCHEMA_VERSION;\n                this.reportError(new Error(errorMessage));\n            }\n            this.metadataCache.set(module, moduleMetadata);\n        }\n        return moduleMetadata;\n    };\n    /**\n     * @param {?} module\n     * @param {?} symbolName\n     * @param {?=} containingFile\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getSymbolByModule = function (module, symbolName, containingFile) {\n        var /** @type {?} */ filePath = this.resolveModule(module, containingFile);\n        if (!filePath) {\n            this.reportError(new Error(\"Could not resolve module \" + module + (containingFile ? \" relative to $ {\\n            containingFile\\n          } \" : '')));\n            return this.getStaticSymbol(\"ERROR:\" + module, symbolName);\n        }\n        return this.getStaticSymbol(filePath, symbolName);\n    };\n    /**\n     * @param {?} module\n     * @param {?=} containingFile\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.resolveModule = function (module, containingFile) {\n        try {\n            return this.host.moduleNameToFileName(module, containingFile);\n        }\n        catch (e) {\n            console.error(\"Could not resolve module '\" + module + \"' relative to file \" + containingFile);\n            this.reportError(e, undefined, containingFile);\n        }\n        return null;\n    };\n    return StaticSymbolResolver;\n}());\n/**\n * @param {?} identifier\n * @return {?}\n */\nfunction unescapeIdentifier(identifier) {\n    return identifier.startsWith('___') ? identifier.substr(1) : identifier;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar AotSummaryResolver = (function () {\n    /**\n     * @param {?} host\n     * @param {?} staticSymbolCache\n     */\n    function AotSummaryResolver(host, staticSymbolCache) {\n        this.host = host;\n        this.staticSymbolCache = staticSymbolCache;\n        this.summaryCache = new Map();\n        this.loadedFilePaths = new Set();\n        this.importAs = new Map();\n    }\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.isLibraryFile = function (filePath) {\n        // Note: We need to strip the .ngfactory. file path,\n        // so this method also works for generated files\n        // (for which host.isSourceFile will always return false).\n        return !this.host.isSourceFile(stripNgFactory(filePath));\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.getLibraryFileName = function (filePath) { return this.host.getOutputFileName(filePath); };\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.resolveSummary = function (staticSymbol) {\n        staticSymbol.assertNoMembers();\n        var /** @type {?} */ summary = this.summaryCache.get(staticSymbol);\n        if (!summary) {\n            this._loadSummaryFile(staticSymbol.filePath);\n            summary = ((this.summaryCache.get(staticSymbol)));\n        }\n        return summary;\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.getSymbolsOf = function (filePath) {\n        this._loadSummaryFile(filePath);\n        return Array.from(this.summaryCache.keys()).filter(function (symbol) { return symbol.filePath === filePath; });\n    };\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.getImportAs = function (staticSymbol) {\n        staticSymbol.assertNoMembers();\n        return ((this.importAs.get(staticSymbol)));\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    AotSummaryResolver.prototype._loadSummaryFile = function (filePath) {\n        var _this = this;\n        if (this.loadedFilePaths.has(filePath)) {\n            return;\n        }\n        this.loadedFilePaths.add(filePath);\n        if (this.isLibraryFile(filePath)) {\n            var /** @type {?} */ summaryFilePath = summaryFileName(filePath);\n            var /** @type {?} */ json = void 0;\n            try {\n                json = this.host.loadSummary(summaryFilePath);\n            }\n            catch (e) {\n                console.error(\"Error loading summary file \" + summaryFilePath);\n                throw e;\n            }\n            if (json) {\n                var _a = deserializeSummaries(this.staticSymbolCache, json), summaries = _a.summaries, importAs = _a.importAs;\n                summaries.forEach(function (summary) { return _this.summaryCache.set(summary.symbol, summary); });\n                importAs.forEach(function (importAs) {\n                    _this.importAs.set(importAs.symbol, _this.staticSymbolCache.get(ngfactoryFilePath(filePath), importAs.importAs));\n                });\n            }\n        }\n    };\n    return AotSummaryResolver;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Creates a new AotCompiler based on options and a host.\n * @param {?} compilerHost\n * @param {?} options\n * @return {?}\n */\nfunction createAotCompiler(compilerHost, options) {\n    var /** @type {?} */ translations = options.translations || '';\n    var /** @type {?} */ urlResolver = createOfflineCompileUrlResolver();\n    var /** @type {?} */ symbolCache = new StaticSymbolCache();\n    var /** @type {?} */ summaryResolver = new AotSummaryResolver(compilerHost, symbolCache);\n    var /** @type {?} */ symbolResolver = new StaticSymbolResolver(compilerHost, symbolCache, summaryResolver);\n    var /** @type {?} */ staticReflector = new StaticReflector(summaryResolver, symbolResolver);\n    StaticAndDynamicReflectionCapabilities.install(staticReflector);\n    var /** @type {?} */ console = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵConsole\"]();\n    var /** @type {?} */ htmlParser = new I18NHtmlParser(new HtmlParser(), translations, options.i18nFormat, __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"MissingTranslationStrategy\"].Warning, console);\n    var /** @type {?} */ config = new CompilerConfig({\n        defaultEncapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewEncapsulation\"].Emulated,\n        useJit: false,\n        enableLegacyTemplate: options.enableLegacyTemplate !== false,\n    });\n    var /** @type {?} */ normalizer = new DirectiveNormalizer({ get: function (url) { return compilerHost.loadResource(url); } }, urlResolver, htmlParser, config);\n    var /** @type {?} */ expressionParser = new Parser(new Lexer());\n    var /** @type {?} */ elementSchemaRegistry = new DomElementSchemaRegistry();\n    var /** @type {?} */ tmplParser = new TemplateParser(config, expressionParser, elementSchemaRegistry, htmlParser, console, []);\n    var /** @type {?} */ resolver = new CompileMetadataResolver(config, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, console, symbolCache, staticReflector);\n    // TODO(vicb): do not pass options.i18nFormat here\n    var /** @type {?} */ importResolver = {\n        getImportAs: function (symbol) { return ((symbolResolver.getImportAs(symbol))); },\n        fileNameToModuleName: function (fileName, containingFilePath) { return compilerHost.fileNameToModuleName(fileName, containingFilePath); },\n        getTypeArity: function (symbol) { return ((symbolResolver.getTypeArity(symbol))); }\n    };\n    var /** @type {?} */ viewCompiler = new ViewCompiler(config, elementSchemaRegistry);\n    var /** @type {?} */ compiler = new AotCompiler(config, compilerHost, resolver, tmplParser, new StyleCompiler(urlResolver), viewCompiler, new NgModuleCompiler(), new TypeScriptEmitter(importResolver), summaryResolver, options.locale || null, options.i18nFormat || null, options.genFilePreamble || null, symbolResolver);\n    return { compiler: compiler, reflector: staticReflector };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} statements\n * @param {?} resultVars\n * @return {?}\n */\nfunction interpretStatements(statements, resultVars) {\n    var /** @type {?} */ stmtsWithReturn = statements.concat([new ReturnStatement(literalArr(resultVars.map(function (resultVar) { return variable(resultVar); })))]);\n    var /** @type {?} */ ctx = new _ExecutionContext(null, null, null, new Map());\n    var /** @type {?} */ visitor = new StatementInterpreter();\n    var /** @type {?} */ result = visitor.visitAllStatements(stmtsWithReturn, ctx);\n    return result != null ? result.value : null;\n}\n/**\n * @param {?} varNames\n * @param {?} varValues\n * @param {?} statements\n * @param {?} ctx\n * @param {?} visitor\n * @return {?}\n */\nfunction _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {\n    var /** @type {?} */ childCtx = ctx.createChildWihtLocalVars();\n    for (var /** @type {?} */ i = 0; i < varNames.length; i++) {\n        childCtx.vars.set(varNames[i], varValues[i]);\n    }\n    var /** @type {?} */ result = visitor.visitAllStatements(statements, childCtx);\n    return result ? result.value : null;\n}\nvar _ExecutionContext = (function () {\n    /**\n     * @param {?} parent\n     * @param {?} instance\n     * @param {?} className\n     * @param {?} vars\n     */\n    function _ExecutionContext(parent, instance, className, vars) {\n        this.parent = parent;\n        this.instance = instance;\n        this.className = className;\n        this.vars = vars;\n    }\n    /**\n     * @return {?}\n     */\n    _ExecutionContext.prototype.createChildWihtLocalVars = function () {\n        return new _ExecutionContext(this, this.instance, this.className, new Map());\n    };\n    return _ExecutionContext;\n}());\nvar ReturnValue = (function () {\n    /**\n     * @param {?} value\n     */\n    function ReturnValue(value) {\n        this.value = value;\n    }\n    return ReturnValue;\n}());\n/**\n * @param {?} _classStmt\n * @param {?} _ctx\n * @param {?} _visitor\n * @return {?}\n */\nfunction createDynamicClass(_classStmt, _ctx, _visitor) {\n    var /** @type {?} */ propertyDescriptors = {};\n    _classStmt.getters.forEach(function (getter) {\n        // Note: use `function` instead of arrow function to capture `this`\n        propertyDescriptors[getter.name] = {\n            configurable: false,\n            get: function () {\n                var /** @type {?} */ instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n                return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);\n            }\n        };\n    });\n    _classStmt.methods.forEach(function (method) {\n        var /** @type {?} */ paramNames = method.params.map(function (param) { return param.name; });\n        // Note: use `function` instead of arrow function to capture `this`\n        propertyDescriptors[((method.name))] = {\n            writable: false,\n            configurable: false,\n            value: function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var /** @type {?} */ instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n                return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);\n            }\n        };\n    });\n    var /** @type {?} */ ctorParamNames = _classStmt.constructorMethod.params.map(function (param) { return param.name; });\n    // Note: use `function` instead of arrow function to capture `this`\n    var /** @type {?} */ ctor = function () {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var /** @type {?} */ instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n        _classStmt.fields.forEach(function (field) { _this[field.name] = undefined; });\n        _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);\n    };\n    var /** @type {?} */ superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;\n    ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);\n    return ctor;\n}\nvar StatementInterpreter = (function () {\n    function StatementInterpreter() {\n    }\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    StatementInterpreter.prototype.debugAst = function (ast) { return debugOutputAstAsTypeScript(ast); };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        ctx.vars.set(stmt.name, stmt.value.visitExpression(this, ctx));\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitWriteVarExpr = function (expr, ctx) {\n        var /** @type {?} */ value = expr.value.visitExpression(this, ctx);\n        var /** @type {?} */ currCtx = ctx;\n        while (currCtx != null) {\n            if (currCtx.vars.has(expr.name)) {\n                currCtx.vars.set(expr.name, value);\n                return value;\n            }\n            currCtx = ((currCtx.parent));\n        }\n        throw new Error(\"Not declared variable \" + expr.name);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitReadVarExpr = function (ast, ctx) {\n        var /** @type {?} */ varName = ((ast.name));\n        if (ast.builtin != null) {\n            switch (ast.builtin) {\n                case BuiltinVar.Super:\n                    return ctx.instance.__proto__;\n                case BuiltinVar.This:\n                    return ctx.instance;\n                case BuiltinVar.CatchError:\n                    varName = CATCH_ERROR_VAR$2;\n                    break;\n                case BuiltinVar.CatchStack:\n                    varName = CATCH_STACK_VAR$2;\n                    break;\n                default:\n                    throw new Error(\"Unknown builtin variable \" + ast.builtin);\n            }\n        }\n        var /** @type {?} */ currCtx = ctx;\n        while (currCtx != null) {\n            if (currCtx.vars.has(varName)) {\n                return currCtx.vars.get(varName);\n            }\n            currCtx = ((currCtx.parent));\n        }\n        throw new Error(\"Not declared variable \" + varName);\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitWriteKeyExpr = function (expr, ctx) {\n        var /** @type {?} */ receiver = expr.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ index = expr.index.visitExpression(this, ctx);\n        var /** @type {?} */ value = expr.value.visitExpression(this, ctx);\n        receiver[index] = value;\n        return value;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitWritePropExpr = function (expr, ctx) {\n        var /** @type {?} */ receiver = expr.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ value = expr.value.visitExpression(this, ctx);\n        receiver[expr.name] = value;\n        return value;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitInvokeMethodExpr = function (expr, ctx) {\n        var /** @type {?} */ receiver = expr.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ args = this.visitAllExpressions(expr.args, ctx);\n        var /** @type {?} */ result;\n        if (expr.builtin != null) {\n            switch (expr.builtin) {\n                case BuiltinMethod.ConcatArray:\n                    result = receiver.concat.apply(receiver, args);\n                    break;\n                case BuiltinMethod.SubscribeObservable:\n                    result = receiver.subscribe({ next: args[0] });\n                    break;\n                case BuiltinMethod.Bind:\n                    result = receiver.bind.apply(receiver, args);\n                    break;\n                default:\n                    throw new Error(\"Unknown builtin method \" + expr.builtin);\n            }\n        }\n        else {\n            result = receiver[((expr.name))].apply(receiver, args);\n        }\n        return result;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitInvokeFunctionExpr = function (stmt, ctx) {\n        var /** @type {?} */ args = this.visitAllExpressions(stmt.args, ctx);\n        var /** @type {?} */ fnExpr = stmt.fn;\n        if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\n            ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);\n            return null;\n        }\n        else {\n            var /** @type {?} */ fn$$1 = stmt.fn.visitExpression(this, ctx);\n            return fn$$1.apply(null, args);\n        }\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitReturnStmt = function (stmt, ctx) {\n        return new ReturnValue(stmt.value.visitExpression(this, ctx));\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        var /** @type {?} */ clazz = createDynamicClass(stmt, ctx, this);\n        ctx.vars.set(stmt.name, clazz);\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitExpressionStmt = function (stmt, ctx) {\n        return stmt.expr.visitExpression(this, ctx);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitIfStmt = function (stmt, ctx) {\n        var /** @type {?} */ condition = stmt.condition.visitExpression(this, ctx);\n        if (condition) {\n            return this.visitAllStatements(stmt.trueCase, ctx);\n        }\n        else if (stmt.falseCase != null) {\n            return this.visitAllStatements(stmt.falseCase, ctx);\n        }\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitTryCatchStmt = function (stmt, ctx) {\n        try {\n            return this.visitAllStatements(stmt.bodyStmts, ctx);\n        }\n        catch (e) {\n            var /** @type {?} */ childCtx = ctx.createChildWihtLocalVars();\n            childCtx.vars.set(CATCH_ERROR_VAR$2, e);\n            childCtx.vars.set(CATCH_STACK_VAR$2, e.stack);\n            return this.visitAllStatements(stmt.catchStmts, childCtx);\n        }\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitThrowStmt = function (stmt, ctx) {\n        throw stmt.error.visitExpression(this, ctx);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?=} context\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitCommentStmt = function (stmt, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitInstantiateExpr = function (ast, ctx) {\n        var /** @type {?} */ args = this.visitAllExpressions(ast.args, ctx);\n        var /** @type {?} */ clazz = ast.classExpr.visitExpression(this, ctx);\n        return new (clazz.bind.apply(clazz, [void 0].concat(args)))();\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitLiteralExpr = function (ast, ctx) { return ast.value; };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitExternalExpr = function (ast, ctx) {\n        return ast.value.reference;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitConditionalExpr = function (ast, ctx) {\n        if (ast.condition.visitExpression(this, ctx)) {\n            return ast.trueCase.visitExpression(this, ctx);\n        }\n        else if (ast.falseCase != null) {\n            return ast.falseCase.visitExpression(this, ctx);\n        }\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitNotExpr = function (ast, ctx) {\n        return !ast.condition.visitExpression(this, ctx);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitCastExpr = function (ast, ctx) {\n        return ast.value.visitExpression(this, ctx);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitFunctionExpr = function (ast, ctx) {\n        var /** @type {?} */ paramNames = ast.params.map(function (param) { return param.name; });\n        return _declareFn(paramNames, ast.statements, ctx, this);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        var /** @type {?} */ paramNames = stmt.params.map(function (param) { return param.name; });\n        ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitBinaryOperatorExpr = function (ast, ctx) {\n        var _this = this;\n        var /** @type {?} */ lhs = function () { return ast.lhs.visitExpression(_this, ctx); };\n        var /** @type {?} */ rhs = function () { return ast.rhs.visitExpression(_this, ctx); };\n        switch (ast.operator) {\n            case BinaryOperator.Equals:\n                return lhs() == rhs();\n            case BinaryOperator.Identical:\n                return lhs() === rhs();\n            case BinaryOperator.NotEquals:\n                return lhs() != rhs();\n            case BinaryOperator.NotIdentical:\n                return lhs() !== rhs();\n            case BinaryOperator.And:\n                return lhs() && rhs();\n            case BinaryOperator.Or:\n                return lhs() || rhs();\n            case BinaryOperator.Plus:\n                return lhs() + rhs();\n            case BinaryOperator.Minus:\n                return lhs() - rhs();\n            case BinaryOperator.Divide:\n                return lhs() / rhs();\n            case BinaryOperator.Multiply:\n                return lhs() * rhs();\n            case BinaryOperator.Modulo:\n                return lhs() % rhs();\n            case BinaryOperator.Lower:\n                return lhs() < rhs();\n            case BinaryOperator.LowerEquals:\n                return lhs() <= rhs();\n            case BinaryOperator.Bigger:\n                return lhs() > rhs();\n            case BinaryOperator.BiggerEquals:\n                return lhs() >= rhs();\n            default:\n                throw new Error(\"Unknown operator \" + ast.operator);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitReadPropExpr = function (ast, ctx) {\n        var /** @type {?} */ result;\n        var /** @type {?} */ receiver = ast.receiver.visitExpression(this, ctx);\n        result = receiver[ast.name];\n        return result;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitReadKeyExpr = function (ast, ctx) {\n        var /** @type {?} */ receiver = ast.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ prop = ast.index.visitExpression(this, ctx);\n        return receiver[prop];\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n        return this.visitAllExpressions(ast.entries, ctx);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitLiteralMapExpr = function (ast, ctx) {\n        var _this = this;\n        var /** @type {?} */ result = {};\n        ast.entries.forEach(function (entry) { return ((result))[entry.key] = entry.value.visitExpression(_this, ctx); });\n        return result;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitCommaExpr = function (ast, context) {\n        var /** @type {?} */ values = this.visitAllExpressions(ast.parts, context);\n        return values[values.length - 1];\n    };\n    /**\n     * @param {?} expressions\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitAllExpressions = function (expressions, ctx) {\n        var _this = this;\n        return expressions.map(function (expr) { return expr.visitExpression(_this, ctx); });\n    };\n    /**\n     * @param {?} statements\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitAllStatements = function (statements, ctx) {\n        for (var /** @type {?} */ i = 0; i < statements.length; i++) {\n            var /** @type {?} */ stmt = statements[i];\n            var /** @type {?} */ val = stmt.visitStatement(this, ctx);\n            if (val instanceof ReturnValue) {\n                return val;\n            }\n        }\n        return null;\n    };\n    return StatementInterpreter;\n}());\n/**\n * @param {?} varNames\n * @param {?} statements\n * @param {?} ctx\n * @param {?} visitor\n * @return {?}\n */\nfunction _declareFn(varNames, statements, ctx, visitor) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return _executeFunctionStatements(varNames, args, statements, ctx, visitor);\n    };\n}\nvar CATCH_ERROR_VAR$2 = 'error';\nvar CATCH_STACK_VAR$2 = 'stack';\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @abstract\n */\nvar AbstractJsEmitterVisitor = (function (_super) {\n    __extends(AbstractJsEmitterVisitor, _super);\n    function AbstractJsEmitterVisitor() {\n        return _super.call(this, false) || this;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        var _this = this;\n        ctx.pushClass(stmt);\n        this._visitClassConstructor(stmt, ctx);\n        if (stmt.parent != null) {\n            ctx.print(stmt, stmt.name + \".prototype = Object.create(\");\n            stmt.parent.visitExpression(this, ctx);\n            ctx.println(stmt, \".prototype);\");\n        }\n        stmt.getters.forEach(function (getter) { return _this._visitClassGetter(stmt, getter, ctx); });\n        stmt.methods.forEach(function (method) { return _this._visitClassMethod(stmt, method, ctx); });\n        ctx.popClass();\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {\n        ctx.print(stmt, \"function \" + stmt.name + \"(\");\n        if (stmt.constructorMethod != null) {\n            this._visitParams(stmt.constructorMethod.params, ctx);\n        }\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        if (stmt.constructorMethod != null) {\n            if (stmt.constructorMethod.body.length > 0) {\n                ctx.println(stmt, \"var self = this;\");\n                this.visitAllStatements(stmt.constructorMethod.body, ctx);\n            }\n        }\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} getter\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype._visitClassGetter = function (stmt, getter, ctx) {\n        ctx.println(stmt, \"Object.defineProperty(\" + stmt.name + \".prototype, '\" + getter.name + \"', { get: function() {\");\n        ctx.incIndent();\n        if (getter.body.length > 0) {\n            ctx.println(stmt, \"var self = this;\");\n            this.visitAllStatements(getter.body, ctx);\n        }\n        ctx.decIndent();\n        ctx.println(stmt, \"}});\");\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} method\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype._visitClassMethod = function (stmt, method, ctx) {\n        ctx.print(stmt, stmt.name + \".prototype.\" + method.name + \" = function(\");\n        this._visitParams(method.params, ctx);\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        if (method.body.length > 0) {\n            ctx.println(stmt, \"var self = this;\");\n            this.visitAllStatements(method.body, ctx);\n        }\n        ctx.decIndent();\n        ctx.println(stmt, \"};\");\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {\n        if (ast.builtin === BuiltinVar.This) {\n            ctx.print(ast, 'self');\n        }\n        else if (ast.builtin === BuiltinVar.Super) {\n            throw new Error(\"'super' needs to be handled at a parent ast node, not at the variable level!\");\n        }\n        else {\n            _super.prototype.visitReadVarExpr.call(this, ast, ctx);\n        }\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"var \" + stmt.name + \" = \");\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, \";\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {\n        ast.value.visitExpression(this, ctx);\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {\n        var /** @type {?} */ fnExpr = expr.fn;\n        if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\n            ((((ctx.currentClass)).parent)).visitExpression(this, ctx);\n            ctx.print(expr, \".call(this\");\n            if (expr.args.length > 0) {\n                ctx.print(expr, \", \");\n                this.visitAllExpressions(expr.args, ctx, ',');\n            }\n            ctx.print(expr, \")\");\n        }\n        else {\n            _super.prototype.visitInvokeFunctionExpr.call(this, expr, ctx);\n        }\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {\n        ctx.print(ast, \"function(\");\n        this._visitParams(ast.params, ctx);\n        ctx.println(ast, \") {\");\n        ctx.incIndent();\n        this.visitAllStatements(ast.statements, ctx);\n        ctx.decIndent();\n        ctx.print(ast, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"function \" + stmt.name + \"(\");\n        this._visitParams(stmt.params, ctx);\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.statements, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {\n        ctx.println(stmt, \"try {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.bodyStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"} catch (\" + CATCH_ERROR_VAR$1.name + \") {\");\n        ctx.incIndent();\n        var /** @type {?} */ catchStmts = [/** @type {?} */ (CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [\n                StmtModifier.Final\n            ]))].concat(stmt.catchStmts);\n        this.visitAllStatements(catchStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} params\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype._visitParams = function (params, ctx) {\n        this.visitAllObjects(function (param) { return ctx.print(null, param.name); }, params, ctx, ',');\n    };\n    /**\n     * @param {?} method\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {\n        var /** @type {?} */ name;\n        switch (method) {\n            case BuiltinMethod.ConcatArray:\n                name = 'concat';\n                break;\n            case BuiltinMethod.SubscribeObservable:\n                name = 'subscribe';\n                break;\n            case BuiltinMethod.Bind:\n                name = 'bind';\n                break;\n            default:\n                throw new Error(\"Unknown builtin method: \" + method);\n        }\n        return name;\n    };\n    return AbstractJsEmitterVisitor;\n}(AbstractEmitterVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} sourceUrl\n * @param {?} ctx\n * @param {?} vars\n * @return {?}\n */\nfunction evalExpression(sourceUrl$$1, ctx, vars) {\n    var /** @type {?} */ fnBody = ctx.toSource() + \"\\n//# sourceURL=\" + sourceUrl$$1;\n    var /** @type {?} */ fnArgNames = [];\n    var /** @type {?} */ fnArgValues = [];\n    for (var /** @type {?} */ argName in vars) {\n        fnArgNames.push(argName);\n        fnArgValues.push(vars[argName]);\n    }\n    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"isDevMode\"])()) {\n        // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n        // E.g. ```\n        // function anonymous(a,b,c\n        // /**/) { ... }```\n        // We don't want to hard code this fact, so we auto detect it via an empty function first.\n        var /** @type {?} */ emptyFn = new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat('return null;'))))().toString();\n        var /** @type {?} */ headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n        fnBody += \"\\n\" + ctx.toSourceMapGenerator(sourceUrl$$1, sourceUrl$$1, headerLines).toJsComment();\n    }\n    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);\n}\n/**\n * @param {?} sourceUrl\n * @param {?} statements\n * @param {?} resultVars\n * @return {?}\n */\nfunction jitStatements(sourceUrl$$1, statements, resultVars) {\n    var /** @type {?} */ converter = new JitEmitterVisitor();\n    var /** @type {?} */ ctx = EmitterVisitorContext.createRoot(resultVars);\n    var /** @type {?} */ returnStmt = new ReturnStatement(literalArr(resultVars.map(function (resultVar) { return variable(resultVar); })));\n    converter.visitAllStatements(statements.concat([returnStmt]), ctx);\n    return evalExpression(sourceUrl$$1, ctx, converter.getArgs());\n}\nvar JitEmitterVisitor = (function (_super) {\n    __extends(JitEmitterVisitor, _super);\n    function JitEmitterVisitor() {\n        var _this = _super.apply(this, arguments) || this;\n        _this._evalArgNames = [];\n        _this._evalArgValues = [];\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    JitEmitterVisitor.prototype.getArgs = function () {\n        var /** @type {?} */ result = {};\n        for (var /** @type {?} */ i = 0; i < this._evalArgNames.length; i++) {\n            result[this._evalArgNames[i]] = this._evalArgValues[i];\n        }\n        return result;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    JitEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {\n        var /** @type {?} */ value = ast.value.reference;\n        var /** @type {?} */ id = this._evalArgValues.indexOf(value);\n        if (id === -1) {\n            id = this._evalArgValues.length;\n            this._evalArgValues.push(value);\n            var /** @type {?} */ name = identifierName(ast.value) || 'val';\n            this._evalArgNames.push(\"jit_\" + name + id);\n        }\n        ctx.print(ast, this._evalArgNames[id]);\n        return null;\n    };\n    return JitEmitterVisitor;\n}(AbstractJsEmitterVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An internal module of the Angular compiler that begins with component types,\n * extracts templates, and eventually produces a compiled version of the component\n * ready for linking into an application.\n *\n * \\@security When compiling templates at runtime, you must ensure that the entire template comes\n * from a trusted source. Attacker-controlled data introduced by a template could expose your\n * application to XSS risks.  For more detail, see the [Security Guide](http://g.co/ng/security).\n */\nvar JitCompiler = (function () {\n    /**\n     * @param {?} _injector\n     * @param {?} _metadataResolver\n     * @param {?} _templateParser\n     * @param {?} _styleCompiler\n     * @param {?} _viewCompiler\n     * @param {?} _ngModuleCompiler\n     * @param {?} _compilerConfig\n     * @param {?} _console\n     */\n    function JitCompiler(_injector, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _compilerConfig, _console) {\n        this._injector = _injector;\n        this._metadataResolver = _metadataResolver;\n        this._templateParser = _templateParser;\n        this._styleCompiler = _styleCompiler;\n        this._viewCompiler = _viewCompiler;\n        this._ngModuleCompiler = _ngModuleCompiler;\n        this._compilerConfig = _compilerConfig;\n        this._console = _console;\n        this._compiledTemplateCache = new Map();\n        this._compiledHostTemplateCache = new Map();\n        this._compiledDirectiveWrapperCache = new Map();\n        this._compiledNgModuleCache = new Map();\n        this._sharedStylesheetCount = 0;\n    }\n    Object.defineProperty(JitCompiler.prototype, \"injector\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this._injector; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype.compileModuleSync = function (moduleType) {\n        return ((this._compileModuleAndComponents(moduleType, true).syncResult));\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype.compileModuleAsync = function (moduleType) {\n        return ((this._compileModuleAndComponents(moduleType, false).asyncResult));\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {\n        return ((this._compileModuleAndAllComponents(moduleType, true).syncResult));\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {\n        return ((this._compileModuleAndAllComponents(moduleType, false).asyncResult));\n    };\n    /**\n     * @param {?} component\n     * @return {?}\n     */\n    JitCompiler.prototype.getNgContentSelectors = function (component) {\n        this._console.warn('Compiler.getNgContentSelectors is deprecated. Use ComponentFactory.ngContentSelectors instead!');\n        var /** @type {?} */ template = this._compiledTemplateCache.get(component);\n        if (!template) {\n            throw new Error(\"The component \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵstringify\"])(component) + \" is not yet compiled!\");\n        }\n        return ((template.compMeta.template)).ngContentSelectors;\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @param {?} isSync\n     * @return {?}\n     */\n    JitCompiler.prototype._compileModuleAndComponents = function (moduleType, isSync) {\n        var _this = this;\n        var /** @type {?} */ loadingPromise = this._loadModules(moduleType, isSync);\n        var /** @type {?} */ createResult = function () {\n            _this._compileComponents(moduleType, null);\n            return _this._compileModule(moduleType);\n        };\n        if (isSync) {\n            return new SyncAsyncResult(createResult());\n        }\n        else {\n            return new SyncAsyncResult(null, loadingPromise.then(createResult));\n        }\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @param {?} isSync\n     * @return {?}\n     */\n    JitCompiler.prototype._compileModuleAndAllComponents = function (moduleType, isSync) {\n        var _this = this;\n        var /** @type {?} */ loadingPromise = this._loadModules(moduleType, isSync);\n        var /** @type {?} */ createResult = function () {\n            var /** @type {?} */ componentFactories = [];\n            _this._compileComponents(moduleType, componentFactories);\n            return new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ModuleWithComponentFactories\"](_this._compileModule(moduleType), componentFactories);\n        };\n        if (isSync) {\n            return new SyncAsyncResult(createResult());\n        }\n        else {\n            return new SyncAsyncResult(null, loadingPromise.then(createResult));\n        }\n    };\n    /**\n     * @param {?} mainModule\n     * @param {?} isSync\n     * @return {?}\n     */\n    JitCompiler.prototype._loadModules = function (mainModule, isSync) {\n        var _this = this;\n        var /** @type {?} */ loadingPromises = [];\n        var /** @type {?} */ ngModule = ((this._metadataResolver.getNgModuleMetadata(mainModule)));\n        // Note: the loadingPromise for a module only includes the loading of the exported directives\n        // of imported modules.\n        // However, for runtime compilation, we want to transitively compile all modules,\n        // so we also need to call loadNgModuleDirectiveAndPipeMetadata for all nested modules.\n        ngModule.transitiveModule.modules.forEach(function (localModuleMeta) {\n            loadingPromises.push(_this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(localModuleMeta.reference, isSync));\n        });\n        return Promise.all(loadingPromises);\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype._compileModule = function (moduleType) {\n        var _this = this;\n        var /** @type {?} */ ngModuleFactory = ((this._compiledNgModuleCache.get(moduleType)));\n        if (!ngModuleFactory) {\n            var /** @type {?} */ moduleMeta_1 = ((this._metadataResolver.getNgModuleMetadata(moduleType)));\n            // Always provide a bound Compiler\n            var /** @type {?} */ extraProviders = [this._metadataResolver.getProviderMetadata(new ProviderMeta(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Compiler\"], { useFactory: function () { return new ModuleBoundCompiler(_this, moduleMeta_1.type.reference); } }))];\n            var /** @type {?} */ compileResult = this._ngModuleCompiler.compile(moduleMeta_1, extraProviders);\n            if (!this._compilerConfig.useJit) {\n                ngModuleFactory =\n                    interpretStatements(compileResult.statements, [compileResult.ngModuleFactoryVar])[0];\n            }\n            else {\n                ngModuleFactory = jitStatements(ngModuleJitUrl(moduleMeta_1), compileResult.statements, [compileResult.ngModuleFactoryVar])[0];\n            }\n            this._compiledNgModuleCache.set(moduleMeta_1.type.reference, ngModuleFactory);\n        }\n        return ngModuleFactory;\n    };\n    /**\n     * \\@internal\n     * @param {?} mainModule\n     * @param {?} allComponentFactories\n     * @return {?}\n     */\n    JitCompiler.prototype._compileComponents = function (mainModule, allComponentFactories) {\n        var _this = this;\n        var /** @type {?} */ ngModule = ((this._metadataResolver.getNgModuleMetadata(mainModule)));\n        var /** @type {?} */ moduleByDirective = new Map();\n        var /** @type {?} */ templates = new Set();\n        ngModule.transitiveModule.modules.forEach(function (localModuleSummary) {\n            var /** @type {?} */ localModuleMeta = ((_this._metadataResolver.getNgModuleMetadata(localModuleSummary.reference)));\n            localModuleMeta.declaredDirectives.forEach(function (dirIdentifier) {\n                moduleByDirective.set(dirIdentifier.reference, localModuleMeta);\n                var /** @type {?} */ dirMeta = _this._metadataResolver.getDirectiveMetadata(dirIdentifier.reference);\n                if (dirMeta.isComponent) {\n                    templates.add(_this._createCompiledTemplate(dirMeta, localModuleMeta));\n                    if (allComponentFactories) {\n                        var /** @type {?} */ template = _this._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);\n                        templates.add(template);\n                        allComponentFactories.push(/** @type {?} */ (dirMeta.componentFactory));\n                    }\n                }\n            });\n        });\n        ngModule.transitiveModule.modules.forEach(function (localModuleSummary) {\n            var /** @type {?} */ localModuleMeta = ((_this._metadataResolver.getNgModuleMetadata(localModuleSummary.reference)));\n            localModuleMeta.declaredDirectives.forEach(function (dirIdentifier) {\n                var /** @type {?} */ dirMeta = _this._metadataResolver.getDirectiveMetadata(dirIdentifier.reference);\n                if (dirMeta.isComponent) {\n                    dirMeta.entryComponents.forEach(function (entryComponentType) {\n                        var /** @type {?} */ moduleMeta = ((moduleByDirective.get(entryComponentType.componentType)));\n                        templates.add(_this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n                    });\n                }\n            });\n            localModuleMeta.entryComponents.forEach(function (entryComponentType) {\n                var /** @type {?} */ moduleMeta = ((moduleByDirective.get(entryComponentType.componentType)));\n                templates.add(_this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n            });\n        });\n        templates.forEach(function (template) { return _this._compileTemplate(template); });\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    JitCompiler.prototype.clearCacheFor = function (type) {\n        this._compiledNgModuleCache.delete(type);\n        this._metadataResolver.clearCacheFor(type);\n        this._compiledHostTemplateCache.delete(type);\n        var /** @type {?} */ compiledTemplate = this._compiledTemplateCache.get(type);\n        if (compiledTemplate) {\n            this._compiledTemplateCache.delete(type);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    JitCompiler.prototype.clearCache = function () {\n        this._metadataResolver.clearCache();\n        this._compiledTemplateCache.clear();\n        this._compiledHostTemplateCache.clear();\n        this._compiledNgModuleCache.clear();\n    };\n    /**\n     * @param {?} compType\n     * @param {?} ngModule\n     * @return {?}\n     */\n    JitCompiler.prototype._createCompiledHostTemplate = function (compType, ngModule) {\n        if (!ngModule) {\n            throw new Error(\"Component \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵstringify\"])(compType) + \" is not part of any NgModule or the module has not been imported into your module.\");\n        }\n        var /** @type {?} */ compiledTemplate = this._compiledHostTemplateCache.get(compType);\n        if (!compiledTemplate) {\n            var /** @type {?} */ compMeta = this._metadataResolver.getDirectiveMetadata(compType);\n            assertComponent(compMeta);\n            var /** @type {?} */ componentFactory = (compMeta.componentFactory);\n            var /** @type {?} */ hostClass = this._metadataResolver.getHostComponentType(compType);\n            var /** @type {?} */ hostMeta = createHostComponentMeta(hostClass, compMeta, /** @type {?} */ (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵgetComponentViewDefinitionFactory\"])(componentFactory)));\n            compiledTemplate =\n                new CompiledTemplate(true, compMeta.type, hostMeta, ngModule, [compMeta.type]);\n            this._compiledHostTemplateCache.set(compType, compiledTemplate);\n        }\n        return compiledTemplate;\n    };\n    /**\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @return {?}\n     */\n    JitCompiler.prototype._createCompiledTemplate = function (compMeta, ngModule) {\n        var /** @type {?} */ compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);\n        if (!compiledTemplate) {\n            assertComponent(compMeta);\n            compiledTemplate = new CompiledTemplate(false, compMeta.type, compMeta, ngModule, ngModule.transitiveModule.directives);\n            this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);\n        }\n        return compiledTemplate;\n    };\n    /**\n     * @param {?} template\n     * @return {?}\n     */\n    JitCompiler.prototype._compileTemplate = function (template) {\n        var _this = this;\n        if (template.isCompiled) {\n            return;\n        }\n        var /** @type {?} */ compMeta = template.compMeta;\n        var /** @type {?} */ externalStylesheetsByModuleUrl = new Map();\n        var /** @type {?} */ stylesCompileResult = this._styleCompiler.compileComponent(compMeta);\n        stylesCompileResult.externalStylesheets.forEach(function (r) { externalStylesheetsByModuleUrl.set(/** @type {?} */ ((r.meta.moduleUrl)), r); });\n        this._resolveStylesCompileResult(stylesCompileResult.componentStylesheet, externalStylesheetsByModuleUrl);\n        var /** @type {?} */ directives = template.directives.map(function (dir) { return _this._metadataResolver.getDirectiveSummary(dir.reference); });\n        var /** @type {?} */ pipes = template.ngModule.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });\n        var _a = this._templateParser.parse(compMeta, /** @type {?} */ ((((compMeta.template)).template)), directives, pipes, template.ngModule.schemas, templateSourceUrl(template.ngModule.type, template.compMeta, /** @type {?} */ ((template.compMeta.template)))), parsedTemplate = _a.template, usedPipes = _a.pipes;\n        var /** @type {?} */ compileResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, variable(stylesCompileResult.componentStylesheet.stylesVar), usedPipes);\n        var /** @type {?} */ statements = stylesCompileResult.componentStylesheet.statements.concat(compileResult.statements);\n        var /** @type {?} */ viewClassAndRendererTypeVars = compMeta.isHost ?\n            [compileResult.viewClassVar] :\n            [compileResult.viewClassVar, compileResult.rendererTypeVar];\n        var /** @type {?} */ viewClass;\n        var /** @type {?} */ rendererType;\n        if (!this._compilerConfig.useJit) {\n            _b = interpretStatements(statements, viewClassAndRendererTypeVars), viewClass = _b[0], rendererType = _b[1];\n        }\n        else {\n            _c = jitStatements(templateJitUrl(template.ngModule.type, template.compMeta), statements, viewClassAndRendererTypeVars), viewClass = _c[0], rendererType = _c[1];\n        }\n        template.compiled(viewClass, rendererType);\n        var _b, _c;\n    };\n    /**\n     * @param {?} result\n     * @param {?} externalStylesheetsByModuleUrl\n     * @return {?}\n     */\n    JitCompiler.prototype._resolveStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {\n        var _this = this;\n        result.dependencies.forEach(function (dep, i) {\n            var /** @type {?} */ nestedCompileResult = ((externalStylesheetsByModuleUrl.get(dep.moduleUrl)));\n            var /** @type {?} */ nestedStylesArr = _this._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);\n            dep.valuePlaceholder.reference = nestedStylesArr;\n        });\n    };\n    /**\n     * @param {?} result\n     * @param {?} externalStylesheetsByModuleUrl\n     * @return {?}\n     */\n    JitCompiler.prototype._resolveAndEvalStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {\n        this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);\n        if (!this._compilerConfig.useJit) {\n            return interpretStatements(result.statements, [result.stylesVar])[0];\n        }\n        else {\n            return jitStatements(sharedStylesheetJitUrl(result.meta, this._sharedStylesheetCount++), result.statements, [result.stylesVar])[0];\n        }\n    };\n    return JitCompiler;\n}());\nJitCompiler.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nJitCompiler.ctorParameters = function () { return [\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Injector\"], },\n    { type: CompileMetadataResolver, },\n    { type: TemplateParser, },\n    { type: StyleCompiler, },\n    { type: ViewCompiler, },\n    { type: NgModuleCompiler, },\n    { type: CompilerConfig, },\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵConsole\"], },\n]; };\nvar CompiledTemplate = (function () {\n    /**\n     * @param {?} isHost\n     * @param {?} compType\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @param {?} directives\n     */\n    function CompiledTemplate(isHost, compType, compMeta, ngModule, directives) {\n        this.isHost = isHost;\n        this.compType = compType;\n        this.compMeta = compMeta;\n        this.ngModule = ngModule;\n        this.directives = directives;\n        this._viewClass = ((null));\n        this.isCompiled = false;\n    }\n    /**\n     * @param {?} viewClass\n     * @param {?} rendererType\n     * @return {?}\n     */\n    CompiledTemplate.prototype.compiled = function (viewClass, rendererType) {\n        this._viewClass = viewClass;\n        ((this.compMeta.componentViewType)).setDelegate(viewClass);\n        for (var /** @type {?} */ prop in rendererType) {\n            ((this.compMeta.rendererType))[prop] = rendererType[prop];\n        }\n        this.isCompiled = true;\n    };\n    return CompiledTemplate;\n}());\n/**\n * @param {?} meta\n * @return {?}\n */\nfunction assertComponent(meta) {\n    if (!meta.isComponent) {\n        throw new Error(\"Could not compile '\" + identifierName(meta.type) + \"' because it is not a component.\");\n    }\n}\n/**\n * Implements `Compiler` by delegating to the JitCompiler using a known module.\n */\nvar ModuleBoundCompiler = (function () {\n    /**\n     * @param {?} _delegate\n     * @param {?} _ngModule\n     */\n    function ModuleBoundCompiler(_delegate, _ngModule) {\n        this._delegate = _delegate;\n        this._ngModule = _ngModule;\n    }\n    Object.defineProperty(ModuleBoundCompiler.prototype, \"_injector\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this._delegate.injector; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.compileModuleSync = function (moduleType) {\n        return this._delegate.compileModuleSync(moduleType);\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.compileModuleAsync = function (moduleType) {\n        return this._delegate.compileModuleAsync(moduleType);\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {\n        return this._delegate.compileModuleAndAllComponentsSync(moduleType);\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {\n        return this._delegate.compileModuleAndAllComponentsAsync(moduleType);\n    };\n    /**\n     * @param {?} component\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.getNgContentSelectors = function (component) {\n        return this._delegate.getNgContentSelectors(component);\n    };\n    /**\n     * Clears all caches\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.clearCache = function () { this._delegate.clearCache(); };\n    /**\n     * Clears the cache for the given component/ngModule.\n     * @param {?} type\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.clearCacheFor = function (type) { this._delegate.clearCacheFor(type); };\n    return ModuleBoundCompiler;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A container for message extracted from the templates.\n */\nvar MessageBundle = (function () {\n    /**\n     * @param {?} _htmlParser\n     * @param {?} _implicitTags\n     * @param {?} _implicitAttrs\n     * @param {?=} _locale\n     */\n    function MessageBundle(_htmlParser, _implicitTags, _implicitAttrs, _locale) {\n        if (_locale === void 0) { _locale = null; }\n        this._htmlParser = _htmlParser;\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n        this._locale = _locale;\n        this._messages = [];\n    }\n    /**\n     * @param {?} html\n     * @param {?} url\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    MessageBundle.prototype.updateFromTemplate = function (html, url, interpolationConfig) {\n        var /** @type {?} */ htmlParserResult = this._htmlParser.parse(html, url, true, interpolationConfig);\n        if (htmlParserResult.errors.length) {\n            return htmlParserResult.errors;\n        }\n        var /** @type {?} */ i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);\n        if (i18nParserResult.errors.length) {\n            return i18nParserResult.errors;\n        }\n        (_a = this._messages).push.apply(_a, i18nParserResult.messages);\n        return null;\n        var _a;\n    };\n    /**\n     * @return {?}\n     */\n    MessageBundle.prototype.getMessages = function () { return this._messages; };\n    /**\n     * @param {?} serializer\n     * @param {?=} filterSources\n     * @return {?}\n     */\n    MessageBundle.prototype.write = function (serializer, filterSources) {\n        var /** @type {?} */ messages = {};\n        var /** @type {?} */ mapperVisitor = new MapPlaceholderNames();\n        // Deduplicate messages based on their ID\n        this._messages.forEach(function (message) {\n            var /** @type {?} */ id = serializer.digest(message);\n            if (!messages.hasOwnProperty(id)) {\n                messages[id] = message;\n            }\n            else {\n                (_a = messages[id].sources).push.apply(_a, message.sources);\n            }\n            var _a;\n        });\n        // Transform placeholder names using the serializer mapping\n        var /** @type {?} */ msgList = Object.keys(messages).map(function (id) {\n            var /** @type {?} */ mapper = serializer.createNameMapper(messages[id]);\n            var /** @type {?} */ src = messages[id];\n            var /** @type {?} */ nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;\n            var /** @type {?} */ transformedMessage = new Message(nodes, {}, {}, src.meaning, src.description, id);\n            transformedMessage.sources = src.sources;\n            if (filterSources) {\n                transformedMessage.sources.forEach(function (source) { return source.filePath = filterSources(source.filePath); });\n            }\n            return transformedMessage;\n        });\n        return serializer.write(msgList, this._locale);\n    };\n    return MessageBundle;\n}());\nvar MapPlaceholderNames = (function (_super) {\n    __extends(MapPlaceholderNames, _super);\n    function MapPlaceholderNames() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} nodes\n     * @param {?} mapper\n     * @return {?}\n     */\n    MapPlaceholderNames.prototype.convert = function (nodes, mapper) {\n        var _this = this;\n        return mapper ? nodes.map(function (n) { return n.visit(_this, mapper); }) : nodes;\n    };\n    /**\n     * @param {?} ph\n     * @param {?} mapper\n     * @return {?}\n     */\n    MapPlaceholderNames.prototype.visitTagPlaceholder = function (ph, mapper) {\n        var _this = this;\n        var /** @type {?} */ startName = ((mapper.toPublicName(ph.startName)));\n        var /** @type {?} */ closeName = ph.closeName ? ((mapper.toPublicName(ph.closeName))) : ph.closeName;\n        var /** @type {?} */ children = ph.children.map(function (n) { return n.visit(_this, mapper); });\n        return new TagPlaceholder(ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan);\n    };\n    /**\n     * @param {?} ph\n     * @param {?} mapper\n     * @return {?}\n     */\n    MapPlaceholderNames.prototype.visitPlaceholder = function (ph, mapper) {\n        return new Placeholder(ph.value, /** @type {?} */ ((mapper.toPublicName(ph.name))), ph.sourceSpan);\n    };\n    /**\n     * @param {?} ph\n     * @param {?} mapper\n     * @return {?}\n     */\n    MapPlaceholderNames.prototype.visitIcuPlaceholder = function (ph, mapper) {\n        return new IcuPlaceholder(ph.value, /** @type {?} */ ((mapper.toPublicName(ph.name))), ph.sourceSpan);\n    };\n    return MapPlaceholderNames;\n}(CloneVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Extract i18n messages from source code\n */\nvar Extractor = (function () {\n    /**\n     * @param {?} host\n     * @param {?} staticSymbolResolver\n     * @param {?} messageBundle\n     * @param {?} metadataResolver\n     */\n    function Extractor(host, staticSymbolResolver, messageBundle, metadataResolver) {\n        this.host = host;\n        this.staticSymbolResolver = staticSymbolResolver;\n        this.messageBundle = messageBundle;\n        this.metadataResolver = metadataResolver;\n    }\n    /**\n     * @param {?} rootFiles\n     * @return {?}\n     */\n    Extractor.prototype.extract = function (rootFiles) {\n        var _this = this;\n        var /** @type {?} */ programSymbols = extractProgramSymbols(this.staticSymbolResolver, rootFiles, this.host);\n        var _a = analyzeAndValidateNgModules(programSymbols, this.host, this.metadataResolver), files = _a.files, ngModules = _a.ngModules;\n        return Promise\n            .all(ngModules.map(function (ngModule) { return _this.metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false); }))\n            .then(function () {\n            var /** @type {?} */ errors = [];\n            files.forEach(function (file) {\n                var /** @type {?} */ compMetas = [];\n                file.directives.forEach(function (directiveType) {\n                    var /** @type {?} */ dirMeta = _this.metadataResolver.getDirectiveMetadata(directiveType);\n                    if (dirMeta && dirMeta.isComponent) {\n                        compMetas.push(dirMeta);\n                    }\n                });\n                compMetas.forEach(function (compMeta) {\n                    var /** @type {?} */ html = ((((compMeta.template)).template));\n                    var /** @type {?} */ interpolationConfig = InterpolationConfig.fromArray(/** @type {?} */ ((compMeta.template)).interpolation);\n                    errors.push.apply(errors, ((_this.messageBundle.updateFromTemplate(html, file.srcUrl, interpolationConfig))));\n                });\n            });\n            if (errors.length) {\n                throw new Error(errors.map(function (e) { return e.toString(); }).join('\\n'));\n            }\n            return _this.messageBundle;\n        });\n    };\n    /**\n     * @param {?} host\n     * @param {?} locale\n     * @return {?}\n     */\n    Extractor.create = function (host, locale) {\n        var /** @type {?} */ htmlParser = new I18NHtmlParser(new HtmlParser());\n        var /** @type {?} */ urlResolver = createOfflineCompileUrlResolver();\n        var /** @type {?} */ symbolCache = new StaticSymbolCache();\n        var /** @type {?} */ summaryResolver = new AotSummaryResolver(host, symbolCache);\n        var /** @type {?} */ staticSymbolResolver = new StaticSymbolResolver(host, symbolCache, summaryResolver);\n        var /** @type {?} */ staticReflector = new StaticReflector(summaryResolver, staticSymbolResolver);\n        StaticAndDynamicReflectionCapabilities.install(staticReflector);\n        var /** @type {?} */ config = new CompilerConfig({ defaultEncapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewEncapsulation\"].Emulated, useJit: false });\n        var /** @type {?} */ normalizer = new DirectiveNormalizer({ get: function (url) { return host.loadResource(url); } }, urlResolver, htmlParser, config);\n        var /** @type {?} */ elementSchemaRegistry = new DomElementSchemaRegistry();\n        var /** @type {?} */ resolver = new CompileMetadataResolver(config, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵConsole\"](), symbolCache, staticReflector);\n        // TODO(vicb): implicit tags & attributes\n        var /** @type {?} */ messageBundle = new MessageBundle(htmlParser, [], {}, locale);\n        var /** @type {?} */ extractor = new Extractor(host, staticSymbolResolver, messageBundle, resolver);\n        return { extractor: extractor, staticReflector: staticReflector };\n    };\n    return Extractor;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _NO_RESOURCE_LOADER = {\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    get: function (url) {\n        throw new Error(\"No ResourceLoader implementation has been provided. Can't read the url \\\"\" + url + \"\\\"\");\n    }\n};\nvar baseHtmlParser = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"InjectionToken\"]('HtmlParser');\n/**\n * @param {?} parser\n * @param {?} translations\n * @param {?} format\n * @param {?} config\n * @param {?} console\n * @return {?}\n */\nfunction i18nHtmlParserFactory(parser, translations, format, config, console) {\n    return new I18NHtmlParser(parser, translations, format, /** @type {?} */ ((config.missingTranslation)), console);\n}\n/**\n * A set of providers that provide `JitCompiler` and its dependencies to use for\n * template compilation.\n */\nvar COMPILER_PROVIDERS = [\n    { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵReflector\"], useValue: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵreflector\"] },\n    { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵReflectorReader\"], useExisting: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵReflector\"] },\n    { provide: ResourceLoader, useValue: _NO_RESOURCE_LOADER },\n    SummaryResolver,\n    __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵConsole\"],\n    Lexer,\n    Parser,\n    {\n        provide: baseHtmlParser,\n        useClass: HtmlParser,\n    },\n    {\n        provide: I18NHtmlParser,\n        useFactory: i18nHtmlParserFactory,\n        deps: [\n            baseHtmlParser,\n            [new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Inject\"](__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"TRANSLATIONS\"])],\n            [new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Optional\"](), new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Inject\"](__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"TRANSLATIONS_FORMAT\"])],\n            [CompilerConfig],\n            [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵConsole\"]],\n        ]\n    },\n    {\n        provide: HtmlParser,\n        useExisting: I18NHtmlParser,\n    },\n    TemplateParser,\n    DirectiveNormalizer,\n    CompileMetadataResolver,\n    DEFAULT_PACKAGE_URL_PROVIDER,\n    StyleCompiler,\n    ViewCompiler,\n    NgModuleCompiler,\n    { provide: CompilerConfig, useValue: new CompilerConfig() },\n    JitCompiler,\n    { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Compiler\"], useExisting: JitCompiler },\n    DomElementSchemaRegistry,\n    { provide: ElementSchemaRegistry, useExisting: DomElementSchemaRegistry },\n    UrlResolver,\n    DirectiveResolver,\n    PipeResolver,\n    NgModuleResolver,\n];\nvar JitCompilerFactory = (function () {\n    /**\n     * @param {?} defaultOptions\n     */\n    function JitCompilerFactory(defaultOptions) {\n        var compilerOptions = {\n            useDebug: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"isDevMode\"])(),\n            useJit: true,\n            defaultEncapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewEncapsulation\"].Emulated,\n            missingTranslation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"MissingTranslationStrategy\"].Warning,\n            enableLegacyTemplate: true,\n        };\n        this._defaultOptions = [compilerOptions].concat(defaultOptions);\n    }\n    /**\n     * @param {?=} options\n     * @return {?}\n     */\n    JitCompilerFactory.prototype.createCompiler = function (options) {\n        if (options === void 0) { options = []; }\n        var /** @type {?} */ opts = _mergeOptions(this._defaultOptions.concat(options));\n        var /** @type {?} */ injector = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ReflectiveInjector\"].resolveAndCreate([\n            COMPILER_PROVIDERS, {\n                provide: CompilerConfig,\n                useFactory: function () {\n                    return new CompilerConfig({\n                        // let explicit values from the compiler options overwrite options\n                        // from the app providers\n                        useJit: opts.useJit,\n                        // let explicit values from the compiler options overwrite options\n                        // from the app providers\n                        defaultEncapsulation: opts.defaultEncapsulation,\n                        missingTranslation: opts.missingTranslation,\n                        enableLegacyTemplate: opts.enableLegacyTemplate,\n                    });\n                },\n                deps: []\n            }, /** @type {?} */ ((opts.providers))\n        ]);\n        return injector.get(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Compiler\"]);\n    };\n    return JitCompilerFactory;\n}());\nJitCompilerFactory.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nJitCompilerFactory.ctorParameters = function () { return [\n    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Inject\"], args: [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"COMPILER_OPTIONS\"],] },] },\n]; };\n/**\n * @return {?}\n */\nfunction _initReflector() {\n    __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵreflector\"].reflectionCapabilities = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ɵReflectionCapabilities\"]();\n}\n/**\n * A platform that included corePlatform and the compiler.\n *\n * \\@experimental\n */\nvar platformCoreDynamic = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"createPlatformFactory\"])(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"platformCore\"], 'coreDynamic', [\n    { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"COMPILER_OPTIONS\"], useValue: {}, multi: true },\n    { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"CompilerFactory\"], useClass: JitCompilerFactory },\n    { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"PLATFORM_INITIALIZER\"], useValue: _initReflector, multi: true },\n]);\n/**\n * @param {?} optionsArr\n * @return {?}\n */\nfunction _mergeOptions(optionsArr) {\n    return {\n        useJit: _lastDefined(optionsArr.map(function (options) { return options.useJit; })),\n        defaultEncapsulation: _lastDefined(optionsArr.map(function (options) { return options.defaultEncapsulation; })),\n        providers: _mergeArrays(optionsArr.map(function (options) { return ((options.providers)); })),\n        missingTranslation: _lastDefined(optionsArr.map(function (options) { return options.missingTranslation; })),\n    };\n}\n/**\n * @template T\n * @param {?} args\n * @return {?}\n */\nfunction _lastDefined(args) {\n    for (var /** @type {?} */ i = args.length - 1; i >= 0; i--) {\n        if (args[i] !== undefined) {\n            return args[i];\n        }\n    }\n    return undefined;\n}\n/**\n * @param {?} parts\n * @return {?}\n */\nfunction _mergeArrays(parts) {\n    var /** @type {?} */ result = [];\n    parts.forEach(function (part) { return part && result.push.apply(result, part); });\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Interface that defines how import statements should be generated.\n * @abstract\n */\nvar ImportResolver = (function () {\n    function ImportResolver() {\n    }\n    /**\n     * Converts a file path to a module name that can be used as an `import.\n     * I.e. `path/to/importedFile.ts` should be imported by `path/to/containingFile.ts`.\n     * @abstract\n     * @param {?} importedFilePath\n     * @param {?} containingFilePath\n     * @return {?}\n     */\n    ImportResolver.prototype.fileNameToModuleName = function (importedFilePath, containingFilePath) { };\n    /**\n     * Converts the given StaticSymbol into another StaticSymbol that should be used\n     * to generate the import from.\n     * @abstract\n     * @param {?} symbol\n     * @return {?}\n     */\n    ImportResolver.prototype.getImportAs = function (symbol) { };\n    /**\n     * Determine the arity of a type.\n     * @abstract\n     * @param {?} symbol\n     * @return {?}\n     */\n    ImportResolver.prototype.getTypeArity = function (symbol) { };\n    return ImportResolver;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all APIs of the compiler package.\n *\n * <div class=\"callout is-critical\">\n *   <header>Unstable APIs</header>\n *   <p>\n *     All compiler apis are currently considered experimental and private!\n *   </p>\n *   <p>\n *     We expect the APIs in this package to keep on changing. Do not rely on them.\n *   </p>\n * </div>\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the compiler package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n//# sourceMappingURL=compiler.js.map\n//# sourceMappingURL=compiler.es5.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL34vQGFuZ3VsYXIvY29tcGlsZXIvQGFuZ3VsYXIvY29tcGlsZXIuZXM1LmpzP2QzZjYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjQuMS4wXG4gKiAoYykgMjAxMC0yMDE3IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuaW1wb3J0IHsgQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUywgQXR0cmlidXRlLCBDT01QSUxFUl9PUFRJT05TLCBDVVNUT01fRUxFTUVOVFNfU0NIRU1BLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBpbGVyLCBDb21waWxlckZhY3RvcnksIENvbXBvbmVudCwgQ29tcG9uZW50RmFjdG9yeSwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBDb21wb25lbnRSZWYsIENvbnRlbnRDaGlsZCwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEhvc3QsIEhvc3RCaW5kaW5nLCBIb3N0TGlzdGVuZXIsIEluamVjdCwgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIEluamVjdG9yLCBJbnB1dCwgTE9DQUxFX0lELCBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSwgTW9kdWxlV2l0aENvbXBvbmVudEZhY3RvcmllcywgTk9fRVJST1JTX1NDSEVNQSwgTmdNb2R1bGUsIE5nTW9kdWxlRmFjdG9yeSwgTmdNb2R1bGVSZWYsIE9wdGlvbmFsLCBPdXRwdXQsIFBBQ0tBR0VfUk9PVF9VUkwsIFBMQVRGT1JNX0lOSVRJQUxJWkVSLCBQaXBlLCBRdWVyeSwgUXVlcnlMaXN0LCBSZWZsZWN0aXZlSW5qZWN0b3IsIFJlbmRlcmVyLCBTZWN1cml0eUNvbnRleHQsIFNlbGYsIFNraXBTZWxmLCBUUkFOU0xBVElPTlMsIFRSQU5TTEFUSU9OU19GT1JNQVQsIFRlbXBsYXRlUmVmLCBUeXBlLCBWZXJzaW9uLCBWaWV3Q2hpbGQsIFZpZXdDaGlsZHJlbiwgVmlld0NvbnRhaW5lclJlZiwgVmlld0VuY2Fwc3VsYXRpb24sIGFuaW1hdGUsIGNyZWF0ZVBsYXRmb3JtRmFjdG9yeSwgZ3JvdXAsIGlzRGV2TW9kZSwga2V5ZnJhbWVzLCBwbGF0Zm9ybUNvcmUsIHJlc29sdmVGb3J3YXJkUmVmLCBzZXF1ZW5jZSwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyLCDJtUNvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIMm1Q29uc29sZSwgybVFTVBUWV9BUlJBWSwgybVFTVBUWV9NQVAsIMm1RVJST1JfQ09NUE9ORU5UX1RZUEUsIMm1TElGRUNZQ0xFX0hPT0tTX1ZBTFVFUywgybVMaWZlY3ljbGVIb29rcywgybVOZ01vZHVsZUluamVjdG9yLCDJtVJlZmxlY3Rpb25DYXBhYmlsaXRpZXMsIMm1UmVmbGVjdG9yLCDJtVJlZmxlY3RvclJlYWRlciwgybVhbmQsIMm1Y2NmLCDJtWNydCwgybVkaWQsIMm1ZWxkLCDJtWVsZW1lbnRFdmVudEZ1bGxOYW1lLCDJtWdldENvbXBvbmVudFZpZXdEZWZpbml0aW9uRmFjdG9yeSwgybVpbmxpbmVJbnRlcnBvbGF0ZSwgybVpbnRlcnBvbGF0ZSwgybVuY2QsIMm1bm92LCDJtXBhZCwgybVwaWQsIMm1cG9kLCDJtXBwZCwgybVwcmQsIMm1cXVkLCDJtXJlZmxlY3RvciwgybVyZWdpc3Rlck1vZHVsZUZhY3RvcnksIMm1c3RyaW5naWZ5LCDJtXRlZCwgybV1bnYsIMm1dmlkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBtb2R1bGVcbiAqIEBkZXNjcmlwdGlvblxuICogRW50cnkgcG9pbnQgZm9yIGFsbCBwdWJsaWMgQVBJcyBvZiB0aGUgY29tbW9uIHBhY2thZ2UuXG4gKi9cbi8qKlxuICogXFxAc3RhYmxlXG4gKi9cbnZhciBWRVJTSU9OID0gbmV3IFZlcnNpb24oJzQuMS4wJyk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEEgc2VnbWVudCBvZiB0ZXh0IHdpdGhpbiB0aGUgdGVtcGxhdGUuXG4gKi9cbnZhciBUZXh0QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBuZ0NvbnRlbnRJbmRleFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRleHRBc3QodmFsdWUsIG5nQ29udGVudEluZGV4LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRleHRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBUZXh0QXN0O1xufSgpKTtcbi8qKlxuICogQSBib3VuZCBleHByZXNzaW9uIHdpdGhpbiB0aGUgdGV4dCBvZiBhIHRlbXBsYXRlLlxuICovXG52YXIgQm91bmRUZXh0QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBuZ0NvbnRlbnRJbmRleFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJvdW5kVGV4dEFzdCh2YWx1ZSwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQm91bmRUZXh0QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Qm91bmRUZXh0KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEJvdW5kVGV4dEFzdDtcbn0oKSk7XG4vKipcbiAqIEEgcGxhaW4gYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQuXG4gKi9cbnZhciBBdHRyQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXR0ckFzdChuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXR0ckFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEF0dHIodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIEF0dHJBc3Q7XG59KCkpO1xuLyoqXG4gKiBBIGJpbmRpbmcgZm9yIGFuIGVsZW1lbnQgcHJvcGVydHkgKGUuZy4gYFtwcm9wZXJ0eV09XCJleHByZXNzaW9uXCJgKSBvciBhbiBhbmltYXRpb24gdHJpZ2dlciAoZS5nLlxuICogYFtcXEB0cmlnZ2VyXT1cInN0YXRlRXhwXCJgKVxuICovXG52YXIgQm91bmRFbGVtZW50UHJvcGVydHlBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gc2VjdXJpdHlDb250ZXh0XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gdW5pdFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJvdW5kRWxlbWVudFByb3BlcnR5QXN0KG5hbWUsIHR5cGUsIHNlY3VyaXR5Q29udGV4dCwgdmFsdWUsIHVuaXQsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zZWN1cml0eUNvbnRleHQgPSBzZWN1cml0eUNvbnRleHQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51bml0ID0gdW5pdDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVsZW1lbnRQcm9wZXJ0eSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdC5wcm90b3R5cGUsIFwiaXNBbmltYXRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09PSBQcm9wZXJ0eUJpbmRpbmdUeXBlLkFuaW1hdGlvbjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEJvdW5kRWxlbWVudFByb3BlcnR5QXN0O1xufSgpKTtcbi8qKlxuICogQSBiaW5kaW5nIGZvciBhbiBlbGVtZW50IGV2ZW50IChlLmcuIGAoZXZlbnQpPVwiaGFuZGxlcigpXCJgKSBvciBhbiBhbmltYXRpb24gdHJpZ2dlciBldmVudCAoZS5nLlxuICogYChcXEB0cmlnZ2VyLnBoYXNlKT1cImNhbGxiYWNrKCRldmVudClcImApLlxuICovXG52YXIgQm91bmRFdmVudEFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0gez99IHBoYXNlXG4gICAgICogQHBhcmFtIHs/fSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQm91bmRFdmVudEFzdChuYW1lLCB0YXJnZXQsIHBoYXNlLCBoYW5kbGVyLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnBoYXNlID0gcGhhc2U7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHs/fSBwaGFzZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQm91bmRFdmVudEFzdC5jYWxjRnVsbE5hbWUgPSBmdW5jdGlvbiAobmFtZSwgdGFyZ2V0LCBwaGFzZSkge1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0ICsgXCI6XCIgKyBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBoYXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJAXCIgKyBuYW1lICsgXCIuXCIgKyBwaGFzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJvdW5kRXZlbnRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFdmVudCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3VuZEV2ZW50QXN0LnByb3RvdHlwZSwgXCJmdWxsTmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBCb3VuZEV2ZW50QXN0LmNhbGNGdWxsTmFtZSh0aGlzLm5hbWUsIHRoaXMudGFyZ2V0LCB0aGlzLnBoYXNlKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvdW5kRXZlbnRBc3QucHJvdG90eXBlLCBcImlzQW5pbWF0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICEhdGhpcy5waGFzZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEJvdW5kRXZlbnRBc3Q7XG59KCkpO1xuLyoqXG4gKiBBIHJlZmVyZW5jZSBkZWNsYXJhdGlvbiBvbiBhbiBlbGVtZW50IChlLmcuIGBsZXQgc29tZU5hbWU9XCJleHByZXNzaW9uXCJgKS5cbiAqL1xudmFyIFJlZmVyZW5jZUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlZmVyZW5jZUFzdChuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVmZXJlbmNlQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmVmZXJlbmNlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZmVyZW5jZUFzdDtcbn0oKSk7XG4vKipcbiAqIEEgdmFyaWFibGUgZGVjbGFyYXRpb24gb24gYSA8bmctdGVtcGxhdGU+IChlLmcuIGB2YXItc29tZU5hbWU9XCJzb21lTG9jYWxOYW1lXCJgKS5cbiAqL1xudmFyIFZhcmlhYmxlQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVmFyaWFibGVBc3QobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZhcmlhYmxlQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VmFyaWFibGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gVmFyaWFibGVBc3Q7XG59KCkpO1xuLyoqXG4gKiBBbiBlbGVtZW50IGRlY2xhcmF0aW9uIGluIGEgdGVtcGxhdGUuXG4gKi9cbnZhciBFbGVtZW50QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGF0dHJzXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dHNcbiAgICAgKiBAcGFyYW0gez99IG91dHB1dHNcbiAgICAgKiBAcGFyYW0gez99IHJlZmVyZW5jZXNcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyc1xuICAgICAqIEBwYXJhbSB7P30gaGFzVmlld0NvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7P30gcXVlcnlNYXRjaGVzXG4gICAgICogQHBhcmFtIHs/fSBjaGlsZHJlblxuICAgICAqIEBwYXJhbSB7P30gbmdDb250ZW50SW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IGVuZFNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbGVtZW50QXN0KG5hbWUsIGF0dHJzLCBpbnB1dHMsIG91dHB1dHMsIHJlZmVyZW5jZXMsIGRpcmVjdGl2ZXMsIHByb3ZpZGVycywgaGFzVmlld0NvbnRhaW5lciwgcXVlcnlNYXRjaGVzLCBjaGlsZHJlbiwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4sIGVuZFNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gcmVmZXJlbmNlcztcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBwcm92aWRlcnM7XG4gICAgICAgIHRoaXMuaGFzVmlld0NvbnRhaW5lciA9IGhhc1ZpZXdDb250YWluZXI7XG4gICAgICAgIHRoaXMucXVlcnlNYXRjaGVzID0gcXVlcnlNYXRjaGVzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5lbmRTb3VyY2VTcGFuID0gZW5kU291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50QXN0O1xufSgpKTtcbi8qKlxuICogQSBgPG5nLXRlbXBsYXRlPmAgZWxlbWVudCBpbmNsdWRlZCBpbiBhbiBBbmd1bGFyIHRlbXBsYXRlLlxuICovXG52YXIgRW1iZWRkZWRUZW1wbGF0ZUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhdHRyc1xuICAgICAqIEBwYXJhbSB7P30gb3V0cHV0c1xuICAgICAqIEBwYXJhbSB7P30gcmVmZXJlbmNlc1xuICAgICAqIEBwYXJhbSB7P30gdmFyaWFibGVzXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVzXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlcnNcbiAgICAgKiBAcGFyYW0gez99IGhhc1ZpZXdDb250YWluZXJcbiAgICAgKiBAcGFyYW0gez99IHF1ZXJ5TWF0Y2hlc1xuICAgICAqIEBwYXJhbSB7P30gY2hpbGRyZW5cbiAgICAgKiBAcGFyYW0gez99IG5nQ29udGVudEluZGV4XG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRW1iZWRkZWRUZW1wbGF0ZUFzdChhdHRycywgb3V0cHV0cywgcmVmZXJlbmNlcywgdmFyaWFibGVzLCBkaXJlY3RpdmVzLCBwcm92aWRlcnMsIGhhc1ZpZXdDb250YWluZXIsIHF1ZXJ5TWF0Y2hlcywgY2hpbGRyZW4sIG5nQ29udGVudEluZGV4LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gcmVmZXJlbmNlcztcbiAgICAgICAgdGhpcy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuICAgICAgICB0aGlzLmhhc1ZpZXdDb250YWluZXIgPSBoYXNWaWV3Q29udGFpbmVyO1xuICAgICAgICB0aGlzLnF1ZXJ5TWF0Y2hlcyA9IHF1ZXJ5TWF0Y2hlcztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1iZWRkZWRUZW1wbGF0ZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVtYmVkZGVkVGVtcGxhdGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gRW1iZWRkZWRUZW1wbGF0ZUFzdDtcbn0oKSk7XG4vKipcbiAqIEEgZGlyZWN0aXZlIHByb3BlcnR5IHdpdGggYSBib3VuZCB2YWx1ZSAoZS5nLiBgKm5nSWY9XCJjb25kaXRpb25cIikuXG4gKi9cbnZhciBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZU5hbWVcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlTmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0KGRpcmVjdGl2ZU5hbWUsIHRlbXBsYXRlTmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlTmFtZTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZU5hbWUgPSB0ZW1wbGF0ZU5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGlyZWN0aXZlUHJvcGVydHkodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdDtcbn0oKSk7XG4vKipcbiAqIEEgZGlyZWN0aXZlIGRlY2xhcmVkIG9uIGFuIGVsZW1lbnQuXG4gKi9cbnZhciBEaXJlY3RpdmVBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dHNcbiAgICAgKiBAcGFyYW0gez99IGhvc3RQcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHs/fSBob3N0RXZlbnRzXG4gICAgICogQHBhcmFtIHs/fSBjb250ZW50UXVlcnlTdGFydElkXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGlyZWN0aXZlQXN0KGRpcmVjdGl2ZSwgaW5wdXRzLCBob3N0UHJvcGVydGllcywgaG9zdEV2ZW50cywgY29udGVudFF1ZXJ5U3RhcnRJZCwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgIHRoaXMuaG9zdFByb3BlcnRpZXMgPSBob3N0UHJvcGVydGllcztcbiAgICAgICAgdGhpcy5ob3N0RXZlbnRzID0gaG9zdEV2ZW50cztcbiAgICAgICAgdGhpcy5jb250ZW50UXVlcnlTdGFydElkID0gY29udGVudFF1ZXJ5U3RhcnRJZDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREaXJlY3RpdmUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGlyZWN0aXZlQXN0O1xufSgpKTtcbi8qKlxuICogQSBwcm92aWRlciBkZWNsYXJlZCBvbiBhbiBlbGVtZW50XG4gKi9cbnZhciBQcm92aWRlckFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAqIEBwYXJhbSB7P30gbXVsdGlQcm92aWRlclxuICAgICAqIEBwYXJhbSB7P30gZWFnZXJcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyc1xuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJUeXBlXG4gICAgICogQHBhcmFtIHs/fSBsaWZlY3ljbGVIb29rc1xuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFByb3ZpZGVyQXN0KHRva2VuLCBtdWx0aVByb3ZpZGVyLCBlYWdlciwgcHJvdmlkZXJzLCBwcm92aWRlclR5cGUsIGxpZmVjeWNsZUhvb2tzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5tdWx0aVByb3ZpZGVyID0gbXVsdGlQcm92aWRlcjtcbiAgICAgICAgdGhpcy5lYWdlciA9IGVhZ2VyO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgdGhpcy5wcm92aWRlclR5cGUgPSBwcm92aWRlclR5cGU7XG4gICAgICAgIHRoaXMubGlmZWN5Y2xlSG9va3MgPSBsaWZlY3ljbGVIb29rcztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQcm92aWRlckFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAvLyBObyB2aXNpdCBtZXRob2QgaW4gdGhlIHZpc2l0b3IgZm9yIG5vdy4uLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBQcm92aWRlckFzdDtcbn0oKSk7XG52YXIgUHJvdmlkZXJBc3RUeXBlID0ge307XG5Qcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSA9IDA7XG5Qcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UgPSAxO1xuUHJvdmlkZXJBc3RUeXBlLkNvbXBvbmVudCA9IDI7XG5Qcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlID0gMztcblByb3ZpZGVyQXN0VHlwZS5CdWlsdGluID0gNDtcblByb3ZpZGVyQXN0VHlwZVtQcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZV0gPSBcIlB1YmxpY1NlcnZpY2VcIjtcblByb3ZpZGVyQXN0VHlwZVtQcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2VdID0gXCJQcml2YXRlU2VydmljZVwiO1xuUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZS5Db21wb25lbnRdID0gXCJDb21wb25lbnRcIjtcblByb3ZpZGVyQXN0VHlwZVtQcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlXSA9IFwiRGlyZWN0aXZlXCI7XG5Qcm92aWRlckFzdFR5cGVbUHJvdmlkZXJBc3RUeXBlLkJ1aWx0aW5dID0gXCJCdWlsdGluXCI7XG4vKipcbiAqIFBvc2l0aW9uIHdoZXJlIGNvbnRlbnQgaXMgdG8gYmUgcHJvamVjdGVkIChpbnN0YW5jZSBvZiBgPG5nLWNvbnRlbnQ+YCBpbiBhIHRlbXBsYXRlKS5cbiAqL1xudmFyIE5nQ29udGVudEFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEBwYXJhbSB7P30gbmdDb250ZW50SW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOZ0NvbnRlbnRBc3QoaW5kZXgsIG5nQ29udGVudEluZGV4LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5nQ29udGVudEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE5nQ29udGVudCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBOZ0NvbnRlbnRBc3Q7XG59KCkpO1xudmFyIFByb3BlcnR5QmluZGluZ1R5cGUgPSB7fTtcblByb3BlcnR5QmluZGluZ1R5cGUuUHJvcGVydHkgPSAwO1xuUHJvcGVydHlCaW5kaW5nVHlwZS5BdHRyaWJ1dGUgPSAxO1xuUHJvcGVydHlCaW5kaW5nVHlwZS5DbGFzcyA9IDI7XG5Qcm9wZXJ0eUJpbmRpbmdUeXBlLlN0eWxlID0gMztcblByb3BlcnR5QmluZGluZ1R5cGUuQW5pbWF0aW9uID0gNDtcblByb3BlcnR5QmluZGluZ1R5cGVbUHJvcGVydHlCaW5kaW5nVHlwZS5Qcm9wZXJ0eV0gPSBcIlByb3BlcnR5XCI7XG5Qcm9wZXJ0eUJpbmRpbmdUeXBlW1Byb3BlcnR5QmluZGluZ1R5cGUuQXR0cmlidXRlXSA9IFwiQXR0cmlidXRlXCI7XG5Qcm9wZXJ0eUJpbmRpbmdUeXBlW1Byb3BlcnR5QmluZGluZ1R5cGUuQ2xhc3NdID0gXCJDbGFzc1wiO1xuUHJvcGVydHlCaW5kaW5nVHlwZVtQcm9wZXJ0eUJpbmRpbmdUeXBlLlN0eWxlXSA9IFwiU3R5bGVcIjtcblByb3BlcnR5QmluZGluZ1R5cGVbUHJvcGVydHlCaW5kaW5nVHlwZS5BbmltYXRpb25dID0gXCJBbmltYXRpb25cIjtcbi8qKlxuICogVmlzaXQgZXZlcnkgbm9kZSBpbiBhIGxpc3Qgb2Yge1xcQGxpbmsgVGVtcGxhdGVBc3R9cyB3aXRoIHRoZSBnaXZlbiB7XFxAbGluayBUZW1wbGF0ZUFzdFZpc2l0b3J9LlxuICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gKiBAcGFyYW0gez99IGFzdHNcbiAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRlbXBsYXRlVmlzaXRBbGwodmlzaXRvciwgYXN0cywgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdCA9IHZpc2l0b3IudmlzaXQgP1xuICAgICAgICBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiAoKHZpc2l0b3IudmlzaXQpKShhc3QsIGNvbnRleHQpIHx8IGFzdC52aXNpdCh2aXNpdG9yLCBjb250ZXh0KTsgfSA6XG4gICAgICAgIGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGFzdC52aXNpdCh2aXNpdG9yLCBjb250ZXh0KTsgfTtcbiAgICBhc3RzLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3RSZXN1bHQgPSB2aXNpdChhc3QpO1xuICAgICAgICBpZiAoYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhc3RSZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQSB0b2tlbiByZXByZXNlbnRpbmcgdGhlIGEgcmVmZXJlbmNlIHRvIGEgc3RhdGljIHR5cGUuXG4gKlxuICogVGhpcyB0b2tlbiBpcyB1bmlxdWUgZm9yIGEgZmlsZVBhdGggYW5kIG5hbWUgYW5kIGNhbiBiZSB1c2VkIGFzIGEgaGFzaCB0YWJsZSBrZXkuXG4gKi9cbnZhciBTdGF0aWNTeW1ib2wgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZVBhdGhcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IG1lbWJlcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGF0aWNTeW1ib2woZmlsZVBhdGgsIG5hbWUsIG1lbWJlcnMpIHtcbiAgICAgICAgdGhpcy5maWxlUGF0aCA9IGZpbGVQYXRoO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSBtZW1iZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbC5wcm90b3R5cGUuYXNzZXJ0Tm9NZW1iZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tZW1iZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogc3ltYm9sIHdpdGhvdXQgbWVtYmVycyBleHBlY3RlZCwgYnV0IGdvdCBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMpICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljU3ltYm9sO1xufSgpKTtcbi8qKlxuICogQSBjYWNoZSBvZiBzdGF0aWMgc3ltYm9sIHVzZWQgYnkgdGhlIFN0YXRpY1JlZmxlY3RvciB0byByZXR1cm4gdGhlIHNhbWUgc3ltYm9sIGZvciB0aGVcbiAqIHNhbWUgc3ltYm9sIHZhbHVlcy5cbiAqL1xudmFyIFN0YXRpY1N5bWJvbENhY2hlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0aWNTeW1ib2xDYWNoZSgpIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkZWNsYXJhdGlvbkZpbGVcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSBtZW1iZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGRlY2xhcmF0aW9uRmlsZSwgbmFtZSwgbWVtYmVycykge1xuICAgICAgICBtZW1iZXJzID0gbWVtYmVycyB8fCBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVtYmVyU3VmZml4ID0gbWVtYmVycy5sZW5ndGggPyBcIi5cIiArIG1lbWJlcnMuam9pbignLicpIDogJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleSA9IFwiXFxcIlwiICsgZGVjbGFyYXRpb25GaWxlICsgXCJcXFwiLlwiICsgbmFtZSArIG1lbWJlclN1ZmZpeDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBTdGF0aWNTeW1ib2woZGVjbGFyYXRpb25GaWxlLCBuYW1lLCBtZW1iZXJzKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY1N5bWJvbENhY2hlO1xufSgpKTtcbnZhciBUYWdDb250ZW50VHlwZSA9IHt9O1xuVGFnQ29udGVudFR5cGUuUkFXX1RFWFQgPSAwO1xuVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhUID0gMTtcblRhZ0NvbnRlbnRUeXBlLlBBUlNBQkxFX0RBVEEgPSAyO1xuVGFnQ29udGVudFR5cGVbVGFnQ29udGVudFR5cGUuUkFXX1RFWFRdID0gXCJSQVdfVEVYVFwiO1xuVGFnQ29udGVudFR5cGVbVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhUXSA9IFwiRVNDQVBBQkxFX1JBV19URVhUXCI7XG5UYWdDb250ZW50VHlwZVtUYWdDb250ZW50VHlwZS5QQVJTQUJMRV9EQVRBXSA9IFwiUEFSU0FCTEVfREFUQVwiO1xuLyoqXG4gKiBAcGFyYW0gez99IGVsZW1lbnROYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzcGxpdE5zTmFtZShlbGVtZW50TmFtZSkge1xuICAgIGlmIChlbGVtZW50TmFtZVswXSAhPSAnOicpIHtcbiAgICAgICAgcmV0dXJuIFtudWxsLCBlbGVtZW50TmFtZV07XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbG9uSW5kZXggPSBlbGVtZW50TmFtZS5pbmRleE9mKCc6JywgMSk7XG4gICAgaWYgKGNvbG9uSW5kZXggPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZm9ybWF0IFxcXCJcIiArIGVsZW1lbnROYW1lICsgXCJcXFwiIGV4cGVjdGluZyBcXFwiOm5hbWVzcGFjZTpuYW1lXFxcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFtlbGVtZW50TmFtZS5zbGljZSgxLCBjb2xvbkluZGV4KSwgZWxlbWVudE5hbWUuc2xpY2UoY29sb25JbmRleCArIDEpXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB0YWdOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc05nQ29udGFpbmVyKHRhZ05hbWUpIHtcbiAgICByZXR1cm4gc3BsaXROc05hbWUodGFnTmFtZSlbMV0gPT09ICduZy1jb250YWluZXInO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHRhZ05hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzTmdDb250ZW50KHRhZ05hbWUpIHtcbiAgICByZXR1cm4gc3BsaXROc05hbWUodGFnTmFtZSlbMV0gPT09ICduZy1jb250ZW50Jztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB0YWdOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc05nVGVtcGxhdGUodGFnTmFtZSkge1xuICAgIHJldHVybiBzcGxpdE5zTmFtZSh0YWdOYW1lKVsxXSA9PT0gJ25nLXRlbXBsYXRlJztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBmdWxsTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0TnNQcmVmaXgoZnVsbE5hbWUpIHtcbiAgICByZXR1cm4gZnVsbE5hbWUgPT09IG51bGwgPyBudWxsIDogc3BsaXROc05hbWUoZnVsbE5hbWUpWzBdO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHByZWZpeFxuICogQHBhcmFtIHs/fSBsb2NhbE5hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG1lcmdlTnNBbmROYW1lKHByZWZpeCwgbG9jYWxOYW1lKSB7XG4gICAgcmV0dXJuIHByZWZpeCA/IFwiOlwiICsgcHJlZml4ICsgXCI6XCIgKyBsb2NhbE5hbWUgOiBsb2NhbE5hbWU7XG59XG4vLyBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUxL3N5bnRheC5odG1sI25hbWVkLWNoYXJhY3Rlci1yZWZlcmVuY2VzXG4vLyBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW50aXRpZXMuanNvblxuLy8gVGhpcyBsaXN0IGlzIG5vdCBleGhhdXN0aXZlIHRvIGtlZXAgdGhlIGNvbXBpbGVyIGZvb3RwcmludCBsb3cuXG4vLyBUaGUgYCYjMTIzO2AgLyBgJiN4MWFiO2Agc3ludGF4IHNob3VsZCBiZSB1c2VkIHdoZW4gdGhlIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2UgZG9lcyBub3Rcbi8vIGV4aXN0LlxudmFyIE5BTUVEX0VOVElUSUVTID0ge1xuICAgICdBYWN1dGUnOiAnXFx1MDBDMScsXG4gICAgJ2FhY3V0ZSc6ICdcXHUwMEUxJyxcbiAgICAnQWNpcmMnOiAnXFx1MDBDMicsXG4gICAgJ2FjaXJjJzogJ1xcdTAwRTInLFxuICAgICdhY3V0ZSc6ICdcXHUwMEI0JyxcbiAgICAnQUVsaWcnOiAnXFx1MDBDNicsXG4gICAgJ2FlbGlnJzogJ1xcdTAwRTYnLFxuICAgICdBZ3JhdmUnOiAnXFx1MDBDMCcsXG4gICAgJ2FncmF2ZSc6ICdcXHUwMEUwJyxcbiAgICAnYWxlZnN5bSc6ICdcXHUyMTM1JyxcbiAgICAnQWxwaGEnOiAnXFx1MDM5MScsXG4gICAgJ2FscGhhJzogJ1xcdTAzQjEnLFxuICAgICdhbXAnOiAnJicsXG4gICAgJ2FuZCc6ICdcXHUyMjI3JyxcbiAgICAnYW5nJzogJ1xcdTIyMjAnLFxuICAgICdhcG9zJzogJ1xcdTAwMjcnLFxuICAgICdBcmluZyc6ICdcXHUwMEM1JyxcbiAgICAnYXJpbmcnOiAnXFx1MDBFNScsXG4gICAgJ2FzeW1wJzogJ1xcdTIyNDgnLFxuICAgICdBdGlsZGUnOiAnXFx1MDBDMycsXG4gICAgJ2F0aWxkZSc6ICdcXHUwMEUzJyxcbiAgICAnQXVtbCc6ICdcXHUwMEM0JyxcbiAgICAnYXVtbCc6ICdcXHUwMEU0JyxcbiAgICAnYmRxdW8nOiAnXFx1MjAxRScsXG4gICAgJ0JldGEnOiAnXFx1MDM5MicsXG4gICAgJ2JldGEnOiAnXFx1MDNCMicsXG4gICAgJ2JydmJhcic6ICdcXHUwMEE2JyxcbiAgICAnYnVsbCc6ICdcXHUyMDIyJyxcbiAgICAnY2FwJzogJ1xcdTIyMjknLFxuICAgICdDY2VkaWwnOiAnXFx1MDBDNycsXG4gICAgJ2NjZWRpbCc6ICdcXHUwMEU3JyxcbiAgICAnY2VkaWwnOiAnXFx1MDBCOCcsXG4gICAgJ2NlbnQnOiAnXFx1MDBBMicsXG4gICAgJ0NoaSc6ICdcXHUwM0E3JyxcbiAgICAnY2hpJzogJ1xcdTAzQzcnLFxuICAgICdjaXJjJzogJ1xcdTAyQzYnLFxuICAgICdjbHVicyc6ICdcXHUyNjYzJyxcbiAgICAnY29uZyc6ICdcXHUyMjQ1JyxcbiAgICAnY29weSc6ICdcXHUwMEE5JyxcbiAgICAnY3JhcnInOiAnXFx1MjFCNScsXG4gICAgJ2N1cCc6ICdcXHUyMjJBJyxcbiAgICAnY3VycmVuJzogJ1xcdTAwQTQnLFxuICAgICdkYWdnZXInOiAnXFx1MjAyMCcsXG4gICAgJ0RhZ2dlcic6ICdcXHUyMDIxJyxcbiAgICAnZGFycic6ICdcXHUyMTkzJyxcbiAgICAnZEFycic6ICdcXHUyMUQzJyxcbiAgICAnZGVnJzogJ1xcdTAwQjAnLFxuICAgICdEZWx0YSc6ICdcXHUwMzk0JyxcbiAgICAnZGVsdGEnOiAnXFx1MDNCNCcsXG4gICAgJ2RpYW1zJzogJ1xcdTI2NjYnLFxuICAgICdkaXZpZGUnOiAnXFx1MDBGNycsXG4gICAgJ0VhY3V0ZSc6ICdcXHUwMEM5JyxcbiAgICAnZWFjdXRlJzogJ1xcdTAwRTknLFxuICAgICdFY2lyYyc6ICdcXHUwMENBJyxcbiAgICAnZWNpcmMnOiAnXFx1MDBFQScsXG4gICAgJ0VncmF2ZSc6ICdcXHUwMEM4JyxcbiAgICAnZWdyYXZlJzogJ1xcdTAwRTgnLFxuICAgICdlbXB0eSc6ICdcXHUyMjA1JyxcbiAgICAnZW1zcCc6ICdcXHUyMDAzJyxcbiAgICAnZW5zcCc6ICdcXHUyMDAyJyxcbiAgICAnRXBzaWxvbic6ICdcXHUwMzk1JyxcbiAgICAnZXBzaWxvbic6ICdcXHUwM0I1JyxcbiAgICAnZXF1aXYnOiAnXFx1MjI2MScsXG4gICAgJ0V0YSc6ICdcXHUwMzk3JyxcbiAgICAnZXRhJzogJ1xcdTAzQjcnLFxuICAgICdFVEgnOiAnXFx1MDBEMCcsXG4gICAgJ2V0aCc6ICdcXHUwMEYwJyxcbiAgICAnRXVtbCc6ICdcXHUwMENCJyxcbiAgICAnZXVtbCc6ICdcXHUwMEVCJyxcbiAgICAnZXVybyc6ICdcXHUyMEFDJyxcbiAgICAnZXhpc3QnOiAnXFx1MjIwMycsXG4gICAgJ2Zub2YnOiAnXFx1MDE5MicsXG4gICAgJ2ZvcmFsbCc6ICdcXHUyMjAwJyxcbiAgICAnZnJhYzEyJzogJ1xcdTAwQkQnLFxuICAgICdmcmFjMTQnOiAnXFx1MDBCQycsXG4gICAgJ2ZyYWMzNCc6ICdcXHUwMEJFJyxcbiAgICAnZnJhc2wnOiAnXFx1MjA0NCcsXG4gICAgJ0dhbW1hJzogJ1xcdTAzOTMnLFxuICAgICdnYW1tYSc6ICdcXHUwM0IzJyxcbiAgICAnZ2UnOiAnXFx1MjI2NScsXG4gICAgJ2d0JzogJz4nLFxuICAgICdoYXJyJzogJ1xcdTIxOTQnLFxuICAgICdoQXJyJzogJ1xcdTIxRDQnLFxuICAgICdoZWFydHMnOiAnXFx1MjY2NScsXG4gICAgJ2hlbGxpcCc6ICdcXHUyMDI2JyxcbiAgICAnSWFjdXRlJzogJ1xcdTAwQ0QnLFxuICAgICdpYWN1dGUnOiAnXFx1MDBFRCcsXG4gICAgJ0ljaXJjJzogJ1xcdTAwQ0UnLFxuICAgICdpY2lyYyc6ICdcXHUwMEVFJyxcbiAgICAnaWV4Y2wnOiAnXFx1MDBBMScsXG4gICAgJ0lncmF2ZSc6ICdcXHUwMENDJyxcbiAgICAnaWdyYXZlJzogJ1xcdTAwRUMnLFxuICAgICdpbWFnZSc6ICdcXHUyMTExJyxcbiAgICAnaW5maW4nOiAnXFx1MjIxRScsXG4gICAgJ2ludCc6ICdcXHUyMjJCJyxcbiAgICAnSW90YSc6ICdcXHUwMzk5JyxcbiAgICAnaW90YSc6ICdcXHUwM0I5JyxcbiAgICAnaXF1ZXN0JzogJ1xcdTAwQkYnLFxuICAgICdpc2luJzogJ1xcdTIyMDgnLFxuICAgICdJdW1sJzogJ1xcdTAwQ0YnLFxuICAgICdpdW1sJzogJ1xcdTAwRUYnLFxuICAgICdLYXBwYSc6ICdcXHUwMzlBJyxcbiAgICAna2FwcGEnOiAnXFx1MDNCQScsXG4gICAgJ0xhbWJkYSc6ICdcXHUwMzlCJyxcbiAgICAnbGFtYmRhJzogJ1xcdTAzQkInLFxuICAgICdsYW5nJzogJ1xcdTI3RTgnLFxuICAgICdsYXF1byc6ICdcXHUwMEFCJyxcbiAgICAnbGFycic6ICdcXHUyMTkwJyxcbiAgICAnbEFycic6ICdcXHUyMUQwJyxcbiAgICAnbGNlaWwnOiAnXFx1MjMwOCcsXG4gICAgJ2xkcXVvJzogJ1xcdTIwMUMnLFxuICAgICdsZSc6ICdcXHUyMjY0JyxcbiAgICAnbGZsb29yJzogJ1xcdTIzMEEnLFxuICAgICdsb3dhc3QnOiAnXFx1MjIxNycsXG4gICAgJ2xveic6ICdcXHUyNUNBJyxcbiAgICAnbHJtJzogJ1xcdTIwMEUnLFxuICAgICdsc2FxdW8nOiAnXFx1MjAzOScsXG4gICAgJ2xzcXVvJzogJ1xcdTIwMTgnLFxuICAgICdsdCc6ICc8JyxcbiAgICAnbWFjcic6ICdcXHUwMEFGJyxcbiAgICAnbWRhc2gnOiAnXFx1MjAxNCcsXG4gICAgJ21pY3JvJzogJ1xcdTAwQjUnLFxuICAgICdtaWRkb3QnOiAnXFx1MDBCNycsXG4gICAgJ21pbnVzJzogJ1xcdTIyMTInLFxuICAgICdNdSc6ICdcXHUwMzlDJyxcbiAgICAnbXUnOiAnXFx1MDNCQycsXG4gICAgJ25hYmxhJzogJ1xcdTIyMDcnLFxuICAgICduYnNwJzogJ1xcdTAwQTAnLFxuICAgICduZGFzaCc6ICdcXHUyMDEzJyxcbiAgICAnbmUnOiAnXFx1MjI2MCcsXG4gICAgJ25pJzogJ1xcdTIyMEInLFxuICAgICdub3QnOiAnXFx1MDBBQycsXG4gICAgJ25vdGluJzogJ1xcdTIyMDknLFxuICAgICduc3ViJzogJ1xcdTIyODQnLFxuICAgICdOdGlsZGUnOiAnXFx1MDBEMScsXG4gICAgJ250aWxkZSc6ICdcXHUwMEYxJyxcbiAgICAnTnUnOiAnXFx1MDM5RCcsXG4gICAgJ251JzogJ1xcdTAzQkQnLFxuICAgICdPYWN1dGUnOiAnXFx1MDBEMycsXG4gICAgJ29hY3V0ZSc6ICdcXHUwMEYzJyxcbiAgICAnT2NpcmMnOiAnXFx1MDBENCcsXG4gICAgJ29jaXJjJzogJ1xcdTAwRjQnLFxuICAgICdPRWxpZyc6ICdcXHUwMTUyJyxcbiAgICAnb2VsaWcnOiAnXFx1MDE1MycsXG4gICAgJ09ncmF2ZSc6ICdcXHUwMEQyJyxcbiAgICAnb2dyYXZlJzogJ1xcdTAwRjInLFxuICAgICdvbGluZSc6ICdcXHUyMDNFJyxcbiAgICAnT21lZ2EnOiAnXFx1MDNBOScsXG4gICAgJ29tZWdhJzogJ1xcdTAzQzknLFxuICAgICdPbWljcm9uJzogJ1xcdTAzOUYnLFxuICAgICdvbWljcm9uJzogJ1xcdTAzQkYnLFxuICAgICdvcGx1cyc6ICdcXHUyMjk1JyxcbiAgICAnb3InOiAnXFx1MjIyOCcsXG4gICAgJ29yZGYnOiAnXFx1MDBBQScsXG4gICAgJ29yZG0nOiAnXFx1MDBCQScsXG4gICAgJ09zbGFzaCc6ICdcXHUwMEQ4JyxcbiAgICAnb3NsYXNoJzogJ1xcdTAwRjgnLFxuICAgICdPdGlsZGUnOiAnXFx1MDBENScsXG4gICAgJ290aWxkZSc6ICdcXHUwMEY1JyxcbiAgICAnb3RpbWVzJzogJ1xcdTIyOTcnLFxuICAgICdPdW1sJzogJ1xcdTAwRDYnLFxuICAgICdvdW1sJzogJ1xcdTAwRjYnLFxuICAgICdwYXJhJzogJ1xcdTAwQjYnLFxuICAgICdwZXJtaWwnOiAnXFx1MjAzMCcsXG4gICAgJ3BlcnAnOiAnXFx1MjJBNScsXG4gICAgJ1BoaSc6ICdcXHUwM0E2JyxcbiAgICAncGhpJzogJ1xcdTAzQzYnLFxuICAgICdQaSc6ICdcXHUwM0EwJyxcbiAgICAncGknOiAnXFx1MDNDMCcsXG4gICAgJ3Bpdic6ICdcXHUwM0Q2JyxcbiAgICAncGx1c21uJzogJ1xcdTAwQjEnLFxuICAgICdwb3VuZCc6ICdcXHUwMEEzJyxcbiAgICAncHJpbWUnOiAnXFx1MjAzMicsXG4gICAgJ1ByaW1lJzogJ1xcdTIwMzMnLFxuICAgICdwcm9kJzogJ1xcdTIyMEYnLFxuICAgICdwcm9wJzogJ1xcdTIyMUQnLFxuICAgICdQc2knOiAnXFx1MDNBOCcsXG4gICAgJ3BzaSc6ICdcXHUwM0M4JyxcbiAgICAncXVvdCc6ICdcXHUwMDIyJyxcbiAgICAncmFkaWMnOiAnXFx1MjIxQScsXG4gICAgJ3JhbmcnOiAnXFx1MjdFOScsXG4gICAgJ3JhcXVvJzogJ1xcdTAwQkInLFxuICAgICdyYXJyJzogJ1xcdTIxOTInLFxuICAgICdyQXJyJzogJ1xcdTIxRDInLFxuICAgICdyY2VpbCc6ICdcXHUyMzA5JyxcbiAgICAncmRxdW8nOiAnXFx1MjAxRCcsXG4gICAgJ3JlYWwnOiAnXFx1MjExQycsXG4gICAgJ3JlZyc6ICdcXHUwMEFFJyxcbiAgICAncmZsb29yJzogJ1xcdTIzMEInLFxuICAgICdSaG8nOiAnXFx1MDNBMScsXG4gICAgJ3Jobyc6ICdcXHUwM0MxJyxcbiAgICAncmxtJzogJ1xcdTIwMEYnLFxuICAgICdyc2FxdW8nOiAnXFx1MjAzQScsXG4gICAgJ3JzcXVvJzogJ1xcdTIwMTknLFxuICAgICdzYnF1byc6ICdcXHUyMDFBJyxcbiAgICAnU2Nhcm9uJzogJ1xcdTAxNjAnLFxuICAgICdzY2Fyb24nOiAnXFx1MDE2MScsXG4gICAgJ3Nkb3QnOiAnXFx1MjJDNScsXG4gICAgJ3NlY3QnOiAnXFx1MDBBNycsXG4gICAgJ3NoeSc6ICdcXHUwMEFEJyxcbiAgICAnU2lnbWEnOiAnXFx1MDNBMycsXG4gICAgJ3NpZ21hJzogJ1xcdTAzQzMnLFxuICAgICdzaWdtYWYnOiAnXFx1MDNDMicsXG4gICAgJ3NpbSc6ICdcXHUyMjNDJyxcbiAgICAnc3BhZGVzJzogJ1xcdTI2NjAnLFxuICAgICdzdWInOiAnXFx1MjI4MicsXG4gICAgJ3N1YmUnOiAnXFx1MjI4NicsXG4gICAgJ3N1bSc6ICdcXHUyMjExJyxcbiAgICAnc3VwJzogJ1xcdTIyODMnLFxuICAgICdzdXAxJzogJ1xcdTAwQjknLFxuICAgICdzdXAyJzogJ1xcdTAwQjInLFxuICAgICdzdXAzJzogJ1xcdTAwQjMnLFxuICAgICdzdXBlJzogJ1xcdTIyODcnLFxuICAgICdzemxpZyc6ICdcXHUwMERGJyxcbiAgICAnVGF1JzogJ1xcdTAzQTQnLFxuICAgICd0YXUnOiAnXFx1MDNDNCcsXG4gICAgJ3RoZXJlNCc6ICdcXHUyMjM0JyxcbiAgICAnVGhldGEnOiAnXFx1MDM5OCcsXG4gICAgJ3RoZXRhJzogJ1xcdTAzQjgnLFxuICAgICd0aGV0YXN5bSc6ICdcXHUwM0QxJyxcbiAgICAndGhpbnNwJzogJ1xcdTIwMDknLFxuICAgICdUSE9STic6ICdcXHUwMERFJyxcbiAgICAndGhvcm4nOiAnXFx1MDBGRScsXG4gICAgJ3RpbGRlJzogJ1xcdTAyREMnLFxuICAgICd0aW1lcyc6ICdcXHUwMEQ3JyxcbiAgICAndHJhZGUnOiAnXFx1MjEyMicsXG4gICAgJ1VhY3V0ZSc6ICdcXHUwMERBJyxcbiAgICAndWFjdXRlJzogJ1xcdTAwRkEnLFxuICAgICd1YXJyJzogJ1xcdTIxOTEnLFxuICAgICd1QXJyJzogJ1xcdTIxRDEnLFxuICAgICdVY2lyYyc6ICdcXHUwMERCJyxcbiAgICAndWNpcmMnOiAnXFx1MDBGQicsXG4gICAgJ1VncmF2ZSc6ICdcXHUwMEQ5JyxcbiAgICAndWdyYXZlJzogJ1xcdTAwRjknLFxuICAgICd1bWwnOiAnXFx1MDBBOCcsXG4gICAgJ3Vwc2loJzogJ1xcdTAzRDInLFxuICAgICdVcHNpbG9uJzogJ1xcdTAzQTUnLFxuICAgICd1cHNpbG9uJzogJ1xcdTAzQzUnLFxuICAgICdVdW1sJzogJ1xcdTAwREMnLFxuICAgICd1dW1sJzogJ1xcdTAwRkMnLFxuICAgICd3ZWllcnAnOiAnXFx1MjExOCcsXG4gICAgJ1hpJzogJ1xcdTAzOUUnLFxuICAgICd4aSc6ICdcXHUwM0JFJyxcbiAgICAnWWFjdXRlJzogJ1xcdTAwREQnLFxuICAgICd5YWN1dGUnOiAnXFx1MDBGRCcsXG4gICAgJ3llbic6ICdcXHUwMEE1JyxcbiAgICAneXVtbCc6ICdcXHUwMEZGJyxcbiAgICAnWXVtbCc6ICdcXHUwMTc4JyxcbiAgICAnWmV0YSc6ICdcXHUwMzk2JyxcbiAgICAnemV0YSc6ICdcXHUwM0I2JyxcbiAgICAnendqJzogJ1xcdTIwMEQnLFxuICAgICd6d25qJzogJ1xcdTIwMEMnLFxufTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBIdG1sVGFnRGVmaW5pdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX18wXG4gICAgICovXG4gICAgZnVuY3Rpb24gSHRtbFRhZ0RlZmluaXRpb24oX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGNsb3NlZEJ5Q2hpbGRyZW4gPSBfYi5jbG9zZWRCeUNoaWxkcmVuLCByZXF1aXJlZFBhcmVudHMgPSBfYi5yZXF1aXJlZFBhcmVudHMsIGltcGxpY2l0TmFtZXNwYWNlUHJlZml4ID0gX2IuaW1wbGljaXROYW1lc3BhY2VQcmVmaXgsIF9jID0gX2IuY29udGVudFR5cGUsIGNvbnRlbnRUeXBlID0gX2MgPT09IHZvaWQgMCA/IFRhZ0NvbnRlbnRUeXBlLlBBUlNBQkxFX0RBVEEgOiBfYywgX2QgPSBfYi5jbG9zZWRCeVBhcmVudCwgY2xvc2VkQnlQYXJlbnQgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgX2UgPSBfYi5pc1ZvaWQsIGlzVm9pZCA9IF9lID09PSB2b2lkIDAgPyBmYWxzZSA6IF9lLCBfZiA9IF9iLmlnbm9yZUZpcnN0TGYsIGlnbm9yZUZpcnN0TGYgPSBfZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZjtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jbG9zZWRCeUNoaWxkcmVuID0ge307XG4gICAgICAgIHRoaXMuY2xvc2VkQnlQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5TZWxmQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgaWYgKGNsb3NlZEJ5Q2hpbGRyZW4gJiYgY2xvc2VkQnlDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjbG9zZWRCeUNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKHRhZ05hbWUpIHsgcmV0dXJuIF90aGlzLmNsb3NlZEJ5Q2hpbGRyZW5bdGFnTmFtZV0gPSB0cnVlOyB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzVm9pZCA9IGlzVm9pZDtcbiAgICAgICAgdGhpcy5jbG9zZWRCeVBhcmVudCA9IGNsb3NlZEJ5UGFyZW50IHx8IGlzVm9pZDtcbiAgICAgICAgaWYgKHJlcXVpcmVkUGFyZW50cyAmJiByZXF1aXJlZFBhcmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlZFBhcmVudHMgPSB7fTtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBwYXJlbnQgaXMgdGhlIGxpc3QgaXMgYXV0b21hdGljYWxseSB3aGVuIG5vbmUgb2YgdGhlIGxpc3RlZCBwYXJlbnRzIGFyZSBwcmVzZW50XG4gICAgICAgICAgICB0aGlzLnBhcmVudFRvQWRkID0gcmVxdWlyZWRQYXJlbnRzWzBdO1xuICAgICAgICAgICAgcmVxdWlyZWRQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHRhZ05hbWUpIHsgcmV0dXJuIF90aGlzLnJlcXVpcmVkUGFyZW50c1t0YWdOYW1lXSA9IHRydWU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW1wbGljaXROYW1lc3BhY2VQcmVmaXggPSBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeCB8fCBudWxsO1xuICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gY29udGVudFR5cGU7XG4gICAgICAgIHRoaXMuaWdub3JlRmlyc3RMZiA9IGlnbm9yZUZpcnN0TGY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3VycmVudFBhcmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHRtbFRhZ0RlZmluaXRpb24ucHJvdG90eXBlLnJlcXVpcmVFeHRyYVBhcmVudCA9IGZ1bmN0aW9uIChjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5yZXF1aXJlZFBhcmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxjUGFyZW50ID0gY3VycmVudFBhcmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1BhcmVudFRlbXBsYXRlID0gbGNQYXJlbnQgPT09ICd0ZW1wbGF0ZScgfHwgY3VycmVudFBhcmVudCA9PT0gJ25nLXRlbXBsYXRlJztcbiAgICAgICAgcmV0dXJuICFpc1BhcmVudFRlbXBsYXRlICYmIHRoaXMucmVxdWlyZWRQYXJlbnRzW2xjUGFyZW50XSAhPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdG1sVGFnRGVmaW5pdGlvbi5wcm90b3R5cGUuaXNDbG9zZWRCeUNoaWxkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWb2lkIHx8IG5hbWUudG9Mb3dlckNhc2UoKSBpbiB0aGlzLmNsb3NlZEJ5Q2hpbGRyZW47XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbFRhZ0RlZmluaXRpb247XG59KCkpO1xuLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1MS9zeW50YXguaHRtbCNvcHRpb25hbC10YWdzXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IGZ1bGx5IGNvbmZvcm0gdG8gdGhlIEhUTUw1IHNwZWMuXG52YXIgVEFHX0RFRklOSVRJT05TID0ge1xuICAgICdiYXNlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICdtZXRhJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICdhcmVhJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICdlbWJlZCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnbGluayc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnaW1nJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICdpbnB1dCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAncGFyYW0nOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ2hyJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICdicic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnc291cmNlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICd0cmFjayc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnd2JyJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICdwJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHtcbiAgICAgICAgY2xvc2VkQnlDaGlsZHJlbjogW1xuICAgICAgICAgICAgJ2FkZHJlc3MnLCAnYXJ0aWNsZScsICdhc2lkZScsICdibG9ja3F1b3RlJywgJ2RpdicsICdkbCcsICdmaWVsZHNldCcsICdmb290ZXInLCAnZm9ybScsXG4gICAgICAgICAgICAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsXG4gICAgICAgICAgICAnbWFpbicsICduYXYnLCAnb2wnLCAncCcsICdwcmUnLCAnc2VjdGlvbicsICd0YWJsZScsICd1bCdcbiAgICAgICAgXSxcbiAgICAgICAgY2xvc2VkQnlQYXJlbnQ6IHRydWVcbiAgICB9KSxcbiAgICAndGhlYWQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3Rib2R5JywgJ3Rmb290J10gfSksXG4gICAgJ3Rib2R5JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keScsICd0Zm9vdCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAndGZvb3QnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3Rib2R5J10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICd0cic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7XG4gICAgICAgIGNsb3NlZEJ5Q2hpbGRyZW46IFsndHInXSxcbiAgICAgICAgcmVxdWlyZWRQYXJlbnRzOiBbJ3Rib2R5JywgJ3Rmb290JywgJ3RoZWFkJ10sXG4gICAgICAgIGNsb3NlZEJ5UGFyZW50OiB0cnVlXG4gICAgfSksXG4gICAgJ3RkJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0ZCcsICd0aCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAndGgnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3RkJywgJ3RoJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdjb2wnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyByZXF1aXJlZFBhcmVudHM6IFsnY29sZ3JvdXAnXSwgaXNWb2lkOiB0cnVlIH0pLFxuICAgICdzdmcnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeDogJ3N2ZycgfSksXG4gICAgJ21hdGgnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeDogJ21hdGgnIH0pLFxuICAgICdsaSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnbGknXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgJ2R0JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydkdCcsICdkZCddIH0pLFxuICAgICdkZCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnZHQnLCAnZGQnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgJ3JiJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydyYicsICdydCcsICdydGMnLCAncnAnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgJ3J0JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydyYicsICdydCcsICdydGMnLCAncnAnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgJ3J0Yyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdycCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnQnLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdvcHRncm91cCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnb3B0Z3JvdXAnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgJ29wdGlvbic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnb3B0aW9uJywgJ29wdGdyb3VwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdwcmUnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpZ25vcmVGaXJzdExmOiB0cnVlIH0pLFxuICAgICdsaXN0aW5nJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaWdub3JlRmlyc3RMZjogdHJ1ZSB9KSxcbiAgICAnc3R5bGUnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuUkFXX1RFWFQgfSksXG4gICAgJ3NjcmlwdCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNvbnRlbnRUeXBlOiBUYWdDb250ZW50VHlwZS5SQVdfVEVYVCB9KSxcbiAgICAndGl0bGUnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhUIH0pLFxuICAgICd0ZXh0YXJlYSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNvbnRlbnRUeXBlOiBUYWdDb250ZW50VHlwZS5FU0NBUEFCTEVfUkFXX1RFWFQsIGlnbm9yZUZpcnN0TGY6IHRydWUgfSksXG59O1xudmFyIF9ERUZBVUxUX1RBR19ERUZJTklUSU9OID0gbmV3IEh0bWxUYWdEZWZpbml0aW9uKCk7XG4vKipcbiAqIEBwYXJhbSB7P30gdGFnTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0SHRtbFRhZ0RlZmluaXRpb24odGFnTmFtZSkge1xuICAgIHJldHVybiBUQUdfREVGSU5JVElPTlNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBfREVGQVVMVF9UQUdfREVGSU5JVElPTjtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfU0VMRUNUT1JfUkVHRVhQID0gbmV3IFJlZ0V4cCgnKFxcXFw6bm90XFxcXCgpfCcgK1xuICAgICcoWy1cXFxcd10rKXwnICtcbiAgICAnKD86XFxcXC4oWy1cXFxcd10rKSl8JyArXG4gICAgLy8gXCItXCIgc2hvdWxkIGFwcGVhciBmaXJzdCBpbiB0aGUgcmVnZXhwIGJlbG93IGFzIEZGMzEgcGFyc2VzIFwiWy4tXFx3XVwiIGFzIGEgcmFuZ2VcbiAgICAnKD86XFxcXFsoWy0uXFxcXHcqXSspKD86PShbXFxcIlxcJ10/KShbXlxcXFxdXFxcIlxcJ10qKVxcXFw1KT9cXFxcXSl8JyArXG4gICAgLy8gXCJbbmFtZT1cInZhbHVlXCJdXCIsXG4gICAgLy8gXCJbbmFtZT0ndmFsdWUnXVwiXG4gICAgJyhcXFxcKSl8JyArXG4gICAgJyhcXFxccyosXFxcXHMqKScsIC8vIFwiLFwiXG4nZycpO1xuLyoqXG4gKiBBIGNzcyBzZWxlY3RvciBjb250YWlucyBhbiBlbGVtZW50IG5hbWUsXG4gKiBjc3MgY2xhc3NlcyBhbmQgYXR0cmlidXRlL3ZhbHVlIHBhaXJzIHdpdGggdGhlIHB1cnBvc2VcbiAqIG9mIHNlbGVjdGluZyBzdWJzZXRzIG91dCBvZiB0aGVtLlxuICovXG52YXIgQ3NzU2VsZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENzc1NlbGVjdG9yKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNsYXNzTmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5hdHRycyA9IFtdO1xuICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDc3NTZWxlY3Rvci5wYXJzZSA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIF9hZGRSZXN1bHQgPSBmdW5jdGlvbiAocmVzLCBjc3NTZWwpIHtcbiAgICAgICAgICAgIGlmIChjc3NTZWwubm90U2VsZWN0b3JzLmxlbmd0aCA+IDAgJiYgIWNzc1NlbC5lbGVtZW50ICYmIGNzc1NlbC5jbGFzc05hbWVzLmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgY3NzU2VsLmF0dHJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgY3NzU2VsLmVsZW1lbnQgPSAnKic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMucHVzaChjc3NTZWwpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjc3NTZWxlY3RvciA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VycmVudCA9IGNzc1NlbGVjdG9yO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbk5vdCA9IGZhbHNlO1xuICAgICAgICBfU0VMRUNUT1JfUkVHRVhQLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChtYXRjaCA9IF9TRUxFQ1RPUl9SRUdFWFAuZXhlYyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgIGlmIChpbk5vdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lc3RpbmcgOm5vdCBpcyBub3QgYWxsb3dlZCBpbiBhIHNlbGVjdG9yJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluTm90ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gbmV3IENzc1NlbGVjdG9yKCk7XG4gICAgICAgICAgICAgICAgY3NzU2VsZWN0b3Iubm90U2VsZWN0b3JzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbMl0pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnNldEVsZW1lbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5hZGRDbGFzc05hbWUobWF0Y2hbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5hZGRBdHRyaWJ1dGUobWF0Y2hbNF0sIG1hdGNoWzZdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs3XSkge1xuICAgICAgICAgICAgICAgIGluTm90ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNzc1NlbGVjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzhdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluTm90KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVsdGlwbGUgc2VsZWN0b3JzIGluIDpub3QgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2FkZFJlc3VsdChyZXN1bHRzLCBjc3NTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgY3NzU2VsZWN0b3IgPSBjdXJyZW50ID0gbmV3IENzc1NlbGVjdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX2FkZFJlc3VsdChyZXN1bHRzLCBjc3NTZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuaXNFbGVtZW50U2VsZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0VsZW1lbnRTZWxlY3RvcigpICYmIHRoaXMuY2xhc3NOYW1lcy5sZW5ndGggPT0gMCAmJiB0aGlzLmF0dHJzLmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycy5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS5oYXNFbGVtZW50U2VsZWN0b3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAhIXRoaXMuZWxlbWVudDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuc2V0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIGlmIChlbGVtZW50ID09PSB2b2lkIDApIHsgZWxlbWVudCA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYSB0ZW1wbGF0ZSBzdHJpbmcgZm9yIGFuIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3Rvci5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS5nZXRNYXRjaGluZ0VsZW1lbnRUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFnTmFtZSA9IHRoaXMuZWxlbWVudCB8fCAnZGl2JztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NBdHRyID0gdGhpcy5jbGFzc05hbWVzLmxlbmd0aCA+IDAgPyBcIiBjbGFzcz1cXFwiXCIgKyB0aGlzLmNsYXNzTmFtZXMuam9pbignICcpICsgXCJcXFwiXCIgOiAnJztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0cnMgPSAnJztcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHRoaXMuYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJOYW1lID0gdGhpcy5hdHRyc1tpXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJWYWx1ZSA9IHRoaXMuYXR0cnNbaSArIDFdICE9PSAnJyA/IFwiPVxcXCJcIiArIHRoaXMuYXR0cnNbaSArIDFdICsgXCJcXFwiXCIgOiAnJztcbiAgICAgICAgICAgIGF0dHJzICs9IFwiIFwiICsgYXR0ck5hbWUgKyBhdHRyVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldEh0bWxUYWdEZWZpbml0aW9uKHRhZ05hbWUpLmlzVm9pZCA/IFwiPFwiICsgdGFnTmFtZSArIGNsYXNzQXR0ciArIGF0dHJzICsgXCIvPlwiIDpcbiAgICAgICAgICAgIFwiPFwiICsgdGFnTmFtZSArIGNsYXNzQXR0ciArIGF0dHJzICsgXCI+PC9cIiArIHRhZ05hbWUgKyBcIj5cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gJyc7IH1cbiAgICAgICAgdGhpcy5hdHRycy5wdXNoKG5hbWUsIHZhbHVlICYmIHZhbHVlLnRvTG93ZXJDYXNlKCkgfHwgJycpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuYWRkQ2xhc3NOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHsgdGhpcy5jbGFzc05hbWVzLnB1c2gobmFtZS50b0xvd2VyQ2FzZSgpKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzID0gdGhpcy5lbGVtZW50IHx8ICcnO1xuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWVzKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoa2xhc3MpIHsgcmV0dXJuIHJlcyArPSBcIi5cIiArIGtsYXNzOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdHRycykge1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHRoaXMuYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gdGhpcy5hdHRyc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IHRoaXMuYXR0cnNbaSArIDFdO1xuICAgICAgICAgICAgICAgIHJlcyArPSBcIltcIiArIG5hbWUgKyAodmFsdWUgPyAnPScgKyB2YWx1ZSA6ICcnKSArIFwiXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90U2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKG5vdFNlbGVjdG9yKSB7IHJldHVybiByZXMgKz0gXCI6bm90KFwiICsgbm90U2VsZWN0b3IgKyBcIilcIjsgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gQ3NzU2VsZWN0b3I7XG59KCkpO1xuLyoqXG4gKiBSZWFkcyBhIGxpc3Qgb2YgQ3NzU2VsZWN0b3JzIGFuZCBhbGxvd3MgdG8gY2FsY3VsYXRlIHdoaWNoIG9uZXNcbiAqIGFyZSBjb250YWluZWQgaW4gYSBnaXZlbiBDc3NTZWxlY3Rvci5cbiAqL1xudmFyIFNlbGVjdG9yTWF0Y2hlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VsZWN0b3JNYXRjaGVyKCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9lbGVtZW50UGFydGlhbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY2xhc3NNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NsYXNzUGFydGlhbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYXR0clZhbHVlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9hdHRyVmFsdWVQYXJ0aWFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9saXN0Q29udGV4dHMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub3RTZWxlY3RvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdG9yTWF0Y2hlci5jcmVhdGVOb3RNYXRjaGVyID0gZnVuY3Rpb24gKG5vdFNlbGVjdG9ycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub3RNYXRjaGVyID0gbmV3IFNlbGVjdG9yTWF0Y2hlcigpO1xuICAgICAgICBub3RNYXRjaGVyLmFkZFNlbGVjdGFibGVzKG5vdFNlbGVjdG9ycywgbnVsbCk7XG4gICAgICAgIHJldHVybiBub3RNYXRjaGVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc3NTZWxlY3RvcnNcbiAgICAgKiBAcGFyYW0gez89fSBjYWxsYmFja0N0eHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuYWRkU2VsZWN0YWJsZXMgPSBmdW5jdGlvbiAoY3NzU2VsZWN0b3JzLCBjYWxsYmFja0N0eHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGlzdENvbnRleHQgPSAoKG51bGwpKTtcbiAgICAgICAgaWYgKGNzc1NlbGVjdG9ycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsaXN0Q29udGV4dCA9IG5ldyBTZWxlY3Rvckxpc3RDb250ZXh0KGNzc1NlbGVjdG9ycyk7XG4gICAgICAgICAgICB0aGlzLl9saXN0Q29udGV4dHMucHVzaChsaXN0Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGNzc1NlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fYWRkU2VsZWN0YWJsZShjc3NTZWxlY3RvcnNbaV0sIGNhbGxiYWNrQ3R4dCwgbGlzdENvbnRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIGZvdW5kIGxhdGVyIG9uIGJ5IGNhbGxpbmcgYG1hdGNoYC5cbiAgICAgKiBAcGFyYW0gez99IGNzc1NlbGVjdG9yIEEgY3NzIHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja0N0eHQgQW4gb3BhcXVlIG9iamVjdCB0aGF0IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGNhbGxiYWNrIG9mIHRoZSBgbWF0Y2hgIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHs/fSBsaXN0Q29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fYWRkU2VsZWN0YWJsZSA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvciwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVyID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IGNzc1NlbGVjdG9yLmVsZW1lbnQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzTmFtZXMgPSBjc3NTZWxlY3Rvci5jbGFzc05hbWVzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRycyA9IGNzc1NlbGVjdG9yLmF0dHJzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxlY3RhYmxlID0gbmV3IFNlbGVjdG9yQ29udGV4dChjc3NTZWxlY3RvciwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1Rlcm1pbmFsID0gYXR0cnMubGVuZ3RoID09PSAwICYmIGNsYXNzTmFtZXMubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgaWYgKGlzVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbChtYXRjaGVyLl9lbGVtZW50TWFwLCBlbGVtZW50LCBzZWxlY3RhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdGNoZXIgPSB0aGlzLl9hZGRQYXJ0aWFsKG1hdGNoZXIuX2VsZW1lbnRQYXJ0aWFsTWFwLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1Rlcm1pbmFsID0gYXR0cnMubGVuZ3RoID09PSAwICYmIGkgPT09IGNsYXNzTmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc1Rlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRlcm1pbmFsKG1hdGNoZXIuX2NsYXNzTWFwLCBjbGFzc05hbWUsIHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwobWF0Y2hlci5fY2xhc3NQYXJ0aWFsTWFwLCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzVGVybWluYWwgPSBpID09PSBhdHRycy5sZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBhdHRyc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXJtaW5hbE1hcCA9IG1hdGNoZXIuX2F0dHJWYWx1ZU1hcDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVybWluYWxWYWx1ZXNNYXAgPSB0ZXJtaW5hbE1hcC5nZXQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGVybWluYWxWYWx1ZXNNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsVmFsdWVzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYWxNYXAuc2V0KG5hbWUsIHRlcm1pbmFsVmFsdWVzTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbCh0ZXJtaW5hbFZhbHVlc01hcCwgdmFsdWUsIHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydGlhbE1hcCA9IG1hdGNoZXIuX2F0dHJWYWx1ZVBhcnRpYWxNYXA7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRpYWxWYWx1ZXNNYXAgPSBwYXJ0aWFsTWFwLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJ0aWFsVmFsdWVzTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsVmFsdWVzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbE1hcC5zZXQobmFtZSwgcGFydGlhbFZhbHVlc01hcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtYXBcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdGFibGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX2FkZFRlcm1pbmFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSwgc2VsZWN0YWJsZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXJtaW5hbExpc3QgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIXRlcm1pbmFsTGlzdCkge1xuICAgICAgICAgICAgdGVybWluYWxMaXN0ID0gW107XG4gICAgICAgICAgICBtYXAuc2V0KG5hbWUsIHRlcm1pbmFsTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVybWluYWxMaXN0LnB1c2goc2VsZWN0YWJsZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1hcFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fYWRkUGFydGlhbCA9IGZ1bmN0aW9uIChtYXAsIG5hbWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlciA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmICghbWF0Y2hlcikge1xuICAgICAgICAgICAgbWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgICAgIG1hcC5zZXQobmFtZSwgbWF0Y2hlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHZpYSBgYWRkU2VsZWN0YWJsZWBcbiAgICAgKiB3aG9zZSBjc3Mgc2VsZWN0b3IgaXMgY29udGFpbmVkIGluIHRoZSBnaXZlbiBjc3Mgc2VsZWN0b3IuXG4gICAgICogQHBhcmFtIHs/fSBjc3NTZWxlY3RvciBBIGNzcyBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gbWF0Y2hlZENhbGxiYWNrIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgb2JqZWN0IGhhbmRlZCBpbnRvIGBhZGRTZWxlY3RhYmxlYFxuICAgICAqIEByZXR1cm4gez99IGJvb2xlYW4gdHJ1ZSBpZiBhIG1hdGNoIHdhcyBmb3VuZFxuICAgICAqL1xuICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAoY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9ICgoY3NzU2VsZWN0b3IuZWxlbWVudCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc05hbWVzID0gY3NzU2VsZWN0b3IuY2xhc3NOYW1lcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0cnMgPSBjc3NTZWxlY3Rvci5hdHRycztcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHRoaXMuX2xpc3RDb250ZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzW2ldLmFscmVhZHlNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hUZXJtaW5hbCh0aGlzLl9lbGVtZW50TWFwLCBlbGVtZW50LCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoUGFydGlhbCh0aGlzLl9lbGVtZW50UGFydGlhbE1hcCwgZWxlbWVudCwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHxcbiAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgaWYgKGNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tpXTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFRlcm1pbmFsKHRoaXMuX2NsYXNzTWFwLCBjbGFzc05hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFBhcnRpYWwodGhpcy5fY2xhc3NQYXJ0aWFsTWFwLCBjbGFzc05hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gYXR0cnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBhdHRyc1tpICsgMV07XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVybWluYWxWYWx1ZXNNYXAgPSAoKHRoaXMuX2F0dHJWYWx1ZU1hcC5nZXQobmFtZSkpKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoVGVybWluYWwodGVybWluYWxWYWx1ZXNNYXAsICcnLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoVGVybWluYWwodGVybWluYWxWYWx1ZXNNYXAsIHZhbHVlLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydGlhbFZhbHVlc01hcCA9ICgodGhpcy5fYXR0clZhbHVlUGFydGlhbE1hcC5nZXQobmFtZSkpKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hQYXJ0aWFsKHBhcnRpYWxWYWx1ZXNNYXAsICcnLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoUGFydGlhbChwYXJ0aWFsVmFsdWVzTWFwLCB2YWx1ZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gbWFwXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBjc3NTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gbWF0Y2hlZENhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9tYXRjaFRlcm1pbmFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykge1xuICAgICAgICBpZiAoIW1hcCB8fCB0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxlY3RhYmxlcyA9IG1hcC5nZXQobmFtZSkgfHwgW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJTZWxlY3RhYmxlcyA9ICgobWFwLmdldCgnKicpKSk7XG4gICAgICAgIGlmIChzdGFyU2VsZWN0YWJsZXMpIHtcbiAgICAgICAgICAgIHNlbGVjdGFibGVzID0gc2VsZWN0YWJsZXMuY29uY2F0KHN0YXJTZWxlY3RhYmxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdGFibGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdGFibGU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgc2VsZWN0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNlbGVjdGFibGUgPSBzZWxlY3RhYmxlc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNlbGVjdGFibGUuZmluYWxpemUoY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gbWFwXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBjc3NTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gbWF0Y2hlZENhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9tYXRjaFBhcnRpYWwgPSBmdW5jdGlvbiAobWFwLCBuYW1lLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB7XG4gICAgICAgIGlmICghbWFwIHx8IHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5lc3RlZFNlbGVjdG9yID0gbWFwLmdldChuYW1lKTtcbiAgICAgICAgaWYgKCFuZXN0ZWRTZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8ocGVyZik6IGdldCByaWQgb2YgcmVjdXJzaW9uIGFuZCBtZWFzdXJlIGFnYWluXG4gICAgICAgIC8vIFRPRE8ocGVyZik6IGRvbid0IHBhc3MgdGhlIHdob2xlIHNlbGVjdG9yIGludG8gdGhlIHJlY3Vyc2lvbixcbiAgICAgICAgLy8gYnV0IG9ubHkgdGhlIG5vdCBwcm9jZXNzZWQgcGFydHNcbiAgICAgICAgcmV0dXJuIG5lc3RlZFNlbGVjdG9yLm1hdGNoKGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spO1xuICAgIH07XG4gICAgcmV0dXJuIFNlbGVjdG9yTWF0Y2hlcjtcbn0oKSk7XG52YXIgU2VsZWN0b3JMaXN0Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZWxlY3Rvckxpc3RDb250ZXh0KHNlbGVjdG9ycykge1xuICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IHNlbGVjdG9ycztcbiAgICAgICAgdGhpcy5hbHJlYWR5TWF0Y2hlZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gU2VsZWN0b3JMaXN0Q29udGV4dDtcbn0oKSk7XG52YXIgU2VsZWN0b3JDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBjYkNvbnRleHRcbiAgICAgKiBAcGFyYW0gez99IGxpc3RDb250ZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gU2VsZWN0b3JDb250ZXh0KHNlbGVjdG9yLCBjYkNvbnRleHQsIGxpc3RDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jYkNvbnRleHQgPSBjYkNvbnRleHQ7XG4gICAgICAgIHRoaXMubGlzdENvbnRleHQgPSBsaXN0Q29udGV4dDtcbiAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMgPSBzZWxlY3Rvci5ub3RTZWxlY3RvcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzU2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3RvckNvbnRleHQucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKGNzc1NlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5ub3RTZWxlY3RvcnMubGVuZ3RoID4gMCAmJiAoIXRoaXMubGlzdENvbnRleHQgfHwgIXRoaXMubGlzdENvbnRleHQuYWxyZWFkeU1hdGNoZWQpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub3RNYXRjaGVyID0gU2VsZWN0b3JNYXRjaGVyLmNyZWF0ZU5vdE1hdGNoZXIodGhpcy5ub3RTZWxlY3RvcnMpO1xuICAgICAgICAgICAgcmVzdWx0ID0gIW5vdE1hdGNoZXIubWF0Y2goY3NzU2VsZWN0b3IsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQgJiYgY2FsbGJhY2sgJiYgKCF0aGlzLmxpc3RDb250ZXh0IHx8ICF0aGlzLmxpc3RDb250ZXh0LmFscmVhZHlNYXRjaGVkKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGlzdENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RDb250ZXh0LmFscmVhZHlNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuc2VsZWN0b3IsIHRoaXMuY2JDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFNlbGVjdG9yQ29udGV4dDtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgTU9EVUxFX1NVRkZJWCA9ICcnO1xudmFyIERBU0hfQ0FTRV9SRUdFWFAgPSAvLSsoW2EtejAtOV0pL2c7XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEByZXR1cm4gez99XG4gKi9cbi8qKlxuICogQHBhcmFtIHs/fSBpbnB1dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZGFzaENhc2VUb0NhbWVsQ2FzZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKERBU0hfQ0FTRV9SRUdFWFAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG1bX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbVsxXS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcGFyYW0gez99IGRlZmF1bHRWYWx1ZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNwbGl0QXRDb2xvbihpbnB1dCwgZGVmYXVsdFZhbHVlcykge1xuICAgIHJldHVybiBfc3BsaXRBdChpbnB1dCwgJzonLCBkZWZhdWx0VmFsdWVzKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpbnB1dFxuICogQHBhcmFtIHs/fSBkZWZhdWx0VmFsdWVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzcGxpdEF0UGVyaW9kKGlucHV0LCBkZWZhdWx0VmFsdWVzKSB7XG4gICAgcmV0dXJuIF9zcGxpdEF0KGlucHV0LCAnLicsIGRlZmF1bHRWYWx1ZXMpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcGFyYW0gez99IGNoYXJhY3RlclxuICogQHBhcmFtIHs/fSBkZWZhdWx0VmFsdWVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfc3BsaXRBdChpbnB1dCwgY2hhcmFjdGVyLCBkZWZhdWx0VmFsdWVzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hhcmFjdGVySW5kZXggPSBpbnB1dC5pbmRleE9mKGNoYXJhY3Rlcik7XG4gICAgaWYgKGNoYXJhY3RlckluZGV4ID09IC0xKVxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlcztcbiAgICByZXR1cm4gW2lucHV0LnNsaWNlKDAsIGNoYXJhY3RlckluZGV4KS50cmltKCksIGlucHV0LnNsaWNlKGNoYXJhY3RlckluZGV4ICsgMSkudHJpbSgpXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gKiBAcGFyYW0gez99IGNvbnRleHRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHZpc2l0VmFsdWUodmFsdWUsIHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBcnJheSgvKiogQHR5cGUgez99ICovICh2YWx1ZSksIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpY3RTdHJpbmdNYXAodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U3RyaW5nTWFwKC8qKiBAdHlwZSB7P30gKi8gKHZhbHVlKSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgdHlwZW9mIHZhbHVlID09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFByaW1pdGl2ZSh2YWx1ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB2aXNpdG9yLnZpc2l0T3RoZXIodmFsdWUsIGNvbnRleHQpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZhbFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbCkge1xuICAgIHJldHVybiB2YWwgIT09IG51bGwgJiYgdmFsICE9PSB1bmRlZmluZWQ7XG59XG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0gez99IHZhbFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbm9VbmRlZmluZWQodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gKChudWxsKSkgOiB2YWw7XG59XG52YXIgVmFsdWVUcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmFsdWVUcmFuc2Zvcm1lcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhcnJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZhbHVlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QXJyYXkgPSBmdW5jdGlvbiAoYXJyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmlzaXRWYWx1ZSh2YWx1ZSwgX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWFwXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcCA9IGZ1bmN0aW9uIChtYXAsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJlc3VsdFtrZXldID0gdmlzaXRWYWx1ZShtYXBba2V5XSwgX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZhbHVlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJpbWl0aXZlID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7IHJldHVybiB2YWx1ZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdE90aGVyID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7IHJldHVybiB2YWx1ZTsgfTtcbiAgICByZXR1cm4gVmFsdWVUcmFuc2Zvcm1lcjtcbn0oKSk7XG52YXIgU3luY0FzeW5jUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN5bmNSZXN1bHRcbiAgICAgKiBAcGFyYW0gez89fSBhc3luY1Jlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN5bmNBc3luY1Jlc3VsdChzeW5jUmVzdWx0LCBhc3luY1Jlc3VsdCkge1xuICAgICAgICBpZiAoYXN5bmNSZXN1bHQgPT09IHZvaWQgMCkgeyBhc3luY1Jlc3VsdCA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5zeW5jUmVzdWx0ID0gc3luY1Jlc3VsdDtcbiAgICAgICAgdGhpcy5hc3luY1Jlc3VsdCA9IGFzeW5jUmVzdWx0O1xuICAgICAgICBpZiAoIWFzeW5jUmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmFzeW5jUmVzdWx0ID0gUHJvbWlzZS5yZXNvbHZlKHN5bmNSZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTeW5jQXN5bmNSZXN1bHQ7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IG1zZ1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3ludGF4RXJyb3IobXNnKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3IgPSBFcnJvcihtc2cpO1xuICAgICgoZXJyb3IpKVtFUlJPUl9TWU5UQVhfRVJST1JdID0gdHJ1ZTtcbiAgICByZXR1cm4gZXJyb3I7XG59XG52YXIgRVJST1JfU1lOVEFYX0VSUk9SID0gJ25nU3ludGF4RXJyb3InO1xuLyoqXG4gKiBAcGFyYW0gez99IGVycm9yXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1N5bnRheEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuICgoZXJyb3IpKVtFUlJPUl9TWU5UQVhfRVJST1JdO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvKFsuKis/Xj0hOiR7fSgpfFtcXF1cXC9cXFxcXSkvZywgJ1xcXFwkMScpO1xufVxudmFyIFNUUklOR19NQVBfUFJPVE8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pO1xuLyoqXG4gKiBAcGFyYW0gez99IG9ialxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RTdHJpbmdNYXAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gU1RSSU5HX01BUF9QUk9UTztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHV0ZjhFbmNvZGUoc3RyKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5jb2RlZCA9ICcnO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSAwOyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29kZVBvaW50ID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAvLyBkZWNvZGUgc3Vycm9nYXRlXG4gICAgICAgIC8vIHNlZSBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+PSAweGQ4MDAgJiYgY29kZVBvaW50IDw9IDB4ZGJmZiAmJiBzdHIubGVuZ3RoID4gKGluZGV4ICsgMSkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvdyA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZiAobG93ID49IDB4ZGMwMCAmJiBsb3cgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSAoKGNvZGVQb2ludCAtIDB4ZDgwMCkgPDwgMTApICsgbG93IC0gMHhkYzAwICsgMHgxMDAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4N2YpIHtcbiAgICAgICAgICAgIGVuY29kZWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8PSAweDdmZikge1xuICAgICAgICAgICAgZW5jb2RlZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweGMwLCAoY29kZVBvaW50ICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICBlbmNvZGVkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGVQb2ludCA+PiAxMikgfCAweGUwLCAoKGNvZGVQb2ludCA+PiA2KSAmIDB4M2YpIHwgMHg4MCwgKGNvZGVQb2ludCAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50IDw9IDB4MWZmZmZmKSB7XG4gICAgICAgICAgICBlbmNvZGVkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweGYwLCAoKGNvZGVQb2ludCA+PiAxMikgJiAweDNmKSB8IDB4ODAsICgoY29kZVBvaW50ID4+IDYpICYgMHgzZikgfCAweDgwLCAoY29kZVBvaW50ICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlZDtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIGdyb3VwIDA6IFwiW3Byb3BdIG9yIChldmVudCkgb3IgQHRyaWdnZXJcIlxuLy8gZ3JvdXAgMTogXCJwcm9wXCIgZnJvbSBcIltwcm9wXVwiXG4vLyBncm91cCAyOiBcImV2ZW50XCIgZnJvbSBcIihldmVudClcIlxuLy8gZ3JvdXAgMzogXCJAdHJpZ2dlclwiIGZyb20gXCJAdHJpZ2dlclwiXG52YXIgSE9TVF9SRUdfRVhQID0gL14oPzooPzpcXFsoW15cXF1dKylcXF0pfCg/OlxcKChbXlxcKV0rKVxcKSkpfChcXEBbLVxcd10rKSQvO1xudmFyIENvbXBpbGVBbmltYXRpb25FbnRyeU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gZGVmaW5pdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uRW50cnlNZXRhZGF0YShuYW1lLCBkZWZpbml0aW9ucykge1xuICAgICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBudWxsOyB9XG4gICAgICAgIGlmIChkZWZpbml0aW9ucyA9PT0gdm9pZCAwKSB7IGRlZmluaXRpb25zID0gbnVsbDsgfVxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25zID0gZGVmaW5pdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uRW50cnlNZXRhZGF0YTtcbn0oKSk7XG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25TdGF0ZU1ldGFkYXRhKCkge1xuICAgIH1cbiAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGE7XG59KCkpO1xudmFyIENvbXBpbGVBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGVOYW1lRXhwclxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YShzdGF0ZU5hbWVFeHByLCBzdHlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGVOYW1lRXhwciA9IHN0YXRlTmFtZUV4cHI7XG4gICAgICAgIF90aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YTtcbn0oQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGEpKTtcbnZhciBDb21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZUNoYW5nZUV4cHJcbiAgICAgKiBAcGFyYW0gez99IHN0ZXBzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhKHN0YXRlQ2hhbmdlRXhwciwgc3RlcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGVDaGFuZ2VFeHByID0gc3RhdGVDaGFuZ2VFeHByO1xuICAgICAgICBfdGhpcy5zdGVwcyA9IHN0ZXBzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGE7XG59KENvbXBpbGVBbmltYXRpb25TdGF0ZU1ldGFkYXRhKSk7XG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEoKSB7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uTWV0YWRhdGE7XG59KCkpO1xudmFyIENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tcGlsZUFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gc3RlcHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YShzdGVwcykge1xuICAgICAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkgeyBzdGVwcyA9IFtdOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhO1xufShDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEpKTtcbnZhciBDb21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICogQHBhcmFtIHs/PX0gc3R5bGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEob2Zmc2V0LCBzdHlsZXMpIHtcbiAgICAgICAgaWYgKHN0eWxlcyA9PT0gdm9pZCAwKSB7IHN0eWxlcyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBfdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhO1xufShDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEpKTtcbnZhciBDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSB0aW1pbmdzXG4gICAgICogQHBhcmFtIHs/PX0gc3R5bGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSh0aW1pbmdzLCBzdHlsZXMpIHtcbiAgICAgICAgaWYgKHRpbWluZ3MgPT09IHZvaWQgMCkgeyB0aW1pbmdzID0gMDsgfVxuICAgICAgICBpZiAoc3R5bGVzID09PSB2b2lkIDApIHsgc3R5bGVzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50aW1pbmdzID0gdGltaW5ncztcbiAgICAgICAgX3RoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhO1xufShDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEpKTtcbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gc3RlcHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEoc3RlcHMpIHtcbiAgICAgICAgaWYgKHN0ZXBzID09PSB2b2lkIDApIHsgc3RlcHMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YTtcbn0oQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhKSk7XG52YXIgQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBzdGVwc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhKHN0ZXBzKSB7XG4gICAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7IHN0ZXBzID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc3RlcHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YTtcbn0oQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSk7XG52YXIgQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBzdGVwc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhKHN0ZXBzKSB7XG4gICAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7IHN0ZXBzID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc3RlcHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YTtcbn0oQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gbmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX3Nhbml0aXplSWRlbnRpZmllcihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvXFxXL2csICdfJyk7XG59XG52YXIgX2Fub255bW91c1R5cGVJbmRleCA9IDA7XG4vKipcbiAqIEBwYXJhbSB7P30gY29tcGlsZUlkZW50aWZpZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlkZW50aWZpZXJOYW1lKGNvbXBpbGVJZGVudGlmaWVyKSB7XG4gICAgaWYgKCFjb21waWxlSWRlbnRpZmllciB8fCAhY29tcGlsZUlkZW50aWZpZXIucmVmZXJlbmNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWYgPSBjb21waWxlSWRlbnRpZmllci5yZWZlcmVuY2U7XG4gICAgaWYgKHJlZiBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICByZXR1cm4gcmVmLm5hbWU7XG4gICAgfVxuICAgIGlmIChyZWZbJ19fYW5vbnltb3VzVHlwZSddKSB7XG4gICAgICAgIHJldHVybiByZWZbJ19fYW5vbnltb3VzVHlwZSddO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZGVudGlmaWVyID0gybVzdHJpbmdpZnkocmVmKTtcbiAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCcoJykgPj0gMCkge1xuICAgICAgICAvLyBjYXNlOiBhbm9ueW1vdXMgZnVuY3Rpb25zIVxuICAgICAgICBpZGVudGlmaWVyID0gXCJhbm9ueW1vdXNfXCIgKyBfYW5vbnltb3VzVHlwZUluZGV4Kys7XG4gICAgICAgIHJlZlsnX19hbm9ueW1vdXNUeXBlJ10gPSBpZGVudGlmaWVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWRlbnRpZmllciA9IF9zYW5pdGl6ZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgfVxuICAgIHJldHVybiBpZGVudGlmaWVyO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvbXBpbGVJZGVudGlmaWVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpZGVudGlmaWVyTW9kdWxlVXJsKGNvbXBpbGVJZGVudGlmaWVyKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVmID0gY29tcGlsZUlkZW50aWZpZXIucmVmZXJlbmNlO1xuICAgIGlmIChyZWYgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHJlZi5maWxlUGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIMm1cmVmbGVjdG9yLmltcG9ydFVyaShyZWYpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvbXBUeXBlXG4gKiBAcGFyYW0gez99IGVtYmVkZGVkVGVtcGxhdGVJbmRleFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdmlld0NsYXNzTmFtZShjb21wVHlwZSwgZW1iZWRkZWRUZW1wbGF0ZUluZGV4KSB7XG4gICAgcmV0dXJuIFwiVmlld19cIiArIGlkZW50aWZpZXJOYW1lKHsgcmVmZXJlbmNlOiBjb21wVHlwZSB9KSArIFwiX1wiICsgZW1iZWRkZWRUZW1wbGF0ZUluZGV4O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvbXBUeXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByZW5kZXJlclR5cGVOYW1lKGNvbXBUeXBlKSB7XG4gICAgcmV0dXJuIFwiUmVuZGVyVHlwZV9cIiArIGlkZW50aWZpZXJOYW1lKHsgcmVmZXJlbmNlOiBjb21wVHlwZSB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb21wVHlwZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaG9zdFZpZXdDbGFzc05hbWUoY29tcFR5cGUpIHtcbiAgICByZXR1cm4gXCJIb3N0Vmlld19cIiArIGlkZW50aWZpZXJOYW1lKHsgcmVmZXJlbmNlOiBjb21wVHlwZSB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBkaXJUeXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkaXJXcmFwcGVyQ2xhc3NOYW1lKGRpclR5cGUpIHtcbiAgICByZXR1cm4gXCJXcmFwcGVyX1wiICsgaWRlbnRpZmllck5hbWUoeyByZWZlcmVuY2U6IGRpclR5cGUgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29tcFR5cGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbXBvbmVudEZhY3RvcnlOYW1lKGNvbXBUeXBlKSB7XG4gICAgcmV0dXJuIGlkZW50aWZpZXJOYW1lKHsgcmVmZXJlbmNlOiBjb21wVHlwZSB9KSArIFwiTmdGYWN0b3J5XCI7XG59XG52YXIgQ29tcGlsZVN1bW1hcnlLaW5kID0ge307XG5Db21waWxlU3VtbWFyeUtpbmQuUGlwZSA9IDA7XG5Db21waWxlU3VtbWFyeUtpbmQuRGlyZWN0aXZlID0gMTtcbkNvbXBpbGVTdW1tYXJ5S2luZC5OZ01vZHVsZSA9IDI7XG5Db21waWxlU3VtbWFyeUtpbmQuSW5qZWN0YWJsZSA9IDM7XG5Db21waWxlU3VtbWFyeUtpbmRbQ29tcGlsZVN1bW1hcnlLaW5kLlBpcGVdID0gXCJQaXBlXCI7XG5Db21waWxlU3VtbWFyeUtpbmRbQ29tcGlsZVN1bW1hcnlLaW5kLkRpcmVjdGl2ZV0gPSBcIkRpcmVjdGl2ZVwiO1xuQ29tcGlsZVN1bW1hcnlLaW5kW0NvbXBpbGVTdW1tYXJ5S2luZC5OZ01vZHVsZV0gPSBcIk5nTW9kdWxlXCI7XG5Db21waWxlU3VtbWFyeUtpbmRbQ29tcGlsZVN1bW1hcnlLaW5kLkluamVjdGFibGVdID0gXCJJbmplY3RhYmxlXCI7XG4vKipcbiAqIEBwYXJhbSB7P30gdG9rZW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRva2VuTmFtZSh0b2tlbikge1xuICAgIHJldHVybiB0b2tlbi52YWx1ZSAhPSBudWxsID8gX3Nhbml0aXplSWRlbnRpZmllcih0b2tlbi52YWx1ZSkgOiBpZGVudGlmaWVyTmFtZSh0b2tlbi5pZGVudGlmaWVyKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB0b2tlblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdG9rZW5SZWZlcmVuY2UodG9rZW4pIHtcbiAgICBpZiAodG9rZW4uaWRlbnRpZmllciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi5pZGVudGlmaWVyLnJlZmVyZW5jZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tlbi52YWx1ZTtcbiAgICB9XG59XG4vKipcbiAqIE1ldGFkYXRhIGFib3V0IGEgc3R5bGVzaGVldFxuICovXG52YXIgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX18wXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbW9kdWxlVXJsID0gX2IubW9kdWxlVXJsLCBzdHlsZXMgPSBfYi5zdHlsZXMsIHN0eWxlVXJscyA9IF9iLnN0eWxlVXJscztcbiAgICAgICAgdGhpcy5tb2R1bGVVcmwgPSBtb2R1bGVVcmwgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBfbm9ybWFsaXplQXJyYXkoc3R5bGVzKTtcbiAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBfbm9ybWFsaXplQXJyYXkoc3R5bGVVcmxzKTtcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGE7XG59KCkpO1xuLyoqXG4gKiBNZXRhZGF0YSByZWdhcmRpbmcgY29tcGlsYXRpb24gb2YgYSB0ZW1wbGF0ZS5cbiAqL1xudmFyIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9fMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhKF9hKSB7XG4gICAgICAgIHZhciBlbmNhcHN1bGF0aW9uID0gX2EuZW5jYXBzdWxhdGlvbiwgdGVtcGxhdGUgPSBfYS50ZW1wbGF0ZSwgdGVtcGxhdGVVcmwgPSBfYS50ZW1wbGF0ZVVybCwgc3R5bGVzID0gX2Euc3R5bGVzLCBzdHlsZVVybHMgPSBfYS5zdHlsZVVybHMsIGV4dGVybmFsU3R5bGVzaGVldHMgPSBfYS5leHRlcm5hbFN0eWxlc2hlZXRzLCBhbmltYXRpb25zID0gX2EuYW5pbWF0aW9ucywgbmdDb250ZW50U2VsZWN0b3JzID0gX2EubmdDb250ZW50U2VsZWN0b3JzLCBpbnRlcnBvbGF0aW9uID0gX2EuaW50ZXJwb2xhdGlvbiwgaXNJbmxpbmUgPSBfYS5pc0lubGluZTtcbiAgICAgICAgdGhpcy5lbmNhcHN1bGF0aW9uID0gZW5jYXBzdWxhdGlvbjtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLnRlbXBsYXRlVXJsID0gdGVtcGxhdGVVcmw7XG4gICAgICAgIHRoaXMuc3R5bGVzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlcyk7XG4gICAgICAgIHRoaXMuc3R5bGVVcmxzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlVXJscyk7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxTdHlsZXNoZWV0cyA9IF9ub3JtYWxpemVBcnJheShleHRlcm5hbFN0eWxlc2hlZXRzKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gYW5pbWF0aW9ucyA/IGZsYXR0ZW4oYW5pbWF0aW9ucykgOiBbXTtcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRTZWxlY3RvcnMgPSBuZ0NvbnRlbnRTZWxlY3RvcnMgfHwgW107XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uICYmIGludGVycG9sYXRpb24ubGVuZ3RoICE9IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidpbnRlcnBvbGF0aW9uJyBzaG91bGQgaGF2ZSBhIHN0YXJ0IGFuZCBhbiBlbmQgc3ltYm9sLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVycG9sYXRpb24gPSBpbnRlcnBvbGF0aW9uO1xuICAgICAgICB0aGlzLmlzSW5saW5lID0gaXNJbmxpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEucHJvdG90eXBlLnRvU3VtbWFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHRoaXMuYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaW0pIHsgcmV0dXJuIGFuaW0ubmFtZTsgfSksXG4gICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IHRoaXMubmdDb250ZW50U2VsZWN0b3JzLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogdGhpcy5lbmNhcHN1bGF0aW9uLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhO1xufSgpKTtcbi8qKlxuICogTWV0YWRhdGEgcmVnYXJkaW5nIGNvbXBpbGF0aW9uIG9mIGEgZGlyZWN0aXZlLlxuICovXG52YXIgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9fMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgaXNIb3N0ID0gX2EuaXNIb3N0LCB0eXBlID0gX2EudHlwZSwgaXNDb21wb25lbnQgPSBfYS5pc0NvbXBvbmVudCwgc2VsZWN0b3IgPSBfYS5zZWxlY3RvciwgZXhwb3J0QXMgPSBfYS5leHBvcnRBcywgY2hhbmdlRGV0ZWN0aW9uID0gX2EuY2hhbmdlRGV0ZWN0aW9uLCBpbnB1dHMgPSBfYS5pbnB1dHMsIG91dHB1dHMgPSBfYS5vdXRwdXRzLCBob3N0TGlzdGVuZXJzID0gX2EuaG9zdExpc3RlbmVycywgaG9zdFByb3BlcnRpZXMgPSBfYS5ob3N0UHJvcGVydGllcywgaG9zdEF0dHJpYnV0ZXMgPSBfYS5ob3N0QXR0cmlidXRlcywgcHJvdmlkZXJzID0gX2EucHJvdmlkZXJzLCB2aWV3UHJvdmlkZXJzID0gX2Eudmlld1Byb3ZpZGVycywgcXVlcmllcyA9IF9hLnF1ZXJpZXMsIHZpZXdRdWVyaWVzID0gX2Eudmlld1F1ZXJpZXMsIGVudHJ5Q29tcG9uZW50cyA9IF9hLmVudHJ5Q29tcG9uZW50cywgdGVtcGxhdGUgPSBfYS50ZW1wbGF0ZSwgY29tcG9uZW50Vmlld1R5cGUgPSBfYS5jb21wb25lbnRWaWV3VHlwZSwgcmVuZGVyZXJUeXBlID0gX2EucmVuZGVyZXJUeXBlLCBjb21wb25lbnRGYWN0b3J5ID0gX2EuY29tcG9uZW50RmFjdG9yeTtcbiAgICAgICAgdGhpcy5pc0hvc3QgPSAhIWlzSG9zdDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5pc0NvbXBvbmVudCA9IGlzQ29tcG9uZW50O1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZXhwb3J0QXMgPSBleHBvcnRBcztcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rpb24gPSBjaGFuZ2VEZXRlY3Rpb247XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLmhvc3RMaXN0ZW5lcnMgPSBob3N0TGlzdGVuZXJzO1xuICAgICAgICB0aGlzLmhvc3RQcm9wZXJ0aWVzID0gaG9zdFByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMuaG9zdEF0dHJpYnV0ZXMgPSBob3N0QXR0cmlidXRlcztcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBfbm9ybWFsaXplQXJyYXkocHJvdmlkZXJzKTtcbiAgICAgICAgdGhpcy52aWV3UHJvdmlkZXJzID0gX25vcm1hbGl6ZUFycmF5KHZpZXdQcm92aWRlcnMpO1xuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBfbm9ybWFsaXplQXJyYXkocXVlcmllcyk7XG4gICAgICAgIHRoaXMudmlld1F1ZXJpZXMgPSBfbm9ybWFsaXplQXJyYXkodmlld1F1ZXJpZXMpO1xuICAgICAgICB0aGlzLmVudHJ5Q29tcG9uZW50cyA9IF9ub3JtYWxpemVBcnJheShlbnRyeUNvbXBvbmVudHMpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMuY29tcG9uZW50Vmlld1R5cGUgPSBjb21wb25lbnRWaWV3VHlwZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlclR5cGUgPSByZW5kZXJlclR5cGU7XG4gICAgICAgIHRoaXMuY29tcG9uZW50RmFjdG9yeSA9IGNvbXBvbmVudEZhY3Rvcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX18wXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEuY3JlYXRlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBpc0hvc3QgPSBfYS5pc0hvc3QsIHR5cGUgPSBfYS50eXBlLCBpc0NvbXBvbmVudCA9IF9hLmlzQ29tcG9uZW50LCBzZWxlY3RvciA9IF9hLnNlbGVjdG9yLCBleHBvcnRBcyA9IF9hLmV4cG9ydEFzLCBjaGFuZ2VEZXRlY3Rpb24gPSBfYS5jaGFuZ2VEZXRlY3Rpb24sIGlucHV0cyA9IF9hLmlucHV0cywgb3V0cHV0cyA9IF9hLm91dHB1dHMsIGhvc3QgPSBfYS5ob3N0LCBwcm92aWRlcnMgPSBfYS5wcm92aWRlcnMsIHZpZXdQcm92aWRlcnMgPSBfYS52aWV3UHJvdmlkZXJzLCBxdWVyaWVzID0gX2EucXVlcmllcywgdmlld1F1ZXJpZXMgPSBfYS52aWV3UXVlcmllcywgZW50cnlDb21wb25lbnRzID0gX2EuZW50cnlDb21wb25lbnRzLCB0ZW1wbGF0ZSA9IF9hLnRlbXBsYXRlLCBjb21wb25lbnRWaWV3VHlwZSA9IF9hLmNvbXBvbmVudFZpZXdUeXBlLCByZW5kZXJlclR5cGUgPSBfYS5yZW5kZXJlclR5cGUsIGNvbXBvbmVudEZhY3RvcnkgPSBfYS5jb21wb25lbnRGYWN0b3J5O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0TGlzdGVuZXJzID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RQcm9wZXJ0aWVzID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RBdHRyaWJ1dGVzID0ge307XG4gICAgICAgIGlmIChob3N0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGhvc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gaG9zdFtrZXldO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hdGNoZXMgPSBrZXkubWF0Y2goSE9TVF9SRUdfRVhQKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBob3N0QXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoZXNbMV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBob3N0UHJvcGVydGllc1ttYXRjaGVzWzFdXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGVzWzJdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdExpc3RlbmVyc1ttYXRjaGVzWzJdXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlucHV0c01hcCA9IHt9O1xuICAgICAgICBpZiAoaW5wdXRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgLy8gY2Fub25pY2FsIHN5bnRheDogYGRpclByb3A6IGVsUHJvcGBcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBgOmAsIHVzZSBkaXJQcm9wID0gZWxQcm9wXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydHMgPSBzcGxpdEF0Q29sb24oYmluZENvbmZpZywgW2JpbmRDb25maWcsIGJpbmRDb25maWddKTtcbiAgICAgICAgICAgICAgICBpbnB1dHNNYXBbcGFydHNbMF1dID0gcGFydHNbMV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXRwdXRzTWFwID0ge307XG4gICAgICAgIGlmIChvdXRwdXRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIG91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAoYmluZENvbmZpZykge1xuICAgICAgICAgICAgICAgIC8vIGNhbm9uaWNhbCBzeW50YXg6IGBkaXJQcm9wOiBlbFByb3BgXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYDpgLCB1c2UgZGlyUHJvcCA9IGVsUHJvcFxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRzID0gc3BsaXRBdENvbG9uKGJpbmRDb25maWcsIFtiaW5kQ29uZmlnLCBiaW5kQ29uZmlnXSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0c01hcFtwYXJ0c1swXV0gPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhKHtcbiAgICAgICAgICAgIGlzSG9zdDogaXNIb3N0LFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGlzQ29tcG9uZW50OiAhIWlzQ29tcG9uZW50LCBzZWxlY3Rvcjogc2VsZWN0b3IsIGV4cG9ydEFzOiBleHBvcnRBcywgY2hhbmdlRGV0ZWN0aW9uOiBjaGFuZ2VEZXRlY3Rpb24sXG4gICAgICAgICAgICBpbnB1dHM6IGlucHV0c01hcCxcbiAgICAgICAgICAgIG91dHB1dHM6IG91dHB1dHNNYXAsXG4gICAgICAgICAgICBob3N0TGlzdGVuZXJzOiBob3N0TGlzdGVuZXJzLFxuICAgICAgICAgICAgaG9zdFByb3BlcnRpZXM6IGhvc3RQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgaG9zdEF0dHJpYnV0ZXM6IGhvc3RBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBwcm92aWRlcnMsXG4gICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiB2aWV3UHJvdmlkZXJzLFxuICAgICAgICAgICAgcXVlcmllczogcXVlcmllcyxcbiAgICAgICAgICAgIHZpZXdRdWVyaWVzOiB2aWV3UXVlcmllcyxcbiAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogZW50cnlDb21wb25lbnRzLFxuICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgICAgICAgY29tcG9uZW50Vmlld1R5cGU6IGNvbXBvbmVudFZpZXdUeXBlLFxuICAgICAgICAgICAgcmVuZGVyZXJUeXBlOiByZW5kZXJlclR5cGUsXG4gICAgICAgICAgICBjb21wb25lbnRGYWN0b3J5OiBjb21wb25lbnRGYWN0b3J5LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLnByb3RvdHlwZS50b1N1bW1hcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdW1tYXJ5S2luZDogQ29tcGlsZVN1bW1hcnlLaW5kLkRpcmVjdGl2ZSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIGlzQ29tcG9uZW50OiB0aGlzLmlzQ29tcG9uZW50LFxuICAgICAgICAgICAgc2VsZWN0b3I6IHRoaXMuc2VsZWN0b3IsXG4gICAgICAgICAgICBleHBvcnRBczogdGhpcy5leHBvcnRBcyxcbiAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMsXG4gICAgICAgICAgICBvdXRwdXRzOiB0aGlzLm91dHB1dHMsXG4gICAgICAgICAgICBob3N0TGlzdGVuZXJzOiB0aGlzLmhvc3RMaXN0ZW5lcnMsXG4gICAgICAgICAgICBob3N0UHJvcGVydGllczogdGhpcy5ob3N0UHJvcGVydGllcyxcbiAgICAgICAgICAgIGhvc3RBdHRyaWJ1dGVzOiB0aGlzLmhvc3RBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiB0aGlzLnByb3ZpZGVycyxcbiAgICAgICAgICAgIHZpZXdQcm92aWRlcnM6IHRoaXMudmlld1Byb3ZpZGVycyxcbiAgICAgICAgICAgIHF1ZXJpZXM6IHRoaXMucXVlcmllcyxcbiAgICAgICAgICAgIHZpZXdRdWVyaWVzOiB0aGlzLnZpZXdRdWVyaWVzLFxuICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiB0aGlzLmVudHJ5Q29tcG9uZW50cyxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogdGhpcy5jaGFuZ2VEZXRlY3Rpb24sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZSAmJiB0aGlzLnRlbXBsYXRlLnRvU3VtbWFyeSgpLFxuICAgICAgICAgICAgY29tcG9uZW50Vmlld1R5cGU6IHRoaXMuY29tcG9uZW50Vmlld1R5cGUsXG4gICAgICAgICAgICByZW5kZXJlclR5cGU6IHRoaXMucmVuZGVyZXJUeXBlLFxuICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yeTogdGhpcy5jb21wb25lbnRGYWN0b3J5XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhO1xufSgpKTtcbi8qKlxuICogQ29uc3RydWN0IHtcXEBsaW5rIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YX0gZnJvbSB7XFxAbGluayBDb21wb25lbnRUeXBlTWV0YWRhdGF9IGFuZCBhIHNlbGVjdG9yLlxuICogQHBhcmFtIHs/fSBob3N0VHlwZVJlZmVyZW5jZVxuICogQHBhcmFtIHs/fSBjb21wTWV0YVxuICogQHBhcmFtIHs/fSBob3N0Vmlld1R5cGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhvc3RDb21wb25lbnRNZXRhKGhvc3RUeXBlUmVmZXJlbmNlLCBjb21wTWV0YSwgaG9zdFZpZXdUeXBlKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGUgPSBDc3NTZWxlY3Rvci5wYXJzZSgvKiogQHR5cGUgez99ICovICgoY29tcE1ldGEuc2VsZWN0b3IpKSlbMF0uZ2V0TWF0Y2hpbmdFbGVtZW50VGVtcGxhdGUoKTtcbiAgICByZXR1cm4gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLmNyZWF0ZSh7XG4gICAgICAgIGlzSG9zdDogdHJ1ZSxcbiAgICAgICAgdHlwZTogeyByZWZlcmVuY2U6IGhvc3RUeXBlUmVmZXJlbmNlLCBkaURlcHM6IFtdLCBsaWZlY3ljbGVIb29rczogW10gfSxcbiAgICAgICAgdGVtcGxhdGU6IG5ldyBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSh7XG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICcnLFxuICAgICAgICAgICAgc3R5bGVzOiBbXSxcbiAgICAgICAgICAgIHN0eWxlVXJsczogW10sXG4gICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IFtdLFxuICAgICAgICAgICAgYW5pbWF0aW9uczogW10sXG4gICAgICAgICAgICBpc0lubGluZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4dGVybmFsU3R5bGVzaGVldHM6IFtdLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogbnVsbFxuICAgICAgICB9KSxcbiAgICAgICAgZXhwb3J0QXM6IG51bGwsXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCxcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIGhvc3Q6IHt9LFxuICAgICAgICBpc0NvbXBvbmVudDogdHJ1ZSxcbiAgICAgICAgc2VsZWN0b3I6ICcqJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXSxcbiAgICAgICAgdmlld1Byb3ZpZGVyczogW10sXG4gICAgICAgIHF1ZXJpZXM6IFtdLFxuICAgICAgICB2aWV3UXVlcmllczogW10sXG4gICAgICAgIGNvbXBvbmVudFZpZXdUeXBlOiBob3N0Vmlld1R5cGUsXG4gICAgICAgIHJlbmRlcmVyVHlwZTogeyBpZDogJ19fSG9zdF9fJywgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSwgc3R5bGVzOiBbXSwgZGF0YToge30gfSxcbiAgICAgICAgZW50cnlDb21wb25lbnRzOiBbXSxcbiAgICAgICAgY29tcG9uZW50RmFjdG9yeTogbnVsbFxuICAgIH0pO1xufVxudmFyIENvbXBpbGVQaXBlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX18wXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZVBpcGVNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGUsIG5hbWUgPSBfYS5uYW1lLCBwdXJlID0gX2EucHVyZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wdXJlID0gISFwdXJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVQaXBlTWV0YWRhdGEucHJvdG90eXBlLnRvU3VtbWFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1bW1hcnlLaW5kOiBDb21waWxlU3VtbWFyeUtpbmQuUGlwZSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIHB1cmU6IHRoaXMucHVyZVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENvbXBpbGVQaXBlTWV0YWRhdGE7XG59KCkpO1xuLyoqXG4gKiBNZXRhZGF0YSByZWdhcmRpbmcgY29tcGlsYXRpb24gb2YgYSBtb2R1bGUuXG4gKi9cbnZhciBDb21waWxlTmdNb2R1bGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfXzBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlTmdNb2R1bGVNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGUsIHByb3ZpZGVycyA9IF9hLnByb3ZpZGVycywgZGVjbGFyZWREaXJlY3RpdmVzID0gX2EuZGVjbGFyZWREaXJlY3RpdmVzLCBleHBvcnRlZERpcmVjdGl2ZXMgPSBfYS5leHBvcnRlZERpcmVjdGl2ZXMsIGRlY2xhcmVkUGlwZXMgPSBfYS5kZWNsYXJlZFBpcGVzLCBleHBvcnRlZFBpcGVzID0gX2EuZXhwb3J0ZWRQaXBlcywgZW50cnlDb21wb25lbnRzID0gX2EuZW50cnlDb21wb25lbnRzLCBib290c3RyYXBDb21wb25lbnRzID0gX2EuYm9vdHN0cmFwQ29tcG9uZW50cywgaW1wb3J0ZWRNb2R1bGVzID0gX2EuaW1wb3J0ZWRNb2R1bGVzLCBleHBvcnRlZE1vZHVsZXMgPSBfYS5leHBvcnRlZE1vZHVsZXMsIHNjaGVtYXMgPSBfYS5zY2hlbWFzLCB0cmFuc2l0aXZlTW9kdWxlID0gX2EudHJhbnNpdGl2ZU1vZHVsZSwgaWQgPSBfYS5pZDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCBudWxsO1xuICAgICAgICB0aGlzLmRlY2xhcmVkRGlyZWN0aXZlcyA9IF9ub3JtYWxpemVBcnJheShkZWNsYXJlZERpcmVjdGl2ZXMpO1xuICAgICAgICB0aGlzLmV4cG9ydGVkRGlyZWN0aXZlcyA9IF9ub3JtYWxpemVBcnJheShleHBvcnRlZERpcmVjdGl2ZXMpO1xuICAgICAgICB0aGlzLmRlY2xhcmVkUGlwZXMgPSBfbm9ybWFsaXplQXJyYXkoZGVjbGFyZWRQaXBlcyk7XG4gICAgICAgIHRoaXMuZXhwb3J0ZWRQaXBlcyA9IF9ub3JtYWxpemVBcnJheShleHBvcnRlZFBpcGVzKTtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBfbm9ybWFsaXplQXJyYXkocHJvdmlkZXJzKTtcbiAgICAgICAgdGhpcy5lbnRyeUNvbXBvbmVudHMgPSBfbm9ybWFsaXplQXJyYXkoZW50cnlDb21wb25lbnRzKTtcbiAgICAgICAgdGhpcy5ib290c3RyYXBDb21wb25lbnRzID0gX25vcm1hbGl6ZUFycmF5KGJvb3RzdHJhcENvbXBvbmVudHMpO1xuICAgICAgICB0aGlzLmltcG9ydGVkTW9kdWxlcyA9IF9ub3JtYWxpemVBcnJheShpbXBvcnRlZE1vZHVsZXMpO1xuICAgICAgICB0aGlzLmV4cG9ydGVkTW9kdWxlcyA9IF9ub3JtYWxpemVBcnJheShleHBvcnRlZE1vZHVsZXMpO1xuICAgICAgICB0aGlzLnNjaGVtYXMgPSBfbm9ybWFsaXplQXJyYXkoc2NoZW1hcyk7XG4gICAgICAgIHRoaXMuaWQgPSBpZCB8fCBudWxsO1xuICAgICAgICB0aGlzLnRyYW5zaXRpdmVNb2R1bGUgPSB0cmFuc2l0aXZlTW9kdWxlIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLnRvU3VtbWFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlID0gKCh0aGlzLnRyYW5zaXRpdmVNb2R1bGUpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1bW1hcnlLaW5kOiBDb21waWxlU3VtbWFyeUtpbmQuTmdNb2R1bGUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IG1vZHVsZS5lbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICBwcm92aWRlcnM6IG1vZHVsZS5wcm92aWRlcnMsXG4gICAgICAgICAgICBtb2R1bGVzOiBtb2R1bGUubW9kdWxlcyxcbiAgICAgICAgICAgIGV4cG9ydGVkRGlyZWN0aXZlczogbW9kdWxlLmV4cG9ydGVkRGlyZWN0aXZlcyxcbiAgICAgICAgICAgIGV4cG9ydGVkUGlwZXM6IG1vZHVsZS5leHBvcnRlZFBpcGVzXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGE7XG59KCkpO1xudmFyIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhKCkge1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IFtdO1xuICAgICAgICB0aGlzLmV4cG9ydGVkRGlyZWN0aXZlc1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5leHBvcnRlZERpcmVjdGl2ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5waXBlc1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5waXBlcyA9IFtdO1xuICAgICAgICB0aGlzLmV4cG9ydGVkUGlwZXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZXhwb3J0ZWRQaXBlcyA9IFtdO1xuICAgICAgICB0aGlzLm1vZHVsZXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMubW9kdWxlcyA9IFtdO1xuICAgICAgICB0aGlzLmVudHJ5Q29tcG9uZW50c1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5lbnRyeUNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlclxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZFByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBtb2R1bGUpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMucHVzaCh7IHByb3ZpZGVyOiBwcm92aWRlciwgbW9kdWxlOiBtb2R1bGUgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlyZWN0aXZlc1NldC5oYXMoaWQucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzU2V0LmFkZChpZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZEV4cG9ydGVkRGlyZWN0aXZlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5leHBvcnRlZERpcmVjdGl2ZXNTZXQuaGFzKGlkLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwb3J0ZWREaXJlY3RpdmVzU2V0LmFkZChpZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgdGhpcy5leHBvcnRlZERpcmVjdGl2ZXMucHVzaChpZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YS5wcm90b3R5cGUuYWRkUGlwZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMucGlwZXNTZXQuaGFzKGlkLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRoaXMucGlwZXNTZXQuYWRkKGlkLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICB0aGlzLnBpcGVzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZEV4cG9ydGVkUGlwZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMuZXhwb3J0ZWRQaXBlc1NldC5oYXMoaWQucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy5leHBvcnRlZFBpcGVzU2V0LmFkZChpZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgdGhpcy5leHBvcnRlZFBpcGVzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZE1vZHVsZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMubW9kdWxlc1NldC5oYXMoaWQucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy5tb2R1bGVzU2V0LmFkZChpZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgdGhpcy5tb2R1bGVzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVjXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZEVudHJ5Q29tcG9uZW50ID0gZnVuY3Rpb24gKGVjKSB7XG4gICAgICAgIGlmICghdGhpcy5lbnRyeUNvbXBvbmVudHNTZXQuaGFzKGVjLmNvbXBvbmVudFR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLmVudHJ5Q29tcG9uZW50c1NldC5hZGQoZWMuY29tcG9uZW50VHlwZSk7XG4gICAgICAgICAgICB0aGlzLmVudHJ5Q29tcG9uZW50cy5wdXNoKGVjKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YTtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gb2JqXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfbm9ybWFsaXplQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIG9iaiB8fCBbXTtcbn1cbnZhciBQcm92aWRlck1ldGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcGFyYW0gez99IF9fMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFByb3ZpZGVyTWV0YSh0b2tlbiwgX2EpIHtcbiAgICAgICAgdmFyIHVzZUNsYXNzID0gX2EudXNlQ2xhc3MsIHVzZVZhbHVlID0gX2EudXNlVmFsdWUsIHVzZUV4aXN0aW5nID0gX2EudXNlRXhpc3RpbmcsIHVzZUZhY3RvcnkgPSBfYS51c2VGYWN0b3J5LCBkZXBzID0gX2EuZGVwcywgbXVsdGkgPSBfYS5tdWx0aTtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLnVzZUNsYXNzID0gdXNlQ2xhc3MgfHwgbnVsbDtcbiAgICAgICAgdGhpcy51c2VWYWx1ZSA9IHVzZVZhbHVlO1xuICAgICAgICB0aGlzLnVzZUV4aXN0aW5nID0gdXNlRXhpc3Rpbmc7XG4gICAgICAgIHRoaXMudXNlRmFjdG9yeSA9IHVzZUZhY3RvcnkgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBzIHx8IG51bGw7XG4gICAgICAgIHRoaXMubXVsdGkgPSAhIW11bHRpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvdmlkZXJNZXRhO1xufSgpKTtcbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7P30gbGlzdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihsaXN0KSB7XG4gICAgcmV0dXJuIGxpc3QucmVkdWNlKGZ1bmN0aW9uIChmbGF0LCBpdGVtKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZsYXRJdGVtID0gQXJyYXkuaXNBcnJheShpdGVtKSA/IGZsYXR0ZW4oaXRlbSkgOiBpdGVtO1xuICAgICAgICByZXR1cm4gKChmbGF0KSkuY29uY2F0KGZsYXRJdGVtKTtcbiAgICB9LCBbXSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdXJsXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzb3VyY2VVcmwodXJsKSB7XG4gICAgLy8gTm90ZTogV2UgbmVlZCAzIFwiL1wiIHNvIHRoYXQgbmcgc2hvd3MgdXAgYXMgYSBzZXBhcmF0ZSBkb21haW5cbiAgICAvLyBpbiB0aGUgY2hyb21lIGRldiB0b29scy5cbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoLyhcXHcrOlxcL1xcL1tcXHc6LV0rKT8oXFwvKyk/LywgJ25nOi8vLycpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG5nTW9kdWxlVHlwZVxuICogQHBhcmFtIHs/fSBjb21wTWV0YVxuICogQHBhcmFtIHs/fSB0ZW1wbGF0ZU1ldGFcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRlbXBsYXRlU291cmNlVXJsKG5nTW9kdWxlVHlwZSwgY29tcE1ldGEsIHRlbXBsYXRlTWV0YSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHVybDtcbiAgICBpZiAodGVtcGxhdGVNZXRhLmlzSW5saW5lKSB7XG4gICAgICAgIGlmIChjb21wTWV0YS50eXBlLnJlZmVyZW5jZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgLy8gTm90ZTogYSAudHMgZmlsZSBtaWdodCBjb250YWluIG11bHRpcGxlIGNvbXBvbmVudHMgd2l0aCBpbmxpbmUgdGVtcGxhdGVzLFxuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBnaXZlIHRoZW0gdW5pcXVlIHVybHMsIGFzIHRoZXNlIHdpbGwgYmUgdXNlZCBmb3Igc291cmNlbWFwcy5cbiAgICAgICAgICAgIHVybCA9IGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlLmZpbGVQYXRoICsgXCIuXCIgKyBjb21wTWV0YS50eXBlLnJlZmVyZW5jZS5uYW1lICsgXCIuaHRtbFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXJsID0gaWRlbnRpZmllck5hbWUobmdNb2R1bGVUeXBlKSArIFwiL1wiICsgaWRlbnRpZmllck5hbWUoY29tcE1ldGEudHlwZSkgKyBcIi5odG1sXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVybCA9ICgodGVtcGxhdGVNZXRhLnRlbXBsYXRlVXJsKSk7XG4gICAgfVxuICAgIC8vIGFsd2F5cyBwcmVwZW5kIG5nOi8vIHRvIG1ha2UgYW5ndWxhciByZXNvdXJjZXMgZWFzeSB0byBmaW5kIGFuZCBub3QgY2xvYmJlclxuICAgIC8vIHVzZXIgcmVzb3VyY2VzLlxuICAgIHJldHVybiBzb3VyY2VVcmwodXJsKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBtZXRhXG4gKiBAcGFyYW0gez99IGlkXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzaGFyZWRTdHlsZXNoZWV0Sml0VXJsKG1ldGEsIGlkKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGF0aFBhcnRzID0gKChtZXRhLm1vZHVsZVVybCkpLnNwbGl0KC9cXC9cXFxcL2cpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VOYW1lID0gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gc291cmNlVXJsKFwiY3NzL1wiICsgaWQgKyBiYXNlTmFtZSArIFwiLm5nc3R5bGUuanNcIik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbW9kdWxlTWV0YVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbmdNb2R1bGVKaXRVcmwobW9kdWxlTWV0YSkge1xuICAgIHJldHVybiBzb3VyY2VVcmwoaWRlbnRpZmllck5hbWUobW9kdWxlTWV0YS50eXBlKSArIFwiL21vZHVsZS5uZ2ZhY3RvcnkuanNcIik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbmdNb2R1bGVUeXBlXG4gKiBAcGFyYW0gez99IGNvbXBNZXRhXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0ZW1wbGF0ZUppdFVybChuZ01vZHVsZVR5cGUsIGNvbXBNZXRhKSB7XG4gICAgcmV0dXJuIHNvdXJjZVVybChpZGVudGlmaWVyTmFtZShuZ01vZHVsZVR5cGUpICsgXCIvXCIgKyBpZGVudGlmaWVyTmFtZShjb21wTWV0YS50eXBlKSArIFwiLm5nZmFjdG9yeS5qc1wiKTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBDb21waWxlckNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX18wXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZXJDb25maWcoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IuZGVmYXVsdEVuY2Fwc3VsYXRpb24sIGRlZmF1bHRFbmNhcHN1bGF0aW9uID0gX2MgPT09IHZvaWQgMCA/IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkIDogX2MsIF9kID0gX2IudXNlSml0LCB1c2VKaXQgPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kLCBtaXNzaW5nVHJhbnNsYXRpb24gPSBfYi5taXNzaW5nVHJhbnNsYXRpb24sIGVuYWJsZUxlZ2FjeVRlbXBsYXRlID0gX2IuZW5hYmxlTGVnYWN5VGVtcGxhdGU7XG4gICAgICAgIHRoaXMuZGVmYXVsdEVuY2Fwc3VsYXRpb24gPSBkZWZhdWx0RW5jYXBzdWxhdGlvbjtcbiAgICAgICAgdGhpcy51c2VKaXQgPSAhIXVzZUppdDtcbiAgICAgICAgdGhpcy5taXNzaW5nVHJhbnNsYXRpb24gPSBtaXNzaW5nVHJhbnNsYXRpb24gfHwgbnVsbDtcbiAgICAgICAgdGhpcy5lbmFibGVMZWdhY3lUZW1wbGF0ZSA9IGVuYWJsZUxlZ2FjeVRlbXBsYXRlICE9PSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVyQ29uZmlnO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBQYXJzZXJFcnJvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gZXJyTG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez89fSBjdHhMb2NhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhcnNlckVycm9yKG1lc3NhZ2UsIGlucHV0LCBlcnJMb2NhdGlvbiwgY3R4TG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmVyckxvY2F0aW9uID0gZXJyTG9jYXRpb247XG4gICAgICAgIHRoaXMuY3R4TG9jYXRpb24gPSBjdHhMb2NhdGlvbjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJQYXJzZXIgRXJyb3I6IFwiICsgbWVzc2FnZSArIFwiIFwiICsgZXJyTG9jYXRpb24gKyBcIiBbXCIgKyBpbnB1dCArIFwiXSBpbiBcIiArIGN0eExvY2F0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gUGFyc2VyRXJyb3I7XG59KCkpO1xudmFyIFBhcnNlU3BhbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFxuICAgICAqIEBwYXJhbSB7P30gZW5kXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VTcGFuKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIFBhcnNlU3Bhbjtcbn0oKSk7XG52YXIgQVNUID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBU1Qoc3Bhbikge1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBU1QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQVNULnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdBU1QnOyB9O1xuICAgIHJldHVybiBBU1Q7XG59KCkpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgcXVvdGVkIGV4cHJlc3Npb24gb2YgdGhlIGZvcm06XG4gKlxuICogcXVvdGUgPSBwcmVmaXggYDpgIHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uXG4gKiBwcmVmaXggPSBpZGVudGlmaWVyXG4gKiB1bmludGVycHJldGVkRXhwcmVzc2lvbiA9IGFyYml0cmFyeSBzdHJpbmdcbiAqXG4gKiBBIHF1b3RlZCBleHByZXNzaW9uIGlzIG1lYW50IHRvIGJlIHByZS1wcm9jZXNzZWQgYnkgYW4gQVNUIHRyYW5zZm9ybWVyIHRoYXRcbiAqIGNvbnZlcnRzIGl0IGludG8gYW5vdGhlciBBU1QgdGhhdCBubyBsb25nZXIgY29udGFpbnMgcXVvdGVkIGV4cHJlc3Npb25zLlxuICogSXQgaXMgbWVhbnQgdG8gYWxsb3cgdGhpcmQtcGFydHkgZGV2ZWxvcGVycyB0byBleHRlbmQgQW5ndWxhciB0ZW1wbGF0ZVxuICogZXhwcmVzc2lvbiBsYW5ndWFnZS4gVGhlIGB1bmludGVycHJldGVkRXhwcmVzc2lvbmAgcGFydCBvZiB0aGUgcXVvdGUgaXNcbiAqIHRoZXJlZm9yZSBub3QgaW50ZXJwcmV0ZWQgYnkgdGhlIEFuZ3VsYXIncyBvd24gZXhwcmVzc2lvbiBwYXJzZXIuXG4gKi9cbnZhciBRdW90ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFF1b3RlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gcHJlZml4XG4gICAgICogQHBhcmFtIHs/fSB1bmludGVycHJldGVkRXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBRdW90ZShzcGFuLCBwcmVmaXgsIHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uLCBsb2NhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIF90aGlzLnVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uID0gdW5pbnRlcnByZXRlZEV4cHJlc3Npb247XG4gICAgICAgIF90aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUXVvdGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFF1b3RlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBRdW90ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnUXVvdGUnOyB9O1xuICAgIHJldHVybiBRdW90ZTtcbn0oQVNUKSk7XG52YXIgRW1wdHlFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRW1wdHlFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVtcHR5RXhwcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbXB0eUV4cHIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfTtcbiAgICByZXR1cm4gRW1wdHlFeHByO1xufShBU1QpKTtcbnZhciBJbXBsaWNpdFJlY2VpdmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW1wbGljaXRSZWNlaXZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbXBsaWNpdFJlY2VpdmVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEltcGxpY2l0UmVjZWl2ZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEltcGxpY2l0UmVjZWl2ZXIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW1wbGljaXRSZWNlaXZlcjtcbn0oQVNUKSk7XG4vKipcbiAqIE11bHRpcGxlIGV4cHJlc3Npb25zIHNlcGFyYXRlZCBieSBhIHNlbWljb2xvbi5cbiAqL1xudmFyIENoYWluID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2hhaW4sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENoYWluKHNwYW4sIGV4cHJlc3Npb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2hhaW4ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoYWluKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENoYWluO1xufShBU1QpKTtcbnZhciBDb25kaXRpb25hbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbmRpdGlvbmFsLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gY29uZGl0aW9uXG4gICAgICogQHBhcmFtIHs/fSB0cnVlRXhwXG4gICAgICogQHBhcmFtIHs/fSBmYWxzZUV4cFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbmRpdGlvbmFsKHNwYW4sIGNvbmRpdGlvbiwgdHJ1ZUV4cCwgZmFsc2VFeHApIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICBfdGhpcy50cnVlRXhwID0gdHJ1ZUV4cDtcbiAgICAgICAgX3RoaXMuZmFsc2VFeHAgPSBmYWxzZUV4cDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25kaXRpb25hbC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29uZGl0aW9uYWwodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29uZGl0aW9uYWw7XG59KEFTVCkpO1xudmFyIFByb3BlcnR5UmVhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb3BlcnR5UmVhZCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJvcGVydHlSZWFkKHNwYW4sIHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByb3BlcnR5UmVhZC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJvcGVydHlSZWFkKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFByb3BlcnR5UmVhZDtcbn0oQVNUKSk7XG52YXIgUHJvcGVydHlXcml0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb3BlcnR5V3JpdGUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSByZWNlaXZlclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcm9wZXJ0eVdyaXRlKHNwYW4sIHJlY2VpdmVyLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQcm9wZXJ0eVdyaXRlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcm9wZXJ0eVdyaXRlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFByb3BlcnR5V3JpdGU7XG59KEFTVCkpO1xudmFyIFNhZmVQcm9wZXJ0eVJlYWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTYWZlUHJvcGVydHlSZWFkLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gcmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTYWZlUHJvcGVydHlSZWFkKHNwYW4sIHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNhZmVQcm9wZXJ0eVJlYWQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFNhZmVQcm9wZXJ0eVJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2FmZVByb3BlcnR5UmVhZDtcbn0oQVNUKSk7XG52YXIgS2V5ZWRSZWFkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoS2V5ZWRSZWFkLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gb2JqXG4gICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBLZXllZFJlYWQoc3Bhbiwgb2JqLCBrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub2JqID0gb2JqO1xuICAgICAgICBfdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgS2V5ZWRSZWFkLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRLZXllZFJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gS2V5ZWRSZWFkO1xufShBU1QpKTtcbnZhciBLZXllZFdyaXRlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoS2V5ZWRXcml0ZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IG9ialxuICAgICAqIEBwYXJhbSB7P30ga2V5XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEtleWVkV3JpdGUoc3Bhbiwgb2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9iaiA9IG9iajtcbiAgICAgICAgX3RoaXMua2V5ID0ga2V5O1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEtleWVkV3JpdGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEtleWVkV3JpdGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gS2V5ZWRXcml0ZTtcbn0oQVNUKSk7XG52YXIgQmluZGluZ1BpcGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCaW5kaW5nUGlwZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IGV4cFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gYXJnc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJpbmRpbmdQaXBlKHNwYW4sIGV4cCwgbmFtZSwgYXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5leHAgPSBleHA7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGlwZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UGlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBCaW5kaW5nUGlwZTtcbn0oQVNUKSk7XG52YXIgTGl0ZXJhbFByaW1pdGl2ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpdGVyYWxQcmltaXRpdmUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpdGVyYWxQcmltaXRpdmUoc3BhbiwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXRlcmFsUHJpbWl0aXZlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsUHJpbWl0aXZlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIExpdGVyYWxQcmltaXRpdmU7XG59KEFTVCkpO1xudmFyIExpdGVyYWxBcnJheSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpdGVyYWxBcnJheSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGl0ZXJhbEFycmF5KHNwYW4sIGV4cHJlc3Npb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGl0ZXJhbEFycmF5LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsQXJyYXkodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGl0ZXJhbEFycmF5O1xufShBU1QpKTtcbnZhciBMaXRlcmFsTWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGl0ZXJhbE1hcCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IGtleXNcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpdGVyYWxNYXAoc3Bhbiwga2V5cywgdmFsdWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmtleXMgPSBrZXlzO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGl0ZXJhbE1hcC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbE1hcCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBMaXRlcmFsTWFwO1xufShBU1QpKTtcbnZhciBJbnRlcnBvbGF0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW50ZXJwb2xhdGlvbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IHN0cmluZ3NcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW50ZXJwb2xhdGlvbihzcGFuLCBzdHJpbmdzLCBleHByZXNzaW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgX3RoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJbnRlcnBvbGF0aW9uLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnRlcnBvbGF0aW9uKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEludGVycG9sYXRpb247XG59KEFTVCkpO1xudmFyIEJpbmFyeSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJpbmFyeSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7P30gbGVmdFxuICAgICAqIEBwYXJhbSB7P30gcmlnaHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCaW5hcnkoc3Bhbiwgb3BlcmF0aW9uLCBsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgIF90aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICBfdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmFyeS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QmluYXJ5KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEJpbmFyeTtcbn0oQVNUKSk7XG52YXIgUHJlZml4Tm90ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJlZml4Tm90LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFByZWZpeE5vdChzcGFuLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByZWZpeE5vdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJlZml4Tm90KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFByZWZpeE5vdDtcbn0oQVNUKSk7XG52YXIgTWV0aG9kQ2FsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ldGhvZENhbGwsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSByZWNlaXZlclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gYXJnc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1ldGhvZENhbGwoc3BhbiwgcmVjZWl2ZXIsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1ldGhvZENhbGwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE1ldGhvZENhbGwodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWV0aG9kQ2FsbDtcbn0oQVNUKSk7XG52YXIgU2FmZU1ldGhvZENhbGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTYWZlTWV0aG9kQ2FsbCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBhcmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2FmZU1ldGhvZENhbGwoc3BhbiwgcmVjZWl2ZXIsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNhZmVNZXRob2RDYWxsLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTYWZlTWV0aG9kQ2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBTYWZlTWV0aG9kQ2FsbDtcbn0oQVNUKSk7XG52YXIgRnVuY3Rpb25DYWxsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnVuY3Rpb25DYWxsLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHs/fSBhcmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRnVuY3Rpb25DYWxsKHNwYW4sIHRhcmdldCwgYXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RnVuY3Rpb25DYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEZ1bmN0aW9uQ2FsbDtcbn0oQVNUKSk7XG52YXIgQVNUV2l0aFNvdXJjZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFTVFdpdGhTb3VyY2UsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFTVFdpdGhTb3VyY2UoYXN0LCBzb3VyY2UsIGxvY2F0aW9uLCBlcnJvcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmV3IFBhcnNlU3BhbigwLCBzb3VyY2UgPT0gbnVsbCA/IDAgOiBzb3VyY2UubGVuZ3RoKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYXN0ID0gYXN0O1xuICAgICAgICBfdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIF90aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIF90aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBU1RXaXRoU291cmNlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBU1RXaXRoU291cmNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuc291cmNlICsgXCIgaW4gXCIgKyB0aGlzLmxvY2F0aW9uOyB9O1xuICAgIHJldHVybiBBU1RXaXRoU291cmNlO1xufShBU1QpKTtcbnZhciBUZW1wbGF0ZUJpbmRpbmcgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30ga2V5XG4gICAgICogQHBhcmFtIHs/fSBrZXlJc1ZhclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlQmluZGluZyhzcGFuLCBrZXksIGtleUlzVmFyLCBuYW1lLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmtleUlzVmFyID0ga2V5SXNWYXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgfVxuICAgIHJldHVybiBUZW1wbGF0ZUJpbmRpbmc7XG59KCkpO1xudmFyIFJlY3Vyc2l2ZUFzdFZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY3Vyc2l2ZUFzdFZpc2l0b3IoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmxlZnQudmlzaXQodGhpcyk7XG4gICAgICAgIGFzdC5yaWdodC52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBjb250ZXh0KTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdCh0aGlzKTtcbiAgICAgICAgYXN0LnRydWVFeHAudmlzaXQodGhpcyk7XG4gICAgICAgIGFzdC5mYWxzZUV4cC52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuZXhwLnZpc2l0KHRoaXMpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICgoYXN0LnRhcmdldCkpLnZpc2l0KHRoaXMpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRJbXBsaWNpdFJlY2VpdmVyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3Qub2JqLnZpc2l0KHRoaXMpO1xuICAgICAgICBhc3Qua2V5LnZpc2l0KHRoaXMpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWVkV3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5vYmoudmlzaXQodGhpcyk7XG4gICAgICAgIGFzdC5rZXkudmlzaXQodGhpcyk7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QudmFsdWVzLCBjb250ZXh0KTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByZWZpeE5vdCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmV4cHJlc3Npb24udmlzaXQodGhpcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJvcGVydHlXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICBhc3QudmFsdWUudmlzaXQodGhpcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2FmZVByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0c1xuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAoYXN0cywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBhc3RzLmZvckVhY2goZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UXVvdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIHJldHVybiBSZWN1cnNpdmVBc3RWaXNpdG9yO1xufSgpKTtcbnZhciBBc3RUcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN0VHJhbnNmb3JtZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRJbXBsaWNpdFJlY2VpdmVyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEludGVycG9sYXRpb24oYXN0LnNwYW4sIGFzdC5zdHJpbmdzLCB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZShhc3Quc3BhbiwgYXN0LnZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlSZWFkKGFzdC5zcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5V3JpdGUoYXN0LnNwYW4sIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUsIGFzdC52YWx1ZS52aXNpdCh0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0U2FmZVByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTYWZlUHJvcGVydHlSZWFkKGFzdC5zcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IE1ldGhvZENhbGwoYXN0LnNwYW4sIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUsIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRTYWZlTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTYWZlTWV0aG9kQ2FsbChhc3Quc3BhbiwgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCBhc3QubmFtZSwgdGhpcy52aXNpdEFsbChhc3QuYXJncykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkNhbGwoYXN0LnNwYW4sIC8qKiBAdHlwZSB7P30gKi8gKChhc3QudGFyZ2V0KSkudmlzaXQodGhpcyksIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5KGFzdC5zcGFuLCB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcChhc3Quc3BhbiwgYXN0LmtleXMsIHRoaXMudmlzaXRBbGwoYXN0LnZhbHVlcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnkoYXN0LnNwYW4sIGFzdC5vcGVyYXRpb24sIGFzdC5sZWZ0LnZpc2l0KHRoaXMpLCBhc3QucmlnaHQudmlzaXQodGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByZWZpeE5vdCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVmaXhOb3QoYXN0LnNwYW4sIGFzdC5leHByZXNzaW9uLnZpc2l0KHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbChhc3Quc3BhbiwgYXN0LmNvbmRpdGlvbi52aXNpdCh0aGlzKSwgYXN0LnRydWVFeHAudmlzaXQodGhpcyksIGFzdC5mYWxzZUV4cC52aXNpdCh0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nUGlwZShhc3Quc3BhbiwgYXN0LmV4cC52aXNpdCh0aGlzKSwgYXN0Lm5hbWUsIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgS2V5ZWRSZWFkKGFzdC5zcGFuLCBhc3Qub2JqLnZpc2l0KHRoaXMpLCBhc3Qua2V5LnZpc2l0KHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRLZXllZFdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEtleWVkV3JpdGUoYXN0LnNwYW4sIGFzdC5vYmoudmlzaXQodGhpcyksIGFzdC5rZXkudmlzaXQodGhpcyksIGFzdC52YWx1ZS52aXNpdCh0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEFsbCA9IGZ1bmN0aW9uIChhc3RzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcyA9IG5ldyBBcnJheShhc3RzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBhc3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXNbaV0gPSBhc3RzW2ldLnZpc2l0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Q2hhaW4gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhaW4oYXN0LnNwYW4sIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UXVvdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVvdGUoYXN0LnNwYW4sIGFzdC5wcmVmaXgsIGFzdC51bmludGVycHJldGVkRXhwcmVzc2lvbiwgYXN0LmxvY2F0aW9uKTtcbiAgICB9O1xuICAgIHJldHVybiBBc3RUcmFuc2Zvcm1lcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgJEVPRiA9IDA7XG52YXIgJFRBQiA9IDk7XG52YXIgJExGID0gMTA7XG52YXIgJFZUQUIgPSAxMTtcbnZhciAkRkYgPSAxMjtcbnZhciAkQ1IgPSAxMztcbnZhciAkU1BBQ0UgPSAzMjtcbnZhciAkQkFORyA9IDMzO1xudmFyICREUSA9IDM0O1xudmFyICRIQVNIID0gMzU7XG52YXIgJCQgPSAzNjtcbnZhciAkUEVSQ0VOVCA9IDM3O1xudmFyICRBTVBFUlNBTkQgPSAzODtcbnZhciAkU1EgPSAzOTtcbnZhciAkTFBBUkVOID0gNDA7XG52YXIgJFJQQVJFTiA9IDQxO1xudmFyICRTVEFSID0gNDI7XG52YXIgJFBMVVMgPSA0MztcbnZhciAkQ09NTUEgPSA0NDtcbnZhciAkTUlOVVMgPSA0NTtcbnZhciAkUEVSSU9EID0gNDY7XG52YXIgJFNMQVNIID0gNDc7XG52YXIgJENPTE9OID0gNTg7XG52YXIgJFNFTUlDT0xPTiA9IDU5O1xudmFyICRMVCA9IDYwO1xudmFyICRFUSA9IDYxO1xudmFyICRHVCA9IDYyO1xudmFyICRRVUVTVElPTiA9IDYzO1xudmFyICQwID0gNDg7XG52YXIgJDkgPSA1NztcbnZhciAkQSA9IDY1O1xudmFyICRFID0gNjk7XG52YXIgJEYgPSA3MDtcbnZhciAkWCA9IDg4O1xudmFyICRaID0gOTA7XG52YXIgJExCUkFDS0VUID0gOTE7XG52YXIgJEJBQ0tTTEFTSCA9IDkyO1xudmFyICRSQlJBQ0tFVCA9IDkzO1xudmFyICRDQVJFVCA9IDk0O1xudmFyICRfID0gOTU7XG52YXIgJGEgPSA5NztcbnZhciAkZSA9IDEwMTtcbnZhciAkZiA9IDEwMjtcbnZhciAkbiA9IDExMDtcbnZhciAkciA9IDExNDtcbnZhciAkdCA9IDExNjtcbnZhciAkdSA9IDExNztcbnZhciAkdiA9IDExODtcbnZhciAkeCA9IDEyMDtcbnZhciAkeiA9IDEyMjtcbnZhciAkTEJSQUNFID0gMTIzO1xudmFyICRCQVIgPSAxMjQ7XG52YXIgJFJCUkFDRSA9IDEyNTtcbnZhciAkTkJTUCA9IDE2MDtcbnZhciAkQlQgPSA5Njtcbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoY29kZSkge1xuICAgIHJldHVybiAoY29kZSA+PSAkVEFCICYmIGNvZGUgPD0gJFNQQUNFKSB8fCAoY29kZSA9PSAkTkJTUCk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNEaWdpdChjb2RlKSB7XG4gICAgcmV0dXJuICQwIDw9IGNvZGUgJiYgY29kZSA8PSAkOTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0FzY2lpTGV0dGVyKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSAkYSAmJiBjb2RlIDw9ICR6IHx8IGNvZGUgPj0gJEEgJiYgY29kZSA8PSAkWjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0FzY2lpSGV4RGlnaXQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49ICRhICYmIGNvZGUgPD0gJGYgfHwgY29kZSA+PSAkQSAmJiBjb2RlIDw9ICRGIHx8IGlzRGlnaXQoY29kZSk7XG59XG4vKipcbiAqIEEgcmVwbGFjZW1lbnQgZm9yIFxcQEluamVjdGFibGUgdG8gYmUgdXNlZCBpbiB0aGUgY29tcGlsZXIsIHNvIHRoYXRcbiAqIHdlIGRvbid0IHRyeSB0byBldmFsdWF0ZSB0aGUgbWV0YWRhdGEgaW4gdGhlIGNvbXBpbGVyIGR1cmluZyBBb1QuXG4gKiBUaGlzIGRlY29yYXRvciBpcyBlbm91Z2ggdG8gbWFrZSB0aGUgY29tcGlsZXIgd29yayB3aXRoIHRoZSBSZWZsZWN0aXZlSW5qZWN0b3IgdGhvdWdoLlxuICogXFxAQW5ub3RhdGlvblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gQ29tcGlsZXJJbmplY3RhYmxlKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQHBhcmFtIHs/fSBpZGVudGlmaWVyXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBhc3NlcnRBcnJheU9mU3RyaW5ncyhpZGVudGlmaWVyLCB2YWx1ZSkge1xuICAgIGlmICghaXNEZXZNb2RlKCkgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgaWRlbnRpZmllciArIFwiJyB0byBiZSBhbiBhcnJheSBvZiBzdHJpbmdzLlwiKTtcbiAgICB9XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBpZGVudGlmaWVyICsgXCInIHRvIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MuXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxudmFyIElOVEVSUE9MQVRJT05fQkxBQ0tMSVNUX1JFR0VYUFMgPSBbXG4gICAgL15cXHMqJC8sXG4gICAgL1s8Pl0vLFxuICAgIC9eW3t9XSQvLFxuICAgIC8mKCN8W2Etel0pL2ksXG4gICAgL15cXC9cXC8vLFxuXTtcbi8qKlxuICogQHBhcmFtIHs/fSBpZGVudGlmaWVyXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBhc3NlcnRJbnRlcnBvbGF0aW9uU3ltYm9scyhpZGVudGlmaWVyLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICEoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09IDIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkICdcIiArIGlkZW50aWZpZXIgKyBcIicgdG8gYmUgYW4gYXJyYXksIFtzdGFydCwgZW5kXS5cIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGV2TW9kZSgpICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRfMSA9ICh2YWx1ZVswXSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZF8xID0gKHZhbHVlWzFdKTtcbiAgICAgICAgLy8gYmxhY2sgbGlzdCBjaGVja2luZ1xuICAgICAgICBJTlRFUlBPTEFUSU9OX0JMQUNLTElTVF9SRUdFWFBTLmZvckVhY2goZnVuY3Rpb24gKHJlZ2V4cCkge1xuICAgICAgICAgICAgaWYgKHJlZ2V4cC50ZXN0KHN0YXJ0XzEpIHx8IHJlZ2V4cC50ZXN0KGVuZF8xKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlsnXCIgKyBzdGFydF8xICsgXCInLCAnXCIgKyBlbmRfMSArIFwiJ10gY29udGFpbnMgdW51c2FibGUgaW50ZXJwb2xhdGlvbiBzeW1ib2wuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgSW50ZXJwb2xhdGlvbkNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFxuICAgICAqIEBwYXJhbSB7P30gZW5kXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW50ZXJwb2xhdGlvbkNvbmZpZyhzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWFya2Vyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW50ZXJwb2xhdGlvbkNvbmZpZy5mcm9tQXJyYXkgPSBmdW5jdGlvbiAobWFya2Vycykge1xuICAgICAgICBpZiAoIW1hcmtlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEludGVycG9sYXRpb25TeW1ib2xzKCdpbnRlcnBvbGF0aW9uJywgbWFya2Vycyk7XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGlvbkNvbmZpZyhtYXJrZXJzWzBdLCBtYXJrZXJzWzFdKTtcbiAgICB9O1xuICAgIDtcbiAgICByZXR1cm4gSW50ZXJwb2xhdGlvbkNvbmZpZztcbn0oKSk7XG52YXIgREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRyA9IG5ldyBJbnRlcnBvbGF0aW9uQ29uZmlnKCd7eycsICd9fScpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFRva2VuVHlwZSA9IHt9O1xuVG9rZW5UeXBlLkNoYXJhY3RlciA9IDA7XG5Ub2tlblR5cGUuSWRlbnRpZmllciA9IDE7XG5Ub2tlblR5cGUuS2V5d29yZCA9IDI7XG5Ub2tlblR5cGUuU3RyaW5nID0gMztcblRva2VuVHlwZS5PcGVyYXRvciA9IDQ7XG5Ub2tlblR5cGUuTnVtYmVyID0gNTtcblRva2VuVHlwZS5FcnJvciA9IDY7XG5Ub2tlblR5cGVbVG9rZW5UeXBlLkNoYXJhY3Rlcl0gPSBcIkNoYXJhY3RlclwiO1xuVG9rZW5UeXBlW1Rva2VuVHlwZS5JZGVudGlmaWVyXSA9IFwiSWRlbnRpZmllclwiO1xuVG9rZW5UeXBlW1Rva2VuVHlwZS5LZXl3b3JkXSA9IFwiS2V5d29yZFwiO1xuVG9rZW5UeXBlW1Rva2VuVHlwZS5TdHJpbmddID0gXCJTdHJpbmdcIjtcblRva2VuVHlwZVtUb2tlblR5cGUuT3BlcmF0b3JdID0gXCJPcGVyYXRvclwiO1xuVG9rZW5UeXBlW1Rva2VuVHlwZS5OdW1iZXJdID0gXCJOdW1iZXJcIjtcblRva2VuVHlwZVtUb2tlblR5cGUuRXJyb3JdID0gXCJFcnJvclwiO1xudmFyIEtFWVdPUkRTID0gWyd2YXInLCAnbGV0JywgJ2FzJywgJ251bGwnLCAndW5kZWZpbmVkJywgJ3RydWUnLCAnZmFsc2UnLCAnaWYnLCAnZWxzZScsICd0aGlzJ107XG52YXIgTGV4ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExleGVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIExleGVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjYW5uZXIgPSBuZXcgX1NjYW5uZXIodGV4dCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VucyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbiA9IHNjYW5uZXIuc2NhblRva2VuKCk7XG4gICAgICAgIHdoaWxlICh0b2tlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB0b2tlbiA9IHNjYW5uZXIuc2NhblRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9O1xuICAgIHJldHVybiBMZXhlcjtcbn0oKSk7XG5MZXhlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5MZXhlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xudmFyIFRva2VuID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBudW1WYWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc3RyVmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUb2tlbihpbmRleCwgdHlwZSwgbnVtVmFsdWUsIHN0clZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5udW1WYWx1ZSA9IG51bVZhbHVlO1xuICAgICAgICB0aGlzLnN0clZhbHVlID0gc3RyVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzQ2hhcmFjdGVyID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuQ2hhcmFjdGVyICYmIHRoaXMubnVtVmFsdWUgPT0gY29kZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzTnVtYmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5OdW1iZXI7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNTdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLlN0cmluZzsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9wZXJhdGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNPcGVyYXRvciA9IGZ1bmN0aW9uIChvcGVyYXRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5PcGVyYXRvciAmJiB0aGlzLnN0clZhbHVlID09IG9wZXJhdGVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5JZGVudGlmaWVyOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZDsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRMZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAnbGV0JzsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRBcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICdhcyc7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkTnVsbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICdudWxsJzsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRVbmRlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAndW5kZWZpbmVkJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZFRydWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAndHJ1ZSc7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkRmFsc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAnZmFsc2UnOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZFRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAndGhpcyc7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNFcnJvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuRXJyb3I7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLk51bWJlciA/IHRoaXMubnVtVmFsdWUgOiAtMTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLkNoYXJhY3RlcjpcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLklkZW50aWZpZXI6XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5LZXl3b3JkOlxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuT3BlcmF0b3I6XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5TdHJpbmc6XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5FcnJvcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJWYWx1ZTtcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLk51bWJlcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5udW1WYWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRva2VuO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBpbmRleFxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBuZXdDaGFyYWN0ZXJUb2tlbihpbmRleCwgY29kZSkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIFRva2VuVHlwZS5DaGFyYWN0ZXIsIGNvZGUsIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGluZGV4XG4gKiBAcGFyYW0gez99IHRleHRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5ld0lkZW50aWZpZXJUb2tlbihpbmRleCwgdGV4dCkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIFRva2VuVHlwZS5JZGVudGlmaWVyLCAwLCB0ZXh0KTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpbmRleFxuICogQHBhcmFtIHs/fSB0ZXh0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBuZXdLZXl3b3JkVG9rZW4oaW5kZXgsIHRleHQpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBUb2tlblR5cGUuS2V5d29yZCwgMCwgdGV4dCk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5kZXhcbiAqIEBwYXJhbSB7P30gdGV4dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbmV3T3BlcmF0b3JUb2tlbihpbmRleCwgdGV4dCkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIFRva2VuVHlwZS5PcGVyYXRvciwgMCwgdGV4dCk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5kZXhcbiAqIEBwYXJhbSB7P30gdGV4dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbmV3U3RyaW5nVG9rZW4oaW5kZXgsIHRleHQpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBUb2tlblR5cGUuU3RyaW5nLCAwLCB0ZXh0KTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpbmRleFxuICogQHBhcmFtIHs/fSBuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBuZXdOdW1iZXJUb2tlbihpbmRleCwgbikge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIFRva2VuVHlwZS5OdW1iZXIsIG4sICcnKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpbmRleFxuICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBuZXdFcnJvclRva2VuKGluZGV4LCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLkVycm9yLCAwLCBtZXNzYWdlKTtcbn1cbnZhciBFT0YgPSBuZXcgVG9rZW4oLTEsIFRva2VuVHlwZS5DaGFyYWN0ZXIsIDAsICcnKTtcbnZhciBfU2Nhbm5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9TY2FubmVyKGlucHV0KSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5wZWVrID0gMDtcbiAgICAgICAgdGhpcy5pbmRleCA9IC0xO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGVlayA9ICsrdGhpcy5pbmRleCA+PSB0aGlzLmxlbmd0aCA/ICRFT0YgOiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlucHV0ID0gdGhpcy5pbnB1dCwgLyoqIEB0eXBlIHs/fSAqLyBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGVlayA9IHRoaXMucGVlaywgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZS5cbiAgICAgICAgd2hpbGUgKHBlZWsgPD0gJFNQQUNFKSB7XG4gICAgICAgICAgICBpZiAoKytpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwZWVrID0gJEVPRjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZWsgPSBpbnB1dC5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlZWsgPSBwZWVrO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBpZGVudGlmaWVycyBhbmQgbnVtYmVycy5cbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHBlZWspKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbklkZW50aWZpZXIoKTtcbiAgICAgICAgaWYgKGlzRGlnaXQocGVlaykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuTnVtYmVyKGluZGV4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSBpbmRleDtcbiAgICAgICAgc3dpdGNoIChwZWVrKSB7XG4gICAgICAgICAgICBjYXNlICRQRVJJT0Q6XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRGlnaXQodGhpcy5wZWVrKSA/IHRoaXMuc2Nhbk51bWJlcihzdGFydCkgOlxuICAgICAgICAgICAgICAgICAgICBuZXdDaGFyYWN0ZXJUb2tlbihzdGFydCwgJFBFUklPRCk7XG4gICAgICAgICAgICBjYXNlICRMUEFSRU46XG4gICAgICAgICAgICBjYXNlICRSUEFSRU46XG4gICAgICAgICAgICBjYXNlICRMQlJBQ0U6XG4gICAgICAgICAgICBjYXNlICRSQlJBQ0U6XG4gICAgICAgICAgICBjYXNlICRMQlJBQ0tFVDpcbiAgICAgICAgICAgIGNhc2UgJFJCUkFDS0VUOlxuICAgICAgICAgICAgY2FzZSAkQ09NTUE6XG4gICAgICAgICAgICBjYXNlICRDT0xPTjpcbiAgICAgICAgICAgIGNhc2UgJFNFTUlDT0xPTjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ2hhcmFjdGVyKHN0YXJ0LCBwZWVrKTtcbiAgICAgICAgICAgIGNhc2UgJFNROlxuICAgICAgICAgICAgY2FzZSAkRFE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblN0cmluZygpO1xuICAgICAgICAgICAgY2FzZSAkSEFTSDpcbiAgICAgICAgICAgIGNhc2UgJFBMVVM6XG4gICAgICAgICAgICBjYXNlICRNSU5VUzpcbiAgICAgICAgICAgIGNhc2UgJFNUQVI6XG4gICAgICAgICAgICBjYXNlICRTTEFTSDpcbiAgICAgICAgICAgIGNhc2UgJFBFUkNFTlQ6XG4gICAgICAgICAgICBjYXNlICRDQVJFVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuT3BlcmF0b3Ioc3RhcnQsIFN0cmluZy5mcm9tQ2hhckNvZGUocGVlaykpO1xuICAgICAgICAgICAgY2FzZSAkUVVFU1RJT046XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgJz8nLCAkUEVSSU9ELCAnLicpO1xuICAgICAgICAgICAgY2FzZSAkTFQ6XG4gICAgICAgICAgICBjYXNlICRHVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCBTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspLCAkRVEsICc9Jyk7XG4gICAgICAgICAgICBjYXNlICRCQU5HOlxuICAgICAgICAgICAgY2FzZSAkRVE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgU3RyaW5nLmZyb21DaGFyQ29kZShwZWVrKSwgJEVRLCAnPScsICRFUSwgJz0nKTtcbiAgICAgICAgICAgIGNhc2UgJEFNUEVSU0FORDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCAnJicsICRBTVBFUlNBTkQsICcmJyk7XG4gICAgICAgICAgICBjYXNlICRCQVI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgJ3wnLCAkQkFSLCAnfCcpO1xuICAgICAgICAgICAgY2FzZSAkTkJTUDpcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXNXaGl0ZXNwYWNlKHRoaXMucGVlaykpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Ub2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyIFtcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUocGVlaykgKyBcIl1cIiwgMCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHBhcmFtIHs/fSBjb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhbkNoYXJhY3RlciA9IGZ1bmN0aW9uIChzdGFydCwgY29kZSkge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIG5ld0NoYXJhY3RlclRva2VuKHN0YXJ0LCBjb2RlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRcbiAgICAgKiBAcGFyYW0gez99IHN0clxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5PcGVyYXRvciA9IGZ1bmN0aW9uIChzdGFydCwgc3RyKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICByZXR1cm4gbmV3T3BlcmF0b3JUb2tlbihzdGFydCwgc3RyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRva2VuaXplIGEgMi8zIGNoYXIgbG9uZyBvcGVyYXRvclxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydCBzdGFydCBpbmRleCBpbiB0aGUgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7P30gb25lIGZpcnN0IHN5bWJvbCAoYWx3YXlzIHBhcnQgb2YgdGhlIG9wZXJhdG9yKVxuICAgICAqIEBwYXJhbSB7P30gdHdvQ29kZSBjb2RlIHBvaW50IGZvciB0aGUgc2Vjb25kIHN5bWJvbFxuICAgICAqIEBwYXJhbSB7P30gdHdvIHNlY29uZCBzeW1ib2wgKHBhcnQgb2YgdGhlIG9wZXJhdG9yIHdoZW4gdGhlIHNlY29uZCBjb2RlIHBvaW50IG1hdGNoZXMpXG4gICAgICogQHBhcmFtIHs/PX0gdGhyZWVDb2RlIGNvZGUgcG9pbnQgZm9yIHRoZSB0aGlyZCBzeW1ib2xcbiAgICAgKiBAcGFyYW0gez89fSB0aHJlZSB0aGlyZCBzeW1ib2wgKHBhcnQgb2YgdGhlIG9wZXJhdG9yIHdoZW4gcHJvdmlkZWQgYW5kIG1hdGNoZXMgc291cmNlIGV4cHJlc3Npb24pXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhbkNvbXBsZXhPcGVyYXRvciA9IGZ1bmN0aW9uIChzdGFydCwgb25lLCB0d29Db2RlLCB0d28sIHRocmVlQ29kZSwgdGhyZWUpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ciA9IG9uZTtcbiAgICAgICAgaWYgKHRoaXMucGVlayA9PSB0d29Db2RlKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHN0ciArPSB0d287XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocmVlQ29kZSAhPSBudWxsICYmIHRoaXMucGVlayA9PSB0aHJlZUNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgc3RyICs9IHRocmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdPcGVyYXRvclRva2VuKHN0YXJ0LCBzdHIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhbklkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHdoaWxlIChpc0lkZW50aWZpZXJQYXJ0KHRoaXMucGVlaykpXG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICByZXR1cm4gS0VZV09SRFMuaW5kZXhPZihzdHIpID4gLTEgPyBuZXdLZXl3b3JkVG9rZW4oc3RhcnQsIHN0cikgOlxuICAgICAgICAgICAgbmV3SWRlbnRpZmllclRva2VuKHN0YXJ0LCBzdHIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5OdW1iZXIgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2ltcGxlID0gKHRoaXMuaW5kZXggPT09IHN0YXJ0KTtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIFNraXAgaW5pdGlhbCBkaWdpdC5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChpc0RpZ2l0KHRoaXMucGVlaykpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVlayA9PSAkUEVSSU9EKSB7XG4gICAgICAgICAgICAgICAgc2ltcGxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0V4cG9uZW50U3RhcnQodGhpcy5wZWVrKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChpc0V4cG9uZW50U2lnbih0aGlzLnBlZWspKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGlnaXQodGhpcy5wZWVrKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0ludmFsaWQgZXhwb25lbnQnLCAtMSk7XG4gICAgICAgICAgICAgICAgc2ltcGxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyaW5nKHN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBzaW1wbGUgPyBwYXJzZUludEF1dG9SYWRpeChzdHIpIDogcGFyc2VGbG9hdChzdHIpO1xuICAgICAgICByZXR1cm4gbmV3TnVtYmVyVG9rZW4oc3RhcnQsIHZhbHVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVvdGUgPSB0aGlzLnBlZWs7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBTa2lwIGluaXRpYWwgcXVvdGUuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJ1ZmZlciA9ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXJrZXIgPSB0aGlzLmluZGV4O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gICAgICAgIHdoaWxlICh0aGlzLnBlZWsgIT0gcXVvdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWsgPT0gJEJBQ0tTTEFTSCkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBpbnB1dC5zdWJzdHJpbmcobWFya2VyLCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1bmVzY2FwZWRDb2RlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIFRTMi4xLWludHJvZHVjZWQgdHlwZSBzdHJpY3RuZXNzXG4gICAgICAgICAgICAgICAgdGhpcy5wZWVrID0gdGhpcy5wZWVrO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlZWsgPT0gJHUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gNCBjaGFyYWN0ZXIgaGV4IGNvZGUgZm9yIHVuaWNvZGUgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoZXggPSBpbnB1dC5zdWJzdHJpbmcodGhpcy5pbmRleCArIDEsIHRoaXMuaW5kZXggKyA1KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9eWzAtOWEtZl0rJC9pLnRlc3QoaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkQ29kZSA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlIFtcXFxcdVwiICsgaGV4ICsgXCJdXCIsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWRDb2RlID0gdW5lc2NhcGUodGhpcy5wZWVrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVuZXNjYXBlZENvZGUpO1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlZWsgPT0gJEVPRikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdVbnRlcm1pbmF0ZWQgcXVvdGUnLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3QgPSBpbnB1dC5zdWJzdHJpbmcobWFya2VyLCB0aGlzLmluZGV4KTtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIFNraXAgdGVybWluYXRpbmcgcXVvdGUuXG4gICAgICAgIHJldHVybiBuZXdTdHJpbmdUb2tlbihzdGFydCwgYnVmZmVyICsgbGFzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gez99IG9mZnNldFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9mZnNldCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3NpdGlvbiA9IHRoaXMuaW5kZXggKyBvZmZzZXQ7XG4gICAgICAgIHJldHVybiBuZXdFcnJvclRva2VuKHBvc2l0aW9uLCBcIkxleGVyIEVycm9yOiBcIiArIG1lc3NhZ2UgKyBcIiBhdCBjb2x1bW4gXCIgKyBwb3NpdGlvbiArIFwiIGluIGV4cHJlc3Npb24gW1wiICsgdGhpcy5pbnB1dCArIFwiXVwiKTtcbiAgICB9O1xuICAgIHJldHVybiBfU2Nhbm5lcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSkge1xuICAgIHJldHVybiAoJGEgPD0gY29kZSAmJiBjb2RlIDw9ICR6KSB8fCAoJEEgPD0gY29kZSAmJiBjb2RlIDw9ICRaKSB8fFxuICAgICAgICAoY29kZSA9PSAkXykgfHwgKGNvZGUgPT0gJCQpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0lkZW50aWZpZXIoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY2FubmVyID0gbmV3IF9TY2FubmVyKGlucHV0KTtcbiAgICBpZiAoIWlzSWRlbnRpZmllclN0YXJ0KHNjYW5uZXIucGVlaykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBzY2FubmVyLmFkdmFuY2UoKTtcbiAgICB3aGlsZSAoc2Nhbm5lci5wZWVrICE9PSAkRU9GKSB7XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChzY2FubmVyLnBlZWspKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBzY2FubmVyLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjb2RlKSB7XG4gICAgcmV0dXJuIGlzQXNjaWlMZXR0ZXIoY29kZSkgfHwgaXNEaWdpdChjb2RlKSB8fCAoY29kZSA9PSAkXykgfHxcbiAgICAgICAgKGNvZGUgPT0gJCQpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRXhwb25lbnRTdGFydChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT0gJGUgfHwgY29kZSA9PSAkRTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0V4cG9uZW50U2lnbihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT0gJE1JTlVTIHx8IGNvZGUgPT0gJFBMVVM7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNRdW90ZShjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT09ICRTUSB8fCBjb2RlID09PSAkRFEgfHwgY29kZSA9PT0gJEJUO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSAkbjpcbiAgICAgICAgICAgIHJldHVybiAkTEY7XG4gICAgICAgIGNhc2UgJGY6XG4gICAgICAgICAgICByZXR1cm4gJEZGO1xuICAgICAgICBjYXNlICRyOlxuICAgICAgICAgICAgcmV0dXJuICRDUjtcbiAgICAgICAgY2FzZSAkdDpcbiAgICAgICAgICAgIHJldHVybiAkVEFCO1xuICAgICAgICBjYXNlICR2OlxuICAgICAgICAgICAgcmV0dXJuICRWVEFCO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IHRleHRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHBhcnNlSW50QXV0b1JhZGl4KHRleHQpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBwYXJzZUludCh0ZXh0KTtcbiAgICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyAnICsgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgU3BsaXRJbnRlcnBvbGF0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0cmluZ3NcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25zXG4gICAgICogQHBhcmFtIHs/fSBvZmZzZXRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3BsaXRJbnRlcnBvbGF0aW9uKHN0cmluZ3MsIGV4cHJlc3Npb25zLCBvZmZzZXRzKSB7XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgICAgdGhpcy5vZmZzZXRzID0gb2Zmc2V0cztcbiAgICB9XG4gICAgcmV0dXJuIFNwbGl0SW50ZXJwb2xhdGlvbjtcbn0oKSk7XG52YXIgVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVCaW5kaW5nc1xuICAgICAqIEBwYXJhbSB7P30gd2FybmluZ3NcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0KHRlbXBsYXRlQmluZGluZ3MsIHdhcm5pbmdzLCBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUJpbmRpbmdzID0gdGVtcGxhdGVCaW5kaW5ncztcbiAgICAgICAgdGhpcy53YXJuaW5ncyA9IHdhcm5pbmdzO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG4gICAgcmV0dXJuIFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0O1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBjb25maWdcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9jcmVhdGVJbnRlcnBvbGF0ZVJlZ0V4cChjb25maWcpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXR0ZXJuID0gZXNjYXBlUmVnRXhwKGNvbmZpZy5zdGFydCkgKyAnKFtcXFxcc1xcXFxTXSo/KScgKyBlc2NhcGVSZWdFeHAoY29uZmlnLmVuZCk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgJ2cnKTtcbn1cbnZhciBQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2xleGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VyKF9sZXhlcikge1xuICAgICAgICB0aGlzLl9sZXhlciA9IF9sZXhlcjtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez89fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQWN0aW9uID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgIHRoaXMuX2NoZWNrTm9JbnRlcnBvbGF0aW9uKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZVRvTGV4ID0gdGhpcy5fc3RyaXBDb21tZW50cyhpbnB1dCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKHRoaXMuX3N0cmlwQ29tbWVudHMoaW5wdXQpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gbmV3IF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIHRva2Vucywgc291cmNlVG9MZXgubGVuZ3RoLCB0cnVlLCB0aGlzLmVycm9ycywgaW5wdXQubGVuZ3RoIC0gc291cmNlVG9MZXgubGVuZ3RoKVxuICAgICAgICAgICAgLnBhcnNlQ2hhaW4oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKGFzdCwgaW5wdXQsIGxvY2F0aW9uLCB0aGlzLmVycm9ycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHBhcmFtIHs/fSBsb2NhdGlvblxuICAgICAqIEBwYXJhbSB7Pz19IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCaW5kaW5nID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IHRoaXMuX3BhcnNlQmluZGluZ0FzdChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNpbXBsZUJpbmRpbmcgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gdGhpcy5fcGFyc2VCaW5kaW5nQXN0KGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLmNoZWNrKGFzdCk7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJIb3N0IGJpbmRpbmcgZXhwcmVzc2lvbiBjYW5ub3QgY29udGFpbiBcIiArIGVycm9ycy5qb2luKCcgJyksIGlucHV0LCBsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKGFzdCwgaW5wdXQsIGxvY2F0aW9uLCB0aGlzLmVycm9ycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHBhcmFtIHs/fSBlcnJMb2NhdGlvblxuICAgICAqIEBwYXJhbSB7Pz19IGN0eExvY2F0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLl9yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBpbnB1dCwgZXJyTG9jYXRpb24sIGN0eExvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNlckVycm9yKG1lc3NhZ2UsIGlucHV0LCBlcnJMb2NhdGlvbiwgY3R4TG9jYXRpb24pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHs/fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZUJpbmRpbmdBc3QgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIC8vIFF1b3RlcyBleHByZXNzaW9ucyB1c2UgM3JkLXBhcnR5IGV4cHJlc3Npb24gbGFuZ3VhZ2UuIFdlIGRvbid0IHdhbnQgdG8gdXNlXG4gICAgICAgIC8vIG91ciBsZXhlciBvciBwYXJzZXIgZm9yIHRoYXQsIHNvIHdlIGNoZWNrIGZvciB0aGF0IGFoZWFkIG9mIHRpbWUuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1b3RlID0gdGhpcy5fcGFyc2VRdW90ZShpbnB1dCwgbG9jYXRpb24pO1xuICAgICAgICBpZiAocXVvdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHF1b3RlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoZWNrTm9JbnRlcnBvbGF0aW9uKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZVRvTGV4ID0gdGhpcy5fc3RyaXBDb21tZW50cyhpbnB1dCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKHNvdXJjZVRvTGV4KTtcbiAgICAgICAgcmV0dXJuIG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIHNvdXJjZVRvTGV4Lmxlbmd0aCwgZmFsc2UsIHRoaXMuZXJyb3JzLCBpbnB1dC5sZW5ndGggLSBzb3VyY2VUb0xleC5sZW5ndGgpXG4gICAgICAgICAgICAucGFyc2VDaGFpbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlUXVvdGUgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uKSB7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZWZpeFNlcGFyYXRvckluZGV4ID0gaW5wdXQuaW5kZXhPZignOicpO1xuICAgICAgICBpZiAocHJlZml4U2VwYXJhdG9ySW5kZXggPT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4ID0gaW5wdXQuc3Vic3RyaW5nKDAsIHByZWZpeFNlcGFyYXRvckluZGV4KS50cmltKCk7XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyKHByZWZpeCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdW5pbnRlcnByZXRlZEV4cHJlc3Npb24gPSBpbnB1dC5zdWJzdHJpbmcocHJlZml4U2VwYXJhdG9ySW5kZXggKyAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBRdW90ZShuZXcgUGFyc2VTcGFuKDAsIGlucHV0Lmxlbmd0aCksIHByZWZpeCwgdW5pbnRlcnByZXRlZEV4cHJlc3Npb24sIGxvY2F0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJlZml4VG9rZW5cbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHBhcmFtIHs/fSBsb2NhdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlQmluZGluZ3MgPSBmdW5jdGlvbiAocHJlZml4VG9rZW4sIGlucHV0LCBsb2NhdGlvbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZShpbnB1dCk7XG4gICAgICAgIGlmIChwcmVmaXhUb2tlbikge1xuICAgICAgICAgICAgLy8gUHJlZml4IHRoZSB0b2tlbnMgd2l0aCB0aGUgdG9rZW5zIGZyb20gcHJlZml4VG9rZW4gYnV0IGhhdmUgdGhlbSB0YWtlIG5vIHNwYWNlICgwIGluZGV4KS5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZWZpeFRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKHByZWZpeFRva2VuKS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB0LmluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdG9rZW5zLnVuc2hpZnQuYXBwbHkodG9rZW5zLCBwcmVmaXhUb2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCBpbnB1dC5sZW5ndGgsIGZhbHNlLCB0aGlzLmVycm9ycywgMClcbiAgICAgICAgICAgIC5wYXJzZVRlbXBsYXRlQmluZGluZ3MoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3BsaXQgPSB0aGlzLnNwbGl0SW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICBpZiAoc3BsaXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgc3BsaXQuZXhwcmVzc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb25UZXh0ID0gc3BsaXQuZXhwcmVzc2lvbnNbaV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VUb0xleCA9IHRoaXMuX3N0cmlwQ29tbWVudHMoZXhwcmVzc2lvblRleHQpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUodGhpcy5fc3RyaXBDb21tZW50cyhzcGxpdC5leHByZXNzaW9uc1tpXSkpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gbmV3IF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIHRva2Vucywgc291cmNlVG9MZXgubGVuZ3RoLCBmYWxzZSwgdGhpcy5lcnJvcnMsIHNwbGl0Lm9mZnNldHNbaV0gKyAoZXhwcmVzc2lvblRleHQubGVuZ3RoIC0gc291cmNlVG9MZXgubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAucGFyc2VDaGFpbigpO1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChhc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShuZXcgSW50ZXJwb2xhdGlvbihuZXcgUGFyc2VTcGFuKDAsIGlucHV0ID09IG51bGwgPyAwIDogaW5wdXQubGVuZ3RoKSwgc3BsaXQuc3RyaW5ncywgZXhwcmVzc2lvbnMpLCBpbnB1dCwgbG9jYXRpb24sIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5zcGxpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVnZXhwID0gX2NyZWF0ZUludGVycG9sYXRlUmVnRXhwKGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IGlucHV0LnNwbGl0KHJlZ2V4cCk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyaW5ncyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvZmZzZXRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZml4ZWQgc3RyaW5nXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBwYXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnQudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gaW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICBvZmZzZXRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gcGFydC5sZW5ndGggKyBpbnRlcnBvbGF0aW9uQ29uZmlnLmVuZC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcignQmxhbmsgZXhwcmVzc2lvbnMgYXJlIG5vdCBhbGxvd2VkIGluIGludGVycG9sYXRlZCBzdHJpbmdzJywgaW5wdXQsIFwiYXQgY29sdW1uIFwiICsgdGhpcy5fZmluZEludGVycG9sYXRpb25FcnJvckNvbHVtbihwYXJ0cywgaSwgaW50ZXJwb2xhdGlvbkNvbmZpZykgKyBcIiBpblwiLCBsb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCgnJGltcGxpY3QnKTtcbiAgICAgICAgICAgICAgICBvZmZzZXRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNwbGl0SW50ZXJwb2xhdGlvbihzdHJpbmdzLCBleHByZXNzaW9ucywgb2Zmc2V0cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHBhcmFtIHs/fSBsb2NhdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS53cmFwTGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKG5ldyBMaXRlcmFsUHJpbWl0aXZlKG5ldyBQYXJzZVNwYW4oMCwgaW5wdXQgPT0gbnVsbCA/IDAgOiBpbnB1dC5sZW5ndGgpLCBpbnB1dCksIGlucHV0LCBsb2NhdGlvbiwgdGhpcy5lcnJvcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5fc3RyaXBDb21tZW50cyA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gdGhpcy5fY29tbWVudFN0YXJ0KGlucHV0KTtcbiAgICAgICAgcmV0dXJuIGkgIT0gbnVsbCA/IGlucHV0LnN1YnN0cmluZygwLCBpKS50cmltKCkgOiBpbnB1dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUuX2NvbW1lbnRTdGFydCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXRlclF1b3RlID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hhciA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXh0Q2hhciA9IGlucHV0LmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICRTTEFTSCAmJiBuZXh0Q2hhciA9PSAkU0xBU0ggJiYgb3V0ZXJRdW90ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgaWYgKG91dGVyUXVvdGUgPT09IGNoYXIpIHtcbiAgICAgICAgICAgICAgICBvdXRlclF1b3RlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG91dGVyUXVvdGUgPT0gbnVsbCAmJiBpc1F1b3RlKGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgb3V0ZXJRdW90ZSA9IGNoYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHBhcmFtIHs/fSBsb2NhdGlvblxuICAgICAqIEBwYXJhbSB7P30gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5fY2hlY2tOb0ludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlZ2V4cCA9IF9jcmVhdGVJbnRlcnBvbGF0ZVJlZ0V4cChpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydHMgPSBpbnB1dC5zcGxpdChyZWdleHApO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJHb3QgaW50ZXJwb2xhdGlvbiAoXCIgKyBpbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0ICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQgKyBcIikgd2hlcmUgZXhwcmVzc2lvbiB3YXMgZXhwZWN0ZWRcIiwgaW5wdXQsIFwiYXQgY29sdW1uIFwiICsgdGhpcy5fZmluZEludGVycG9sYXRpb25FcnJvckNvbHVtbihwYXJ0cywgMSwgaW50ZXJwb2xhdGlvbkNvbmZpZykgKyBcIiBpblwiLCBsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFydHNcbiAgICAgKiBAcGFyYW0gez99IHBhcnRJbkVycklkeFxuICAgICAqIEBwYXJhbSB7P30gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5fZmluZEludGVycG9sYXRpb25FcnJvckNvbHVtbiA9IGZ1bmN0aW9uIChwYXJ0cywgcGFydEluRXJySWR4LCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVyckxvY2F0aW9uID0gJyc7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaiA9IDA7IGogPCBwYXJ0SW5FcnJJZHg7IGorKykge1xuICAgICAgICAgICAgZXJyTG9jYXRpb24gKz0gaiAlIDIgPT09IDAgP1xuICAgICAgICAgICAgICAgIHBhcnRzW2pdIDpcbiAgICAgICAgICAgICAgICBcIlwiICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCArIHBhcnRzW2pdICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVyckxvY2F0aW9uLmxlbmd0aDtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZXI7XG59KCkpO1xuUGFyc2VyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblBhcnNlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IExleGVyLCB9LFxuXTsgfTtcbnZhciBfUGFyc2VBU1QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHs/fSB0b2tlbnNcbiAgICAgKiBAcGFyYW0gez99IGlucHV0TGVuZ3RoXG4gICAgICogQHBhcmFtIHs/fSBwYXJzZUFjdGlvblxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICogQHBhcmFtIHs/fSBvZmZzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIGlucHV0TGVuZ3RoLCBwYXJzZUFjdGlvbiwgZXJyb3JzLCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgICAgICB0aGlzLmlucHV0TGVuZ3RoID0gaW5wdXRMZW5ndGg7XG4gICAgICAgIHRoaXMucGFyc2VBY3Rpb24gPSBwYXJzZUFjdGlvbjtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZCA9IDA7XG4gICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQgPSAwO1xuICAgICAgICB0aGlzLnJicmFjZXNFeHBlY3RlZCA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9mZnNldFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gdGhpcy5pbmRleCArIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIGkgPCB0aGlzLnRva2Vucy5sZW5ndGggPyB0aGlzLnRva2Vuc1tpXSA6IEVPRjtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfUGFyc2VBU1QucHJvdG90eXBlLCBcIm5leHRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wZWVrKDApOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX1BhcnNlQVNULnByb3RvdHlwZSwgXCJpbnB1dEluZGV4XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkgPyB0aGlzLm5leHQuaW5kZXggKyB0aGlzLm9mZnNldCA6XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dExlbmd0aCArIHRoaXMub2Zmc2V0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnNwYW4gPSBmdW5jdGlvbiAoc3RhcnQpIHsgcmV0dXJuIG5ldyBQYXJzZVNwYW4oc3RhcnQsIHRoaXMuaW5wdXRJbmRleCk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiAoKSB7IHRoaXMuaW5kZXgrKzsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUub3B0aW9uYWxDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0LmlzQ2hhcmFjdGVyKGNvZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGVla0tleXdvcmRMZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5leHQuaXNLZXl3b3JkTGV0KCk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBlZWtLZXl3b3JkQXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5leHQuaXNLZXl3b3JkQXMoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0Q2hhcmFjdGVyID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoY29kZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZXJyb3IoXCJNaXNzaW5nIGV4cGVjdGVkIFwiICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9wXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLm9wdGlvbmFsT3BlcmF0b3IgPSBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dC5pc09wZXJhdG9yKG9wKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvcGVyYXRvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RPcGVyYXRvciA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKG9wZXJhdG9yKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5lcnJvcihcIk1pc3NpbmcgZXhwZWN0ZWQgb3BlcmF0b3IgXCIgKyBvcGVyYXRvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbiA9IHRoaXMubmV4dDtcbiAgICAgICAgaWYgKCFuLmlzSWRlbnRpZmllcigpICYmICFuLmlzS2V5d29yZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCB0b2tlbiBcIiArIG4gKyBcIiwgZXhwZWN0ZWQgaWRlbnRpZmllciBvciBrZXl3b3JkXCIpO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICByZXR1cm4gbi50b1N0cmluZygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmRPclN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbiA9IHRoaXMubmV4dDtcbiAgICAgICAgaWYgKCFuLmlzSWRlbnRpZmllcigpICYmICFuLmlzS2V5d29yZCgpICYmICFuLmlzU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgbiArIFwiLCBleHBlY3RlZCBpZGVudGlmaWVyLCBrZXl3b3JkLCBvciBzdHJpbmdcIik7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VDaGFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwcnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgIGV4cHJzLnB1c2goZXhwcik7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkU0VNSUNPTE9OKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wYXJzZUFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdCaW5kaW5nIGV4cHJlc3Npb24gY2Fubm90IGNvbnRhaW4gY2hhaW5lZCBleHByZXNzaW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRTRU1JQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgfSAvLyByZWFkIGFsbCBzZW1pY29sb25zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gJ1wiICsgdGhpcy5uZXh0ICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHBycy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICBpZiAoZXhwcnMubGVuZ3RoID09IDEpXG4gICAgICAgICAgICByZXR1cm4gZXhwcnNbMF07XG4gICAgICAgIHJldHVybiBuZXcgQ2hhaW4odGhpcy5zcGFuKHN0YXJ0KSwgZXhwcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlUGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignfCcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZUFjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ0Nhbm5vdCBoYXZlIGEgcGlwZSBpbiBhbiBhY3Rpb24gZXhwcmVzc2lvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSAoKHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCgpKSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT0xPTikpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKHRoaXMucGFyc2VFeHByZXNzaW9uKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluZGluZ1BpcGUodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgcmVzdWx0LCBuYW1lLCBhcmdzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignfCcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucGFyc2VDb25kaXRpb25hbCgpOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNvbmRpdGlvbmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5wYXJzZUxvZ2ljYWxPcigpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc/JykpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHllcyA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBubyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb24gPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiQ29uZGl0aW9uYWwgZXhwcmVzc2lvbiBcIiArIGV4cHJlc3Npb24gKyBcIiByZXF1aXJlcyBhbGwgMyBleHByZXNzaW9uc1wiKTtcbiAgICAgICAgICAgICAgICBubyA9IG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBubyA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsKHRoaXMuc3BhbihzdGFydCksIHJlc3VsdCwgeWVzLCBubyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VMb2dpY2FsT3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICd8fCdcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5wYXJzZUxvZ2ljYWxBbmQoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignfHwnKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmlnaHQgPSB0aGlzLnBhcnNlTG9naWNhbEFuZCgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCAnfHwnLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlTG9naWNhbEFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gJyYmJ1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLnBhcnNlRXF1YWxpdHkoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignJiYnKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmlnaHQgPSB0aGlzLnBhcnNlRXF1YWxpdHkoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgJyYmJywgcmVzdWx0LCByaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUVxdWFsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAnPT0nLCchPScsJz09PScsJyE9PSdcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5wYXJzZVJlbGF0aW9uYWwoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByaWdodCA9IHRoaXMucGFyc2VSZWxhdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VSZWxhdGlvbmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAnPCcsICc+JywgJzw9JywgJz49J1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLnBhcnNlQWRkaXRpdmUoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJpZ2h0ID0gdGhpcy5wYXJzZUFkZGl0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VBZGRpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gJysnLCAnLSdcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5wYXJzZU11bHRpcGxpY2F0aXZlKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBUb2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmlnaHQgPSB0aGlzLnBhcnNlTXVsdGlwbGljYXRpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCBvcGVyYXRvciwgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZU11bHRpcGxpY2F0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAnKicsICclJywgJy8nXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByaWdodCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCBvcGVyYXRvciwgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcGVyYXRvciA9IHRoaXMubmV4dC5zdHJWYWx1ZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5KHRoaXMuc3BhbihzdGFydCksIG9wZXJhdG9yLCBuZXcgTGl0ZXJhbFByaW1pdGl2ZShuZXcgUGFyc2VTcGFuKHN0YXJ0LCBzdGFydCksIDApLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByZWZpeE5vdCh0aGlzLnNwYW4oc3RhcnQpLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2FsbENoYWluKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VDYWxsQ2hhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkUEVSSU9EKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwocmVzdWx0LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz8uJykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlQWNjZXNzTWVtYmVyT3JNZXRob2RDYWxsKHJlc3VsdCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRMQlJBQ0tFVCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkKys7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkLS07XG4gICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJCUkFDS0VUKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEtleWVkV3JpdGUodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgcmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBLZXllZFJlYWQodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgcmVzdWx0LCBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJExQQVJFTikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSB0aGlzLnBhcnNlQ2FsbEFyZ3VtZW50cygpO1xuICAgICAgICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkLS07XG4gICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJQQVJFTik7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEZ1bmN0aW9uQ2FsbCh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCByZXN1bHQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlUHJpbWFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRMUEFSRU4pKSB7XG4gICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkLS07XG4gICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUlBBUkVOKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZE51bGwoKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZFVuZGVmaW5lZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB2b2lkIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRUcnVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRGYWxzZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZFRoaXMoKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEltcGxpY2l0UmVjZWl2ZXIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkTEJSQUNLRVQpKSB7XG4gICAgICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkKys7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50cyA9IHRoaXMucGFyc2VFeHByZXNzaW9uTGlzdCgkUkJSQUNLRVQpO1xuICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJCUkFDS0VUKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5KHRoaXMuc3BhbihzdGFydCksIGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNDaGFyYWN0ZXIoJExCUkFDRSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0lkZW50aWZpZXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwobmV3IEltcGxpY2l0UmVjZWl2ZXIodGhpcy5zcGFuKHN0YXJ0KSksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNOdW1iZXIoKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0aGlzLm5leHQudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNTdHJpbmcoKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGl0ZXJhbFZhbHVlID0gdGhpcy5uZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCBsaXRlcmFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgZXhwcmVzc2lvbjogXCIgKyB0aGlzLmlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gXCIgKyB0aGlzLm5leHQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGVybWluYXRvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUV4cHJlc3Npb25MaXN0ID0gZnVuY3Rpb24gKHRlcm1pbmF0b3IpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gW107XG4gICAgICAgIGlmICghdGhpcy5uZXh0LmlzQ2hhcmFjdGVyKHRlcm1pbmF0b3IpKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5wYXJzZVBpcGUoKSk7XG4gICAgICAgICAgICB9IHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT01NQSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VMaXRlcmFsTWFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXlzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJExCUkFDRSk7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25hbENoYXJhY3RlcigkUkJSQUNFKSkge1xuICAgICAgICAgICAgdGhpcy5yYnJhY2VzRXhwZWN0ZWQrKztcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXkgPSAoKHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZE9yU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkQ09MT04pO1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMucGFyc2VQaXBlKCkpO1xuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09NTUEpKTtcbiAgICAgICAgICAgIHRoaXMucmJyYWNlc0V4cGVjdGVkLS07XG4gICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUkJSQUNFKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXAodGhpcy5zcGFuKHN0YXJ0KSwga2V5cywgdmFsdWVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0gez89fSBpc1NhZmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwgPSBmdW5jdGlvbiAocmVjZWl2ZXIsIGlzU2FmZSkge1xuICAgICAgICBpZiAoaXNTYWZlID09PSB2b2lkIDApIHsgaXNTYWZlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSByZWNlaXZlci5zcGFuLnN0YXJ0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9ICgodGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkKCkpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJExQQVJFTikpIHtcbiAgICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkKys7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gdGhpcy5wYXJzZUNhbGxBcmd1bWVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSUEFSRU4pO1xuICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNwYW4gPSB0aGlzLnNwYW4oc3RhcnQpO1xuICAgICAgICAgICAgcmV0dXJuIGlzU2FmZSA/IG5ldyBTYWZlTWV0aG9kQ2FsbChzcGFuLCByZWNlaXZlciwgaWQsIGFyZ3MpIDpcbiAgICAgICAgICAgICAgICBuZXcgTWV0aG9kQ2FsbChzcGFuLCByZWNlaXZlciwgaWQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzU2FmZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdUaGUgXFwnPy5cXCcgb3BlcmF0b3IgY2Fubm90IGJlIHVzZWQgaW4gdGhlIGFzc2lnbm1lbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNhZmVQcm9wZXJ0eVJlYWQodGhpcy5zcGFuKHN0YXJ0KSwgcmVjZWl2ZXIsIGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdCaW5kaW5ncyBjYW5ub3QgY29udGFpbiBhc3NpZ25tZW50cycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eVdyaXRlKHRoaXMuc3BhbihzdGFydCksIHJlY2VpdmVyLCBpZCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eVJlYWQodGhpcy5zcGFuKHN0YXJ0KSwgcmVjZWl2ZXIsIGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNhbGxBcmd1bWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQuaXNDaGFyYWN0ZXIoJFJQQVJFTikpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvc2l0aW9uYWxzID0gW107XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHBvc2l0aW9uYWxzLnB1c2godGhpcy5wYXJzZVBpcGUoKSk7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKSk7XG4gICAgICAgIHJldHVybiAocG9zaXRpb25hbHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQW4gaWRlbnRpZmllciwgYSBrZXl3b3JkLCBhIHN0cmluZyB3aXRoIGFuIG9wdGlvbmFsIGAtYCBpbmJldHdlZW4uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wZXJhdG9yRm91bmQgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZE9yU3RyaW5nKCk7XG4gICAgICAgICAgICBvcGVyYXRvckZvdW5kID0gdGhpcy5vcHRpb25hbE9wZXJhdG9yKCctJyk7XG4gICAgICAgICAgICBpZiAob3BlcmF0b3JGb3VuZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG9wZXJhdG9yRm91bmQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VUZW1wbGF0ZUJpbmRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5ncyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVmaXggPSAoKG51bGwpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd2FybmluZ3MgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5SXNWYXIgPSB0aGlzLnBlZWtLZXl3b3JkTGV0KCk7XG4gICAgICAgICAgICBpZiAoa2V5SXNWYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJhd0tleSA9IHRoaXMuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5KCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXkgPSByYXdLZXk7XG4gICAgICAgICAgICBpZiAoIWtleUlzVmFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHByZWZpeCArIGtleVswXS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT0xPTik7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gKChudWxsKSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByZXNzaW9uID0gKChudWxsKSk7XG4gICAgICAgICAgICBpZiAoa2V5SXNWYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gJ1xcJGltcGxpY2l0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlZWtLZXl3b3JkQXMoKSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxldFN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBjb25zdW1lIGBhc2BcbiAgICAgICAgICAgICAgICBuYW1lID0gcmF3S2V5O1xuICAgICAgICAgICAgICAgIGtleSA9IHRoaXMuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5KCk7IC8vIHJlYWQgbG9jYWwgdmFyIG5hbWVcbiAgICAgICAgICAgICAgICBrZXlJc1ZhciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQgIT09IEVPRiAmJiAhdGhpcy5wZWVrS2V5d29yZExldCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRfMiA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZSA9IHRoaXMuaW5wdXQuc3Vic3RyaW5nKHN0YXJ0XzIgLSB0aGlzLm9mZnNldCwgdGhpcy5pbnB1dEluZGV4IC0gdGhpcy5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBuZXcgQVNUV2l0aFNvdXJjZShhc3QsIHNvdXJjZSwgdGhpcy5sb2NhdGlvbiwgdGhpcy5lcnJvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmluZGluZ3MucHVzaChuZXcgVGVtcGxhdGVCaW5kaW5nKHRoaXMuc3BhbihzdGFydCksIGtleSwga2V5SXNWYXIsIG5hbWUsIGV4cHJlc3Npb24pKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWtLZXl3b3JkQXMoKSAmJiAha2V5SXNWYXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZXRTdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gY29uc3VtZSBgYXNgXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGV0TmFtZSA9IHRoaXMuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5KCk7IC8vIHJlYWQgbG9jYWwgdmFyIG5hbWVcbiAgICAgICAgICAgICAgICBiaW5kaW5ncy5wdXNoKG5ldyBUZW1wbGF0ZUJpbmRpbmcodGhpcy5zcGFuKGxldFN0YXJ0KSwgbGV0TmFtZSwgdHJ1ZSwga2V5LCAvKiogQHR5cGUgez99ICovICgobnVsbCkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJFNFTUlDT0xPTikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT01NQSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZUJpbmRpbmdQYXJzZVJlc3VsdChiaW5kaW5ncywgd2FybmluZ3MsIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7Pz19IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gbnVsbDsgfVxuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBQYXJzZXJFcnJvcihtZXNzYWdlLCB0aGlzLmlucHV0LCB0aGlzLmxvY2F0aW9uVGV4dChpbmRleCksIHRoaXMubG9jYXRpb24pKTtcbiAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBpbmRleFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5sb2NhdGlvblRleHQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSBudWxsOyB9XG4gICAgICAgIGlmIChpbmRleCA9PSBudWxsKVxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICByZXR1cm4gKGluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSA/IFwiYXQgY29sdW1uIFwiICsgKHRoaXMudG9rZW5zW2luZGV4XS5pbmRleCArIDEpICsgXCIgaW5cIiA6XG4gICAgICAgICAgICBcImF0IHRoZSBlbmQgb2YgdGhlIGV4cHJlc3Npb25cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuID0gdGhpcy5uZXh0O1xuICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCAmJiAhbi5pc0NoYXJhY3RlcigkU0VNSUNPTE9OKSAmJlxuICAgICAgICAgICAgKHRoaXMucnBhcmVuc0V4cGVjdGVkIDw9IDAgfHwgIW4uaXNDaGFyYWN0ZXIoJFJQQVJFTikpICYmXG4gICAgICAgICAgICAodGhpcy5yYnJhY2VzRXhwZWN0ZWQgPD0gMCB8fCAhbi5pc0NoYXJhY3RlcigkUkJSQUNFKSkgJiZcbiAgICAgICAgICAgICh0aGlzLnJicmFja2V0c0V4cGVjdGVkIDw9IDAgfHwgIW4uaXNDaGFyYWN0ZXIoJFJCUkFDS0VUKSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQuaXNFcnJvcigpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2VyRXJyb3IoLyoqIEB0eXBlIHs/fSAqLyAoKHRoaXMubmV4dC50b1N0cmluZygpKSksIHRoaXMuaW5wdXQsIHRoaXMubG9jYXRpb25UZXh0KCksIHRoaXMubG9jYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgbiA9IHRoaXMubmV4dDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIF9QYXJzZUFTVDtcbn0oKSk7XG52YXIgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyKCkge1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIuY2hlY2sgPSBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHMgPSBuZXcgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIoKTtcbiAgICAgICAgYXN0LnZpc2l0KHMpO1xuICAgICAgICByZXR1cm4gcy5lcnJvcnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0SW1wbGljaXRSZWNlaXZlciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRTYWZlTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy52aXNpdEFsbChhc3QudmFsdWVzKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0QmluYXJ5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB0aGlzLmVycm9ycy5wdXNoKCdwaXBlcycpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEtleWVkV3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAoYXN0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gYXN0cy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UXVvdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgcmV0dXJuIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBQYXJzZUxvY2F0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZpbGVcbiAgICAgKiBAcGFyYW0gez99IG9mZnNldFxuICAgICAqIEBwYXJhbSB7P30gbGluZVxuICAgICAqIEBwYXJhbSB7P30gY29sXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VMb2NhdGlvbihmaWxlLCBvZmZzZXQsIGxpbmUsIGNvbCkge1xuICAgICAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5jb2wgPSBjb2w7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VMb2NhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldCAhPSBudWxsID8gdGhpcy5maWxlLnVybCArIFwiQFwiICsgdGhpcy5saW5lICsgXCI6XCIgKyB0aGlzLmNvbCA6IHRoaXMuZmlsZS51cmw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlbHRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZUxvY2F0aW9uLnByb3RvdHlwZS5tb3ZlQnkgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlID0gdGhpcy5maWxlLmNvbnRlbnQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlbiA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaW5lID0gdGhpcy5saW5lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2wgPSB0aGlzLmNvbDtcbiAgICAgICAgd2hpbGUgKG9mZnNldCA+IDAgJiYgZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgICAgIGRlbHRhKys7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoY2ggPT0gJExGKSB7XG4gICAgICAgICAgICAgICAgbGluZS0tO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByaW9yTGluZSA9IHNvdXJjZS5zdWJzdHIoMCwgb2Zmc2V0IC0gMSkubGFzdEluZGV4T2YoU3RyaW5nLmZyb21DaGFyQ29kZSgkTEYpKTtcbiAgICAgICAgICAgICAgICBjb2wgPSBwcmlvckxpbmUgPiAwID8gb2Zmc2V0IC0gcHJpb3JMaW5lIDogb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IGxlbiAmJiBkZWx0YSA+IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoID0gc291cmNlLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgZGVsdGEtLTtcbiAgICAgICAgICAgIGlmIChjaCA9PSAkTEYpIHtcbiAgICAgICAgICAgICAgICBsaW5lKys7XG4gICAgICAgICAgICAgICAgY29sID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VMb2NhdGlvbih0aGlzLmZpbGUsIG9mZnNldCwgbGluZSwgY29sKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWF4Q2hhcnNcbiAgICAgKiBAcGFyYW0gez99IG1heExpbmVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZUxvY2F0aW9uLnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKG1heENoYXJzLCBtYXhMaW5lcykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZW50ID0gdGhpcy5maWxlLmNvbnRlbnQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmIChzdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPiBjb250ZW50Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBzdGFydE9mZnNldCA9IGNvbnRlbnQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R4Q2hhcnMgPSAwO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R4TGluZXMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGN0eENoYXJzIDwgbWF4Q2hhcnMgJiYgc3RhcnRPZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQtLTtcbiAgICAgICAgICAgICAgICBjdHhDaGFycysrO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50W3N0YXJ0T2Zmc2V0XSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKytjdHhMaW5lcyA9PSBtYXhMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHhDaGFycyA9IDA7XG4gICAgICAgICAgICBjdHhMaW5lcyA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoY3R4Q2hhcnMgPCBtYXhDaGFycyAmJiBlbmRPZmZzZXQgPCBjb250ZW50Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBlbmRPZmZzZXQrKztcbiAgICAgICAgICAgICAgICBjdHhDaGFycysrO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50W2VuZE9mZnNldF0gPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCsrY3R4TGluZXMgPT0gbWF4TGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGNvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0T2Zmc2V0LCB0aGlzLm9mZnNldCksXG4gICAgICAgICAgICAgICAgYWZ0ZXI6IGNvbnRlbnQuc3Vic3RyaW5nKHRoaXMub2Zmc2V0LCBlbmRPZmZzZXQgKyAxKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyc2VMb2NhdGlvbjtcbn0oKSk7XG52YXIgUGFyc2VTb3VyY2VGaWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhcnNlU291cmNlRmlsZShjb250ZW50LCB1cmwpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgfVxuICAgIHJldHVybiBQYXJzZVNvdXJjZUZpbGU7XG59KCkpO1xudmFyIFBhcnNlU291cmNlU3BhbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFxuICAgICAqIEBwYXJhbSB7P30gZW5kXG4gICAgICogQHBhcmFtIHs/PX0gZGV0YWlsc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhcnNlU291cmNlU3BhbihzdGFydCwgZW5kLCBkZXRhaWxzKSB7XG4gICAgICAgIGlmIChkZXRhaWxzID09PSB2b2lkIDApIHsgZGV0YWlscyA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZVNvdXJjZVNwYW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5maWxlLmNvbnRlbnQuc3Vic3RyaW5nKHRoaXMuc3RhcnQub2Zmc2V0LCB0aGlzLmVuZC5vZmZzZXQpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlU291cmNlU3Bhbjtcbn0oKSk7XG52YXIgUGFyc2VFcnJvckxldmVsID0ge307XG5QYXJzZUVycm9yTGV2ZWwuV0FSTklORyA9IDA7XG5QYXJzZUVycm9yTGV2ZWwuRVJST1IgPSAxO1xuUGFyc2VFcnJvckxldmVsW1BhcnNlRXJyb3JMZXZlbC5XQVJOSU5HXSA9IFwiV0FSTklOR1wiO1xuUGFyc2VFcnJvckxldmVsW1BhcnNlRXJyb3JMZXZlbC5FUlJPUl0gPSBcIkVSUk9SXCI7XG52YXIgUGFyc2VFcnJvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSBtc2dcbiAgICAgKiBAcGFyYW0gez89fSBsZXZlbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhcnNlRXJyb3Ioc3BhbiwgbXNnLCBsZXZlbCkge1xuICAgICAgICBpZiAobGV2ZWwgPT09IHZvaWQgMCkgeyBsZXZlbCA9IFBhcnNlRXJyb3JMZXZlbC5FUlJPUjsgfVxuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgICAgICB0aGlzLm1zZyA9IG1zZztcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHggPSB0aGlzLnNwYW4uc3RhcnQuZ2V0Q29udGV4dCgxMDAsIDMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZXh0U3RyID0gY3R4ID8gXCIgKFxcXCJcIiArIGN0eC5iZWZvcmUgKyBcIltcIiArIFBhcnNlRXJyb3JMZXZlbFt0aGlzLmxldmVsXSArIFwiIC0+XVwiICsgY3R4LmFmdGVyICsgXCJcXFwiKVwiIDogJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRldGFpbHMgPSB0aGlzLnNwYW4uZGV0YWlscyA/IFwiLCBcIiArIHRoaXMuc3Bhbi5kZXRhaWxzIDogJyc7XG4gICAgICAgIHJldHVybiBcIlwiICsgdGhpcy5tc2cgKyBjb250ZXh0U3RyICsgXCI6IFwiICsgdGhpcy5zcGFuLnN0YXJ0ICsgZGV0YWlscztcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZUVycm9yO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBraW5kXG4gKiBAcGFyYW0gez99IHR5cGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHR5cGVTb3VyY2VTcGFuKGtpbmQsIHR5cGUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVVcmwgPSBpZGVudGlmaWVyTW9kdWxlVXJsKHR5cGUpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZUZpbGVOYW1lID0gbW9kdWxlVXJsICE9IG51bGwgPyBcImluIFwiICsga2luZCArIFwiIFwiICsgaWRlbnRpZmllck5hbWUodHlwZSkgKyBcIiBpbiBcIiArIG1vZHVsZVVybCA6XG4gICAgICAgIFwiaW4gXCIgKyBraW5kICsgXCIgXCIgKyBpZGVudGlmaWVyTmFtZSh0eXBlKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VGaWxlID0gbmV3IFBhcnNlU291cmNlRmlsZSgnJywgc291cmNlRmlsZU5hbWUpO1xuICAgIHJldHVybiBuZXcgUGFyc2VTb3VyY2VTcGFuKG5ldyBQYXJzZUxvY2F0aW9uKHNvdXJjZUZpbGUsIC0xLCAtMSwgLTEpLCBuZXcgUGFyc2VMb2NhdGlvbihzb3VyY2VGaWxlLCAtMSwgLTEsIC0xKSk7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgVGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRleHQodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRleHQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBUZXh0O1xufSgpKTtcbnZhciBFeHBhbnNpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3dpdGNoVmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IGNhc2VzXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSBzd2l0Y2hWYWx1ZVNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFeHBhbnNpb24oc3dpdGNoVmFsdWUsIHR5cGUsIGNhc2VzLCBzb3VyY2VTcGFuLCBzd2l0Y2hWYWx1ZVNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5zd2l0Y2hWYWx1ZSA9IHN3aXRjaFZhbHVlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNhc2VzID0gY2FzZXM7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuc3dpdGNoVmFsdWVTb3VyY2VTcGFuID0gc3dpdGNoVmFsdWVTb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cGFuc2lvbi5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEV4cGFuc2lvbih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gRXhwYW5zaW9uO1xufSgpKTtcbnZhciBFeHBhbnNpb25DYXNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IGV4cFNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFeHBhbnNpb25DYXNlKHZhbHVlLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB2YWx1ZVNvdXJjZVNwYW4sIGV4cFNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLnZhbHVlU291cmNlU3BhbiA9IHZhbHVlU291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5leHBTb3VyY2VTcGFuID0gZXhwU291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHBhbnNpb25DYXNlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RXhwYW5zaW9uQ2FzZSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gRXhwYW5zaW9uQ2FzZTtcbn0oKSk7XG52YXIgQXR0cmlidXRlJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez89fSB2YWx1ZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBdHRyaWJ1dGUkMShuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdmFsdWVTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNwYW4gPSB2YWx1ZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXR0cmlidXRlJDEucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRBdHRyaWJ1dGUodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIEF0dHJpYnV0ZSQxO1xufSgpKTtcbnZhciBFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGF0dHJzXG4gICAgICogQHBhcmFtIHs/fSBjaGlsZHJlblxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7Pz19IHN0YXJ0U291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7Pz19IGVuZFNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbGVtZW50KG5hbWUsIGF0dHJzLCBjaGlsZHJlbiwgc291cmNlU3Bhbiwgc3RhcnRTb3VyY2VTcGFuLCBlbmRTb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmIChzdGFydFNvdXJjZVNwYW4gPT09IHZvaWQgMCkgeyBzdGFydFNvdXJjZVNwYW4gPSBudWxsOyB9XG4gICAgICAgIGlmIChlbmRTb3VyY2VTcGFuID09PSB2b2lkIDApIHsgZW5kU291cmNlU3BhbiA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuc3RhcnRTb3VyY2VTcGFuID0gc3RhcnRTb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmVuZFNvdXJjZVNwYW4gPSBlbmRTb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRFbGVtZW50KHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBFbGVtZW50O1xufSgpKTtcbnZhciBDb21tZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tbWVudCh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tbWVudC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdENvbW1lbnQodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIENvbW1lbnQ7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHZpc2l0b3JcbiAqIEBwYXJhbSB7P30gbm9kZXNcbiAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHZpc2l0QWxsKHZpc2l0b3IsIG5vZGVzLCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0ID0gdmlzaXRvci52aXNpdCA/XG4gICAgICAgIGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuICgodmlzaXRvci52aXNpdCkpKGFzdCwgY29udGV4dCkgfHwgYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpOyB9IDpcbiAgICAgICAgZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpOyB9O1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3RSZXN1bHQgPSB2aXNpdChhc3QpO1xuICAgICAgICBpZiAoYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhc3RSZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUb2tlblR5cGUkMSA9IHt9O1xuVG9rZW5UeXBlJDEuVEFHX09QRU5fU1RBUlQgPSAwO1xuVG9rZW5UeXBlJDEuVEFHX09QRU5fRU5EID0gMTtcblRva2VuVHlwZSQxLlRBR19PUEVOX0VORF9WT0lEID0gMjtcblRva2VuVHlwZSQxLlRBR19DTE9TRSA9IDM7XG5Ub2tlblR5cGUkMS5URVhUID0gNDtcblRva2VuVHlwZSQxLkVTQ0FQQUJMRV9SQVdfVEVYVCA9IDU7XG5Ub2tlblR5cGUkMS5SQVdfVEVYVCA9IDY7XG5Ub2tlblR5cGUkMS5DT01NRU5UX1NUQVJUID0gNztcblRva2VuVHlwZSQxLkNPTU1FTlRfRU5EID0gODtcblRva2VuVHlwZSQxLkNEQVRBX1NUQVJUID0gOTtcblRva2VuVHlwZSQxLkNEQVRBX0VORCA9IDEwO1xuVG9rZW5UeXBlJDEuQVRUUl9OQU1FID0gMTE7XG5Ub2tlblR5cGUkMS5BVFRSX1ZBTFVFID0gMTI7XG5Ub2tlblR5cGUkMS5ET0NfVFlQRSA9IDEzO1xuVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlQgPSAxNDtcblRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX1ZBTFVFID0gMTU7XG5Ub2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQgPSAxNjtcblRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9FTkQgPSAxNztcblRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX0VORCA9IDE4O1xuVG9rZW5UeXBlJDEuRU9GID0gMTk7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5UQUdfT1BFTl9TVEFSVF0gPSBcIlRBR19PUEVOX1NUQVJUXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5UQUdfT1BFTl9FTkRdID0gXCJUQUdfT1BFTl9FTkRcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLlRBR19PUEVOX0VORF9WT0lEXSA9IFwiVEFHX09QRU5fRU5EX1ZPSURcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLlRBR19DTE9TRV0gPSBcIlRBR19DTE9TRVwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuVEVYVF0gPSBcIlRFWFRcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLkVTQ0FQQUJMRV9SQVdfVEVYVF0gPSBcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuUkFXX1RFWFRdID0gXCJSQVdfVEVYVFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuQ09NTUVOVF9TVEFSVF0gPSBcIkNPTU1FTlRfU1RBUlRcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLkNPTU1FTlRfRU5EXSA9IFwiQ09NTUVOVF9FTkRcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLkNEQVRBX1NUQVJUXSA9IFwiQ0RBVEFfU1RBUlRcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLkNEQVRBX0VORF0gPSBcIkNEQVRBX0VORFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuQVRUUl9OQU1FXSA9IFwiQVRUUl9OQU1FXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5BVFRSX1ZBTFVFXSA9IFwiQVRUUl9WQUxVRVwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuRE9DX1RZUEVdID0gXCJET0NfVFlQRVwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlRdID0gXCJFWFBBTlNJT05fRk9STV9TVEFSVFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfVkFMVUVdID0gXCJFWFBBTlNJT05fQ0FTRV9WQUxVRVwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUXSA9IFwiRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfRU5EXSA9IFwiRVhQQU5TSU9OX0NBU0VfRVhQX0VORFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fRU5EXSA9IFwiRVhQQU5TSU9OX0ZPUk1fRU5EXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5FT0ZdID0gXCJFT0ZcIjtcbnZhciBUb2tlbiQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IHBhcnRzXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9rZW4kMSh0eXBlLCBwYXJ0cywgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnBhcnRzID0gcGFydHM7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIHJldHVybiBUb2tlbiQxO1xufSgpKTtcbnZhciBUb2tlbkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVG9rZW5FcnJvciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yTXNnXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblR5cGVcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUb2tlbkVycm9yKGVycm9yTXNnLCB0b2tlblR5cGUsIHNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgZXJyb3JNc2cpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRva2VuVHlwZSA9IHRva2VuVHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVG9rZW5FcnJvcjtcbn0oUGFyc2VFcnJvcikpO1xudmFyIFRva2VuaXplUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRva2Vuc1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9rZW5pemVSZXN1bHQodG9rZW5zLCBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gVG9rZW5pemVSZXN1bHQ7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHNvdXJjZVxuICogQHBhcmFtIHs/fSB1cmxcbiAqIEBwYXJhbSB7P30gZ2V0VGFnRGVmaW5pdGlvblxuICogQHBhcmFtIHs/PX0gdG9rZW5pemVFeHBhbnNpb25Gb3Jtc1xuICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemUoc291cmNlLCB1cmwsIGdldFRhZ0RlZmluaXRpb24sIHRva2VuaXplRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICBpZiAodG9rZW5pemVFeHBhbnNpb25Gb3JtcyA9PT0gdm9pZCAwKSB7IHRva2VuaXplRXhwYW5zaW9uRm9ybXMgPSBmYWxzZTsgfVxuICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICByZXR1cm4gbmV3IF9Ub2tlbml6ZXIobmV3IFBhcnNlU291cmNlRmlsZShzb3VyY2UsIHVybCksIGdldFRhZ0RlZmluaXRpb24sIHRva2VuaXplRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpXG4gICAgICAgIC50b2tlbml6ZSgpO1xufVxudmFyIF9DUl9PUl9DUkxGX1JFR0VYUCA9IC9cXHJcXG4/L2c7XG4vKipcbiAqIEBwYXJhbSB7P30gY2hhckNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2coY2hhckNvZGUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGFyID0gY2hhckNvZGUgPT09ICRFT0YgPyAnRU9GJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgIHJldHVybiBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyIFxcXCJcIiArIGNoYXIgKyBcIlxcXCJcIjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlbnRpdHlTcmNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF91bmtub3duRW50aXR5RXJyb3JNc2coZW50aXR5U3JjKSB7XG4gICAgcmV0dXJuIFwiVW5rbm93biBlbnRpdHkgXFxcIlwiICsgZW50aXR5U3JjICsgXCJcXFwiIC0gdXNlIHRoZSBcXFwiJiM8ZGVjaW1hbD47XFxcIiBvciAgXFxcIiYjeDxoZXg+O1xcXCIgc3ludGF4XCI7XG59XG52YXIgX0NvbnRyb2xGbG93RXJyb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfQ29udHJvbEZsb3dFcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBfQ29udHJvbEZsb3dFcnJvcjtcbn0oKSk7XG52YXIgX1Rva2VuaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZmlsZSBUaGUgaHRtbCBzb3VyY2VcbiAgICAgKiBAcGFyYW0gez99IF9nZXRUYWdEZWZpbml0aW9uXG4gICAgICogQHBhcmFtIHs/fSBfdG9rZW5pemVJY3UgV2hldGhlciB0byB0b2tlbml6ZSBJQ1UgbWVzc2FnZXMgKGNvbnNpZGVyZWQgYXMgdGV4dCBub2RlcyB3aGVuIGZhbHNlKVxuICAgICAqIEBwYXJhbSB7Pz19IF9pbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICovXG4gICAgZnVuY3Rpb24gX1Rva2VuaXplcihfZmlsZSwgX2dldFRhZ0RlZmluaXRpb24sIF90b2tlbml6ZUljdSwgX2ludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgaWYgKF9pbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgX2ludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgIHRoaXMuX2ZpbGUgPSBfZmlsZTtcbiAgICAgICAgdGhpcy5fZ2V0VGFnRGVmaW5pdGlvbiA9IF9nZXRUYWdEZWZpbml0aW9uO1xuICAgICAgICB0aGlzLl90b2tlbml6ZUljdSA9IF90b2tlbml6ZUljdTtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgICAgICB0aGlzLl9wZWVrID0gLTE7XG4gICAgICAgIHRoaXMuX25leHRQZWVrID0gLTE7XG4gICAgICAgIHRoaXMuX2luZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuX2xpbmUgPSAwO1xuICAgICAgICB0aGlzLl9jb2x1bW4gPSAtMTtcbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrID0gW107XG4gICAgICAgIHRoaXMuX2luSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLl9pbnB1dCA9IF9maWxlLmNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IF9maWxlLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgICAgICAgLy8gSW4gb3JkZXIgdG8ga2VlcCB0aGUgb3JpZ2luYWwgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSwgd2UgY2FuIG5vdFxuICAgICAgICAvLyBwcmUtcHJvY2VzcyBpdC5cbiAgICAgICAgLy8gSW5zdGVhZCBDUnMgYXJlIHByb2Nlc3NlZCByaWdodCBiZWZvcmUgaW5zdGFudGlhdGluZyB0aGUgdG9rZW5zLlxuICAgICAgICByZXR1cm4gY29udGVudC5yZXBsYWNlKF9DUl9PUl9DUkxGX1JFR0VYUCwgJ1xcbicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09ICRFT0YpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTFQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEJBTkcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRMQlJBQ0tFVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ2RhdGEoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRNSU5VUykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ29tbWVudChzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRG9jVHlwZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRTTEFTSCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdDbG9zZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGFnT3BlbihzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoISh0aGlzLl90b2tlbml6ZUljdSAmJiB0aGlzLl90b2tlbml6ZUV4cGFuc2lvbkZvcm0oKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgX0NvbnRyb2xGbG93RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChlLmVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRU9GKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuaXplUmVzdWx0KG1lcmdlVGV4dFRva2Vucyh0aGlzLnRva2VucyksIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fdG9rZW5pemVFeHBhbnNpb25Gb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNFeHBhbnNpb25Gb3JtU3RhcnQodGhpcy5faW5wdXQsIHRoaXMuX2luZGV4LCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKSkge1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkZvcm1TdGFydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRXhwYW5zaW9uQ2FzZVN0YXJ0KHRoaXMuX3BlZWspICYmIHRoaXMuX2lzSW5FeHBhbnNpb25Gb3JtKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25DYXNlU3RhcnQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wZWVrID09PSAkUkJSQUNFKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNJbkV4cGFuc2lvbkNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25DYXNlRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faXNJbkV4cGFuc2lvbkZvcm0oKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25Gb3JtRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VMb2NhdGlvbih0aGlzLl9maWxlLCB0aGlzLl9pbmRleCwgdGhpcy5fbGluZSwgdGhpcy5fY29sdW1uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IHN0YXJ0XG4gICAgICogQHBhcmFtIHs/PX0gZW5kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0U3BhbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTsgfVxuICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gdGhpcy5fZ2V0TG9jYXRpb24oKTsgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydCwgZW5kKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYmVnaW5Ub2tlbiA9IGZ1bmN0aW9uICh0eXBlLCBzdGFydCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7IH1cbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuU3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuVHlwZSA9IHR5cGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcnRzXG4gICAgICogQHBhcmFtIHs/PX0gZW5kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZW5kVG9rZW4gPSBmdW5jdGlvbiAocGFydHMsIGVuZCkge1xuICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gdGhpcy5fZ2V0TG9jYXRpb24oKTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbiA9IG5ldyBUb2tlbiQxKHRoaXMuX2N1cnJlbnRUb2tlblR5cGUsIHBhcnRzLCBuZXcgUGFyc2VTb3VyY2VTcGFuKHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0LCBlbmQpKTtcbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gKChudWxsKSk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblR5cGUgPSAoKG51bGwpKTtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtc2dcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jcmVhdGVFcnJvciA9IGZ1bmN0aW9uIChtc2csIHNwYW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzSW5FeHBhbnNpb25Gb3JtKCkpIHtcbiAgICAgICAgICAgIG1zZyArPSBcIiAoRG8geW91IGhhdmUgYW4gdW5lc2NhcGVkIFxcXCJ7XFxcIiBpbiB5b3VyIHRlbXBsYXRlPyBVc2UgXFxcInt7ICd7JyB9fVxcXCIpIHRvIGVzY2FwZSBpdC4pXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3IgPSBuZXcgVG9rZW5FcnJvcihtc2csIHRoaXMuX2N1cnJlbnRUb2tlblR5cGUsIHNwYW4pO1xuICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5TdGFydCA9ICgobnVsbCkpO1xuICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5UeXBlID0gKChudWxsKSk7XG4gICAgICAgIHJldHVybiBuZXcgX0NvbnRyb2xGbG93RXJyb3IoZXJyb3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYWR2YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luZGV4ID49IHRoaXMuX2xlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZygkRU9GKSwgdGhpcy5fZ2V0U3BhbigpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGVlayA9PT0gJExGKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lKys7XG4gICAgICAgICAgICB0aGlzLl9jb2x1bW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsgIT09ICRMRiAmJiB0aGlzLl9wZWVrICE9PSAkQ1IpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbHVtbisrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luZGV4Kys7XG4gICAgICAgIHRoaXMuX3BlZWsgPSB0aGlzLl9pbmRleCA+PSB0aGlzLl9sZW5ndGggPyAkRU9GIDogdGhpcy5faW5wdXQuY2hhckNvZGVBdCh0aGlzLl9pbmRleCk7XG4gICAgICAgIHRoaXMuX25leHRQZWVrID1cbiAgICAgICAgICAgIHRoaXMuX2luZGV4ICsgMSA+PSB0aGlzLl9sZW5ndGggPyAkRU9GIDogdGhpcy5faW5wdXQuY2hhckNvZGVBdCh0aGlzLl9pbmRleCArIDEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFyQ29kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2F0dGVtcHRDaGFyQ29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICAgICAgICBpZiAodGhpcy5fcGVlayA9PT0gY2hhckNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2hhckNvZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0Q2hhckNvZGVDYXNlSW5zZW5zaXRpdmUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgICAgICAgaWYgKGNvbXBhcmVDaGFyQ29kZUNhc2VJbnNlbnNpdGl2ZSh0aGlzLl9wZWVrLCBjaGFyQ29kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2hhckNvZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXF1aXJlQ2hhckNvZGUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG9jYXRpb24gPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRDaGFyQ29kZShjaGFyQ29kZSkpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fcGVlayksIHRoaXMuX2dldFNwYW4obG9jYXRpb24sIGxvY2F0aW9uKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2hhcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0U3RyID0gZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlbiA9IGNoYXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX2luZGV4ICsgbGVuID4gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5pdGlhbFBvc2l0aW9uID0gdGhpcy5fc2F2ZVBvc2l0aW9uKCk7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0Q2hhckNvZGUoY2hhcnMuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhdHRlbXB0aW5nIHRvIHBhcnNlIHRoZSBzdHJpbmcgZmFpbHMsIHdlIHdhbnQgdG8gcmVzZXQgdGhlIHBhcnNlclxuICAgICAgICAgICAgICAgIC8vIHRvIHdoZXJlIGl0IHdhcyBiZWZvcmUgdGhlIGF0dGVtcHRcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXN0b3JlUG9zaXRpb24oaW5pdGlhbFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdFN0ckNhc2VJbnNlbnNpdGl2ZSA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdENoYXJDb2RlQ2FzZUluc2Vuc2l0aXZlKGNoYXJzLmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3JlcXVpcmVTdHIgPSBmdW5jdGlvbiAoY2hhcnMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG9jYXRpb24gPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRTdHIoY2hhcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMuX3BlZWspLCB0aGlzLl9nZXRTcGFuKGxvY2F0aW9uKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJlZGljYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbiA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgd2hpbGUgKCFwcmVkaWNhdGUodGhpcy5fcGVlaykpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0gez99IGxlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4gPSBmdW5jdGlvbiAocHJlZGljYXRlLCBsZW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKHByZWRpY2F0ZSk7XG4gICAgICAgIGlmICh0aGlzLl9pbmRleCAtIHN0YXJ0Lm9mZnNldCA8IGxlbikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9wZWVrKSwgdGhpcy5fZ2V0U3BhbihzdGFydCwgc3RhcnQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdFVudGlsQ2hhciA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZWVrICE9PSBjaGFyKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVjb2RlRW50aXRpZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkQ2hhciA9IGZ1bmN0aW9uIChkZWNvZGVFbnRpdGllcykge1xuICAgICAgICBpZiAoZGVjb2RlRW50aXRpZXMgJiYgdGhpcy5fcGVlayA9PT0gJEFNUEVSU0FORCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZUVudGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dFtpbmRleF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2RlY29kZUVudGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEhBU0gpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0hleCA9IHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkeCkgfHwgdGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRYKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG51bWJlclN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKS5vZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzRGlnaXRFbnRpdHlFbmQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsgIT0gJFNFTUlDT0xPTikge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fcGVlayksIHRoaXMuX2dldFNwYW4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHJOdW0gPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcobnVtYmVyU3RhcnQsIHRoaXMuX2luZGV4IC0gMSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoYXJDb2RlID0gcGFyc2VJbnQoc3RyTnVtLCBpc0hleCA/IDE2IDogMTApO1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50aXR5ID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHN0YXJ0Lm9mZnNldCArIDEsIHRoaXMuX2luZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3Vua25vd25FbnRpdHlFcnJvck1zZyhlbnRpdHkpLCB0aGlzLl9nZXRTcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydFBvc2l0aW9uID0gdGhpcy5fc2F2ZVBvc2l0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTmFtZWRFbnRpdHlFbmQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsgIT0gJFNFTUlDT0xPTikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVQb3NpdGlvbihzdGFydFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyYnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyhzdGFydC5vZmZzZXQgKyAxLCB0aGlzLl9pbmRleCAtIDEpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hhciA9IE5BTUVEX0VOVElUSUVTW25hbWVdO1xuICAgICAgICAgICAgaWYgKCFjaGFyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3Vua25vd25FbnRpdHlFcnJvck1zZyhuYW1lKSwgdGhpcy5fZ2V0U3BhbihzdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoYXI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVjb2RlRW50aXRpZXNcbiAgICAgKiBAcGFyYW0gez99IGZpcnN0Q2hhck9mRW5kXG4gICAgICogQHBhcmFtIHs/fSBhdHRlbXB0RW5kUmVzdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVSYXdUZXh0ID0gZnVuY3Rpb24gKGRlY29kZUVudGl0aWVzLCBmaXJzdENoYXJPZkVuZCwgYXR0ZW1wdEVuZFJlc3QpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFnQ2xvc2VTdGFydDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGV4dFN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihkZWNvZGVFbnRpdGllcyA/IFRva2VuVHlwZSQxLkVTQ0FQQUJMRV9SQVdfVEVYVCA6IFRva2VuVHlwZSQxLlJBV19URVhULCB0ZXh0U3RhcnQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IFtdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdGFnQ2xvc2VTdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKGZpcnN0Q2hhck9mRW5kKSAmJiBhdHRlbXB0RW5kUmVzdCgpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faW5kZXggPiB0YWdDbG9zZVN0YXJ0Lm9mZnNldCkge1xuICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgY2hhcmFjdGVycyBjb25zdW1lZCBieSB0aGUgcHJldmlvdXMgaWYgc3RhdGVtZW50IHRvIHRoZSBvdXRwdXRcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX2lucHV0LnN1YnN0cmluZyh0YWdDbG9zZVN0YXJ0Lm9mZnNldCwgdGhpcy5faW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl9wZWVrICE9PSBmaXJzdENoYXJPZkVuZCkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIoZGVjb2RlRW50aXRpZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZW5kVG9rZW4oW3RoaXMuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMocGFydHMuam9pbignJykpXSwgdGFnQ2xvc2VTdGFydCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUNvbW1lbnQgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5DT01NRU5UX1NUQVJULCBzdGFydCk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkTUlOVVMpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRleHRUb2tlbiA9IHRoaXMuX2NvbnN1bWVSYXdUZXh0KGZhbHNlLCAkTUlOVVMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9hdHRlbXB0U3RyKCctPicpOyB9KTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5DT01NRU5UX0VORCwgdGV4dFRva2VuLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVDZGF0YSA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkNEQVRBX1NUQVJULCBzdGFydCk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVTdHIoJ0NEQVRBWycpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRleHRUb2tlbiA9IHRoaXMuX2NvbnN1bWVSYXdUZXh0KGZhbHNlLCAkUkJSQUNLRVQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9hdHRlbXB0U3RyKCddPicpOyB9KTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5DREFUQV9FTkQsIHRleHRUb2tlbi5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRG9jVHlwZSA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkRPQ19UWVBFLCBzdGFydCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRVbnRpbENoYXIoJEdUKTtcbiAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdGhpcy5faW5wdXQuc3Vic3RyaW5nKHN0YXJ0Lm9mZnNldCArIDIsIHRoaXMuX2luZGV4IC0gMSldKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVQcmVmaXhBbmROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lT3JQcmVmaXhTdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVmaXggPSAoKG51bGwpKTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09ICRDT0xPTiAmJiAhaXNQcmVmaXhFbmQodGhpcy5fcGVlaykpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lU3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLl9wZWVrID09PSAkQ09MT04pIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHByZWZpeCA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyhuYW1lT3JQcmVmaXhTdGFydCwgdGhpcy5faW5kZXggLSAxKTtcbiAgICAgICAgICAgIG5hbWVTdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmFtZVN0YXJ0ID0gbmFtZU9yUHJlZml4U3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlVW50aWxGbihpc05hbWVFbmQsIHRoaXMuX2luZGV4ID09PSBuYW1lU3RhcnQgPyAxIDogMCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcobmFtZVN0YXJ0LCB0aGlzLl9pbmRleCk7XG4gICAgICAgIHJldHVybiBbcHJlZml4LCBuYW1lXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGFnT3BlbiA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzYXZlZFBvcyA9IHRoaXMuX3NhdmVQb3NpdGlvbigpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWdOYW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb3dlcmNhc2VUYWdOYW1lO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFpc0FzY2lpTGV0dGVyKHRoaXMuX3BlZWspKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9wZWVrKSwgdGhpcy5fZ2V0U3BhbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVTdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRhZ09wZW5TdGFydChzdGFydCk7XG4gICAgICAgICAgICB0YWdOYW1lID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKG5hbWVTdGFydCwgdGhpcy5faW5kZXgpO1xuICAgICAgICAgICAgbG93ZXJjYXNlVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl9wZWVrICE9PSAkU0xBU0ggJiYgdGhpcy5fcGVlayAhPT0gJEdUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUF0dHJpYnV0ZU5hbWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkRVEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUF0dHJpYnV0ZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdPcGVuRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgX0NvbnRyb2xGbG93RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBzdGFydCB0YWcgaXMgaW52YWxpZCwgYXNzdW1lIHdlIHdhbnQgYSBcIjxcIlxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVQb3NpdGlvbihzYXZlZFBvcyk7XG4gICAgICAgICAgICAgICAgLy8gQmFjayB0byBiYWNrIHRleHQgdG9rZW5zIGFyZSBtZXJnZWQgYXQgdGhlIGVuZFxuICAgICAgICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuVEVYVCwgc3RhcnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFsnPCddKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRlbnRUb2tlblR5cGUgPSB0aGlzLl9nZXRUYWdEZWZpbml0aW9uKHRhZ05hbWUpLmNvbnRlbnRUeXBlO1xuICAgICAgICBpZiAoY29udGVudFRva2VuVHlwZSA9PT0gVGFnQ29udGVudFR5cGUuUkFXX1RFWFQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlKGxvd2VyY2FzZVRhZ05hbWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZW50VG9rZW5UeXBlID09PSBUYWdDb250ZW50VHlwZS5FU0NBUEFCTEVfUkFXX1RFWFQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlKGxvd2VyY2FzZVRhZ05hbWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGxvd2VyY2FzZVRhZ05hbWVcbiAgICAgKiBAcGFyYW0gez99IGRlY29kZUVudGl0aWVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVJhd1RleHRXaXRoVGFnQ2xvc2UgPSBmdW5jdGlvbiAobG93ZXJjYXNlVGFnTmFtZSwgZGVjb2RlRW50aXRpZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGV4dFRva2VuID0gdGhpcy5fY29uc3VtZVJhd1RleHQoZGVjb2RlRW50aXRpZXMsICRMVCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRTTEFTSCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIGlmICghX3RoaXMuX2F0dGVtcHRTdHJDYXNlSW5zZW5zaXRpdmUobG93ZXJjYXNlVGFnTmFtZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRHVCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlRBR19DTE9TRSwgdGV4dFRva2VuLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oWy8qKiBAdHlwZSB7P30gKi8gKChudWxsKSksIGxvd2VyY2FzZVRhZ05hbWVdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGFnT3BlblN0YXJ0ID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuVEFHX09QRU5fU1RBUlQsIHN0YXJ0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydHMgPSB0aGlzLl9jb25zdW1lUHJlZml4QW5kTmFtZSgpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihwYXJ0cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5BVFRSX05BTUUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVmaXhBbmROYW1lID0gdGhpcy5fY29uc3VtZVByZWZpeEFuZE5hbWUoKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4ocHJlZml4QW5kTmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lQXR0cmlidXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuQVRUUl9WQUxVRSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fcGVlayA9PT0gJFNRIHx8IHRoaXMuX3BlZWsgPT09ICREUSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVvdGVDaGFyID0gdGhpcy5fcGVlaztcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRzID0gW107XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fcGVlayAhPT0gcXVvdGVDaGFyKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9yZWFkQ2hhcih0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnRzLmpvaW4oJycpO1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWVTdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlVW50aWxGbihpc05hbWVFbmQsIDEpO1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcodmFsdWVTdGFydCwgdGhpcy5faW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zKHZhbHVlKV0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ09wZW5FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VuVHlwZSA9IHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkU0xBU0gpID8gVG9rZW5UeXBlJDEuVEFHX09QRU5fRU5EX1ZPSUQgOiBUb2tlblR5cGUkMS5UQUdfT1BFTl9FTkQ7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4odG9rZW5UeXBlKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRHVCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGFnQ2xvc2UgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5UQUdfQ0xPU0UsIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVmaXhBbmROYW1lID0gdGhpcy5fY29uc3VtZVByZWZpeEFuZE5hbWUoKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJEdUKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4ocHJlZml4QW5kTmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uRm9ybVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX1NUQVJULCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRMQlJBQ0UpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wdXNoKFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX1NUQVJUKTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5SQVdfVEVYVCwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbmRpdGlvbiA9IHRoaXMuX3JlYWRVbnRpbCgkQ09NTUEpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbY29uZGl0aW9uXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkQ09NTUEpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuUkFXX1RFWFQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlID0gdGhpcy5fcmVhZFVudGlsKCRDT01NQSk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFt0eXBlXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkQ09NTUEpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uQ2FzZVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX1ZBTFVFLCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0aGlzLl9yZWFkVW50aWwoJExCUkFDRSkudHJpbSgpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdmFsdWVdLCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkTEJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10sIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wdXNoKFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uQ2FzZUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfRU5ELCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRSQlJBQ0UpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLnBvcCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbkZvcm1FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fRU5ELCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRSQlJBQ0UpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wb3AoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuVEVYVCwgc3RhcnQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IFtdO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyAmJiB0aGlzLl9hdHRlbXB0U3RyKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbkludGVycG9sYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyAmJiB0aGlzLl9pbkludGVycG9sYXRpb24gJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0U3RyKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuZW5kKSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9yZWFkQ2hhcih0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKCF0aGlzLl9pc1RleHRFbmQoKSk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zKHBhcnRzLmpvaW4oJycpKV0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5faXNUZXh0RW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcGVlayA9PT0gJExUIHx8IHRoaXMuX3BlZWsgPT09ICRFT0YpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90b2tlbml6ZUljdSAmJiAhdGhpcy5faW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoaXNFeHBhbnNpb25Gb3JtU3RhcnQodGhpcy5faW5wdXQsIHRoaXMuX2luZGV4LCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IG9mIGFuIGV4cGFuc2lvbiBmb3JtXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlayA9PT0gJFJCUkFDRSAmJiB0aGlzLl9pc0luRXhwYW5zaW9uQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5kIG9mIGFuZCBleHBhbnNpb24gY2FzZVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3NhdmVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLl9wZWVrLCB0aGlzLl9pbmRleCwgdGhpcy5fY29sdW1uLCB0aGlzLl9saW5lLCB0aGlzLnRva2Vucy5sZW5ndGhdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZFVudGlsID0gZnVuY3Rpb24gKGNoYXIpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdFVudGlsQ2hhcihjaGFyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0LnN1YnN0cmluZyhzdGFydCwgdGhpcy5faW5kZXgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3Jlc3RvcmVQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB0aGlzLl9wZWVrID0gcG9zaXRpb25bMF07XG4gICAgICAgIHRoaXMuX2luZGV4ID0gcG9zaXRpb25bMV07XG4gICAgICAgIHRoaXMuX2NvbHVtbiA9IHBvc2l0aW9uWzJdO1xuICAgICAgICB0aGlzLl9saW5lID0gcG9zaXRpb25bM107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5iVG9rZW5zID0gcG9zaXRpb25bNF07XG4gICAgICAgIGlmIChuYlRva2VucyA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGFueSBleHRyYSB0b2tlbnNcbiAgICAgICAgICAgIHRoaXMudG9rZW5zID0gdGhpcy50b2tlbnMuc2xpY2UoMCwgbmJUb2tlbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9pc0luRXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2tbdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCAtIDFdID09PVxuICAgICAgICAgICAgICAgIFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2lzSW5FeHBhbnNpb25Gb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFja1t0aGlzLl9leHBhbnNpb25DYXNlU3RhY2subGVuZ3RoIC0gMV0gPT09XG4gICAgICAgICAgICAgICAgVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlQ7XG4gICAgfTtcbiAgICByZXR1cm4gX1Rva2VuaXplcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNOb3RXaGl0ZXNwYWNlKGNvZGUpIHtcbiAgICByZXR1cm4gIWlzV2hpdGVzcGFjZShjb2RlKSB8fCBjb2RlID09PSAkRU9GO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzTmFtZUVuZChjb2RlKSB7XG4gICAgcmV0dXJuIGlzV2hpdGVzcGFjZShjb2RlKSB8fCBjb2RlID09PSAkR1QgfHwgY29kZSA9PT0gJFNMQVNIIHx8XG4gICAgICAgIGNvZGUgPT09ICRTUSB8fCBjb2RlID09PSAkRFEgfHwgY29kZSA9PT0gJEVRO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzUHJlZml4RW5kKGNvZGUpIHtcbiAgICByZXR1cm4gKGNvZGUgPCAkYSB8fCAkeiA8IGNvZGUpICYmIChjb2RlIDwgJEEgfHwgJFogPCBjb2RlKSAmJlxuICAgICAgICAoY29kZSA8ICQwIHx8IGNvZGUgPiAkOSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNEaWdpdEVudGl0eUVuZChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT0gJFNFTUlDT0xPTiB8fCBjb2RlID09ICRFT0YgfHwgIWlzQXNjaWlIZXhEaWdpdChjb2RlKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc05hbWVkRW50aXR5RW5kKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PSAkU0VNSUNPTE9OIHx8IGNvZGUgPT0gJEVPRiB8fCAhaXNBc2NpaUxldHRlcihjb2RlKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpbnB1dFxuICogQHBhcmFtIHs/fSBvZmZzZXRcbiAqIEBwYXJhbSB7P30gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNFeHBhbnNpb25Gb3JtU3RhcnQoaW5wdXQsIG9mZnNldCwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzSW50ZXJwb2xhdGlvblN0YXJ0ID0gaW50ZXJwb2xhdGlvbkNvbmZpZyA/IGlucHV0LmluZGV4T2YoaW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCwgb2Zmc2V0KSA9PSBvZmZzZXQgOiBmYWxzZTtcbiAgICByZXR1cm4gaW5wdXQuY2hhckNvZGVBdChvZmZzZXQpID09ICRMQlJBQ0UgJiYgIWlzSW50ZXJwb2xhdGlvblN0YXJ0O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHBlZWtcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRXhwYW5zaW9uQ2FzZVN0YXJ0KHBlZWspIHtcbiAgICByZXR1cm4gcGVlayA9PT0gJEVRIHx8IGlzQXNjaWlMZXR0ZXIocGVlayk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZTFcbiAqIEBwYXJhbSB7P30gY29kZTJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVDaGFyQ29kZUNhc2VJbnNlbnNpdGl2ZShjb2RlMSwgY29kZTIpIHtcbiAgICByZXR1cm4gdG9VcHBlckNhc2VDaGFyQ29kZShjb2RlMSkgPT0gdG9VcHBlckNhc2VDaGFyQ29kZShjb2RlMik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdG9VcHBlckNhc2VDaGFyQ29kZShjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gJGEgJiYgY29kZSA8PSAkeiA/IGNvZGUgLSAkYSArICRBIDogY29kZTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzcmNUb2tlbnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG1lcmdlVGV4dFRva2VucyhzcmNUb2tlbnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkc3RUb2tlbnMgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYXN0RHN0VG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHNyY1Rva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbiA9IHNyY1Rva2Vuc1tpXTtcbiAgICAgICAgaWYgKGxhc3REc3RUb2tlbiAmJiBsYXN0RHN0VG9rZW4udHlwZSA9PSBUb2tlblR5cGUkMS5URVhUICYmIHRva2VuLnR5cGUgPT0gVG9rZW5UeXBlJDEuVEVYVCkge1xuICAgICAgICAgICAgbGFzdERzdFRva2VuLnBhcnRzWzBdICs9IHRva2VuLnBhcnRzWzBdO1xuICAgICAgICAgICAgbGFzdERzdFRva2VuLnNvdXJjZVNwYW4uZW5kID0gdG9rZW4uc291cmNlU3Bhbi5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYXN0RHN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIGRzdFRva2Vucy5wdXNoKGxhc3REc3RUb2tlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRzdFRva2Vucztcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUcmVlRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmVlRXJyb3IsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50TmFtZVxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gbXNnXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJlZUVycm9yKGVsZW1lbnROYW1lLCBzcGFuLCBtc2cpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgbXNnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lbGVtZW50TmFtZSA9IGVsZW1lbnROYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IG1zZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJlZUVycm9yLmNyZWF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgc3BhbiwgbXNnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUVycm9yKGVsZW1lbnROYW1lLCBzcGFuLCBtc2cpO1xuICAgIH07XG4gICAgcmV0dXJuIFRyZWVFcnJvcjtcbn0oUGFyc2VFcnJvcikpO1xudmFyIFBhcnNlVHJlZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByb290Tm9kZXNcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhcnNlVHJlZVJlc3VsdChyb290Tm9kZXMsIGVycm9ycykge1xuICAgICAgICB0aGlzLnJvb3ROb2RlcyA9IHJvb3ROb2RlcztcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgfVxuICAgIHJldHVybiBQYXJzZVRyZWVSZXN1bHQ7XG59KCkpO1xudmFyIFBhcnNlciQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGdldFRhZ0RlZmluaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXJzZXIkMShnZXRUYWdEZWZpbml0aW9uKSB7XG4gICAgICAgIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbiA9IGdldFRhZ0RlZmluaXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez89fSBwYXJzZUV4cGFuc2lvbkZvcm1zXG4gICAgICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyJDEucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgdXJsLCBwYXJzZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChwYXJzZUV4cGFuc2lvbkZvcm1zID09PSB2b2lkIDApIHsgcGFyc2VFeHBhbnNpb25Gb3JtcyA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9rZW5zQW5kRXJyb3JzID0gdG9rZW5pemUoc291cmNlLCB1cmwsIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbiwgcGFyc2VFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyZWVBbmRFcnJvcnMgPSBuZXcgX1RyZWVCdWlsZGVyKHRva2Vuc0FuZEVycm9ycy50b2tlbnMsIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbikuYnVpbGQoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVRyZWVSZXN1bHQodHJlZUFuZEVycm9ycy5yb290Tm9kZXMsICgodG9rZW5zQW5kRXJyb3JzLmVycm9ycykpLmNvbmNhdCh0cmVlQW5kRXJyb3JzLmVycm9ycykpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlciQxO1xufSgpKTtcbnZhciBfVHJlZUJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5zXG4gICAgICogQHBhcmFtIHs/fSBnZXRUYWdEZWZpbml0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gX1RyZWVCdWlsZGVyKHRva2VucywgZ2V0VGFnRGVmaW5pdGlvbikge1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgdGhpcy5nZXRUYWdEZWZpbml0aW9uID0gZ2V0VGFnRGVmaW5pdGlvbjtcbiAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5fcm9vdE5vZGVzID0gW107XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZWVrLnR5cGUgIT09IFRva2VuVHlwZSQxLkVPRikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuVEFHX09QRU5fU1RBUlQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lU3RhcnRUYWcodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuVEFHX0NMT1NFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUVuZFRhZyh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5DREFUQV9TVEFSVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ2RhdGEodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuQ09NTUVOVF9TVEFSVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ29tbWVudCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5URVhUIHx8IHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuUkFXX1RFWFQgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkVTQ0FQQUJMRV9SQVdfVEVYVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGV4dCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9TVEFSVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb24odGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNraXAgYWxsIG90aGVyIHRva2Vucy4uLlxuICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdCh0aGlzLl9yb290Tm9kZXMsIHRoaXMuX2Vycm9ycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2FkdmFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXYgPSB0aGlzLl9wZWVrO1xuICAgICAgICBpZiAodGhpcy5faW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiB0aGVyZSBpcyBhbHdheXMgYW4gRU9GIHRva2VuIGF0IHRoZSBlbmRcbiAgICAgICAgICAgIHRoaXMuX2luZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGVlayA9IHRoaXMudG9rZW5zW3RoaXMuX2luZGV4XTtcbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2FkdmFuY2VJZiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0VG9rZW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVDZGF0YSA9IGZ1bmN0aW9uIChzdGFydFRva2VuKSB7XG4gICAgICAgIHRoaXMuX2NvbnN1bWVUZXh0KHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgIHRoaXMuX2FkdmFuY2VJZihUb2tlblR5cGUkMS5DREFUQV9FTkQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZUNvbW1lbnQgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGV4dCA9IHRoaXMuX2FkdmFuY2VJZihUb2tlblR5cGUkMS5SQVdfVEVYVCk7XG4gICAgICAgIHRoaXMuX2FkdmFuY2VJZihUb2tlblR5cGUkMS5DT01NRU5UX0VORCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gdGV4dCAhPSBudWxsID8gdGV4dC5wYXJ0c1swXS50cmltKCkgOiBudWxsO1xuICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgQ29tbWVudCh2YWx1ZSwgdG9rZW4uc291cmNlU3BhbikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzd2l0Y2hWYWx1ZSA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHlwZSA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2FzZXMgPSBbXTtcbiAgICAgICAgLy8gcmVhZCA9XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX1ZBTFVFKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBDYXNlID0gdGhpcy5fcGFyc2VFeHBhbnNpb25DYXNlKCk7XG4gICAgICAgICAgICBpZiAoIWV4cENhc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlcnJvclxuICAgICAgICAgICAgY2FzZXMucHVzaChleHBDYXNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkIHRoZSBmaW5hbCB9XG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgIT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX0VORCkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCB0aGlzLl9wZWVrLnNvdXJjZVNwYW4sIFwiSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAnfScuXCIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3Bhbih0b2tlbi5zb3VyY2VTcGFuLnN0YXJ0LCB0aGlzLl9wZWVrLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQobmV3IEV4cGFuc2lvbihzd2l0Y2hWYWx1ZS5wYXJ0c1swXSwgdHlwZS5wYXJ0c1swXSwgY2FzZXMsIHNvdXJjZVNwYW4sIHN3aXRjaFZhbHVlLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9wYXJzZUV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAvLyByZWFkIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSAhPT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHRoaXMuX3BlZWsuc291cmNlU3BhbiwgXCJJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd7Jy5cIikpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZCB1bnRpbCB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHAgPSB0aGlzLl9jb2xsZWN0RXhwYW5zaW9uRXhwVG9rZW5zKHN0YXJ0KTtcbiAgICAgICAgaWYgKCFleHApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICBleHAucHVzaChuZXcgVG9rZW4kMShUb2tlblR5cGUkMS5FT0YsIFtdLCBlbmQuc291cmNlU3BhbikpO1xuICAgICAgICAvLyBwYXJzZSBldmVyeXRoaW5nIGluIGJldHdlZW4geyBhbmQgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJzZWRFeHAgPSBuZXcgX1RyZWVCdWlsZGVyKGV4cCwgdGhpcy5nZXRUYWdEZWZpbml0aW9uKS5idWlsZCgpO1xuICAgICAgICBpZiAocGFyc2VkRXhwLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcnMgPSB0aGlzLl9lcnJvcnMuY29uY2F0KC8qKiBAdHlwZSB7P30gKi8gKHBhcnNlZEV4cC5lcnJvcnMpKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHZhbHVlLnNvdXJjZVNwYW4uc3RhcnQsIGVuZC5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cFNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0LnNvdXJjZVNwYW4uc3RhcnQsIGVuZC5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgIHJldHVybiBuZXcgRXhwYW5zaW9uQ2FzZSh2YWx1ZS5wYXJ0c1swXSwgcGFyc2VkRXhwLnJvb3ROb2Rlcywgc291cmNlU3BhbiwgdmFsdWUuc291cmNlU3BhbiwgZXhwU291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb2xsZWN0RXhwYW5zaW9uRXhwVG9rZW5zID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cCA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBhbnNpb25Gb3JtU3RhY2sgPSBbVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUXTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX1NUQVJUIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICBleHBhbnNpb25Gb3JtU3RhY2sucHVzaCh0aGlzLl9wZWVrLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX0VORCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0T25TdGFjayhleHBhbnNpb25Gb3JtU3RhY2ssIFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5zaW9uRm9ybVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwYW5zaW9uRm9ybVN0YWNrLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgc3RhcnQuc291cmNlU3BhbiwgXCJJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd9Jy5cIikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9FTkQpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdE9uU3RhY2soZXhwYW5zaW9uRm9ybVN0YWNrLCBUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9TVEFSVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5zaW9uRm9ybVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCBzdGFydC5zb3VyY2VTcGFuLCBcIkludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ30nLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkVPRikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgc3RhcnQuc291cmNlU3BhbiwgXCJJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd9Jy5cIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwLnB1c2godGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZVRleHQgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGV4dCA9IHRva2VuLnBhcnRzWzBdO1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPiAwICYmIHRleHRbMF0gPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudCA9IHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCAmJiBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmdldFRhZ0RlZmluaXRpb24ocGFyZW50Lm5hbWUpLmlnbm9yZUZpcnN0TGYpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQobmV3IFRleHQodGV4dCwgdG9rZW4uc291cmNlU3BhbikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2Nsb3NlVm9pZEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWwgPSB0aGlzLl9lbGVtZW50U3RhY2tbdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihlbC5uYW1lKS5pc1ZvaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRUYWdUb2tlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZVN0YXJ0VGFnID0gZnVuY3Rpb24gKHN0YXJ0VGFnVG9rZW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4ID0gc3RhcnRUYWdUb2tlbi5wYXJ0c1swXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IHN0YXJ0VGFnVG9rZW4ucGFydHNbMV07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJzID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkFUVFJfTkFNRSkge1xuICAgICAgICAgICAgYXR0cnMucHVzaCh0aGlzLl9jb25zdW1lQXR0cih0aGlzLl9hZHZhbmNlKCkpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmdWxsTmFtZSA9IHRoaXMuX2dldEVsZW1lbnRGdWxsTmFtZShwcmVmaXgsIG5hbWUsIHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGZDbG9zaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIE5vdGU6IFRoZXJlIGNvdWxkIGhhdmUgYmVlbiBhIHRva2VuaXplciBlcnJvclxuICAgICAgICAvLyBzbyB0aGF0IHdlIGRvbid0IGdldCBhIHRva2VuIGZvciB0aGUgZW5kIHRhZy4uLlxuICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5UQUdfT1BFTl9FTkRfVk9JRCkge1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgc2VsZkNsb3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFnRGVmID0gdGhpcy5nZXRUYWdEZWZpbml0aW9uKGZ1bGxOYW1lKTtcbiAgICAgICAgICAgIGlmICghKHRhZ0RlZi5jYW5TZWxmQ2xvc2UgfHwgZ2V0TnNQcmVmaXgoZnVsbE5hbWUpICE9PSBudWxsIHx8IHRhZ0RlZi5pc1ZvaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShmdWxsTmFtZSwgc3RhcnRUYWdUb2tlbi5zb3VyY2VTcGFuLCBcIk9ubHkgdm9pZCBhbmQgZm9yZWlnbiBlbGVtZW50cyBjYW4gYmUgc2VsZiBjbG9zZWQgXFxcIlwiICsgc3RhcnRUYWdUb2tlbi5wYXJ0c1sxXSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5UQUdfT1BFTl9FTkQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHNlbGZDbG9zaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kID0gdGhpcy5fcGVlay5zb3VyY2VTcGFuLnN0YXJ0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydFRhZ1Rva2VuLnNvdXJjZVNwYW4uc3RhcnQsIGVuZCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsID0gbmV3IEVsZW1lbnQoZnVsbE5hbWUsIGF0dHJzLCBbXSwgc3Bhbiwgc3BhbiwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fcHVzaEVsZW1lbnQoZWwpO1xuICAgICAgICBpZiAoc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcEVsZW1lbnQoZnVsbE5hbWUpO1xuICAgICAgICAgICAgZWwuZW5kU291cmNlU3BhbiA9IHNwYW47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX3B1c2hFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50RWwgPSB0aGlzLl9lbGVtZW50U3RhY2tbdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihwYXJlbnRFbC5uYW1lKS5pc0Nsb3NlZEJ5Q2hpbGQoZWwubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFnRGVmID0gdGhpcy5nZXRUYWdEZWZpbml0aW9uKGVsLm5hbWUpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50U2tpcHBpbmdDb250YWluZXJzKCksIHBhcmVudCA9IF9hLnBhcmVudCwgY29udGFpbmVyID0gX2EuY29udGFpbmVyO1xuICAgICAgICBpZiAocGFyZW50ICYmIHRhZ0RlZi5yZXF1aXJlRXh0cmFQYXJlbnQocGFyZW50Lm5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXdQYXJlbnQgPSBuZXcgRWxlbWVudCh0YWdEZWYucGFyZW50VG9BZGQsIFtdLCBbXSwgZWwuc291cmNlU3BhbiwgZWwuc3RhcnRTb3VyY2VTcGFuLCBlbC5lbmRTb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHRoaXMuX2luc2VydEJlZm9yZUNvbnRhaW5lcihwYXJlbnQsIGNvbnRhaW5lciwgbmV3UGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChlbCk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5wdXNoKGVsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZW5kVGFnVG9rZW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVFbmRUYWcgPSBmdW5jdGlvbiAoZW5kVGFnVG9rZW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnVsbE5hbWUgPSB0aGlzLl9nZXRFbGVtZW50RnVsbE5hbWUoZW5kVGFnVG9rZW4ucGFydHNbMF0sIGVuZFRhZ1Rva2VuLnBhcnRzWzFdLCB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkpO1xuICAgICAgICBpZiAodGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpKSB7XG4gICAgICAgICAgICAoKHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKSkpLmVuZFNvdXJjZVNwYW4gPSBlbmRUYWdUb2tlbi5zb3VyY2VTcGFuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdldFRhZ0RlZmluaXRpb24oZnVsbE5hbWUpLmlzVm9pZCkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShmdWxsTmFtZSwgZW5kVGFnVG9rZW4uc291cmNlU3BhbiwgXCJWb2lkIGVsZW1lbnRzIGRvIG5vdCBoYXZlIGVuZCB0YWdzIFxcXCJcIiArIGVuZFRhZ1Rva2VuLnBhcnRzWzFdICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5fcG9wRWxlbWVudChmdWxsTmFtZSkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVyck1zZyA9IFwiVW5leHBlY3RlZCBjbG9zaW5nIHRhZyBcXFwiXCIgKyBmdWxsTmFtZSArIFwiXFxcIi4gSXQgbWF5IGhhcHBlbiB3aGVuIHRoZSB0YWcgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgYnkgYW5vdGhlciB0YWcuIEZvciBtb3JlIGluZm8gc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNjbG9zaW5nLWVsZW1lbnRzLXRoYXQtaGF2ZS1pbXBsaWVkLWVuZC10YWdzXCI7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKGZ1bGxOYW1lLCBlbmRUYWdUb2tlbi5zb3VyY2VTcGFuLCBlcnJNc2cpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmdWxsTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fcG9wRWxlbWVudCA9IGZ1bmN0aW9uIChmdWxsTmFtZSkge1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHN0YWNrSW5kZXggPSB0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gMTsgc3RhY2tJbmRleCA+PSAwOyBzdGFja0luZGV4LS0pIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsID0gdGhpcy5fZWxlbWVudFN0YWNrW3N0YWNrSW5kZXhdO1xuICAgICAgICAgICAgaWYgKGVsLm5hbWUgPT0gZnVsbE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2suc3BsaWNlKHN0YWNrSW5kZXgsIHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSBzdGFja0luZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRUYWdEZWZpbml0aW9uKGVsLm5hbWUpLmNsb3NlZEJ5UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0ck5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVBdHRyID0gZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZ1bGxOYW1lID0gbWVyZ2VOc0FuZE5hbWUoYXR0ck5hbWUucGFydHNbMF0sIGF0dHJOYW1lLnBhcnRzWzFdKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kID0gYXR0ck5hbWUuc291cmNlU3Bhbi5lbmQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlU3BhbiA9ICgodW5kZWZpbmVkKSk7XG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkFUVFJfVkFMVUUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlVG9rZW4gPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlVG9rZW4ucGFydHNbMF07XG4gICAgICAgICAgICBlbmQgPSB2YWx1ZVRva2VuLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICAgICAgdmFsdWVTcGFuID0gdmFsdWVUb2tlbi5zb3VyY2VTcGFuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlJDEoZnVsbE5hbWUsIHZhbHVlLCBuZXcgUGFyc2VTb3VyY2VTcGFuKGF0dHJOYW1lLnNvdXJjZVNwYW4uc3RhcnQsIGVuZCksIHZhbHVlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2dldFBhcmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoID4gMCA/IHRoaXMuX2VsZW1lbnRTdGFja1t0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFyZW50IGluIHRoZSBET00gYW5kIHRoZSBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBgPG5nLWNvbnRhaW5lcj5gIGVsZW1lbnRzIGFyZSBza2lwcGVkIGFzIHRoZXkgYXJlIG5vdCByZW5kZXJlZCBhcyBET00gZWxlbWVudC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2dldFBhcmVudEVsZW1lbnRTa2lwcGluZ0NvbnRhaW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKCFpc05nQ29udGFpbmVyKHRoaXMuX2VsZW1lbnRTdGFja1tpXS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHBhcmVudDogdGhpcy5fZWxlbWVudFN0YWNrW2ldLCBjb250YWluZXI6IGNvbnRhaW5lciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5fZWxlbWVudFN0YWNrW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHBhcmVudDogdGhpcy5fZWxlbWVudFN0YWNrW3RoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxXSwgY29udGFpbmVyOiBjb250YWluZXIgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fYWRkVG9QYXJlbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnQgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCk7XG4gICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yb290Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgbm9kZSBiZXR3ZWVuIHRoZSBwYXJlbnQgYW5kIHRoZSBjb250YWluZXIuXG4gICAgICogV2hlbiBubyBjb250YWluZXIgaXMgZ2l2ZW4sIHRoZSBub2RlIGlzIGFwcGVuZGVkIGFzIGEgY2hpbGQgb2YgdGhlIHBhcmVudC5cbiAgICAgKiBBbHNvIHVwZGF0ZXMgdGhlIGVsZW1lbnQgc3RhY2sgYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2luc2VydEJlZm9yZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChwYXJlbnQsIGNvbnRhaW5lciwgbm9kZSkge1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQobm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBjb250YWluZXIgd2l0aCB0aGUgbmV3IG5vZGUgaW4gdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbltpbmRleF0gPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goY29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5zcGxpY2UodGhpcy5fZWxlbWVudFN0YWNrLmluZGV4T2YoY29udGFpbmVyKSwgMCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJlZml4XG4gICAgICogQHBhcmFtIHs/fSBsb2NhbE5hbWVcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudEVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2dldEVsZW1lbnRGdWxsTmFtZSA9IGZ1bmN0aW9uIChwcmVmaXgsIGxvY2FsTmFtZSwgcGFyZW50RWxlbWVudCkge1xuICAgICAgICBpZiAocHJlZml4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHByZWZpeCA9ICgodGhpcy5nZXRUYWdEZWZpbml0aW9uKGxvY2FsTmFtZSkuaW1wbGljaXROYW1lc3BhY2VQcmVmaXgpKTtcbiAgICAgICAgICAgIGlmIChwcmVmaXggPT0gbnVsbCAmJiBwYXJlbnRFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBnZXROc1ByZWZpeChwYXJlbnRFbGVtZW50Lm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZU5zQW5kTmFtZShwcmVmaXgsIGxvY2FsTmFtZSk7XG4gICAgfTtcbiAgICByZXR1cm4gX1RyZWVCdWlsZGVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBzdGFja1xuICogQHBhcmFtIHs/fSBlbGVtZW50XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBsYXN0T25TdGFjayhzdGFjaywgZWxlbWVudCkge1xuICAgIHJldHVybiBzdGFjay5sZW5ndGggPiAwICYmIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBlbGVtZW50O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIE1lc3NhZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZXMgbWVzc2FnZSBBU1RcbiAgICAgKiBAcGFyYW0gez99IHBsYWNlaG9sZGVycyBtYXBzIHBsYWNlaG9sZGVyIG5hbWVzIHRvIHN0YXRpYyBjb250ZW50XG4gICAgICogQHBhcmFtIHs/fSBwbGFjZWhvbGRlclRvTWVzc2FnZSBtYXBzIHBsYWNlaG9sZGVyIG5hbWVzIHRvIG1lc3NhZ2VzICh1c2VkIGZvciBuZXN0ZWQgSUNVIG1lc3NhZ2VzKVxuICAgICAqIEBwYXJhbSB7P30gbWVhbmluZ1xuICAgICAqIEBwYXJhbSB7P30gZGVzY3JpcHRpb25cbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWVzc2FnZShub2RlcywgcGxhY2Vob2xkZXJzLCBwbGFjZWhvbGRlclRvTWVzc2FnZSwgbWVhbmluZywgZGVzY3JpcHRpb24sIGlkKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlcnMgPSBwbGFjZWhvbGRlcnM7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJUb01lc3NhZ2UgPSBwbGFjZWhvbGRlclRvTWVzc2FnZTtcbiAgICAgICAgdGhpcy5tZWFuaW5nID0gbWVhbmluZztcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlcyA9IFt7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYXRoOiBub2Rlc1swXS5zb3VyY2VTcGFuLnN0YXJ0LmZpbGUudXJsLFxuICAgICAgICAgICAgICAgICAgICBzdGFydExpbmU6IG5vZGVzWzBdLnNvdXJjZVNwYW4uc3RhcnQubGluZSArIDEsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29sOiBub2Rlc1swXS5zb3VyY2VTcGFuLnN0YXJ0LmNvbCArIDEsXG4gICAgICAgICAgICAgICAgICAgIGVuZExpbmU6IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLnNvdXJjZVNwYW4uZW5kLmxpbmUgKyAxLFxuICAgICAgICAgICAgICAgICAgICBlbmRDb2w6IG5vZGVzWzBdLnNvdXJjZVNwYW4uc3RhcnQuY29sICsgMVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VzID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE1lc3NhZ2U7XG59KCkpO1xudmFyIFRleHQkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRleHQkMSh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRleHQkMS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFRleHQkMTtcbn0oKSk7XG52YXIgQ29udGFpbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoaWxkcmVuXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29udGFpbmVyKGNoaWxkcmVuLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0Q29udGFpbmVyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBDb250YWluZXI7XG59KCkpO1xudmFyIEljdSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBjYXNlc1xuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEljdShleHByZXNzaW9uLCB0eXBlLCBjYXNlcywgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNhc2VzID0gY2FzZXM7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEljdS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEljdSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gSWN1O1xufSgpKTtcbnZhciBUYWdQbGFjZWhvbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YWdcbiAgICAgKiBAcGFyYW0gez99IGF0dHJzXG4gICAgICogQHBhcmFtIHs/fSBzdGFydE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNsb3NlTmFtZVxuICAgICAqIEBwYXJhbSB7P30gY2hpbGRyZW5cbiAgICAgKiBAcGFyYW0gez99IGlzVm9pZFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRhZ1BsYWNlaG9sZGVyKHRhZywgYXR0cnMsIHN0YXJ0TmFtZSwgY2xvc2VOYW1lLCBjaGlsZHJlbiwgaXNWb2lkLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuc3RhcnROYW1lID0gc3RhcnROYW1lO1xuICAgICAgICB0aGlzLmNsb3NlTmFtZSA9IGNsb3NlTmFtZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmlzVm9pZCA9IGlzVm9pZDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGFnUGxhY2Vob2xkZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUYWdQbGFjZWhvbGRlcih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gVGFnUGxhY2Vob2xkZXI7XG59KCkpO1xudmFyIFBsYWNlaG9sZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGxhY2Vob2xkZXIodmFsdWUsIG5hbWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFBsYWNlaG9sZGVyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBQbGFjZWhvbGRlcjtcbn0oKSk7XG52YXIgSWN1UGxhY2Vob2xkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJY3VQbGFjZWhvbGRlcih2YWx1ZSwgbmFtZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEljdVBsYWNlaG9sZGVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0SWN1UGxhY2Vob2xkZXIodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIEljdVBsYWNlaG9sZGVyO1xufSgpKTtcbnZhciBDbG9uZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsb25lVmlzaXRvcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2xvbmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gbmV3IFRleHQkMSh0ZXh0LnZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4pOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2xvbmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRyZW4gPSBjb250YWluZXIuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29udGFpbmVyKGNoaWxkcmVuLCBjb250YWluZXIuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdVxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENsb25lVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhc2VzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjYXNlc1trZXldID0gaWN1LmNhc2VzW2tleV0udmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbXNnID0gbmV3IEljdShpY3UuZXhwcmVzc2lvbiwgaWN1LnR5cGUsIGNhc2VzLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgICAgIG1zZy5leHByZXNzaW9uUGxhY2Vob2xkZXIgPSBpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyO1xuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENsb25lVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZHJlbiA9IHBoLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gbi52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IFRhZ1BsYWNlaG9sZGVyKHBoLnRhZywgcGguYXR0cnMsIHBoLnN0YXJ0TmFtZSwgcGguY2xvc2VOYW1lLCBjaGlsZHJlbiwgcGguaXNWb2lkLCBwaC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDbG9uZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFjZWhvbGRlcihwaC52YWx1ZSwgcGgubmFtZSwgcGguc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2xvbmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgSWN1UGxhY2Vob2xkZXIocGgudmFsdWUsIHBoLm5hbWUsIHBoLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgcmV0dXJuIENsb25lVmlzaXRvcjtcbn0oKSk7XG52YXIgUmVjdXJzZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY3Vyc2VWaXNpdG9yKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQudmlzaXQoX3RoaXMpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyhpY3UuY2FzZXMpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgaWN1LmNhc2VzW2tdLnZpc2l0KF90aGlzKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcGguY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnZpc2l0KF90aGlzKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHsgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7IH07XG4gICAgO1xuICAgIHJldHVybiBSZWN1cnNlVmlzaXRvcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTID0ge1xuICAgICdBJzogJ0xJTksnLFxuICAgICdCJzogJ0JPTERfVEVYVCcsXG4gICAgJ0JSJzogJ0xJTkVfQlJFQUsnLFxuICAgICdFTSc6ICdFTVBIQVNJU0VEX1RFWFQnLFxuICAgICdIMSc6ICdIRUFESU5HX0xFVkVMMScsXG4gICAgJ0gyJzogJ0hFQURJTkdfTEVWRUwyJyxcbiAgICAnSDMnOiAnSEVBRElOR19MRVZFTDMnLFxuICAgICdINCc6ICdIRUFESU5HX0xFVkVMNCcsXG4gICAgJ0g1JzogJ0hFQURJTkdfTEVWRUw1JyxcbiAgICAnSDYnOiAnSEVBRElOR19MRVZFTDYnLFxuICAgICdIUic6ICdIT1JJWk9OVEFMX1JVTEUnLFxuICAgICdJJzogJ0lUQUxJQ19URVhUJyxcbiAgICAnTEknOiAnTElTVF9JVEVNJyxcbiAgICAnTElOSyc6ICdNRURJQV9MSU5LJyxcbiAgICAnT0wnOiAnT1JERVJFRF9MSVNUJyxcbiAgICAnUCc6ICdQQVJBR1JBUEgnLFxuICAgICdRJzogJ1FVT1RBVElPTicsXG4gICAgJ1MnOiAnU1RSSUtFVEhST1VHSF9URVhUJyxcbiAgICAnU01BTEwnOiAnU01BTExfVEVYVCcsXG4gICAgJ1NVQic6ICdTVUJTVFJJUFQnLFxuICAgICdTVVAnOiAnU1VQRVJTQ1JJUFQnLFxuICAgICdUQk9EWSc6ICdUQUJMRV9CT0RZJyxcbiAgICAnVEQnOiAnVEFCTEVfQ0VMTCcsXG4gICAgJ1RGT09UJzogJ1RBQkxFX0ZPT1RFUicsXG4gICAgJ1RIJzogJ1RBQkxFX0hFQURFUl9DRUxMJyxcbiAgICAnVEhFQUQnOiAnVEFCTEVfSEVBREVSJyxcbiAgICAnVFInOiAnVEFCTEVfUk9XJyxcbiAgICAnVFQnOiAnTU9OT1NQQUNFRF9URVhUJyxcbiAgICAnVSc6ICdVTkRFUkxJTkVEX1RFWFQnLFxuICAgICdVTCc6ICdVTk9SREVSRURfTElTVCcsXG59O1xuLyoqXG4gKiBDcmVhdGVzIHVuaXF1ZSBuYW1lcyBmb3IgcGxhY2Vob2xkZXIgd2l0aCBkaWZmZXJlbnQgY29udGVudC5cbiAqXG4gKiBSZXR1cm5zIHRoZSBzYW1lIHBsYWNlaG9sZGVyIG5hbWUgd2hlbiB0aGUgY29udGVudCBpcyBpZGVudGljYWwuXG4gKlxuICogXFxAaW50ZXJuYWxcbiAqL1xudmFyIFBsYWNlaG9sZGVyUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBsYWNlaG9sZGVyUmVnaXN0cnkoKSB7XG4gICAgICAgIHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50cyA9IHt9O1xuICAgICAgICB0aGlzLl9zaWduYXR1cmVUb05hbWUgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YWdcbiAgICAgKiBAcGFyYW0gez99IGF0dHJzXG4gICAgICogQHBhcmFtIHs/fSBpc1ZvaWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBsYWNlaG9sZGVyUmVnaXN0cnkucHJvdG90eXBlLmdldFN0YXJ0VGFnUGxhY2Vob2xkZXJOYW1lID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGlzVm9pZCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzaWduYXR1cmUgPSB0aGlzLl9oYXNoVGFnKHRhZywgYXR0cnMsIGlzVm9pZCk7XG4gICAgICAgIGlmICh0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwcGVyVGFnID0gdGFnLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VOYW1lID0gVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTW3VwcGVyVGFnXSB8fCBcIlRBR19cIiArIHVwcGVyVGFnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gdGhpcy5fZ2VuZXJhdGVVbmlxdWVOYW1lKGlzVm9pZCA/IGJhc2VOYW1lIDogXCJTVEFSVF9cIiArIGJhc2VOYW1lKTtcbiAgICAgICAgdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0gPSBuYW1lO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZSA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2lnbmF0dXJlID0gdGhpcy5faGFzaENsb3NpbmdUYWcodGFnKTtcbiAgICAgICAgaWYgKHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBwZXJUYWcgPSB0YWcudG9VcHBlckNhc2UoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZU5hbWUgPSBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVNbdXBwZXJUYWddIHx8IFwiVEFHX1wiICsgdXBwZXJUYWc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUoXCJDTE9TRV9cIiArIGJhc2VOYW1lKTtcbiAgICAgICAgdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0gPSBuYW1lO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGxhY2Vob2xkZXJSZWdpc3RyeS5wcm90b3R5cGUuZ2V0UGxhY2Vob2xkZXJOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBwZXJOYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzaWduYXR1cmUgPSBcIlBIOiBcIiArIHVwcGVyTmFtZSArIFwiPVwiICsgY29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdW5pcXVlTmFtZSA9IHRoaXMuX2dlbmVyYXRlVW5pcXVlTmFtZSh1cHBlck5hbWUpO1xuICAgICAgICB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSA9IHVuaXF1ZU5hbWU7XG4gICAgICAgIHJldHVybiB1bmlxdWVOYW1lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRVbmlxdWVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUobmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnXG4gICAgICogQHBhcmFtIHs/fSBhdHRyc1xuICAgICAqIEBwYXJhbSB7P30gaXNWb2lkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5faGFzaFRhZyA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBpc1ZvaWQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSBcIjxcIiArIHRhZztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycykuc29ydCgpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gXCIgXCIgKyBuYW1lICsgXCI9XCIgKyBhdHRyc1tuYW1lXTsgfSkuam9pbignJyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZCA9IGlzVm9pZCA/ICcvPicgOiBcIj48L1wiICsgdGFnICsgXCI+XCI7XG4gICAgICAgIHJldHVybiBzdGFydCArIHN0ckF0dHJzICsgZW5kO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBsYWNlaG9sZGVyUmVnaXN0cnkucHJvdG90eXBlLl9oYXNoQ2xvc2luZ1RhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRoaXMuX2hhc2hUYWcoXCIvXCIgKyB0YWcsIHt9LCBmYWxzZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBiYXNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5fZ2VuZXJhdGVVbmlxdWVOYW1lID0gZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VlbiA9IHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50cy5oYXNPd25Qcm9wZXJ0eShiYXNlKTtcbiAgICAgICAgaWYgKCFzZWVuKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHNbYmFzZV0gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWQgPSB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHNbYmFzZV07XG4gICAgICAgIHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50c1tiYXNlXSA9IGlkICsgMTtcbiAgICAgICAgcmV0dXJuIGJhc2UgKyBcIl9cIiArIGlkO1xuICAgIH07XG4gICAgcmV0dXJuIFBsYWNlaG9sZGVyUmVnaXN0cnk7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9leHBQYXJzZXIgPSBuZXcgUGFyc2VyKG5ldyBMZXhlcigpKTtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIGNvbnZlcnRpbmcgaHRtbCBub2RlcyB0byBhbiBpMThuIE1lc3NhZ2UgZ2l2ZW4gYW4gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICogQHBhcmFtIHs/fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJMThuTWVzc2FnZUZhY3RvcnkoaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX0kxOG5WaXNpdG9yKF9leHBQYXJzZXIsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZXMsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCkgeyByZXR1cm4gdmlzaXRvci50b0kxOG5NZXNzYWdlKG5vZGVzLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgaWQpOyB9O1xufVxudmFyIF9JMThuVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZXhwcmVzc2lvblBhcnNlclxuICAgICAqIEBwYXJhbSB7P30gX2ludGVycG9sYXRpb25Db25maWdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfSTE4blZpc2l0b3IoX2V4cHJlc3Npb25QYXJzZXIsIF9pbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2V4cHJlc3Npb25QYXJzZXIgPSBfZXhwcmVzc2lvblBhcnNlcjtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVzXG4gICAgICogQHBhcmFtIHs/fSBtZWFuaW5nXG4gICAgICogQHBhcmFtIHs/fSBkZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudG9JMThuTWVzc2FnZSA9IGZ1bmN0aW9uIChub2RlcywgbWVhbmluZywgZGVzY3JpcHRpb24sIGlkKSB7XG4gICAgICAgIHRoaXMuX2lzSWN1ID0gbm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZXNbMF0gaW5zdGFuY2VvZiBFeHBhbnNpb247XG4gICAgICAgIHRoaXMuX2ljdURlcHRoID0gMDtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeSA9IG5ldyBQbGFjZWhvbGRlclJlZ2lzdHJ5KCk7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9Db250ZW50ID0ge307XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9NZXNzYWdlID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5vZGVzID0gdmlzaXRBbGwodGhpcywgbm9kZXMsIHt9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlKGkxOG5vZGVzLCB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudCwgdGhpcy5fcGxhY2Vob2xkZXJUb01lc3NhZ2UsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZHJlbiA9IHZpc2l0QWxsKHRoaXMsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0cnMgPSB7fTtcbiAgICAgICAgZWwuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgLy8gRG8gbm90IHZpc2l0IHRoZSBhdHRyaWJ1dGVzLCB0cmFuc2xhdGFibGUgb25lcyBhcmUgdG9wLWxldmVsIEFTVHNcbiAgICAgICAgICAgIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNWb2lkID0gZ2V0SHRtbFRhZ0RlZmluaXRpb24oZWwubmFtZSkuaXNWb2lkO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydFBoTmFtZSA9IHRoaXMuX3BsYWNlaG9sZGVyUmVnaXN0cnkuZ2V0U3RhcnRUYWdQbGFjZWhvbGRlck5hbWUoZWwubmFtZSwgYXR0cnMsIGlzVm9pZCk7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9Db250ZW50W3N0YXJ0UGhOYW1lXSA9ICgoZWwuc291cmNlU3BhbikpLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsb3NlUGhOYW1lID0gJyc7XG4gICAgICAgIGlmICghaXNWb2lkKSB7XG4gICAgICAgICAgICBjbG9zZVBoTmFtZSA9IHRoaXMuX3BsYWNlaG9sZGVyUmVnaXN0cnkuZ2V0Q2xvc2VUYWdQbGFjZWhvbGRlck5hbWUoZWwubmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudFtjbG9zZVBoTmFtZV0gPSBcIjwvXCIgKyBlbC5uYW1lICsgXCI+XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUYWdQbGFjZWhvbGRlcihlbC5uYW1lLCBhdHRycywgc3RhcnRQaE5hbWUsIGNsb3NlUGhOYW1lLCBjaGlsZHJlbiwgaXNWb2lkLCAvKiogQHR5cGUgez99ICovICgoZWwuc291cmNlU3BhbikpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24oYXR0cmlidXRlLnZhbHVlLCBhdHRyaWJ1dGUuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uKHRleHQudmFsdWUsIC8qKiBAdHlwZSB7P30gKi8gKCh0ZXh0LnNvdXJjZVNwYW4pKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2ljdURlcHRoKys7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5JY3VDYXNlcyA9IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpMThuSWN1ID0gbmV3IEljdShpY3Uuc3dpdGNoVmFsdWUsIGljdS50eXBlLCBpMThuSWN1Q2FzZXMsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgaWN1LmNhc2VzLmZvckVhY2goZnVuY3Rpb24gKGNhemUpIHtcbiAgICAgICAgICAgIGkxOG5JY3VDYXNlc1tjYXplLnZhbHVlXSA9IG5ldyBDb250YWluZXIoY2F6ZS5leHByZXNzaW9uLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcywge30pOyB9KSwgY2F6ZS5leHBTb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2ljdURlcHRoLS07XG4gICAgICAgIGlmICh0aGlzLl9pc0ljdSB8fCB0aGlzLl9pY3VEZXB0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgYW4gSUNVIG5vZGUgd2hlbjpcbiAgICAgICAgICAgIC8vIC0gdGhlIG1lc3NhZ2UgKHZzIGEgcGFydCBvZiB0aGUgbWVzc2FnZSkgaXMgYW4gSUNVIG1lc3NhZ2UsIG9yXG4gICAgICAgICAgICAvLyAtIHRoZSBJQ1UgbWVzc2FnZSBpcyBuZXN0ZWQuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBQaCA9IHRoaXMuX3BsYWNlaG9sZGVyUmVnaXN0cnkuZ2V0VW5pcXVlUGxhY2Vob2xkZXIoXCJWQVJfXCIgKyBpY3UudHlwZSk7XG4gICAgICAgICAgICBpMThuSWN1LmV4cHJlc3Npb25QbGFjZWhvbGRlciA9IGV4cFBoO1xuICAgICAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJUb0NvbnRlbnRbZXhwUGhdID0gaWN1LnN3aXRjaFZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGkxOG5JY3U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWxzZSByZXR1cm5zIGEgcGxhY2Vob2xkZXJcbiAgICAgICAgLy8gSUNVIHBsYWNlaG9sZGVycyBzaG91bGQgbm90IGJlIHJlcGxhY2VkIHdpdGggdGhlaXIgb3JpZ2luYWwgY29udGVudCBidXQgd2l0aCB0aGUgdGhlaXJcbiAgICAgICAgLy8gdHJhbnNsYXRpb25zLiBXZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyB2aXNpdG9yICh0aGV5IGFyZSBub3QgcmUtZW50cmFudCkgdG8gY29tcHV0ZSB0aGVcbiAgICAgICAgLy8gbWVzc2FnZSBpZC5cbiAgICAgICAgLy8gVE9ETyh2aWNiKTogYWRkIGEgaHRtbC5Ob2RlIC0+IGkxOG4uTWVzc2FnZSBjYWNoZSB0byBhdm9pZCBoYXZpbmcgdG8gcmUtY3JlYXRlIHRoZSBtc2dcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGhOYW1lID0gdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRQbGFjZWhvbGRlck5hbWUoJ0lDVScsIGljdS5zb3VyY2VTcGFuLnRvU3RyaW5nKCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdG9yID0gbmV3IF9JMThuVmlzaXRvcih0aGlzLl9leHByZXNzaW9uUGFyc2VyLCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJUb01lc3NhZ2VbcGhOYW1lXSA9IHZpc2l0b3IudG9JMThuTWVzc2FnZShbaWN1XSwgJycsICcnLCAnJyk7XG4gICAgICAgIHJldHVybiBuZXcgSWN1UGxhY2Vob2xkZXIoaTE4bkljdSwgcGhOYW1lLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdUNhc2VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlYWNoYWJsZSBjb2RlJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHRleHQsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3BsaXRJbnRlcnBvbGF0aW9uID0gdGhpcy5fZXhwcmVzc2lvblBhcnNlci5zcGxpdEludGVycG9sYXRpb24odGV4dCwgc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpLCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgaWYgKCFzcGxpdEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgIC8vIE5vIGV4cHJlc3Npb24sIHJldHVybiBhIHNpbmdsZSB0ZXh0XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHQkMSh0ZXh0LCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gYSBncm91cCBvZiB0ZXh0ICsgZXhwcmVzc2lvbnNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGFpbmVyID0gbmV3IENvbnRhaW5lcihub2Rlcywgc291cmNlU3Bhbik7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX2ludGVycG9sYXRpb25Db25maWcsIHNEZWxpbWl0ZXIgPSBfYS5zdGFydCwgZURlbGltaXRlciA9IF9hLmVuZDtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwcmVzc2lvbiA9IHNwbGl0SW50ZXJwb2xhdGlvbi5leHByZXNzaW9uc1tpXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VOYW1lID0gX2V4dHJhY3RQbGFjZWhvbGRlck5hbWUoZXhwcmVzc2lvbikgfHwgJ0lOVEVSUE9MQVRJT04nO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGhOYW1lID0gdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRQbGFjZWhvbGRlck5hbWUoYmFzZU5hbWUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgaWYgKHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzW2ldLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gYWRkIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDEoc3BsaXRJbnRlcnBvbGF0aW9uLnN0cmluZ3NbaV0sIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3IFBsYWNlaG9sZGVyKGV4cHJlc3Npb24sIHBoTmFtZSwgc291cmNlU3BhbikpO1xuICAgICAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJUb0NvbnRlbnRbcGhOYW1lXSA9IHNEZWxpbWl0ZXIgKyBleHByZXNzaW9uICsgZURlbGltaXRlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgbGFzdCBpbmRleCBjb250YWlucyBubyBleHByZXNzaW9uXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3RTdHJpbmdJZHggPSBzcGxpdEludGVycG9sYXRpb24uc3RyaW5ncy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoc3BsaXRJbnRlcnBvbGF0aW9uLnN0cmluZ3NbbGFzdFN0cmluZ0lkeF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDEoc3BsaXRJbnRlcnBvbGF0aW9uLnN0cmluZ3NbbGFzdFN0cmluZ0lkeF0sIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH07XG4gICAgcmV0dXJuIF9JMThuVmlzaXRvcjtcbn0oKSk7XG52YXIgX0NVU1RPTV9QSF9FWFAgPSAvXFwvXFwvW1xcc1xcU10qaTE4bltcXHNcXFNdKlxcKFtcXHNcXFNdKnBoW1xcc1xcU10qPVtcXHNcXFNdKihcInwnKShbXFxzXFxTXSo/KVxcMVtcXHNcXFNdKlxcKS9nO1xuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfZXh0cmFjdFBsYWNlaG9sZGVyTmFtZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5zcGxpdChfQ1VTVE9NX1BIX0VYUClbMl07XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEFuIGkxOG4gZXJyb3IuXG4gKi9cbnZhciBJMThuRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJMThuRXJyb3IsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSBtc2dcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJMThuRXJyb3Ioc3BhbiwgbXNnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBtc2cpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBJMThuRXJyb3I7XG59KFBhcnNlRXJyb3IpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfSTE4Tl9BVFRSID0gJ2kxOG4nO1xudmFyIF9JMThOX0FUVFJfUFJFRklYID0gJ2kxOG4tJztcbnZhciBfSTE4Tl9DT01NRU5UX1BSRUZJWF9SRUdFWFAgPSAvXmkxOG46Py87XG52YXIgTUVBTklOR19TRVBBUkFUT1IgPSAnfCc7XG52YXIgSURfU0VQQVJBVE9SID0gJ0BAJztcbi8qKlxuICogRXh0cmFjdCB0cmFuc2xhdGFibGUgbWVzc2FnZXMgZnJvbSBhbiBodG1sIEFTVFxuICogQHBhcmFtIHs/fSBub2Rlc1xuICogQHBhcmFtIHs/fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gKiBAcGFyYW0gez99IGltcGxpY2l0VGFnc1xuICogQHBhcmFtIHs/fSBpbXBsaWNpdEF0dHJzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBleHRyYWN0TWVzc2FnZXMobm9kZXMsIGludGVycG9sYXRpb25Db25maWcsIGltcGxpY2l0VGFncywgaW1wbGljaXRBdHRycykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX1Zpc2l0b3IoaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKTtcbiAgICByZXR1cm4gdmlzaXRvci5leHRyYWN0KG5vZGVzLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBub2Rlc1xuICogQHBhcmFtIHs/fSB0cmFuc2xhdGlvbnNcbiAqIEBwYXJhbSB7P30gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICogQHBhcmFtIHs/fSBpbXBsaWNpdFRhZ3NcbiAqIEBwYXJhbSB7P30gaW1wbGljaXRBdHRyc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbWVyZ2VUcmFuc2xhdGlvbnMobm9kZXMsIHRyYW5zbGF0aW9ucywgaW50ZXJwb2xhdGlvbkNvbmZpZywgaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBfVmlzaXRvcihpbXBsaWNpdFRhZ3MsIGltcGxpY2l0QXR0cnMpO1xuICAgIHJldHVybiB2aXNpdG9yLm1lcmdlKG5vZGVzLCB0cmFuc2xhdGlvbnMsIGludGVycG9sYXRpb25Db25maWcpO1xufVxudmFyIEV4dHJhY3Rpb25SZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZXNcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEV4dHJhY3Rpb25SZXN1bHQobWVzc2FnZXMsIGVycm9ycykge1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gRXh0cmFjdGlvblJlc3VsdDtcbn0oKSk7XG52YXIgX1Zpc2l0b3JNb2RlID0ge307XG5fVmlzaXRvck1vZGUuRXh0cmFjdCA9IDA7XG5fVmlzaXRvck1vZGUuTWVyZ2UgPSAxO1xuX1Zpc2l0b3JNb2RlW19WaXNpdG9yTW9kZS5FeHRyYWN0XSA9IFwiRXh0cmFjdFwiO1xuX1Zpc2l0b3JNb2RlW19WaXNpdG9yTW9kZS5NZXJnZV0gPSBcIk1lcmdlXCI7XG4vKipcbiAqIFRoaXMgVmlzaXRvciBpcyB1c2VkOlxuICogMS4gdG8gZXh0cmFjdCBhbGwgdGhlIHRyYW5zbGF0YWJsZSBzdHJpbmdzIGZyb20gYW4gaHRtbCBBU1QgKHNlZSBgZXh0cmFjdCgpYCksXG4gKiAyLiB0byByZXBsYWNlIHRoZSB0cmFuc2xhdGFibGUgc3RyaW5ncyB3aXRoIHRoZSBhY3R1YWwgdHJhbnNsYXRpb25zIChzZWUgYG1lcmdlKClgKVxuICpcbiAqIFxcQGludGVybmFsXG4gKi9cbnZhciBfVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfaW1wbGljaXRUYWdzXG4gICAgICogQHBhcmFtIHs/fSBfaW1wbGljaXRBdHRyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9WaXNpdG9yKF9pbXBsaWNpdFRhZ3MsIF9pbXBsaWNpdEF0dHJzKSB7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0VGFncyA9IF9pbXBsaWNpdFRhZ3M7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0QXR0cnMgPSBfaW1wbGljaXRBdHRycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIG1lc3NhZ2VzIGZyb20gdGhlIHRyZWVcbiAgICAgKiBAcGFyYW0gez99IG5vZGVzXG4gICAgICogQHBhcmFtIHs/fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uIChub2RlcywgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9pbml0KF9WaXNpdG9yTW9kZS5FeHRyYWN0LCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcywgbnVsbCk7IH0pO1xuICAgICAgICBpZiAodGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLCAnVW5jbG9zZWQgYmxvY2snKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEV4dHJhY3Rpb25SZXN1bHQodGhpcy5fbWVzc2FnZXMsIHRoaXMuX2Vycm9ycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdHJlZSB3aGVyZSBhbGwgdHJhbnNsYXRhYmxlIG5vZGVzIGFyZSB0cmFuc2xhdGVkXG4gICAgICogQHBhcmFtIHs/fSBub2Rlc1xuICAgICAqIEBwYXJhbSB7P30gdHJhbnNsYXRpb25zXG4gICAgICogQHBhcmFtIHs/fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAobm9kZXMsIHRyYW5zbGF0aW9ucywgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICB0aGlzLl9pbml0KF9WaXNpdG9yTW9kZS5NZXJnZSwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIHRoaXMuX3RyYW5zbGF0aW9ucyA9IHRyYW5zbGF0aW9ucztcbiAgICAgICAgLy8gQ29uc3RydWN0IGEgc2luZ2xlIGZha2Ugcm9vdCBlbGVtZW50XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHdyYXBwZXIgPSBuZXcgRWxlbWVudCgnd3JhcHBlcicsIFtdLCBub2RlcywgLyoqIEB0eXBlIHs/fSAqLyAoKHVuZGVmaW5lZCkpLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zbGF0ZWROb2RlID0gd3JhcHBlci52aXNpdCh0aGlzLCBudWxsKTtcbiAgICAgICAgaWYgKHRoaXMuX2luSTE4bkJsb2NrKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSwgJ1VuY2xvc2VkIGJsb2NrJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVRyZWVSZXN1bHQodHJhbnNsYXRlZE5vZGUuY2hpbGRyZW4sIHRoaXMuX2Vycm9ycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdUNhc2VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoaWN1Q2FzZSwgY29udGV4dCkge1xuICAgICAgICAvLyBQYXJzZSBjYXNlcyBmb3IgdHJhbnNsYXRhYmxlIGh0bWwgYXR0cmlidXRlc1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByZXNzaW9uID0gdmlzaXRBbGwodGhpcywgaWN1Q2FzZS5leHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHBhbnNpb25DYXNlKGljdUNhc2UudmFsdWUsIGV4cHJlc3Npb24sIGljdUNhc2Uuc291cmNlU3BhbiwgaWN1Q2FzZS52YWx1ZVNvdXJjZVNwYW4sIGljdUNhc2UuZXhwU291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX21heUJlQWRkQmxvY2tDaGlsZHJlbihpY3UpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3YXNJbkljdSA9IHRoaXMuX2luSWN1O1xuICAgICAgICBpZiAoIXRoaXMuX2luSWN1KSB7XG4gICAgICAgICAgICAvLyBuZXN0ZWQgSUNVIG1lc3NhZ2VzIHNob3VsZCBub3QgYmUgZXh0cmFjdGVkIGJ1dCB0b3AtbGV2ZWwgdHJhbnNsYXRlZCBhcyBhIHdob2xlXG4gICAgICAgICAgICBpZiAodGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKFtpY3VdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2luSWN1ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYXNlcyA9IHZpc2l0QWxsKHRoaXMsIGljdS5jYXNlcywgY29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgIGljdSA9IG5ldyBFeHBhbnNpb24oaWN1LnN3aXRjaFZhbHVlLCBpY3UudHlwZSwgY2FzZXMsIGljdS5zb3VyY2VTcGFuLCBpY3Uuc3dpdGNoVmFsdWVTb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbkljdSA9IHdhc0luSWN1O1xuICAgICAgICByZXR1cm4gaWN1O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21tZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNPcGVuaW5nID0gX2lzT3BlbmluZ0NvbW1lbnQoY29tbWVudCk7XG4gICAgICAgIGlmIChpc09wZW5pbmcgJiYgdGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGNvbW1lbnQsICdDb3VsZCBub3Qgc3RhcnQgYSBibG9jayBpbnNpZGUgYSB0cmFuc2xhdGFibGUgc2VjdGlvbicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzQ2xvc2luZyA9IF9pc0Nsb3NpbmdDb21tZW50KGNvbW1lbnQpO1xuICAgICAgICBpZiAoaXNDbG9zaW5nICYmICF0aGlzLl9pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ1RyeWluZyB0byBjbG9zZSBhbiB1bm9wZW5lZCBibG9jaycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5JMThuTm9kZSAmJiAhdGhpcy5faW5JY3UpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPcGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luSTE4bkJsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tTdGFydERlcHRoID0gdGhpcy5fZGVwdGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2NrQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tNZWFuaW5nQW5kRGVzYyA9ICgoY29tbWVudC52YWx1ZSkpLnJlcGxhY2UoX0kxOE5fQ09NTUVOVF9QUkVGSVhfUkVHRVhQLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcGVuVHJhbnNsYXRhYmxlU2VjdGlvbihjb21tZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNDbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kZXB0aCA9PSB0aGlzLl9ibG9ja1N0YXJ0RGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVHJhbnNsYXRhYmxlU2VjdGlvbihjb21tZW50LCB0aGlzLl9ibG9ja0NoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luSTE4bkJsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXNzYWdlID0gKCh0aGlzLl9hZGRNZXNzYWdlKHRoaXMuX2Jsb2NrQ2hpbGRyZW4sIHRoaXMuX2Jsb2NrTWVhbmluZ0FuZERlc2MpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSBhdHRyaWJ1dGVzIGluIHNlY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlcyA9IHRoaXMuX3RyYW5zbGF0ZU1lc3NhZ2UoY29tbWVudCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRBbGwodGhpcywgbm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ0kxOE4gYmxvY2tzIHNob3VsZCBub3QgY3Jvc3MgZWxlbWVudCBib3VuZGFyaWVzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9tYXlCZUFkZEJsb2NrQ2hpbGRyZW4oZWwpO1xuICAgICAgICB0aGlzLl9kZXB0aCsrO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3YXNJbkkxOG5Ob2RlID0gdGhpcy5faW5JMThuTm9kZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd2FzSW5JbXBsaWNpdE5vZGUgPSB0aGlzLl9pbkltcGxpY2l0Tm9kZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2xhdGVkQ2hpbGROb2RlcyA9ICgodW5kZWZpbmVkKSk7XG4gICAgICAgIC8vIEV4dHJhY3Q6XG4gICAgICAgIC8vIC0gdG9wIGxldmVsIG5vZGVzIHdpdGggdGhlIChpbXBsaWNpdCkgXCJpMThuXCIgYXR0cmlidXRlIGlmIG5vdCBhbHJlYWR5IGluIGEgc2VjdGlvblxuICAgICAgICAvLyAtIElDVSBtZXNzYWdlc1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpMThuQXR0ciA9IF9nZXRJMThuQXR0cihlbCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5NZXRhID0gaTE4bkF0dHIgPyBpMThuQXR0ci52YWx1ZSA6ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0ltcGxpY2l0ID0gdGhpcy5faW1wbGljaXRUYWdzLnNvbWUoZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gZWwubmFtZSA9PT0gdGFnOyB9KSAmJiAhdGhpcy5faW5JY3UgJiZcbiAgICAgICAgICAgICF0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNUb3BMZXZlbEltcGxpY2l0ID0gIXdhc0luSW1wbGljaXROb2RlICYmIGlzSW1wbGljaXQ7XG4gICAgICAgIHRoaXMuX2luSW1wbGljaXROb2RlID0gd2FzSW5JbXBsaWNpdE5vZGUgfHwgaXNJbXBsaWNpdDtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbiAmJiAhdGhpcy5faW5JY3UpIHtcbiAgICAgICAgICAgIGlmIChpMThuQXR0ciB8fCBpc1RvcExldmVsSW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbkkxOG5Ob2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXNzYWdlID0gKCh0aGlzLl9hZGRNZXNzYWdlKGVsLmNoaWxkcmVuLCBpMThuTWV0YSkpKTtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVkQ2hpbGROb2RlcyA9IHRoaXMuX3RyYW5zbGF0ZU1lc3NhZ2UoZWwsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT0gX1Zpc2l0b3JNb2RlLkV4dHJhY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1RyYW5zbGF0YWJsZSA9IGkxOG5BdHRyIHx8IGlzVG9wTGV2ZWxJbXBsaWNpdDtcbiAgICAgICAgICAgICAgICBpZiAoaXNUcmFuc2xhdGFibGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZW5UcmFuc2xhdGFibGVTZWN0aW9uKGVsKTtcbiAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbC5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgaWYgKGlzVHJhbnNsYXRhYmxlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVRyYW5zbGF0YWJsZVNlY3Rpb24oZWwsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpMThuQXR0ciB8fCBpc1RvcExldmVsSW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlbCwgJ0NvdWxkIG5vdCBtYXJrIGFuIGVsZW1lbnQgYXMgdHJhbnNsYXRhYmxlIGluc2lkZSBhIHRyYW5zbGF0YWJsZSBzZWN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PSBfVmlzaXRvck1vZGUuRXh0cmFjdCkge1xuICAgICAgICAgICAgICAgIC8vIERlc2NlbmQgaW50byBjaGlsZCBub2RlcyBmb3IgZXh0cmFjdGlvblxuICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdE5vZGVzID0gdHJhbnNsYXRlZENoaWxkTm9kZXMgfHwgZWwuY2hpbGRyZW47XG4gICAgICAgICAgICB2aXNpdE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRlZCA9IGNoaWxkLnZpc2l0KF90aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAodmlzaXRlZCAmJiAhX3RoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCBhZGQgdGhlIGNoaWxkcmVuIGZyb20gdHJhbnNsYXRhYmxlIHNlY3Rpb25zICg9IGkxOG4gYmxvY2tzIGhlcmUpXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXkgd2lsbCBiZSBhZGRlZCBsYXRlciBpbiB0aGlzIGxvb3Agd2hlbiB0aGUgYmxvY2sgY2xvc2VzIChpLmUuIG9uIGA8IS0tIC9pMThuIC0tPmApXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBjaGlsZE5vZGVzLmNvbmNhdCh2aXNpdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aXNpdEF0dHJpYnV0ZXNPZihlbCk7XG4gICAgICAgIHRoaXMuX2RlcHRoLS07XG4gICAgICAgIHRoaXMuX2luSTE4bk5vZGUgPSB3YXNJbkkxOG5Ob2RlO1xuICAgICAgICB0aGlzLl9pbkltcGxpY2l0Tm9kZSA9IHdhc0luSW1wbGljaXROb2RlO1xuICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2xhdGVkQXR0cnMgPSB0aGlzLl90cmFuc2xhdGVBdHRyaWJ1dGVzKGVsKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudChlbC5uYW1lLCB0cmFuc2xhdGVkQXR0cnMsIGNoaWxkTm9kZXMsIGVsLnNvdXJjZVNwYW4sIGVsLnN0YXJ0U291cmNlU3BhbiwgZWwuZW5kU291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEBwYXJhbSB7P30gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG1vZGUsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgdGhpcy5fbW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuX2luSTE4bkJsb2NrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2luSTE4bk5vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGVwdGggPSAwO1xuICAgICAgICB0aGlzLl9pbkljdSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UgPSBjcmVhdGVJMThuTWVzc2FnZUZhY3RvcnkoaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0QXR0cmlidXRlc09mID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cGxpY2l0QXR0ck5hbWVUb1ZhbHVlID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGltcGxpY2l0QXR0ck5hbWVzID0gdGhpcy5faW1wbGljaXRBdHRyc1tlbC5uYW1lXSB8fCBbXTtcbiAgICAgICAgZWwuYXR0cnMuZmlsdGVyKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUuc3RhcnRzV2l0aChfSTE4Tl9BVFRSX1BSRUZJWCk7IH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gZXhwbGljaXRBdHRyTmFtZVRvVmFsdWVbYXR0ci5uYW1lLnNsaWNlKF9JMThOX0FUVFJfUFJFRklYLmxlbmd0aCldID1cbiAgICAgICAgICAgIGF0dHIudmFsdWU7IH0pO1xuICAgICAgICBlbC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICBpZiAoYXR0ci5uYW1lIGluIGV4cGxpY2l0QXR0ck5hbWVUb1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2FkZE1lc3NhZ2UoW2F0dHJdLCBleHBsaWNpdEF0dHJOYW1lVG9WYWx1ZVthdHRyLm5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGltcGxpY2l0QXR0ck5hbWVzLnNvbWUoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gbmFtZTsgfSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYWRkTWVzc2FnZShbYXR0cl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/PX0gbXNnTWV0YVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl9hZGRNZXNzYWdlID0gZnVuY3Rpb24gKGFzdCwgbXNnTWV0YSkge1xuICAgICAgICBpZiAoYXN0Lmxlbmd0aCA9PSAwIHx8XG4gICAgICAgICAgICBhc3QubGVuZ3RoID09IDEgJiYgYXN0WzBdIGluc3RhbmNlb2YgQXR0cmlidXRlJDEgJiYgISgoYXN0WzBdKSkudmFsdWUpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBjcmVhdGUgZW1wdHkgbWVzc2FnZXNcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IF9wYXJzZU1lc3NhZ2VNZXRhKG1zZ01ldGEpLCBtZWFuaW5nID0gX2EubWVhbmluZywgZGVzY3JpcHRpb24gPSBfYS5kZXNjcmlwdGlvbiwgaWQgPSBfYS5pZDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVzc2FnZSA9IHRoaXMuX2NyZWF0ZUkxOG5NZXNzYWdlKGFzdCwgbWVhbmluZywgZGVzY3JpcHRpb24sIGlkKTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUuX3RyYW5zbGF0ZU1lc3NhZ2UgPSBmdW5jdGlvbiAoZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgJiYgdGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlcyA9IHRoaXMuX3RyYW5zbGF0aW9ucy5nZXQobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAobm9kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlbCwgXCJUcmFuc2xhdGlvbiB1bmF2YWlsYWJsZSBmb3IgbWVzc2FnZSBpZD1cXFwiXCIgKyB0aGlzLl90cmFuc2xhdGlvbnMuZGlnZXN0KG1lc3NhZ2UpICsgXCJcXFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fdHJhbnNsYXRlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRyaWJ1dGVzID0gZWwuYXR0cnM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5QYXJzZWRNZXNzYWdlTWV0YSA9IHt9O1xuICAgICAgICBhdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChhdHRyLm5hbWUuc3RhcnRzV2l0aChfSTE4Tl9BVFRSX1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgICBpMThuUGFyc2VkTWVzc2FnZU1ldGFbYXR0ci5uYW1lLnNsaWNlKF9JMThOX0FUVFJfUFJFRklYLmxlbmd0aCldID1cbiAgICAgICAgICAgICAgICAgICAgX3BhcnNlTWVzc2FnZU1ldGEoYXR0ci52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2xhdGVkQXR0cmlidXRlcyA9IFtdO1xuICAgICAgICBhdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgPT09IF9JMThOX0FUVFIgfHwgYXR0ci5uYW1lLnN0YXJ0c1dpdGgoX0kxOE5fQVRUUl9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgaTE4biBzcGVjaWZpYyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF0dHIudmFsdWUgJiYgYXR0ci52YWx1ZSAhPSAnJyAmJiBpMThuUGFyc2VkTWVzc2FnZU1ldGEuaGFzT3duUHJvcGVydHkoYXR0ci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGkxOG5QYXJzZWRNZXNzYWdlTWV0YVthdHRyLm5hbWVdLCBtZWFuaW5nID0gX2EubWVhbmluZywgZGVzY3JpcHRpb24gPSBfYS5kZXNjcmlwdGlvbiwgaWQgPSBfYS5pZDtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXNzYWdlID0gX3RoaXMuX2NyZWF0ZUkxOG5NZXNzYWdlKFthdHRyXSwgbWVhbmluZywgZGVzY3JpcHRpb24sIGlkKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlcyA9IF90aGlzLl90cmFuc2xhdGlvbnMuZ2V0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRBdHRyaWJ1dGVzLnB1c2gobmV3IEF0dHJpYnV0ZSQxKGF0dHIubmFtZSwgJycsIGF0dHIuc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGVzWzBdIGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSAoKG5vZGVzWzBdKSkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVkQXR0cmlidXRlcy5wdXNoKG5ldyBBdHRyaWJ1dGUkMShhdHRyLm5hbWUsIHZhbHVlLCBhdHRyLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihlbCwgXCJVbmV4cGVjdGVkIHRyYW5zbGF0aW9uIGZvciBhdHRyaWJ1dGUgXFxcIlwiICsgYXR0ci5uYW1lICsgXCJcXFwiIChpZD1cXFwiXCIgKyAoaWQgfHwgX3RoaXMuX3RyYW5zbGF0aW9ucy5kaWdlc3QobWVzc2FnZSkpICsgXCJcXFwiKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKGVsLCBcIlRyYW5zbGF0aW9uIHVuYXZhaWxhYmxlIGZvciBhdHRyaWJ1dGUgXFxcIlwiICsgYXR0ci5uYW1lICsgXCJcXFwiIChpZD1cXFwiXCIgKyAoaWQgfHwgX3RoaXMuX3RyYW5zbGF0aW9ucy5kaWdlc3QobWVzc2FnZSkpICsgXCJcXFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVkQXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZWRBdHRyaWJ1dGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBub2RlIGFzIGEgY2hpbGQgb2YgdGhlIGJsb2NrIHdoZW46XG4gICAgICogLSB3ZSBhcmUgaW4gYSBibG9jayxcbiAgICAgKiAtIHdlIGFyZSBub3QgaW5zaWRlIGEgSUNVIG1lc3NhZ2UgKHRob3NlIGFyZSBoYW5kbGVkIHNlcGFyYXRlbHkpLFxuICAgICAqIC0gdGhlIG5vZGUgaXMgYSBcImRpcmVjdCBjaGlsZFwiIG9mIHRoZSBibG9ja1xuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl9tYXlCZUFkZEJsb2NrQ2hpbGRyZW4gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5faW5JMThuQmxvY2sgJiYgIXRoaXMuX2luSWN1ICYmIHRoaXMuX2RlcHRoID09IHRoaXMuX2Jsb2NrU3RhcnREZXB0aCkge1xuICAgICAgICAgICAgdGhpcy5fYmxvY2tDaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGUgc3RhcnQgb2YgYSBzZWN0aW9uLCBzZWUgYF9jbG9zZVRyYW5zbGF0YWJsZVNlY3Rpb25gXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUuX29wZW5UcmFuc2xhdGFibGVTZWN0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihub2RlLCAnVW5leHBlY3RlZCBzZWN0aW9uIHN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0ID0gdGhpcy5fbWVzc2FnZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX1Zpc2l0b3IucHJvdG90eXBlLCBcIl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHRyYW5zbGF0YWJsZSBzZWN0aW9uIGNvdWxkIGJlOlxuICAgICAgICAgKiAtIHRoZSBjb250ZW50IG9mIHRyYW5zbGF0YWJsZSBlbGVtZW50LFxuICAgICAgICAgKiAtIG5vZGVzIGJldHdlZW4gYDwhLS0gaTE4biAtLT5gIGFuZCBgPCEtLSAvaTE4biAtLT5gIGNvbW1lbnRzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0ICE9PSB2b2lkIDA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRlcm1pbmF0ZXMgYSBzZWN0aW9uLlxuICAgICAqXG4gICAgICogSWYgYSBzZWN0aW9uIGhhcyBvbmx5IG9uZSBzaWduaWZpY2FudCBjaGlsZHJlbiAoY29tbWVudHMgbm90IHNpZ25pZmljYW50KSB0aGVuIHdlIHNob3VsZCBub3RcbiAgICAgKiBrZWVwIHRoZSBtZXNzYWdlIGZyb20gdGhpcyBjaGlsZHJlbjpcbiAgICAgKlxuICAgICAqIGA8cCBpMThuPVwibWVhbmluZ3xkZXNjcmlwdGlvblwiPntJQ1UgbWVzc2FnZX08L3A+YCB3b3VsZCBwcm9kdWNlIHR3byBtZXNzYWdlczpcbiAgICAgKiAtIG9uZSBmb3IgdGhlIDxwPiBjb250ZW50IHdpdGggbWVhbmluZyBhbmQgZGVzY3JpcHRpb24sXG4gICAgICogLSBhbm90aGVyIG9uZSBmb3IgdGhlIElDVSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogSW4gdGhpcyBjYXNlIHRoZSBsYXN0IG1lc3NhZ2UgaXMgZGlzY2FyZGVkIGFzIGl0IGNvbnRhaW5zIGxlc3MgaW5mb3JtYXRpb24gKHRoZSBBU1QgaXNcbiAgICAgKiBvdGhlcndpc2UgaWRlbnRpY2FsKS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB3ZSBzaG91bGQgc3RpbGwga2VlcCBtZXNzYWdlcyBleHRyYWN0ZWQgZnJvbSBhdHRyaWJ1dGVzIGluc2lkZSB0aGUgc2VjdGlvbiAoaWUgaW4gdGhlXG4gICAgICogSUNVIG1lc3NhZ2UgaGVyZSlcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdENoaWxkcmVuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUuX2Nsb3NlVHJhbnNsYXRhYmxlU2VjdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBkaXJlY3RDaGlsZHJlbikge1xuICAgICAgICBpZiAoIXRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihub2RlLCAnVW5leHBlY3RlZCBzZWN0aW9uIGVuZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0SW5kZXggPSB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzaWduaWZpY2FudENoaWxkcmVuID0gZGlyZWN0Q2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uIChjb3VudCwgbm9kZSkgeyByZXR1cm4gY291bnQgKyAobm9kZSBpbnN0YW5jZW9mIENvbW1lbnQgPyAwIDogMSk7IH0sIDApO1xuICAgICAgICBpZiAoc2lnbmlmaWNhbnRDaGlsZHJlbiA9PSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSB0aGlzLl9tZXNzYWdlcy5sZW5ndGggLSAxOyBpID49IHN0YXJ0SW5kZXg7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IHRoaXMuX21lc3NhZ2VzW2ldLm5vZGVzO1xuICAgICAgICAgICAgICAgIGlmICghKGFzdC5sZW5ndGggPT0gMSAmJiBhc3RbMF0gaW5zdGFuY2VvZiBUZXh0JDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcGFyYW0gez99IG1zZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl9yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtc2cpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcigvKiogQHR5cGUgez99ICovICgobm9kZS5zb3VyY2VTcGFuKSksIG1zZykpO1xuICAgIH07XG4gICAgcmV0dXJuIF9WaXNpdG9yO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfaXNPcGVuaW5nQ29tbWVudChuKSB7XG4gICAgcmV0dXJuICEhKG4gaW5zdGFuY2VvZiBDb21tZW50ICYmIG4udmFsdWUgJiYgbi52YWx1ZS5zdGFydHNXaXRoKCdpMThuJykpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9pc0Nsb3NpbmdDb21tZW50KG4pIHtcbiAgICByZXR1cm4gISEobiBpbnN0YW5jZW9mIENvbW1lbnQgJiYgbi52YWx1ZSAmJiBuLnZhbHVlID09PSAnL2kxOG4nKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfZ2V0STE4bkF0dHIocCkge1xuICAgIHJldHVybiBwLmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gX0kxOE5fQVRUUjsgfSkgfHwgbnVsbDtcbn1cbi8qKlxuICogQHBhcmFtIHs/PX0gaTE4blxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX3BhcnNlTWVzc2FnZU1ldGEoaTE4bikge1xuICAgIGlmICghaTE4bilcbiAgICAgICAgcmV0dXJuIHsgbWVhbmluZzogJycsIGRlc2NyaXB0aW9uOiAnJywgaWQ6ICcnIH07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWRJbmRleCA9IGkxOG4uaW5kZXhPZihJRF9TRVBBUkFUT1IpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlc2NJbmRleCA9IGkxOG4uaW5kZXhPZihNRUFOSU5HX1NFUEFSQVRPUik7XG4gICAgdmFyIF9hID0gKGlkSW5kZXggPiAtMSkgPyBbaTE4bi5zbGljZSgwLCBpZEluZGV4KSwgaTE4bi5zbGljZShpZEluZGV4ICsgMildIDogW2kxOG4sICcnXSwgbWVhbmluZ0FuZERlc2MgPSBfYVswXSwgaWQgPSBfYVsxXTtcbiAgICB2YXIgX2IgPSAoZGVzY0luZGV4ID4gLTEpID9cbiAgICAgICAgW21lYW5pbmdBbmREZXNjLnNsaWNlKDAsIGRlc2NJbmRleCksIG1lYW5pbmdBbmREZXNjLnNsaWNlKGRlc2NJbmRleCArIDEpXSA6XG4gICAgICAgIFsnJywgbWVhbmluZ0FuZERlc2NdLCBtZWFuaW5nID0gX2JbMF0sIGRlc2NyaXB0aW9uID0gX2JbMV07XG4gICAgcmV0dXJuIHsgbWVhbmluZzogbWVhbmluZywgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLCBpZDogaWQgfTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBYbWxUYWdEZWZpbml0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYbWxUYWdEZWZpbml0aW9uKCkge1xuICAgICAgICB0aGlzLmNsb3NlZEJ5UGFyZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29udGVudFR5cGUgPSBUYWdDb250ZW50VHlwZS5QQVJTQUJMRV9EQVRBO1xuICAgICAgICB0aGlzLmlzVm9pZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlnbm9yZUZpcnN0TGYgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5TZWxmQ2xvc2UgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRQYXJlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRhZ0RlZmluaXRpb24ucHJvdG90eXBlLnJlcXVpcmVFeHRyYVBhcmVudCA9IGZ1bmN0aW9uIChjdXJyZW50UGFyZW50KSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRhZ0RlZmluaXRpb24ucHJvdG90eXBlLmlzQ2xvc2VkQnlDaGlsZCA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICByZXR1cm4gWG1sVGFnRGVmaW5pdGlvbjtcbn0oKSk7XG52YXIgX1RBR19ERUZJTklUSU9OID0gbmV3IFhtbFRhZ0RlZmluaXRpb24oKTtcbi8qKlxuICogQHBhcmFtIHs/fSB0YWdOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRYbWxUYWdEZWZpbml0aW9uKHRhZ05hbWUpIHtcbiAgICByZXR1cm4gX1RBR19ERUZJTklUSU9OO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFhtbFBhcnNlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFhtbFBhcnNlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBYbWxQYXJzZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBnZXRYbWxUYWdEZWZpbml0aW9uKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gcGFyc2VFeHBhbnNpb25Gb3Jtc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3Jtcykge1xuICAgICAgICBpZiAocGFyc2VFeHBhbnNpb25Gb3JtcyA9PT0gdm9pZCAwKSB7IHBhcnNlRXhwYW5zaW9uRm9ybXMgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5wYXJzZS5jYWxsKHRoaXMsIHNvdXJjZSwgdXJsLCBwYXJzZUV4cGFuc2lvbkZvcm1zKTtcbiAgICB9O1xuICAgIHJldHVybiBYbWxQYXJzZXI7XG59KFBhcnNlciQxKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZGlnZXN0KG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5pZCB8fCBzaGExKHNlcmlhbGl6ZU5vZGVzKG1lc3NhZ2Uubm9kZXMpLmpvaW4oJycpICsgKFwiW1wiICsgbWVzc2FnZS5tZWFuaW5nICsgXCJdXCIpKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkZWNpbWFsRGlnZXN0KG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS5pZCkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZS5pZDtcbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBfU2VyaWFsaXplcklnbm9yZUljdUV4cFZpc2l0b3IoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IG1lc3NhZ2Uubm9kZXMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnZpc2l0KHZpc2l0b3IsIG51bGwpOyB9KTtcbiAgICByZXR1cm4gY29tcHV0ZU1zZ0lkKHBhcnRzLmpvaW4oJycpLCBtZXNzYWdlLm1lYW5pbmcpO1xufVxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGkxOG4gYXN0IHRvIHNvbWV0aGluZyB4bWwtbGlrZSBpbiBvcmRlciB0byBnZW5lcmF0ZSBhbiBVSUQuXG4gKlxuICogVGhlIHZpc2l0b3IgaXMgYWxzbyB1c2VkIGluIHRoZSBpMThuIHBhcnNlciB0ZXN0c1xuICpcbiAqIFxcQGludGVybmFsXG4gKi9cbnZhciBfU2VyaWFsaXplclZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9TZXJpYWxpemVyVmlzaXRvcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiB0ZXh0LnZhbHVlOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gXCJbXCIgKyBjb250YWluZXIuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQudmlzaXQoX3RoaXMpOyB9KS5qb2luKCcsICcpICsgXCJdXCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyQ2FzZXMgPSBPYmplY3Qua2V5cyhpY3UuY2FzZXMpLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gayArIFwiIHtcIiArIGljdS5jYXNlc1trXS52aXNpdChfdGhpcykgKyBcIn1cIjsgfSk7XG4gICAgICAgIHJldHVybiBcIntcIiArIGljdS5leHByZXNzaW9uICsgXCIsIFwiICsgaWN1LnR5cGUgKyBcIiwgXCIgKyBzdHJDYXNlcy5qb2luKCcsICcpICsgXCJ9XCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHBoLmlzVm9pZCA/XG4gICAgICAgICAgICBcIjxwaCB0YWcgbmFtZT1cXFwiXCIgKyBwaC5zdGFydE5hbWUgKyBcIlxcXCIvPlwiIDpcbiAgICAgICAgICAgIFwiPHBoIHRhZyBuYW1lPVxcXCJcIiArIHBoLnN0YXJ0TmFtZSArIFwiXFxcIj5cIiArIHBoLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnZpc2l0KF90aGlzKTsgfSkuam9pbignLCAnKSArIFwiPC9waCBuYW1lPVxcXCJcIiArIHBoLmNsb3NlTmFtZSArIFwiXFxcIj5cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcGgudmFsdWUgPyBcIjxwaCBuYW1lPVxcXCJcIiArIHBoLm5hbWUgKyBcIlxcXCI+XCIgKyBwaC52YWx1ZSArIFwiPC9waD5cIiA6IFwiPHBoIG5hbWU9XFxcIlwiICsgcGgubmFtZSArIFwiXFxcIi8+XCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBcIjxwaCBpY3UgbmFtZT1cXFwiXCIgKyBwaC5uYW1lICsgXCJcXFwiPlwiICsgcGgudmFsdWUudmlzaXQodGhpcykgKyBcIjwvcGg+XCI7XG4gICAgfTtcbiAgICByZXR1cm4gX1NlcmlhbGl6ZXJWaXNpdG9yO1xufSgpKTtcbnZhciBzZXJpYWxpemVyVmlzaXRvciA9IG5ldyBfU2VyaWFsaXplclZpc2l0b3IoKTtcbi8qKlxuICogQHBhcmFtIHs/fSBub2Rlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplTm9kZXMobm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnZpc2l0KHNlcmlhbGl6ZXJWaXNpdG9yLCBudWxsKTsgfSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgaTE4biBhc3QgdG8gc29tZXRoaW5nIHhtbC1saWtlIGluIG9yZGVyIHRvIGdlbmVyYXRlIGFuIFVJRC5cbiAqXG4gKiBJZ25vcmUgdGhlIElDVSBleHByZXNzaW9ucyBzbyB0aGF0IG1lc3NhZ2UgSURzIHN0YXlzIGlkZW50aWNhbCBpZiBvbmx5IHRoZSBleHByZXNzaW9uIGNoYW5nZXMuXG4gKlxuICogXFxAaW50ZXJuYWxcbiAqL1xudmFyIF9TZXJpYWxpemVySWdub3JlSWN1RXhwVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9TZXJpYWxpemVySWdub3JlSWN1RXhwVmlzaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBfU2VyaWFsaXplcklnbm9yZUljdUV4cFZpc2l0b3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TZXJpYWxpemVySWdub3JlSWN1RXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ckNhc2VzID0gT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGsgKyBcIiB7XCIgKyBpY3UuY2FzZXNba10udmlzaXQoX3RoaXMpICsgXCJ9XCI7IH0pO1xuICAgICAgICAvLyBEbyBub3QgdGFrZSB0aGUgZXhwcmVzc2lvbiBpbnRvIGFjY291bnRcbiAgICAgICAgcmV0dXJuIFwie1wiICsgaWN1LnR5cGUgKyBcIiwgXCIgKyBzdHJDYXNlcy5qb2luKCcsICcpICsgXCJ9XCI7XG4gICAgfTtcbiAgICByZXR1cm4gX1NlcmlhbGl6ZXJJZ25vcmVJY3VFeHBWaXNpdG9yO1xufShfU2VyaWFsaXplclZpc2l0b3IpKTtcbi8qKlxuICogQ29tcHV0ZSB0aGUgU0hBMSBvZiB0aGUgZ2l2ZW4gc3RyaW5nXG4gKlxuICogc2VlIGh0dHA6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9maXBzL2ZpcHMxODAtNC9maXBzLTE4MC00LnBkZlxuICpcbiAqIFdBUk5JTkc6IHRoaXMgZnVuY3Rpb24gaGFzIG5vdCBiZWVuIGRlc2lnbmVkIG5vdCB0ZXN0ZWQgd2l0aCBzZWN1cml0eSBpbiBtaW5kLlxuICogICAgICAgICAgRE8gTk9UIFVTRSBJVCBJTiBBIFNFQ1VSSVRZIFNFTlNJVElWRSBDT05URVhULlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNoYTEoc3RyKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXRmOCA9IHV0ZjhFbmNvZGUoc3RyKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3b3JkczMyID0gc3RyaW5nVG9Xb3JkczMyKHV0ZjgsIEVuZGlhbi5CaWcpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlbiA9IHV0ZjgubGVuZ3RoICogODtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3ID0gbmV3IEFycmF5KDgwKTtcbiAgICB2YXIgX2EgPSBbMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMF0sIGEgPSBfYVswXSwgYiA9IF9hWzFdLCBjID0gX2FbMl0sIGQgPSBfYVszXSwgZSA9IF9hWzRdO1xuICAgIHdvcmRzMzJbbGVuID4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbGVuICUgMzIpO1xuICAgIHdvcmRzMzJbKChsZW4gKyA2NCA+PiA5KSA8PCA0KSArIDE1XSA9IGxlbjtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgd29yZHMzMi5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgICAgdmFyIF9iID0gW2EsIGIsIGMsIGQsIGVdLCBoMCA9IF9iWzBdLCBoMSA9IF9iWzFdLCBoMiA9IF9iWzJdLCBoMyA9IF9iWzNdLCBoNCA9IF9iWzRdO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGogPSAwOyBqIDwgODA7IGorKykge1xuICAgICAgICAgICAgaWYgKGogPCAxNikge1xuICAgICAgICAgICAgICAgIHdbal0gPSB3b3JkczMyW2kgKyBqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdbal0gPSByb2wzMih3W2ogLSAzXSBeIHdbaiAtIDhdIF4gd1tqIC0gMTRdIF4gd1tqIC0gMTZdLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYyA9IGZrKGosIGIsIGMsIGQpLCBmID0gX2NbMF0sIGsgPSBfY1sxXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXAgPSBbcm9sMzIoYSwgNSksIGYsIGUsIGssIHdbal1dLnJlZHVjZShhZGQzMik7XG4gICAgICAgICAgICBfZCA9IFtkLCBjLCByb2wzMihiLCAzMCksIGEsIHRlbXBdLCBlID0gX2RbMF0sIGQgPSBfZFsxXSwgYyA9IF9kWzJdLCBiID0gX2RbM10sIGEgPSBfZFs0XTtcbiAgICAgICAgfVxuICAgICAgICBfZSA9IFthZGQzMihhLCBoMCksIGFkZDMyKGIsIGgxKSwgYWRkMzIoYywgaDIpLCBhZGQzMihkLCBoMyksIGFkZDMyKGUsIGg0KV0sIGEgPSBfZVswXSwgYiA9IF9lWzFdLCBjID0gX2VbMl0sIGQgPSBfZVszXSwgZSA9IF9lWzRdO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZVN0cmluZ1RvSGV4U3RyaW5nKHdvcmRzMzJUb0J5dGVTdHJpbmcoW2EsIGIsIGMsIGQsIGVdKSk7XG4gICAgdmFyIF9kLCBfZTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpbmRleFxuICogQHBhcmFtIHs/fSBiXG4gKiBAcGFyYW0gez99IGNcbiAqIEBwYXJhbSB7P30gZFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZmsoaW5kZXgsIGIsIGMsIGQpIHtcbiAgICBpZiAoaW5kZXggPCAyMCkge1xuICAgICAgICByZXR1cm4gWyhiICYgYykgfCAofmIgJiBkKSwgMHg1YTgyNzk5OV07XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDQwKSB7XG4gICAgICAgIHJldHVybiBbYiBeIGMgXiBkLCAweDZlZDllYmExXTtcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgNjApIHtcbiAgICAgICAgcmV0dXJuIFsoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCksIDB4OGYxYmJjZGNdO1xuICAgIH1cbiAgICByZXR1cm4gW2IgXiBjIF4gZCwgMHhjYTYyYzFkNl07XG59XG4vKipcbiAqIENvbXB1dGUgdGhlIGZpbmdlcnByaW50IG9mIHRoZSBnaXZlbiBzdHJpbmdcbiAqXG4gKiBUaGUgb3V0cHV0IGlzIDY0IGJpdCBudW1iZXIgZW5jb2RlZCBhcyBhIGRlY2ltYWwgc3RyaW5nXG4gKlxuICogYmFzZWQgb246XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvYmxvYi9tYXN0ZXIvc3JjL2NvbS9nb29nbGUvamF2YXNjcmlwdC9qc2NvbXAvR29vZ2xlSnNNZXNzYWdlSWRHZW5lcmF0b3IuamF2YVxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGZpbmdlcnByaW50KHN0cikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHV0ZjggPSB1dGY4RW5jb2RlKHN0cik7XG4gICAgdmFyIF9hID0gW2hhc2gzMih1dGY4LCAwKSwgaGFzaDMyKHV0ZjgsIDEwMjA3MildLCBoaSA9IF9hWzBdLCBsbyA9IF9hWzFdO1xuICAgIGlmIChoaSA9PSAwICYmIChsbyA9PSAwIHx8IGxvID09IDEpKSB7XG4gICAgICAgIGhpID0gaGkgXiAweDEzMGY5YmVmO1xuICAgICAgICBsbyA9IGxvIF4gLTB4NmI1ZjU2ZDg7XG4gICAgfVxuICAgIHJldHVybiBbaGksIGxvXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBtc2dcbiAqIEBwYXJhbSB7P30gbWVhbmluZ1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZU1zZ0lkKG1zZywgbWVhbmluZykge1xuICAgIHZhciBfYSA9IGZpbmdlcnByaW50KG1zZyksIGhpID0gX2FbMF0sIGxvID0gX2FbMV07XG4gICAgaWYgKG1lYW5pbmcpIHtcbiAgICAgICAgdmFyIF9iID0gZmluZ2VycHJpbnQobWVhbmluZyksIGhpbSA9IF9iWzBdLCBsb20gPSBfYlsxXTtcbiAgICAgICAgX2MgPSBhZGQ2NChyb2w2NChbaGksIGxvXSwgMSksIFtoaW0sIGxvbV0pLCBoaSA9IF9jWzBdLCBsbyA9IF9jWzFdO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZVN0cmluZ1RvRGVjU3RyaW5nKHdvcmRzMzJUb0J5dGVTdHJpbmcoW2hpICYgMHg3ZmZmZmZmZiwgbG9dKSk7XG4gICAgdmFyIF9jO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHN0clxuICogQHBhcmFtIHs/fSBjXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBoYXNoMzIoc3RyLCBjKSB7XG4gICAgdmFyIF9hID0gWzB4OWUzNzc5YjksIDB4OWUzNzc5YjldLCBhID0gX2FbMF0sIGIgPSBfYVsxXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSArIDEyIDw9IGxlbjsgaSArPSAxMikge1xuICAgICAgICBhID0gYWRkMzIoYSwgd29yZEF0KHN0ciwgaSwgRW5kaWFuLkxpdHRsZSkpO1xuICAgICAgICBiID0gYWRkMzIoYiwgd29yZEF0KHN0ciwgaSArIDQsIEVuZGlhbi5MaXR0bGUpKTtcbiAgICAgICAgYyA9IGFkZDMyKGMsIHdvcmRBdChzdHIsIGkgKyA4LCBFbmRpYW4uTGl0dGxlKSk7XG4gICAgICAgIF9iID0gbWl4KFthLCBiLCBjXSksIGEgPSBfYlswXSwgYiA9IF9iWzFdLCBjID0gX2JbMl07XG4gICAgfVxuICAgIGEgPSBhZGQzMihhLCB3b3JkQXQoc3RyLCBpLCBFbmRpYW4uTGl0dGxlKSk7XG4gICAgYiA9IGFkZDMyKGIsIHdvcmRBdChzdHIsIGkgKyA0LCBFbmRpYW4uTGl0dGxlKSk7XG4gICAgLy8gdGhlIGZpcnN0IGJ5dGUgb2YgYyBpcyByZXNlcnZlZCBmb3IgdGhlIGxlbmd0aFxuICAgIGMgPSBhZGQzMihjLCBsZW4pO1xuICAgIGMgPSBhZGQzMihjLCB3b3JkQXQoc3RyLCBpICsgOCwgRW5kaWFuLkxpdHRsZSkgPDwgOCk7XG4gICAgcmV0dXJuIG1peChbYSwgYiwgY10pWzJdO1xuICAgIHZhciBfYjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBfXzBcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG1peChfYSkge1xuICAgIHZhciBhID0gX2FbMF0sIGIgPSBfYVsxXSwgYyA9IF9hWzJdO1xuICAgIGEgPSBzdWIzMihhLCBiKTtcbiAgICBhID0gc3ViMzIoYSwgYyk7XG4gICAgYSBePSBjID4+PiAxMztcbiAgICBiID0gc3ViMzIoYiwgYyk7XG4gICAgYiA9IHN1YjMyKGIsIGEpO1xuICAgIGIgXj0gYSA8PCA4O1xuICAgIGMgPSBzdWIzMihjLCBhKTtcbiAgICBjID0gc3ViMzIoYywgYik7XG4gICAgYyBePSBiID4+PiAxMztcbiAgICBhID0gc3ViMzIoYSwgYik7XG4gICAgYSA9IHN1YjMyKGEsIGMpO1xuICAgIGEgXj0gYyA+Pj4gMTI7XG4gICAgYiA9IHN1YjMyKGIsIGMpO1xuICAgIGIgPSBzdWIzMihiLCBhKTtcbiAgICBiIF49IGEgPDwgMTY7XG4gICAgYyA9IHN1YjMyKGMsIGEpO1xuICAgIGMgPSBzdWIzMihjLCBiKTtcbiAgICBjIF49IGIgPj4+IDU7XG4gICAgYSA9IHN1YjMyKGEsIGIpO1xuICAgIGEgPSBzdWIzMihhLCBjKTtcbiAgICBhIF49IGMgPj4+IDM7XG4gICAgYiA9IHN1YjMyKGIsIGMpO1xuICAgIGIgPSBzdWIzMihiLCBhKTtcbiAgICBiIF49IGEgPDwgMTA7XG4gICAgYyA9IHN1YjMyKGMsIGEpO1xuICAgIGMgPSBzdWIzMihjLCBiKTtcbiAgICBjIF49IGIgPj4+IDE1O1xuICAgIHJldHVybiBbYSwgYiwgY107XG59XG52YXIgRW5kaWFuID0ge307XG5FbmRpYW4uTGl0dGxlID0gMDtcbkVuZGlhbi5CaWcgPSAxO1xuRW5kaWFuW0VuZGlhbi5MaXR0bGVdID0gXCJMaXR0bGVcIjtcbkVuZGlhbltFbmRpYW4uQmlnXSA9IFwiQmlnXCI7XG4vKipcbiAqIEBwYXJhbSB7P30gYVxuICogQHBhcmFtIHs/fSBiXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBhZGQzMihhLCBiKSB7XG4gICAgcmV0dXJuIGFkZDMydG82NChhLCBiKVsxXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBhXG4gKiBAcGFyYW0gez99IGJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFkZDMydG82NChhLCBiKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG93ID0gKGEgJiAweGZmZmYpICsgKGIgJiAweGZmZmYpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGhpZ2ggPSAoYSA+Pj4gMTYpICsgKGIgPj4+IDE2KSArIChsb3cgPj4+IDE2KTtcbiAgICByZXR1cm4gW2hpZ2ggPj4+IDE2LCAoaGlnaCA8PCAxNikgfCAobG93ICYgMHhmZmZmKV07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gX18wXG4gKiBAcGFyYW0gez99IF9fMVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYWRkNjQoX2EsIF9iKSB7XG4gICAgdmFyIGFoID0gX2FbMF0sIGFsID0gX2FbMV07XG4gICAgdmFyIGJoID0gX2JbMF0sIGJsID0gX2JbMV07XG4gICAgdmFyIF9jID0gYWRkMzJ0bzY0KGFsLCBibCksIGNhcnJ5ID0gX2NbMF0sIGwgPSBfY1sxXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoID0gYWRkMzIoYWRkMzIoYWgsIGJoKSwgY2FycnkpO1xuICAgIHJldHVybiBbaCwgbF07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gYVxuICogQHBhcmFtIHs/fSBiXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzdWIzMihhLCBiKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG93ID0gKGEgJiAweGZmZmYpIC0gKGIgJiAweGZmZmYpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGhpZ2ggPSAoYSA+PiAxNikgLSAoYiA+PiAxNikgKyAobG93ID4+IDE2KTtcbiAgICByZXR1cm4gKGhpZ2ggPDwgMTYpIHwgKGxvdyAmIDB4ZmZmZik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gYVxuICogQHBhcmFtIHs/fSBjb3VudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcm9sMzIoYSwgY291bnQpIHtcbiAgICByZXR1cm4gKGEgPDwgY291bnQpIHwgKGEgPj4+ICgzMiAtIGNvdW50KSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gX18wXG4gKiBAcGFyYW0gez99IGNvdW50XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByb2w2NChfYSwgY291bnQpIHtcbiAgICB2YXIgaGkgPSBfYVswXSwgbG8gPSBfYVsxXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoID0gKGhpIDw8IGNvdW50KSB8IChsbyA+Pj4gKDMyIC0gY291bnQpKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsID0gKGxvIDw8IGNvdW50KSB8IChoaSA+Pj4gKDMyIC0gY291bnQpKTtcbiAgICByZXR1cm4gW2gsIGxdO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHN0clxuICogQHBhcmFtIHs/fSBlbmRpYW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvV29yZHMzMihzdHIsIGVuZGlhbikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHdvcmRzMzIgPSBBcnJheSgoc3RyLmxlbmd0aCArIDMpID4+PiAyKTtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgd29yZHMzMi5sZW5ndGg7IGkrKykge1xuICAgICAgICB3b3JkczMyW2ldID0gd29yZEF0KHN0ciwgaSAqIDQsIGVuZGlhbik7XG4gICAgfVxuICAgIHJldHVybiB3b3JkczMyO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHN0clxuICogQHBhcmFtIHs/fSBpbmRleFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYnl0ZUF0KHN0ciwgaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPj0gc3RyLmxlbmd0aCA/IDAgOiBzdHIuY2hhckNvZGVBdChpbmRleCkgJiAweGZmO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHN0clxuICogQHBhcmFtIHs/fSBpbmRleFxuICogQHBhcmFtIHs/fSBlbmRpYW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHdvcmRBdChzdHIsIGluZGV4LCBlbmRpYW4pIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3b3JkID0gMDtcbiAgICBpZiAoZW5kaWFuID09PSBFbmRpYW4uQmlnKSB7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHdvcmQgKz0gYnl0ZUF0KHN0ciwgaW5kZXggKyBpKSA8PCAoMjQgLSA4ICogaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHdvcmQgKz0gYnl0ZUF0KHN0ciwgaW5kZXggKyBpKSA8PCA4ICogaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd29yZDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB3b3JkczMyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB3b3JkczMyVG9CeXRlU3RyaW5nKHdvcmRzMzIpIHtcbiAgICByZXR1cm4gd29yZHMzMi5yZWR1Y2UoZnVuY3Rpb24gKHN0ciwgd29yZCkgeyByZXR1cm4gc3RyICsgd29yZDMyVG9CeXRlU3RyaW5nKHdvcmQpOyB9LCAnJyk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gd29yZFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gd29yZDMyVG9CeXRlU3RyaW5nKHdvcmQpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHIgPSAnJztcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCh3b3JkID4+PiA4ICogKDMgLSBpKSkgJiAweGZmKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGJ5dGVTdHJpbmdUb0hleFN0cmluZyhzdHIpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoZXggPSAnJztcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGIgPSBieXRlQXQoc3RyLCBpKTtcbiAgICAgICAgaGV4ICs9IChiID4+PiA0KS50b1N0cmluZygxNikgKyAoYiAmIDB4MGYpLnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIGhleC50b0xvd2VyQ2FzZSgpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHN0clxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYnl0ZVN0cmluZ1RvRGVjU3RyaW5nKHN0cikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlY2ltYWwgPSAnJztcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b1RoZVBvd2VyID0gJzEnO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IHN0ci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBkZWNpbWFsID0gYWRkQmlnSW50KGRlY2ltYWwsIG51bWJlclRpbWVzQmlnSW50KGJ5dGVBdChzdHIsIGkpLCB0b1RoZVBvd2VyKSk7XG4gICAgICAgIHRvVGhlUG93ZXIgPSBudW1iZXJUaW1lc0JpZ0ludCgyNTYsIHRvVGhlUG93ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjaW1hbC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHhcbiAqIEBwYXJhbSB7P30geVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYWRkQmlnSW50KHgsIHkpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdW0gPSAnJztcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZW4gPSBNYXRoLm1heCh4Lmxlbmd0aCwgeS5sZW5ndGgpO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDAsIC8qKiBAdHlwZSB7P30gKi8gY2FycnkgPSAwOyBpIDwgbGVuIHx8IGNhcnJ5OyBpKyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG1wU3VtID0gY2FycnkgKyArKHhbaV0gfHwgMCkgKyArKHlbaV0gfHwgMCk7XG4gICAgICAgIGlmICh0bXBTdW0gPj0gMTApIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gMTtcbiAgICAgICAgICAgIHN1bSArPSB0bXBTdW0gLSAxMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgICAgIHN1bSArPSB0bXBTdW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBudW1cbiAqIEBwYXJhbSB7P30gYlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbnVtYmVyVGltZXNCaWdJbnQobnVtLCBiKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvZHVjdCA9ICcnO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGJUb1RoZVBvd2VyID0gYjtcbiAgICBmb3IgKDsgbnVtICE9PSAwOyBudW0gPSBudW0gPj4+IDEpIHtcbiAgICAgICAgaWYgKG51bSAmIDEpXG4gICAgICAgICAgICBwcm9kdWN0ID0gYWRkQmlnSW50KHByb2R1Y3QsIGJUb1RoZVBvd2VyKTtcbiAgICAgICAgYlRvVGhlUG93ZXIgPSBhZGRCaWdJbnQoYlRvVGhlUG93ZXIsIGJUb1RoZVBvd2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2R1Y3Q7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgU2VyaWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VyaWFsaXplcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlc1xuICAgICAqIEBwYXJhbSB7P30gbG9jYWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJpYWxpemVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlcywgbG9jYWxlKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZW50XG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcmlhbGl6ZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY29udGVudCwgdXJsKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJpYWxpemVyLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAobWVzc2FnZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VyaWFsaXplci5wcm90b3R5cGUuY3JlYXRlTmFtZU1hcHBlciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBudWxsOyB9O1xuICAgIHJldHVybiBTZXJpYWxpemVyO1xufSgpKTtcbi8qKlxuICogQSBzaW1wbGUgbWFwcGVyIHRoYXQgdGFrZSBhIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBhbiBpbnRlcm5hbCBuYW1lIHRvIGEgcHVibGljIG5hbWVcbiAqL1xudmFyIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHs/fSBtYXBOYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIobWVzc2FnZSwgbWFwTmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5tYXBOYW1lID0gbWFwTmFtZTtcbiAgICAgICAgX3RoaXMuaW50ZXJuYWxUb1B1YmxpYyA9IHt9O1xuICAgICAgICBfdGhpcy5wdWJsaWNUb05leHRJZCA9IHt9O1xuICAgICAgICBfdGhpcy5wdWJsaWNUb0ludGVybmFsID0ge307XG4gICAgICAgIG1lc3NhZ2Uubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW50ZXJuYWxOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVQbGFjZWhvbGRlck1hcHBlci5wcm90b3R5cGUudG9QdWJsaWNOYW1lID0gZnVuY3Rpb24gKGludGVybmFsTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFRvUHVibGljLmhhc093blByb3BlcnR5KGludGVybmFsTmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFRvUHVibGljW2ludGVybmFsTmFtZV0gOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHVibGljTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIucHJvdG90eXBlLnRvSW50ZXJuYWxOYW1lID0gZnVuY3Rpb24gKHB1YmxpY05hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljVG9JbnRlcm5hbC5oYXNPd25Qcm9wZXJ0eShwdWJsaWNOYW1lKSA/IHRoaXMucHVibGljVG9JbnRlcm5hbFtwdWJsaWNOYW1lXSA6XG4gICAgICAgICAgICBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVQbGFjZWhvbGRlck1hcHBlci5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0UGxhY2Vob2xkZXJOYW1lKHBoLnN0YXJ0TmFtZSk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlci5jYWxsKHRoaXMsIHBoLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdFBsYWNlaG9sZGVyTmFtZShwaC5jbG9zZU5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7IHRoaXMudmlzaXRQbGFjZWhvbGRlck5hbWUocGgubmFtZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRQbGFjZWhvbGRlck5hbWUocGgubmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGludGVybmFsTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXJOYW1lID0gZnVuY3Rpb24gKGludGVybmFsTmFtZSkge1xuICAgICAgICBpZiAoIWludGVybmFsTmFtZSB8fCB0aGlzLmludGVybmFsVG9QdWJsaWMuaGFzT3duUHJvcGVydHkoaW50ZXJuYWxOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHB1YmxpY05hbWUgPSB0aGlzLm1hcE5hbWUoaW50ZXJuYWxOYW1lKTtcbiAgICAgICAgaWYgKHRoaXMucHVibGljVG9JbnRlcm5hbC5oYXNPd25Qcm9wZXJ0eShwdWJsaWNOYW1lKSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IFhNQiB3aGVuIGl0IGhhcyBhbHJlYWR5IGJlZW4gdXNlZFxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV4dElkID0gdGhpcy5wdWJsaWNUb05leHRJZFtwdWJsaWNOYW1lXTtcbiAgICAgICAgICAgIHRoaXMucHVibGljVG9OZXh0SWRbcHVibGljTmFtZV0gPSBuZXh0SWQgKyAxO1xuICAgICAgICAgICAgcHVibGljTmFtZSA9IHB1YmxpY05hbWUgKyBcIl9cIiArIG5leHRJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHVibGljVG9OZXh0SWRbcHVibGljTmFtZV0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW50ZXJuYWxUb1B1YmxpY1tpbnRlcm5hbE5hbWVdID0gcHVibGljTmFtZTtcbiAgICAgICAgdGhpcy5wdWJsaWNUb0ludGVybmFsW3B1YmxpY05hbWVdID0gaW50ZXJuYWxOYW1lO1xuICAgIH07XG4gICAgcmV0dXJuIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyO1xufShSZWN1cnNlVmlzaXRvcikpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9WaXNpdG9yJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9WaXNpdG9yJDEoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvciQxLnByb3RvdHlwZS52aXNpdFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyQXR0cnMgPSB0aGlzLl9zZXJpYWxpemVBdHRyaWJ1dGVzKHRhZy5hdHRycyk7XG4gICAgICAgIGlmICh0YWcuY2hpbGRyZW4ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcIjxcIiArIHRhZy5uYW1lICsgc3RyQXR0cnMgKyBcIi8+XCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyQ2hpbGRyZW4gPSB0YWcuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzKTsgfSk7XG4gICAgICAgIHJldHVybiBcIjxcIiArIHRhZy5uYW1lICsgc3RyQXR0cnMgKyBcIj5cIiArIHN0ckNoaWxkcmVuLmpvaW4oJycpICsgXCI8L1wiICsgdGFnLm5hbWUgKyBcIj5cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIHRleHQudmFsdWU7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkZWNsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvciQxLnByb3RvdHlwZS52aXNpdERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGRlY2wpIHtcbiAgICAgICAgcmV0dXJuIFwiPD94bWxcIiArIHRoaXMuX3NlcmlhbGl6ZUF0dHJpYnV0ZXMoZGVjbC5hdHRycykgKyBcIiA/PlwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhdHRyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMS5wcm90b3R5cGUuX3NlcmlhbGl6ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoYXR0cnMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycykubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBuYW1lICsgXCI9XFxcIlwiICsgYXR0cnNbbmFtZV0gKyBcIlxcXCJcIjsgfSkuam9pbignICcpO1xuICAgICAgICByZXR1cm4gc3RyQXR0cnMubGVuZ3RoID4gMCA/ICcgJyArIHN0ckF0dHJzIDogJyc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRvY3R5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0RG9jdHlwZSA9IGZ1bmN0aW9uIChkb2N0eXBlKSB7XG4gICAgICAgIHJldHVybiBcIjwhRE9DVFlQRSBcIiArIGRvY3R5cGUucm9vdFRhZyArIFwiIFtcXG5cIiArIGRvY3R5cGUuZHRkICsgXCJcXG5dPlwiO1xuICAgIH07XG4gICAgcmV0dXJuIF9WaXNpdG9yJDE7XG59KCkpO1xudmFyIF92aXNpdG9yID0gbmV3IF9WaXNpdG9yJDEoKTtcbi8qKlxuICogQHBhcmFtIHs/fSBub2Rlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplKG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdmlzaXRvcik7IH0pLmpvaW4oJycpO1xufVxudmFyIERlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVuZXNjYXBlZEF0dHJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVjbGFyYXRpb24odW5lc2NhcGVkQXR0cnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5hdHRycyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh1bmVzY2FwZWRBdHRycykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgX3RoaXMuYXR0cnNba10gPSBfZXNjYXBlWG1sKHVuZXNjYXBlZEF0dHJzW2tdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVjbGFyYXRpb24ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJhdGlvbih0aGlzKTsgfTtcbiAgICByZXR1cm4gRGVjbGFyYXRpb247XG59KCkpO1xudmFyIERvY3R5cGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcm9vdFRhZ1xuICAgICAqIEBwYXJhbSB7P30gZHRkXG4gICAgICovXG4gICAgZnVuY3Rpb24gRG9jdHlwZShyb290VGFnLCBkdGQpIHtcbiAgICAgICAgdGhpcy5yb290VGFnID0gcm9vdFRhZztcbiAgICAgICAgdGhpcy5kdGQgPSBkdGQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvY3R5cGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXREb2N0eXBlKHRoaXMpOyB9O1xuICAgIHJldHVybiBEb2N0eXBlO1xufSgpKTtcbnZhciBUYWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IHVuZXNjYXBlZEF0dHJzXG4gICAgICogQHBhcmFtIHs/PX0gY2hpbGRyZW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUYWcobmFtZSwgdW5lc2NhcGVkQXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmICh1bmVzY2FwZWRBdHRycyA9PT0gdm9pZCAwKSB7IHVuZXNjYXBlZEF0dHJzID0ge307IH1cbiAgICAgICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHsgY2hpbGRyZW4gPSBbXTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuYXR0cnMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModW5lc2NhcGVkQXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIF90aGlzLmF0dHJzW2tdID0gX2VzY2FwZVhtbCh1bmVzY2FwZWRBdHRyc1trXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRhZy5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdFRhZyh0aGlzKTsgfTtcbiAgICByZXR1cm4gVGFnO1xufSgpKTtcbnZhciBUZXh0JDIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdW5lc2NhcGVkVmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUZXh0JDIodW5lc2NhcGVkVmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IF9lc2NhcGVYbWwodW5lc2NhcGVkVmFsdWUpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZXh0JDIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMpOyB9O1xuICAgIHJldHVybiBUZXh0JDI7XG59KCkpO1xudmFyIENSID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ1IsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gd3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDUih3cykge1xuICAgICAgICBpZiAod3MgPT09IHZvaWQgMCkgeyB3cyA9IDA7IH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiXFxuXCIgKyBuZXcgQXJyYXkod3MgKyAxKS5qb2luKCcgJykpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDUjtcbn0oVGV4dCQyKSk7XG52YXIgX0VTQ0FQRURfQ0hBUlMgPSBbXG4gICAgWy8mL2csICcmYW1wOyddLFxuICAgIFsvXCIvZywgJyZxdW90OyddLFxuICAgIFsvJy9nLCAnJmFwb3M7J10sXG4gICAgWy88L2csICcmbHQ7J10sXG4gICAgWy8+L2csICcmZ3Q7J10sXG5dO1xuLyoqXG4gKiBAcGFyYW0gez99IHRleHRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9lc2NhcGVYbWwodGV4dCkge1xuICAgIHJldHVybiBfRVNDQVBFRF9DSEFSUy5yZWR1Y2UoZnVuY3Rpb24gKHRleHQsIGVudHJ5KSB7IHJldHVybiB0ZXh0LnJlcGxhY2UoZW50cnlbMF0sIGVudHJ5WzFdKTsgfSwgdGV4dCk7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX1ZFUlNJT04gPSAnMS4yJztcbnZhciBfWE1MTlMgPSAndXJuOm9hc2lzOm5hbWVzOnRjOnhsaWZmOmRvY3VtZW50OjEuMic7XG4vLyBUT0RPKHZpY2IpOiBtYWtlIHRoaXMgYSBwYXJhbSAocy9fLy0vKVxudmFyIF9ERUZBVUxUX1NPVVJDRV9MQU5HID0gJ2VuJztcbnZhciBfUExBQ0VIT0xERVJfVEFHID0gJ3gnO1xudmFyIF9GSUxFX1RBRyA9ICdmaWxlJztcbnZhciBfU09VUkNFX1RBRyA9ICdzb3VyY2UnO1xudmFyIF9UQVJHRVRfVEFHID0gJ3RhcmdldCc7XG52YXIgX1VOSVRfVEFHID0gJ3RyYW5zLXVuaXQnO1xudmFyIF9DT05URVhUX0dST1VQX1RBRyA9ICdjb250ZXh0LWdyb3VwJztcbnZhciBfQ09OVEVYVF9UQUcgPSAnY29udGV4dCc7XG52YXIgWGxpZmYgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhYbGlmZiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBYbGlmZigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VzXG4gICAgICogQHBhcmFtIHs/fSBsb2NhbGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlcywgbG9jYWxlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX1dyaXRlVmlzaXRvcigpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc1VuaXRzID0gW107XG4gICAgICAgIG1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRleHRUYWdzID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGV4dEdyb3VwVGFnID0gbmV3IFRhZyhfQ09OVEVYVF9HUk9VUF9UQUcsIHsgcHVycG9zZTogJ2xvY2F0aW9uJyB9KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0R3JvdXBUYWcuY2hpbGRyZW4ucHVzaChuZXcgQ1IoMTApLCBuZXcgVGFnKF9DT05URVhUX1RBRywgeyAnY29udGV4dC10eXBlJzogJ3NvdXJjZWZpbGUnIH0sIFtuZXcgVGV4dCQyKHNvdXJjZS5maWxlUGF0aCldKSwgbmV3IENSKDEwKSwgbmV3IFRhZyhfQ09OVEVYVF9UQUcsIHsgJ2NvbnRleHQtdHlwZSc6ICdsaW5lbnVtYmVyJyB9LCBbbmV3IFRleHQkMihcIlwiICsgc291cmNlLnN0YXJ0TGluZSldKSwgbmV3IENSKDgpKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0VGFncy5wdXNoKG5ldyBDUig4KSwgY29udGV4dEdyb3VwVGFnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNVbml0ID0gbmV3IFRhZyhfVU5JVF9UQUcsIHsgaWQ6IG1lc3NhZ2UuaWQsIGRhdGF0eXBlOiAnaHRtbCcgfSk7XG4gICAgICAgICAgICAoX2EgPSB0cmFuc1VuaXQuY2hpbGRyZW4pLnB1c2guYXBwbHkoX2EsIFtuZXcgQ1IoOCksIG5ldyBUYWcoX1NPVVJDRV9UQUcsIHt9LCB2aXNpdG9yLnNlcmlhbGl6ZShtZXNzYWdlLm5vZGVzKSksIG5ldyBDUig4KSwgbmV3IFRhZyhfVEFSR0VUX1RBRyldLmNvbmNhdChjb250ZXh0VGFncykpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0cmFuc1VuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoJ25vdGUnLCB7IHByaW9yaXR5OiAnMScsIGZyb206ICdkZXNjcmlwdGlvbicgfSwgW25ldyBUZXh0JDIobWVzc2FnZS5kZXNjcmlwdGlvbildKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tZWFuaW5nKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNVbml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBwcmlvcml0eTogJzEnLCBmcm9tOiAnbWVhbmluZycgfSwgW25ldyBUZXh0JDIobWVzc2FnZS5tZWFuaW5nKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zVW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig2KSk7XG4gICAgICAgICAgICB0cmFuc1VuaXRzLnB1c2gobmV3IENSKDYpLCB0cmFuc1VuaXQpO1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm9keSA9IG5ldyBUYWcoJ2JvZHknLCB7fSwgdHJhbnNVbml0cy5jb25jYXQoW25ldyBDUig0KV0pKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlsZSA9IG5ldyBUYWcoJ2ZpbGUnLCB7XG4gICAgICAgICAgICAnc291cmNlLWxhbmd1YWdlJzogbG9jYWxlIHx8IF9ERUZBVUxUX1NPVVJDRV9MQU5HLFxuICAgICAgICAgICAgZGF0YXR5cGU6ICdwbGFpbnRleHQnLFxuICAgICAgICAgICAgb3JpZ2luYWw6ICduZzIudGVtcGxhdGUnLFxuICAgICAgICB9LCBbbmV3IENSKDQpLCBib2R5LCBuZXcgQ1IoMildKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geGxpZmYgPSBuZXcgVGFnKCd4bGlmZicsIHsgdmVyc2lvbjogX1ZFUlNJT04sIHhtbG5zOiBfWE1MTlMgfSwgW25ldyBDUigyKSwgZmlsZSwgbmV3IENSKCldKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShbXG4gICAgICAgICAgICBuZXcgRGVjbGFyYXRpb24oeyB2ZXJzaW9uOiAnMS4wJywgZW5jb2Rpbmc6ICdVVEYtOCcgfSksIG5ldyBDUigpLCB4bGlmZiwgbmV3IENSKClcbiAgICAgICAgXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY29udGVudCwgdXJsKSB7XG4gICAgICAgIC8vIHhsaWZmIHRvIHhtbCBub2Rlc1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB4bGlmZlBhcnNlciA9IG5ldyBYbGlmZlBhcnNlcigpO1xuICAgICAgICB2YXIgX2EgPSB4bGlmZlBhcnNlci5wYXJzZShjb250ZW50LCB1cmwpLCBsb2NhbGUgPSBfYS5sb2NhbGUsIG1zZ0lkVG9IdG1sID0gX2EubXNnSWRUb0h0bWwsIGVycm9ycyA9IF9hLmVycm9ycztcbiAgICAgICAgLy8geG1sIG5vZGVzIHRvIGkxOG4gbm9kZXNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTE4bk5vZGVzQnlNc2dJZCA9IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb252ZXJ0ZXIgPSBuZXcgWG1sVG9JMThuKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKG1zZ0lkVG9IdG1sKS5mb3JFYWNoKGZ1bmN0aW9uIChtc2dJZCkge1xuICAgICAgICAgICAgdmFyIF9hID0gY29udmVydGVyLmNvbnZlcnQobXNnSWRUb0h0bWxbbXNnSWRdLCB1cmwpLCBpMThuTm9kZXMgPSBfYS5pMThuTm9kZXMsIGUgPSBfYS5lcnJvcnM7XG4gICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGUpO1xuICAgICAgICAgICAgaTE4bk5vZGVzQnlNc2dJZFttc2dJZF0gPSBpMThuTm9kZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieGxpZmYgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsb2NhbGU6IC8qKiBAdHlwZSB7P30gKi8gKChsb2NhbGUpKSwgaTE4bk5vZGVzQnlNc2dJZDogaTE4bk5vZGVzQnlNc2dJZCB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZi5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIGRpZ2VzdChtZXNzYWdlKTsgfTtcbiAgICByZXR1cm4gWGxpZmY7XG59KFNlcmlhbGl6ZXIpKTtcbnZhciBfV3JpdGVWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfV3JpdGVWaXNpdG9yKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gW25ldyBUZXh0JDIodGV4dC52YWx1ZSldOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzID0gW107XG4gICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBub2RlLnZpc2l0KF90aGlzKSk7IH0pO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdVxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlcyA9IFtuZXcgVGV4dCQyKFwie1wiICsgaWN1LmV4cHJlc3Npb25QbGFjZWhvbGRlciArIFwiLCBcIiArIGljdS50eXBlICsgXCIsIFwiKV07XG4gICAgICAgIE9iamVjdC5rZXlzKGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgbm9kZXMucHVzaC5hcHBseShub2RlcywgW25ldyBUZXh0JDIoYyArIFwiIHtcIildLmNvbmNhdChpY3UuY2FzZXNbY10udmlzaXQoX3RoaXMpLCBbbmV3IFRleHQkMihcIn0gXCIpXSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQyKFwifVwiKSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRhZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0eXBlID0gZ2V0Q3R5cGVGb3JUYWcocGgudGFnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRywgeyBpZDogcGguc3RhcnROYW1lLCBjdHlwZTogY3R5cGUgfSk7XG4gICAgICAgIGlmIChwaC5pc1ZvaWQpIHtcbiAgICAgICAgICAgIC8vIHZvaWQgdGFncyBoYXZlIG5vIGNoaWxkcmVuIG5vciBjbG9zaW5nIHRhZ3NcbiAgICAgICAgICAgIHJldHVybiBbc3RhcnRUYWdQaF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xvc2VUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRywgeyBpZDogcGguY2xvc2VOYW1lLCBjdHlwZTogY3R5cGUgfSk7XG4gICAgICAgIHJldHVybiBbc3RhcnRUYWdQaF0uY29uY2F0KHRoaXMuc2VyaWFsaXplKHBoLmNoaWxkcmVuKSwgW2Nsb3NlVGFnUGhdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHLCB7IGlkOiBwaC5uYW1lIH0pXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHLCB7IGlkOiBwaC5uYW1lIH0pXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gX1dyaXRlVmlzaXRvcjtcbn0oKSk7XG52YXIgWGxpZmZQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhsaWZmUGFyc2VyKCkge1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHhsaWZmXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh4bGlmZiwgdXJsKSB7XG4gICAgICAgIHRoaXMuX3VuaXRNbFN0cmluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX21zZ0lkVG9IdG1sID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHhtbCA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZSh4bGlmZiwgdXJsLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IHhtbC5lcnJvcnM7XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIHhtbC5yb290Tm9kZXMsIG51bGwpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbXNnSWRUb0h0bWw6IHRoaXMuX21zZ0lkVG9IdG1sLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLl9lcnJvcnMsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIF9VTklUX1RBRzpcbiAgICAgICAgICAgICAgICB0aGlzLl91bml0TWxTdHJpbmcgPSAoKG51bGwpKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZEF0dHIgPSBlbGVtZW50LmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ2lkJzsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpZEF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCI8XCIgKyBfVU5JVF9UQUcgKyBcIj4gbWlzc2VzIHRoZSBcXFwiaWRcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkID0gaWRBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbXNnSWRUb0h0bWwuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIkR1cGxpY2F0ZWQgdHJhbnNsYXRpb25zIGZvciBtc2cgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5fdW5pdE1sU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21zZ0lkVG9IdG1sW2lkXSA9IHRoaXMuX3VuaXRNbFN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiTWVzc2FnZSBcIiArIGlkICsgXCIgbWlzc2VzIGEgdHJhbnNsYXRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9TT1VSQ0VfVEFHOlxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBzb3VyY2UgbWVzc2FnZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfVEFSR0VUX1RBRzpcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lclRleHRTdGFydCA9ICgoZWxlbWVudC5zdGFydFNvdXJjZVNwYW4pKS5lbmQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyVGV4dEVuZCA9ICgoZWxlbWVudC5lbmRTb3VyY2VTcGFuKSkuc3RhcnQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRlbnQgPSAoKGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuKSkuc3RhcnQuZmlsZS5jb250ZW50O1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyVGV4dCA9IGNvbnRlbnQuc2xpY2UoaW5uZXJUZXh0U3RhcnQsIGlubmVyVGV4dEVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5pdE1sU3RyaW5nID0gaW5uZXJUZXh0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfRklMRV9UQUc6XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG9jYWxlQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAndGFyZ2V0LWxhbmd1YWdlJzsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZUF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFRPRE8odmljYik6IGFzc2VydCBmaWxlIHN0cnVjdHVyZSwgeGxpZmYgdmVyc2lvblxuICAgICAgICAgICAgICAgIC8vIEZvciBub3cgb25seSByZWN1cnNlIG9uIHVuaGFuZGxlZCBub2Rlc1xuICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21tZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cGFuc2lvblxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwYW5zaW9uQ2FzZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcigvKiogQHR5cGUgez99ICovICgobm9kZS5zb3VyY2VTcGFuKSksIG1lc3NhZ2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBYbGlmZlBhcnNlcjtcbn0oKSk7XG52YXIgWG1sVG9JMThuID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYbWxUb0kxOG4oKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAobWVzc2FnZSwgdXJsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHhtbEljdSA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZShtZXNzYWdlLCB1cmwsIHRydWUpO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSB4bWxJY3UuZXJyb3JzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpMThuTm9kZXMgPSB0aGlzLl9lcnJvcnMubGVuZ3RoID4gMCB8fCB4bWxJY3Uucm9vdE5vZGVzLmxlbmd0aCA9PSAwID9cbiAgICAgICAgICAgIFtdIDpcbiAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIHhtbEljdS5yb290Tm9kZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaTE4bk5vZGVzOiBpMThuTm9kZXMsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gbmV3IFRleHQkMSh0ZXh0LnZhbHVlLCAvKiogQHR5cGUgez99ICovICgodGV4dC5zb3VyY2VTcGFuKSkpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChlbC5uYW1lID09PSBfUExBQ0VIT0xERVJfVEFHKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lQXR0ciA9IGVsLmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ2lkJzsgfSk7XG4gICAgICAgICAgICBpZiAobmFtZUF0dHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBsYWNlaG9sZGVyKCcnLCBuYW1lQXR0ci52YWx1ZSwgLyoqIEB0eXBlIHs/fSAqLyAoKGVsLnNvdXJjZVNwYW4pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgXCI8XCIgKyBfUExBQ0VIT0xERVJfVEFHICsgXCI+IG1pc3NlcyB0aGUgXFxcImlkXFxcIiBhdHRyaWJ1dGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgXCJVbmV4cGVjdGVkIHRhZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYXNlTWFwID0ge307XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgY2FzZU1hcFtjLnZhbHVlXSA9IG5ldyBDb250YWluZXIoYy5ub2RlcywgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJY3UoaWN1LnN3aXRjaFZhbHVlLCBpY3UudHlwZSwgY2FzZU1hcCwgaWN1LnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VDYXNlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChpY3VDYXNlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogaWN1Q2FzZS52YWx1ZSxcbiAgICAgICAgICAgIG5vZGVzOiB2aXNpdEFsbCh0aGlzLCBpY3VDYXNlLmV4cHJlc3Npb24pLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21tZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLl9hZGRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3IoLyoqIEB0eXBlIHs/fSAqLyAoKG5vZGUuc291cmNlU3BhbikpLCBtZXNzYWdlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gWG1sVG9JMThuO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB0YWdcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldEN0eXBlRm9yVGFnKHRhZykge1xuICAgIHN3aXRjaCAodGFnLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnYnInOlxuICAgICAgICAgICAgcmV0dXJuICdsYic7XG4gICAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICAgICAgICByZXR1cm4gJ2ltYWdlJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIngtXCIgKyB0YWc7XG4gICAgfVxufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9WRVJTSU9OJDEgPSAnMi4wJztcbnZhciBfWE1MTlMkMSA9ICd1cm46b2FzaXM6bmFtZXM6dGM6eGxpZmY6ZG9jdW1lbnQ6Mi4wJztcbi8vIFRPRE8odmljYik6IG1ha2UgdGhpcyBhIHBhcmFtIChzL18vLS8pXG52YXIgX0RFRkFVTFRfU09VUkNFX0xBTkckMSA9ICdlbic7XG52YXIgX1BMQUNFSE9MREVSX1RBRyQxID0gJ3BoJztcbnZhciBfUExBQ0VIT0xERVJfU1BBTk5JTkdfVEFHID0gJ3BjJztcbnZhciBfWExJRkZfVEFHID0gJ3hsaWZmJztcbnZhciBfU09VUkNFX1RBRyQxID0gJ3NvdXJjZSc7XG52YXIgX1RBUkdFVF9UQUckMSA9ICd0YXJnZXQnO1xudmFyIF9VTklUX1RBRyQxID0gJ3VuaXQnO1xudmFyIFhsaWZmMiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFhsaWZmMiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBYbGlmZjIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlc1xuICAgICAqIEBwYXJhbSB7P30gbG9jYWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZjIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG1lc3NhZ2VzLCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBfV3JpdGVWaXNpdG9yJDEoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdW5pdHMgPSBbXTtcbiAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdW5pdCA9IG5ldyBUYWcoX1VOSVRfVEFHJDEsIHsgaWQ6IG1lc3NhZ2UuaWQgfSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kZXNjcmlwdGlvbiB8fCBtZXNzYWdlLm1lYW5pbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub3RlcyA9IG5ldyBUYWcoJ25vdGVzJyk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbm90ZXMuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoJ25vdGUnLCB7IGNhdGVnb3J5OiAnZGVzY3JpcHRpb24nIH0sIFtuZXcgVGV4dCQyKG1lc3NhZ2UuZGVzY3JpcHRpb24pXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5tZWFuaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGVzLmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBjYXRlZ29yeTogJ21lYW5pbmcnIH0sIFtuZXcgVGV4dCQyKG1lc3NhZ2UubWVhbmluZyldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vdGVzLmNoaWxkcmVuLnB1c2gobmV3IENSKDYpKTtcbiAgICAgICAgICAgICAgICB1bml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDYpLCBub3Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWdtZW50ID0gbmV3IFRhZygnc2VnbWVudCcpO1xuICAgICAgICAgICAgc2VnbWVudC5jaGlsZHJlbi5wdXNoKG5ldyBDUig4KSwgbmV3IFRhZyhfU09VUkNFX1RBRyQxLCB7fSwgdmlzaXRvci5zZXJpYWxpemUobWVzc2FnZS5ub2RlcykpLCBuZXcgQ1IoNikpO1xuICAgICAgICAgICAgdW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig2KSwgc2VnbWVudCwgbmV3IENSKDQpKTtcbiAgICAgICAgICAgIHVuaXRzLnB1c2gobmV3IENSKDQpLCB1bml0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbGUgPSBuZXcgVGFnKCdmaWxlJywgeyAnb3JpZ2luYWwnOiAnbmcudGVtcGxhdGUnLCBpZDogJ25naTE4bicgfSwgdW5pdHMuY29uY2F0KFtuZXcgQ1IoMildKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHhsaWZmID0gbmV3IFRhZyhfWExJRkZfVEFHLCB7IHZlcnNpb246IF9WRVJTSU9OJDEsIHhtbG5zOiBfWE1MTlMkMSwgc3JjTGFuZzogbG9jYWxlIHx8IF9ERUZBVUxUX1NPVVJDRV9MQU5HJDEgfSwgW25ldyBDUigyKSwgZmlsZSwgbmV3IENSKCldKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShbXG4gICAgICAgICAgICBuZXcgRGVjbGFyYXRpb24oeyB2ZXJzaW9uOiAnMS4wJywgZW5jb2Rpbmc6ICdVVEYtOCcgfSksIG5ldyBDUigpLCB4bGlmZiwgbmV3IENSKClcbiAgICAgICAgXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvbnRlbnQsIHVybCkge1xuICAgICAgICAvLyB4bGlmZiB0byB4bWwgbm9kZXNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geGxpZmYyUGFyc2VyID0gbmV3IFhsaWZmMlBhcnNlcigpO1xuICAgICAgICB2YXIgX2EgPSB4bGlmZjJQYXJzZXIucGFyc2UoY29udGVudCwgdXJsKSwgbG9jYWxlID0gX2EubG9jYWxlLCBtc2dJZFRvSHRtbCA9IF9hLm1zZ0lkVG9IdG1sLCBlcnJvcnMgPSBfYS5lcnJvcnM7XG4gICAgICAgIC8vIHhtbCBub2RlcyB0byBpMThuIG5vZGVzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5Ob2Rlc0J5TXNnSWQgPSB7fTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udmVydGVyID0gbmV3IFhtbFRvSTE4biQxKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKG1zZ0lkVG9IdG1sKS5mb3JFYWNoKGZ1bmN0aW9uIChtc2dJZCkge1xuICAgICAgICAgICAgdmFyIF9hID0gY29udmVydGVyLmNvbnZlcnQobXNnSWRUb0h0bWxbbXNnSWRdLCB1cmwpLCBpMThuTm9kZXMgPSBfYS5pMThuTm9kZXMsIGUgPSBfYS5lcnJvcnM7XG4gICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGUpO1xuICAgICAgICAgICAgaTE4bk5vZGVzQnlNc2dJZFttc2dJZF0gPSBpMThuTm9kZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieGxpZmYyIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbG9jYWxlOiAvKiogQHR5cGUgez99ICovICgobG9jYWxlKSksIGkxOG5Ob2Rlc0J5TXNnSWQ6IGkxOG5Ob2Rlc0J5TXNnSWQgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYyLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAobWVzc2FnZSkgeyByZXR1cm4gZGVjaW1hbERpZ2VzdChtZXNzYWdlKTsgfTtcbiAgICByZXR1cm4gWGxpZmYyO1xufShTZXJpYWxpemVyKSk7XG52YXIgX1dyaXRlVmlzaXRvciQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfV3JpdGVWaXNpdG9yJDEoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIFtuZXcgVGV4dCQyKHRleHQudmFsdWUpXTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzID0gW107XG4gICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBub2RlLnZpc2l0KF90aGlzKSk7IH0pO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdVxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzID0gW25ldyBUZXh0JDIoXCJ7XCIgKyBpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyICsgXCIsIFwiICsgaWN1LnR5cGUgKyBcIiwgXCIpXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBbbmV3IFRleHQkMihjICsgXCIge1wiKV0uY29uY2F0KGljdS5jYXNlc1tjXS52aXNpdChfdGhpcyksIFtuZXcgVGV4dCQyKFwifSBcIildKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDIoXCJ9XCIpKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlID0gZ2V0VHlwZUZvclRhZyhwaC50YWcpO1xuICAgICAgICBpZiAocGguaXNWb2lkKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQxLCB7XG4gICAgICAgICAgICAgICAgaWQ6ICh0aGlzLl9uZXh0UGxhY2Vob2xkZXJJZCsrKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGVxdWl2OiBwaC5zdGFydE5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBkaXNwOiBcIjxcIiArIHBoLnRhZyArIFwiLz5cIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFt0YWdQaF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFnUGMgPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9TUEFOTklOR19UQUcsIHtcbiAgICAgICAgICAgIGlkOiAodGhpcy5fbmV4dFBsYWNlaG9sZGVySWQrKykudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGVxdWl2U3RhcnQ6IHBoLnN0YXJ0TmFtZSxcbiAgICAgICAgICAgIGVxdWl2RW5kOiBwaC5jbG9zZU5hbWUsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgZGlzcFN0YXJ0OiBcIjxcIiArIHBoLnRhZyArIFwiPlwiLFxuICAgICAgICAgICAgZGlzcEVuZDogXCI8L1wiICsgcGgudGFnICsgXCI+XCIsXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgcGguY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzKTsgfSkpO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiB0YWdQYy5jaGlsZHJlbi5wdXNoKG5vZGUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhZ1BjLmNoaWxkcmVuLnB1c2gobmV3IFRleHQkMignJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdGFnUGNdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQxLCB7XG4gICAgICAgICAgICAgICAgaWQ6ICh0aGlzLl9uZXh0UGxhY2Vob2xkZXJJZCsrKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGVxdWl2OiBwaC5uYW1lLFxuICAgICAgICAgICAgICAgIGRpc3A6IFwie3tcIiArIHBoLnZhbHVlICsgXCJ9fVwiLFxuICAgICAgICAgICAgfSldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQxLCB7IGlkOiAodGhpcy5fbmV4dFBsYWNlaG9sZGVySWQrKykudG9TdHJpbmcoKSB9KV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfV3JpdGVWaXNpdG9yJDEucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9uZXh0UGxhY2Vob2xkZXJJZCA9IDA7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBfV3JpdGVWaXNpdG9yJDE7XG59KCkpO1xudmFyIFhsaWZmMlBhcnNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWGxpZmYyUGFyc2VyKCkge1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHhsaWZmXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmMlBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoeGxpZmYsIHVybCkge1xuICAgICAgICB0aGlzLl91bml0TWxTdHJpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLl9tc2dJZFRvSHRtbCA9IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB4bWwgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UoeGxpZmYsIHVybCwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSB4bWwuZXJyb3JzO1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCB4bWwucm9vdE5vZGVzLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1zZ0lkVG9IdG1sOiB0aGlzLl9tc2dJZFRvSHRtbCxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmMlBhcnNlci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgc3dpdGNoIChlbGVtZW50Lm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgX1VOSVRfVEFHJDE6XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5pdE1sU3RyaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZEF0dHIgPSBlbGVtZW50LmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ2lkJzsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpZEF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCI8XCIgKyBfVU5JVF9UQUckMSArIFwiPiBtaXNzZXMgdGhlIFxcXCJpZFxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWQgPSBpZEF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tc2dJZFRvSHRtbC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiRHVwbGljYXRlZCB0cmFuc2xhdGlvbnMgZm9yIG1zZyBcIiArIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl91bml0TWxTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWxbaWRdID0gdGhpcy5fdW5pdE1sU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCJNZXNzYWdlIFwiICsgaWQgKyBcIiBtaXNzZXMgYSB0cmFuc2xhdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX1NPVVJDRV9UQUckMTpcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgc291cmNlIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX1RBUkdFVF9UQUckMTpcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lclRleHRTdGFydCA9ICgoZWxlbWVudC5zdGFydFNvdXJjZVNwYW4pKS5lbmQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyVGV4dEVuZCA9ICgoZWxlbWVudC5lbmRTb3VyY2VTcGFuKSkuc3RhcnQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRlbnQgPSAoKGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuKSkuc3RhcnQuZmlsZS5jb250ZW50O1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyVGV4dCA9IGNvbnRlbnQuc2xpY2UoaW5uZXJUZXh0U3RhcnQsIGlubmVyVGV4dEVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5pdE1sU3RyaW5nID0gaW5uZXJUZXh0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfWExJRkZfVEFHOlxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvY2FsZUF0dHIgPSBlbGVtZW50LmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ3RyZ0xhbmcnOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGVBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2ZXJzaW9uQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAndmVyc2lvbic7IH0pO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2ZXJzaW9uID0gdmVyc2lvbkF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uICE9PSAnMi4wJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCJUaGUgWExJRkYgZmlsZSB2ZXJzaW9uIFwiICsgdmVyc2lvbiArIFwiIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggWExJRkYgMi4wIHNlcmlhbGl6ZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZjJQYXJzZXIucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYyUGFyc2VyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYyUGFyc2VyLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwYW5zaW9uXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZjJQYXJzZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwYW5zaW9uQ2FzZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYyUGFyc2VyLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoZXhwYW5zaW9uQ2FzZSwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYyUGFyc2VyLnByb3RvdHlwZS5fYWRkRXJyb3IgPSBmdW5jdGlvbiAobm9kZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbWVzc2FnZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFhsaWZmMlBhcnNlcjtcbn0oKSk7XG52YXIgWG1sVG9JMThuJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhtbFRvSTE4biQxKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuJDEucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAobWVzc2FnZSwgdXJsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHhtbEljdSA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZShtZXNzYWdlLCB1cmwsIHRydWUpO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSB4bWxJY3UuZXJyb3JzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpMThuTm9kZXMgPSB0aGlzLl9lcnJvcnMubGVuZ3RoID4gMCB8fCB4bWxJY3Uucm9vdE5vZGVzLmxlbmd0aCA9PSAwID9cbiAgICAgICAgICAgIFtdIDogW10uY29uY2F0LmFwcGx5KFtdLCB2aXNpdEFsbCh0aGlzLCB4bWxJY3Uucm9vdE5vZGVzKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpMThuTm9kZXM6IGkxOG5Ob2RlcyxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMS5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIG5ldyBUZXh0JDEodGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMS5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHN3aXRjaCAoZWwubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBfUExBQ0VIT0xERVJfVEFHJDE6XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZUF0dHIgPSBlbC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdlcXVpdic7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lQXR0cikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBQbGFjZWhvbGRlcignJywgbmFtZUF0dHIudmFsdWUsIGVsLnNvdXJjZVNwYW4pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIFwiPFwiICsgX1BMQUNFSE9MREVSX1RBRyQxICsgXCI+IG1pc3NlcyB0aGUgXFxcImVxdWl2XFxcIiBhdHRyaWJ1dGVcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9QTEFDRUhPTERFUl9TUEFOTklOR19UQUc6XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRBdHRyID0gZWwuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnZXF1aXZTdGFydCc7IH0pO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZEF0dHIgPSBlbC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdlcXVpdkVuZCc7IH0pO1xuICAgICAgICAgICAgICAgIGlmICghc3RhcnRBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBcIjxcIiArIF9QTEFDRUhPTERFUl9UQUckMSArIFwiPiBtaXNzZXMgdGhlIFxcXCJlcXVpdlN0YXJ0XFxcIiBhdHRyaWJ1dGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFlbmRBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBcIjxcIiArIF9QTEFDRUhPTERFUl9UQUckMSArIFwiPiBtaXNzZXMgdGhlIFxcXCJlcXVpdkVuZFxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRJZCA9IHN0YXJ0QXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kSWQgPSBlbmRBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZXMuY29uY2F0LmFwcGx5KG5vZGVzLCBbbmV3IFBsYWNlaG9sZGVyKCcnLCBzdGFydElkLCBlbC5zb3VyY2VTcGFuKV0uY29uY2F0KGVsLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcywgbnVsbCk7IH0pLCBbbmV3IFBsYWNlaG9sZGVyKCcnLCBlbmRJZCwgZWwuc291cmNlU3BhbildKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgXCJVbmV4cGVjdGVkIHRhZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMS5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhc2VNYXAgPSB7fTtcbiAgICAgICAgdmlzaXRBbGwodGhpcywgaWN1LmNhc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBjYXNlTWFwW2MudmFsdWVdID0gbmV3IENvbnRhaW5lcihjLm5vZGVzLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEljdShpY3Uuc3dpdGNoVmFsdWUsIGljdS50eXBlLCBjYXNlTWFwLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdUNhc2VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4biQxLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoaWN1Q2FzZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGljdUNhc2UudmFsdWUsXG4gICAgICAgICAgICBub2RlczogW10uY29uY2F0LmFwcGx5KFtdLCB2aXNpdEFsbCh0aGlzLCBpY3VDYXNlLmV4cHJlc3Npb24pKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuJDEucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4biQxLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4biQxLnByb3RvdHlwZS5fYWRkRXJyb3IgPSBmdW5jdGlvbiAobm9kZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbWVzc2FnZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFhtbFRvSTE4biQxO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB0YWdcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldFR5cGVGb3JUYWcodGFnKSB7XG4gICAgc3dpdGNoICh0YWcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlICdicic6XG4gICAgICAgIGNhc2UgJ2InOlxuICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICByZXR1cm4gJ2ZtdCc7XG4gICAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICAgICAgICByZXR1cm4gJ2ltYWdlJztcbiAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICByZXR1cm4gJ2xpbmsnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgfVxufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9NRVNTQUdFU19UQUcgPSAnbWVzc2FnZWJ1bmRsZSc7XG52YXIgX01FU1NBR0VfVEFHID0gJ21zZyc7XG52YXIgX1BMQUNFSE9MREVSX1RBRyQyID0gJ3BoJztcbnZhciBfRVhFTVBMRV9UQUcgPSAnZXgnO1xudmFyIF9TT1VSQ0VfVEFHJDIgPSAnc291cmNlJztcbnZhciBfRE9DVFlQRSA9IFwiPCFFTEVNRU5UIG1lc3NhZ2VidW5kbGUgKG1zZykqPlxcbjwhQVRUTElTVCBtZXNzYWdlYnVuZGxlIGNsYXNzIENEQVRBICNJTVBMSUVEPlxcblxcbjwhRUxFTUVOVCBtc2cgKCNQQ0RBVEF8cGh8c291cmNlKSo+XFxuPCFBVFRMSVNUIG1zZyBpZCBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIHNlcSBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIG5hbWUgQ0RBVEEgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyBkZXNjIENEQVRBICNJTVBMSUVEPlxcbjwhQVRUTElTVCBtc2cgbWVhbmluZyBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIG9ic29sZXRlIChvYnNvbGV0ZSkgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyB4bWw6c3BhY2UgKGRlZmF1bHR8cHJlc2VydmUpIFxcXCJkZWZhdWx0XFxcIj5cXG48IUFUVExJU1QgbXNnIGlzX2hpZGRlbiBDREFUQSAjSU1QTElFRD5cXG5cXG48IUVMRU1FTlQgc291cmNlICgjUENEQVRBKT5cXG5cXG48IUVMRU1FTlQgcGggKCNQQ0RBVEF8ZXgpKj5cXG48IUFUVExJU1QgcGggbmFtZSBDREFUQSAjUkVRVUlSRUQ+XFxuXFxuPCFFTEVNRU5UIGV4ICgjUENEQVRBKT5cIjtcbnZhciBYbWIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhYbWIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWG1iKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZXNcbiAgICAgKiBAcGFyYW0gez99IGxvY2FsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1iLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlcywgbG9jYWxlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4YW1wbGVWaXNpdG9yID0gbmV3IEV4YW1wbGVWaXNpdG9yKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX1Zpc2l0b3IkMigpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByb290Tm9kZSA9IG5ldyBUYWcoX01FU1NBR0VTX1RBRyk7XG4gICAgICAgIG1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJzID0geyBpZDogbWVzc2FnZS5pZCB9O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBhdHRyc1snZGVzYyddID0gbWVzc2FnZS5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1lYW5pbmcpIHtcbiAgICAgICAgICAgICAgICBhdHRyc1snbWVhbmluZyddID0gbWVzc2FnZS5tZWFuaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlVGFncyA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZVRhZ3MucHVzaChuZXcgVGFnKF9TT1VSQ0VfVEFHJDIsIHt9LCBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUZXh0JDIoc291cmNlLmZpbGVQYXRoICsgXCI6XCIgKyBzb3VyY2Uuc3RhcnRMaW5lICsgKHNvdXJjZS5lbmRMaW5lICE9PSBzb3VyY2Uuc3RhcnRMaW5lID8gJywnICsgc291cmNlLmVuZExpbmUgOiAnJykpXG4gICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByb290Tm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBDUigyKSwgbmV3IFRhZyhfTUVTU0FHRV9UQUcsIGF0dHJzLCBzb3VyY2VUYWdzLmNvbmNhdCh2aXNpdG9yLnNlcmlhbGl6ZShtZXNzYWdlLm5vZGVzKSkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb3ROb2RlLmNoaWxkcmVuLnB1c2gobmV3IENSKCkpO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplKFtcbiAgICAgICAgICAgIG5ldyBEZWNsYXJhdGlvbih7IHZlcnNpb246ICcxLjAnLCBlbmNvZGluZzogJ1VURi04JyB9KSxcbiAgICAgICAgICAgIG5ldyBDUigpLFxuICAgICAgICAgICAgbmV3IERvY3R5cGUoX01FU1NBR0VTX1RBRywgX0RPQ1RZUEUpLFxuICAgICAgICAgICAgbmV3IENSKCksXG4gICAgICAgICAgICBleGFtcGxlVmlzaXRvci5hZGREZWZhdWx0RXhhbXBsZXMocm9vdE5vZGUpLFxuICAgICAgICAgICAgbmV3IENSKCksXG4gICAgICAgIF0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250ZW50XG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtYi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWIucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBkaWdlc3QkMShtZXNzYWdlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtYi5wcm90b3R5cGUuY3JlYXRlTmFtZU1hcHBlciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIobWVzc2FnZSwgdG9QdWJsaWNOYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBYbWI7XG59KFNlcmlhbGl6ZXIpKTtcbnZhciBfVmlzaXRvciQyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfVmlzaXRvciQyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvciQyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gW25ldyBUZXh0JDIodGV4dC52YWx1ZSldOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvciQyLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXMgPSBbXTtcbiAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGVzLnB1c2guYXBwbHkobm9kZXMsIG5vZGUudmlzaXQoX3RoaXMpKTsgfSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMi5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzID0gW25ldyBUZXh0JDIoXCJ7XCIgKyBpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyICsgXCIsIFwiICsgaWN1LnR5cGUgKyBcIiwgXCIpXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBbbmV3IFRleHQkMihjICsgXCIge1wiKV0uY29uY2F0KGljdS5jYXNlc1tjXS52aXNpdChfdGhpcyksIFtuZXcgVGV4dCQyKFwifSBcIildKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDIoXCJ9XCIpKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yJDIucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRFeCA9IG5ldyBUYWcoX0VYRU1QTEVfVEFHLCB7fSwgW25ldyBUZXh0JDIoXCI8XCIgKyBwaC50YWcgKyBcIj5cIildKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQyLCB7IG5hbWU6IHBoLnN0YXJ0TmFtZSB9LCBbc3RhcnRFeF0pO1xuICAgICAgICBpZiAocGguaXNWb2lkKSB7XG4gICAgICAgICAgICAvLyB2b2lkIHRhZ3MgaGF2ZSBubyBjaGlsZHJlbiBub3IgY2xvc2luZyB0YWdzXG4gICAgICAgICAgICByZXR1cm4gW3N0YXJ0VGFnUGhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsb3NlRXggPSBuZXcgVGFnKF9FWEVNUExFX1RBRywge30sIFtuZXcgVGV4dCQyKFwiPC9cIiArIHBoLnRhZyArIFwiPlwiKV0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbG9zZVRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDIsIHsgbmFtZTogcGguY2xvc2VOYW1lIH0sIFtjbG9zZUV4XSk7XG4gICAgICAgIHJldHVybiBbc3RhcnRUYWdQaF0uY29uY2F0KHRoaXMuc2VyaWFsaXplKHBoLmNoaWxkcmVuKSwgW2Nsb3NlVGFnUGhdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvciQyLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDIsIHsgbmFtZTogcGgubmFtZSB9KV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMi5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQyLCB7IG5hbWU6IHBoLm5hbWUgfSldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2Rlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBfVmlzaXRvciQyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkaWdlc3QkMShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGRlY2ltYWxEaWdlc3QobWVzc2FnZSk7XG59XG52YXIgRXhhbXBsZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4YW1wbGVWaXNpdG9yKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4YW1wbGVWaXNpdG9yLnByb3RvdHlwZS5hZGREZWZhdWx0RXhhbXBsZXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBub2RlLnZpc2l0KHRoaXMpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeGFtcGxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0YWcubmFtZSA9PT0gX1BMQUNFSE9MREVSX1RBRyQyKSB7XG4gICAgICAgICAgICBpZiAoIXRhZy5jaGlsZHJlbiB8fCB0YWcuY2hpbGRyZW4ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleFRleHQgPSBuZXcgVGV4dCQyKHRhZy5hdHRyc1snbmFtZSddIHx8ICcuLi4nKTtcbiAgICAgICAgICAgICAgICB0YWcuY2hpbGRyZW4gPSBbbmV3IFRhZyhfRVhFTVBMRV9UQUcsIHt9LCBbZXhUZXh0XSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhZy5jaGlsZHJlbikge1xuICAgICAgICAgICAgdGFnLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeGFtcGxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlY2xcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4YW1wbGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGRlY2wpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRvY3R5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4YW1wbGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdERvY3R5cGUgPSBmdW5jdGlvbiAoZG9jdHlwZSkgeyB9O1xuICAgIHJldHVybiBFeGFtcGxlVmlzaXRvcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gaW50ZXJuYWxOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0b1B1YmxpY05hbWUoaW50ZXJuYWxOYW1lKSB7XG4gICAgcmV0dXJuIGludGVybmFsTmFtZS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL1teQS1aMC05X10vZywgJ18nKTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfVFJBTlNMQVRJT05TX1RBRyA9ICd0cmFuc2xhdGlvbmJ1bmRsZSc7XG52YXIgX1RSQU5TTEFUSU9OX1RBRyA9ICd0cmFuc2xhdGlvbic7XG52YXIgX1BMQUNFSE9MREVSX1RBRyQzID0gJ3BoJztcbnZhciBYdGIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhYdGIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWHRiKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZXNcbiAgICAgKiBAcGFyYW0gez99IGxvY2FsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWHRiLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlcywgbG9jYWxlKSB7IHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQnKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWHRiLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvbnRlbnQsIHVybCkge1xuICAgICAgICAvLyB4dGIgdG8geG1sIG5vZGVzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHh0YlBhcnNlciA9IG5ldyBYdGJQYXJzZXIoKTtcbiAgICAgICAgdmFyIF9hID0geHRiUGFyc2VyLnBhcnNlKGNvbnRlbnQsIHVybCksIGxvY2FsZSA9IF9hLmxvY2FsZSwgbXNnSWRUb0h0bWwgPSBfYS5tc2dJZFRvSHRtbCwgZXJyb3JzID0gX2EuZXJyb3JzO1xuICAgICAgICAvLyB4bWwgbm9kZXMgdG8gaTE4biBub2Rlc1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpMThuTm9kZXNCeU1zZ0lkID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnZlcnRlciA9IG5ldyBYbWxUb0kxOG4kMigpO1xuICAgICAgICAvLyBCZWNhdXNlIHdlIHNob3VsZCBiZSBhYmxlIHRvIGxvYWQgeHRiIGZpbGVzIHRoYXQgcmVseSBvbiBmZWF0dXJlcyBub3Qgc3VwcG9ydGVkIGJ5IGFuZ3VsYXIsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZGVsYXkgdGhlIGNvbnZlcnNpb24gb2YgaHRtbCB0byBpMThuIG5vZGVzIHNvIHRoYXQgbm9uIGFuZ3VsYXIgbWVzc2FnZXMgYXJlIG5vdFxuICAgICAgICAvLyBjb252ZXJ0ZWRcbiAgICAgICAgT2JqZWN0LmtleXMobXNnSWRUb0h0bWwpLmZvckVhY2goZnVuY3Rpb24gKG1zZ0lkKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZUZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGNvbnZlcnRlci5jb252ZXJ0KG1zZ0lkVG9IdG1sW21zZ0lkXSwgdXJsKSwgaTE4bk5vZGVzID0gX2EuaTE4bk5vZGVzLCBlcnJvcnMgPSBfYS5lcnJvcnM7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieHRiIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpMThuTm9kZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY3JlYXRlTGF6eVByb3BlcnR5KGkxOG5Ob2Rlc0J5TXNnSWQsIG1zZ0lkLCB2YWx1ZUZuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4dGIgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsb2NhbGU6IC8qKiBAdHlwZSB7P30gKi8gKChsb2NhbGUpKSwgaTE4bk5vZGVzQnlNc2dJZDogaTE4bk5vZGVzQnlNc2dJZCB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGIucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBkaWdlc3QkMShtZXNzYWdlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFh0Yi5wcm90b3R5cGUuY3JlYXRlTmFtZU1hcHBlciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIobWVzc2FnZSwgdG9QdWJsaWNOYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBYdGI7XG59KFNlcmlhbGl6ZXIpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBtZXNzYWdlc1xuICogQHBhcmFtIHs/fSBpZFxuICogQHBhcmFtIHs/fSB2YWx1ZUZuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVMYXp5UHJvcGVydHkobWVzc2FnZXMsIGlkLCB2YWx1ZUZuKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lc3NhZ2VzLCBpZCwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB2YWx1ZUZuKCk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWVzc2FnZXMsIGlkLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoXykgeyB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBvdmVyd3JpdGUgYW4gWFRCIHRyYW5zbGF0aW9uJyk7IH0sXG4gICAgfSk7XG59XG52YXIgWHRiUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYdGJQYXJzZXIoKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30geHRiXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoeHRiLCB1cmwpIHtcbiAgICAgICAgdGhpcy5fYnVuZGxlRGVwdGggPSAwO1xuICAgICAgICB0aGlzLl9tc2dJZFRvSHRtbCA9IHt9O1xuICAgICAgICAvLyBXZSBjYW4gbm90IHBhcnNlIHRoZSBJQ1UgbWVzc2FnZXMgYXQgdGhpcyBwb2ludCBhcyBzb21lIG1lc3NhZ2VzIG1pZ2h0IG5vdCBvcmlnaW5hdGVcbiAgICAgICAgLy8gZnJvbSBBbmd1bGFyIHRoYXQgY291bGQgbm90IGJlIGxleCdkLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB4bWwgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UoeHRiLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sLmVycm9ycztcbiAgICAgICAgdmlzaXRBbGwodGhpcywgeG1sLnJvb3ROb2Rlcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtc2dJZFRvSHRtbDogdGhpcy5fbXNnSWRUb0h0bWwsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycyxcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIF9UUkFOU0xBVElPTlNfVEFHOlxuICAgICAgICAgICAgICAgIHRoaXMuX2J1bmRsZURlcHRoKys7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2J1bmRsZURlcHRoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9UUkFOU0xBVElPTlNfVEFHICsgXCI+IGVsZW1lbnRzIGNhbiBub3QgYmUgbmVzdGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYW5nQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnbGFuZyc7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChsYW5nQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBsYW5nQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVuZGxlRGVwdGgtLTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX1RSQU5TTEFUSU9OX1RBRzpcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZEF0dHIgPSBlbGVtZW50LmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ2lkJzsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpZEF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCI8XCIgKyBfVFJBTlNMQVRJT05fVEFHICsgXCI+IG1pc3NlcyB0aGUgXFxcImlkXFxcIiBhdHRyaWJ1dGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9IGlkQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21zZ0lkVG9IdG1sLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCJEdXBsaWNhdGVkIHRyYW5zbGF0aW9ucyBmb3IgbXNnIFwiICsgaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJUZXh0U3RhcnQgPSAoKGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuKSkuZW5kLm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlubmVyVGV4dEVuZCA9ICgoZWxlbWVudC5lbmRTb3VyY2VTcGFuKSkuc3RhcnQub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGVudCA9ICgoZWxlbWVudC5zdGFydFNvdXJjZVNwYW4pKS5zdGFydC5maWxlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lclRleHQgPSBjb250ZW50LnNsaWNlKC8qKiBAdHlwZSB7P30gKi8gKChpbm5lclRleHRTdGFydCkpLCAvKiogQHR5cGUgez99ICovICgoaW5uZXJUZXh0RW5kKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWxbaWRdID0gaW5uZXJUZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCAnVW5leHBlY3RlZCB0YWcnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21tZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHBhbnNpb25cbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoZXhwYW5zaW9uLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHBhbnNpb25DYXNlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLl9hZGRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3IoLyoqIEB0eXBlIHs/fSAqLyAoKG5vZGUuc291cmNlU3BhbikpLCBtZXNzYWdlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gWHRiUGFyc2VyO1xufSgpKTtcbnZhciBYbWxUb0kxOG4kMiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWG1sVG9JMThuJDIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMi5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uIChtZXNzYWdlLCB1cmwpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geG1sSWN1ID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKG1lc3NhZ2UsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IHhtbEljdS5lcnJvcnM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5Ob2RlcyA9IHRoaXMuX2Vycm9ycy5sZW5ndGggPiAwIHx8IHhtbEljdS5yb290Tm9kZXMubGVuZ3RoID09IDAgP1xuICAgICAgICAgICAgW10gOlxuICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgeG1sSWN1LnJvb3ROb2Rlcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpMThuTm9kZXM6IGkxOG5Ob2RlcyxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMi5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIG5ldyBUZXh0JDEodGV4dC52YWx1ZSwgLyoqIEB0eXBlIHs/fSAqLyAoKHRleHQuc291cmNlU3BhbikpKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuJDIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYXNlTWFwID0ge307XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgY2FzZU1hcFtjLnZhbHVlXSA9IG5ldyBDb250YWluZXIoYy5ub2RlcywgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJY3UoaWN1LnN3aXRjaFZhbHVlLCBpY3UudHlwZSwgY2FzZU1hcCwgaWN1LnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VDYXNlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMi5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBpY3VDYXNlLnZhbHVlLFxuICAgICAgICAgICAgbm9kZXM6IHZpc2l0QWxsKHRoaXMsIGljdUNhc2UuZXhwcmVzc2lvbiksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMi5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChlbC5uYW1lID09PSBfUExBQ0VIT0xERVJfVEFHJDMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVBdHRyID0gZWwuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnbmFtZSc7IH0pO1xuICAgICAgICAgICAgaWYgKG5hbWVBdHRyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQbGFjZWhvbGRlcignJywgbmFtZUF0dHIudmFsdWUsIC8qKiBAdHlwZSB7P30gKi8gKChlbC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIFwiPFwiICsgX1BMQUNFSE9MREVSX1RBRyQzICsgXCI+IG1pc3NlcyB0aGUgXFxcIm5hbWVcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBcIlVuZXhwZWN0ZWQgdGFnXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21tZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMi5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuJDIucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuJDIucHJvdG90eXBlLl9hZGRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3IoLyoqIEB0eXBlIHs/fSAqLyAoKG5vZGUuc291cmNlU3BhbikpLCBtZXNzYWdlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gWG1sVG9JMThuJDI7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEh0bWxQYXJzZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIdG1sUGFyc2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEh0bWxQYXJzZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBnZXRIdG1sVGFnRGVmaW5pdGlvbikgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7Pz19IHBhcnNlRXhwYW5zaW9uRm9ybXNcbiAgICAgKiBAcGFyYW0gez89fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBIdG1sUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICBpZiAocGFyc2VFeHBhbnNpb25Gb3JtcyA9PT0gdm9pZCAwKSB7IHBhcnNlRXhwYW5zaW9uRm9ybXMgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnBhcnNlLmNhbGwodGhpcywgc291cmNlLCB1cmwsIHBhcnNlRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgIH07XG4gICAgcmV0dXJuIEh0bWxQYXJzZXI7XG59KFBhcnNlciQxKSk7XG5IdG1sUGFyc2VyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkh0bWxQYXJzZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSBjb250YWluZXIgZm9yIHRyYW5zbGF0ZWQgbWVzc2FnZXNcbiAqL1xudmFyIFRyYW5zbGF0aW9uQnVuZGxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBfaTE4bk5vZGVzQnlNc2dJZFxuICAgICAqIEBwYXJhbSB7Pz19IGxvY2FsZVxuICAgICAqIEBwYXJhbSB7Pz19IGRpZ2VzdFxuICAgICAqIEBwYXJhbSB7Pz19IG1hcHBlckZhY3RvcnlcbiAgICAgKiBAcGFyYW0gez89fSBtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnNvbGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmFuc2xhdGlvbkJ1bmRsZShfaTE4bk5vZGVzQnlNc2dJZCwgbG9jYWxlLCBkaWdlc3QsIG1hcHBlckZhY3RvcnksIG1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5LCBjb25zb2xlKSB7XG4gICAgICAgIGlmIChfaTE4bk5vZGVzQnlNc2dJZCA9PT0gdm9pZCAwKSB7IF9pMThuTm9kZXNCeU1zZ0lkID0ge307IH1cbiAgICAgICAgaWYgKG1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5ID09PSB2b2lkIDApIHsgbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgPSBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneS5XYXJuaW5nOyB9XG4gICAgICAgIHRoaXMuX2kxOG5Ob2Rlc0J5TXNnSWQgPSBfaTE4bk5vZGVzQnlNc2dJZDtcbiAgICAgICAgdGhpcy5kaWdlc3QgPSBkaWdlc3Q7XG4gICAgICAgIHRoaXMubWFwcGVyRmFjdG9yeSA9IG1hcHBlckZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX2kxOG5Ub0h0bWwgPSBuZXcgSTE4blRvSHRtbFZpc2l0b3IoX2kxOG5Ob2Rlc0J5TXNnSWQsIGxvY2FsZSwgZGlnZXN0LCBtYXBwZXJGYWN0b3J5LCBtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSwgY29uc29sZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/fSBzZXJpYWxpemVyXG4gICAgICogQHBhcmFtIHs/fSBtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnNvbGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zbGF0aW9uQnVuZGxlLmxvYWQgPSBmdW5jdGlvbiAoY29udGVudCwgdXJsLCBzZXJpYWxpemVyLCBtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSwgY29uc29sZSkge1xuICAgICAgICB2YXIgX2EgPSBzZXJpYWxpemVyLmxvYWQoY29udGVudCwgdXJsKSwgbG9jYWxlID0gX2EubG9jYWxlLCBpMThuTm9kZXNCeU1zZ0lkID0gX2EuaTE4bk5vZGVzQnlNc2dJZDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlnZXN0Rm4gPSBmdW5jdGlvbiAobSkgeyByZXR1cm4gc2VyaWFsaXplci5kaWdlc3QobSk7IH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcHBlckZhY3RvcnkgPSBmdW5jdGlvbiAobSkgeyByZXR1cm4gKChzZXJpYWxpemVyLmNyZWF0ZU5hbWVNYXBwZXIobSkpKTsgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2xhdGlvbkJ1bmRsZShpMThuTm9kZXNCeU1zZ0lkLCBsb2NhbGUsIGRpZ2VzdEZuLCBtYXBwZXJGYWN0b3J5LCBtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSwgY29uc29sZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNyY01zZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNsYXRpb25CdW5kbGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChzcmNNc2cpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaHRtbCA9IHRoaXMuX2kxOG5Ub0h0bWwuY29udmVydChzcmNNc2cpO1xuICAgICAgICBpZiAoaHRtbC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaHRtbC5lcnJvcnMuam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBodG1sLm5vZGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcmNNc2dcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zbGF0aW9uQnVuZGxlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoc3JjTXNnKSB7IHJldHVybiB0aGlzLmRpZ2VzdChzcmNNc2cpIGluIHRoaXMuX2kxOG5Ob2Rlc0J5TXNnSWQ7IH07XG4gICAgcmV0dXJuIFRyYW5zbGF0aW9uQnVuZGxlO1xufSgpKTtcbnZhciBJMThuVG9IdG1sVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX2kxOG5Ob2Rlc0J5TXNnSWRcbiAgICAgKiBAcGFyYW0gez89fSBfbG9jYWxlXG4gICAgICogQHBhcmFtIHs/PX0gX2RpZ2VzdFxuICAgICAqIEBwYXJhbSB7Pz19IF9tYXBwZXJGYWN0b3J5XG4gICAgICogQHBhcmFtIHs/PX0gX21pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5XG4gICAgICogQHBhcmFtIHs/PX0gX2NvbnNvbGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJMThuVG9IdG1sVmlzaXRvcihfaTE4bk5vZGVzQnlNc2dJZCwgX2xvY2FsZSwgX2RpZ2VzdCwgX21hcHBlckZhY3RvcnksIF9taXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSwgX2NvbnNvbGUpIHtcbiAgICAgICAgaWYgKF9pMThuTm9kZXNCeU1zZ0lkID09PSB2b2lkIDApIHsgX2kxOG5Ob2Rlc0J5TXNnSWQgPSB7fTsgfVxuICAgICAgICB0aGlzLl9pMThuTm9kZXNCeU1zZ0lkID0gX2kxOG5Ob2Rlc0J5TXNnSWQ7XG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IF9sb2NhbGU7XG4gICAgICAgIHRoaXMuX2RpZ2VzdCA9IF9kaWdlc3Q7XG4gICAgICAgIHRoaXMuX21hcHBlckZhY3RvcnkgPSBfbWFwcGVyRmFjdG9yeTtcbiAgICAgICAgdGhpcy5fbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgPSBfbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3k7XG4gICAgICAgIHRoaXMuX2NvbnNvbGUgPSBfY29uc29sZTtcbiAgICAgICAgdGhpcy5fY29udGV4dFN0YWNrID0gW107XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNyY01zZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSTE4blRvSHRtbFZpc2l0b3IucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoc3JjTXNnKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHRTdGFjay5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9lcnJvcnMubGVuZ3RoID0gMDtcbiAgICAgICAgLy8gaTE4biB0byB0ZXh0XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRleHQgPSB0aGlzLl9jb252ZXJ0VG9UZXh0KHNyY01zZyk7XG4gICAgICAgIC8vIHRleHQgdG8gaHRtbFxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cmwgPSBzcmNNc2cubm9kZXNbMF0uc291cmNlU3Bhbi5zdGFydC5maWxlLnVybDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaHRtbCA9IG5ldyBIdG1sUGFyc2VyKCkucGFyc2UodGV4dCwgdXJsLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGVzOiBodG1sLnJvb3ROb2RlcyxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLmNvbmNhdChodG1sLmVycm9ycyksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIHRleHQudmFsdWU7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBjb250YWluZXIuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnZpc2l0KF90aGlzKTsgfSkuam9pbignJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdVxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEkxOG5Ub0h0bWxWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2FzZXMgPSBPYmplY3Qua2V5cyhpY3UuY2FzZXMpLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gayArIFwiIHtcIiArIGljdS5jYXNlc1trXS52aXNpdChfdGhpcykgKyBcIn1cIjsgfSk7XG4gICAgICAgIC8vIFRPRE8odmljYik6IE9uY2UgYWxsIGZvcm1hdCBzd2l0Y2ggdG8gdXNpbmcgZXhwcmVzc2lvbiBwbGFjZWhvbGRlcnNcbiAgICAgICAgLy8gd2Ugc2hvdWxkIHRocm93IHdoZW4gdGhlIHBsYWNlaG9sZGVyIGlzIG5vdCBpbiB0aGUgc291cmNlIG1lc3NhZ2VcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwID0gdGhpcy5fc3JjTXNnLnBsYWNlaG9sZGVycy5oYXNPd25Qcm9wZXJ0eShpY3UuZXhwcmVzc2lvbikgP1xuICAgICAgICAgICAgdGhpcy5fc3JjTXNnLnBsYWNlaG9sZGVyc1tpY3UuZXhwcmVzc2lvbl0gOlxuICAgICAgICAgICAgaWN1LmV4cHJlc3Npb247XG4gICAgICAgIHJldHVybiBcIntcIiArIGV4cCArIFwiLCBcIiArIGljdS50eXBlICsgXCIsIFwiICsgY2FzZXMuam9pbignICcpICsgXCJ9XCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSTE4blRvSHRtbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGhOYW1lID0gdGhpcy5fbWFwcGVyKHBoLm5hbWUpO1xuICAgICAgICBpZiAodGhpcy5fc3JjTXNnLnBsYWNlaG9sZGVycy5oYXNPd25Qcm9wZXJ0eShwaE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3JjTXNnLnBsYWNlaG9sZGVyc1twaE5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zcmNNc2cucGxhY2Vob2xkZXJUb01lc3NhZ2UuaGFzT3duUHJvcGVydHkocGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRUb1RleHQodGhpcy5fc3JjTXNnLnBsYWNlaG9sZGVyVG9NZXNzYWdlW3BoTmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZEVycm9yKHBoLCBcIlVua25vd24gcGxhY2Vob2xkZXIgXFxcIlwiICsgcGgubmFtZSArIFwiXFxcIlwiKTtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEkxOG5Ub0h0bWxWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRhZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhZyA9IFwiXCIgKyBwaC50YWc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJzID0gT2JqZWN0LmtleXMocGguYXR0cnMpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmFtZSArIFwiPVxcXCJcIiArIHBoLmF0dHJzW25hbWVdICsgXCJcXFwiXCI7IH0pLmpvaW4oJyAnKTtcbiAgICAgICAgaWYgKHBoLmlzVm9pZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiPFwiICsgdGFnICsgXCIgXCIgKyBhdHRycyArIFwiLz5cIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZHJlbiA9IHBoLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy52aXNpdChfdGhpcyk7IH0pLmpvaW4oJycpO1xuICAgICAgICByZXR1cm4gXCI8XCIgKyB0YWcgKyBcIiBcIiArIGF0dHJzICsgXCI+XCIgKyBjaGlsZHJlbiArIFwiPC9cIiArIHRhZyArIFwiPlwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEkxOG5Ub0h0bWxWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIEFuIElDVSBwbGFjZWhvbGRlciByZWZlcmVuY2VzIHRoZSBzb3VyY2UgbWVzc2FnZSB0byBiZSBzZXJpYWxpemVkXG4gICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0VG9UZXh0KHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlclRvTWVzc2FnZVtwaC5uYW1lXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgc291cmNlIG1lc3NhZ2UgdG8gYSB0cmFuc2xhdGVkIHRleHQgc3RyaW5nOlxuICAgICAqIC0gdGV4dCBub2RlcyBhcmUgcmVwbGFjZWQgd2l0aCB0aGVpciB0cmFuc2xhdGlvbixcbiAgICAgKiAtIHBsYWNlaG9sZGVycyBhcmUgcmVwbGFjZWQgd2l0aCB0aGVpciBjb250ZW50LFxuICAgICAqIC0gSUNVIG5vZGVzIGFyZSBjb252ZXJ0ZWQgdG8gSUNVIGV4cHJlc3Npb25zLlxuICAgICAqIEBwYXJhbSB7P30gc3JjTXNnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUuX2NvbnZlcnRUb1RleHQgPSBmdW5jdGlvbiAoc3JjTXNnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkID0gdGhpcy5fZGlnZXN0KHNyY01zZyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcHBlciA9IHRoaXMuX21hcHBlckZhY3RvcnkgPyB0aGlzLl9tYXBwZXJGYWN0b3J5KHNyY01zZykgOiBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlcztcbiAgICAgICAgdGhpcy5fY29udGV4dFN0YWNrLnB1c2goeyBtc2c6IHRoaXMuX3NyY01zZywgbWFwcGVyOiB0aGlzLl9tYXBwZXIgfSk7XG4gICAgICAgIHRoaXMuX3NyY01zZyA9IHNyY01zZztcbiAgICAgICAgaWYgKHRoaXMuX2kxOG5Ob2Rlc0J5TXNnSWQuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZXJlIGlzIGEgdHJhbnNsYXRpb24gdXNlIGl0cyBub2RlcyBhcyB0aGUgc291cmNlXG4gICAgICAgICAgICAvLyBBbmQgY3JlYXRlIGEgbWFwcGVyIHRvIGNvbnZlcnQgc2VyaWFsaXplZCBwbGFjZWhvbGRlciBuYW1lcyB0byBpbnRlcm5hbCBuYW1lc1xuICAgICAgICAgICAgbm9kZXMgPSB0aGlzLl9pMThuTm9kZXNCeU1zZ0lkW2lkXTtcbiAgICAgICAgICAgIHRoaXMuX21hcHBlciA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXBwZXIgPyAoKG1hcHBlci50b0ludGVybmFsTmFtZShuYW1lKSkpIDogbmFtZTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdoZW4gbm8gdHJhbnNsYXRpb24gaGFzIGJlZW4gZm91bmRcbiAgICAgICAgICAgIC8vIC0gcmVwb3J0IGFuIGVycm9yIC8gYSB3YXJuaW5nIC8gbm90aGluZyxcbiAgICAgICAgICAgIC8vIC0gdXNlIHRoZSBub2RlcyBmcm9tIHRoZSBvcmlnaW5hbCBtZXNzYWdlXG4gICAgICAgICAgICAvLyAtIHBsYWNlaG9sZGVycyBhcmUgYWxyZWFkeSBpbnRlcm5hbCBhbmQgbmVlZCBubyBtYXBwZXJcbiAgICAgICAgICAgIGlmICh0aGlzLl9taXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSA9PT0gTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kuRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHggPSB0aGlzLl9sb2NhbGUgPyBcIiBmb3IgbG9jYWxlIFxcXCJcIiArIHRoaXMuX2xvY2FsZSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3Ioc3JjTXNnLm5vZGVzWzBdLCBcIk1pc3NpbmcgdHJhbnNsYXRpb24gZm9yIG1lc3NhZ2UgXFxcIlwiICsgaWQgKyBcIlxcXCJcIiArIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9jb25zb2xlICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgPT09IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5Lldhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHggPSB0aGlzLl9sb2NhbGUgPyBcIiBmb3IgbG9jYWxlIFxcXCJcIiArIHRoaXMuX2xvY2FsZSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc29sZS53YXJuKFwiTWlzc2luZyB0cmFuc2xhdGlvbiBmb3IgbWVzc2FnZSBcXFwiXCIgKyBpZCArIFwiXFxcIlwiICsgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVzID0gc3JjTXNnLm5vZGVzO1xuICAgICAgICAgICAgdGhpcy5fbWFwcGVyID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWU7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGV4dCA9IG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pLmpvaW4oJycpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZXh0ID0gKCh0aGlzLl9jb250ZXh0U3RhY2sucG9wKCkpKTtcbiAgICAgICAgdGhpcy5fc3JjTXNnID0gY29udGV4dC5tc2c7XG4gICAgICAgIHRoaXMuX21hcHBlciA9IGNvbnRleHQubWFwcGVyO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgKiBAcGFyYW0gez99IG1zZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSTE4blRvSHRtbFZpc2l0b3IucHJvdG90eXBlLl9hZGRFcnJvciA9IGZ1bmN0aW9uIChlbCwgbXNnKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3IoZWwuc291cmNlU3BhbiwgbXNnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gSTE4blRvSHRtbFZpc2l0b3I7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEkxOE5IdG1sUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9odG1sUGFyc2VyXG4gICAgICogQHBhcmFtIHs/PX0gdHJhbnNsYXRpb25zXG4gICAgICogQHBhcmFtIHs/PX0gdHJhbnNsYXRpb25zRm9ybWF0XG4gICAgICogQHBhcmFtIHs/PX0gbWlzc2luZ1RyYW5zbGF0aW9uXG4gICAgICogQHBhcmFtIHs/PX0gY29uc29sZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEkxOE5IdG1sUGFyc2VyKF9odG1sUGFyc2VyLCB0cmFuc2xhdGlvbnMsIHRyYW5zbGF0aW9uc0Zvcm1hdCwgbWlzc2luZ1RyYW5zbGF0aW9uLCBjb25zb2xlKSB7XG4gICAgICAgIGlmIChtaXNzaW5nVHJhbnNsYXRpb24gPT09IHZvaWQgMCkgeyBtaXNzaW5nVHJhbnNsYXRpb24gPSBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneS5XYXJuaW5nOyB9XG4gICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgaWYgKHRyYW5zbGF0aW9ucykge1xuICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZXIgPSBjcmVhdGVTZXJpYWxpemVyKHRyYW5zbGF0aW9uc0Zvcm1hdCk7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2xhdGlvbkJ1bmRsZSA9XG4gICAgICAgICAgICAgICAgVHJhbnNsYXRpb25CdW5kbGUubG9hZCh0cmFuc2xhdGlvbnMsICdpMThuJywgc2VyaWFsaXplciwgbWlzc2luZ1RyYW5zbGF0aW9uLCBjb25zb2xlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gcGFyc2VFeHBhbnNpb25Gb3Jtc1xuICAgICAqIEBwYXJhbSB7Pz19IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEkxOE5IdG1sUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICBpZiAocGFyc2VFeHBhbnNpb25Gb3JtcyA9PT0gdm9pZCAwKSB7IHBhcnNlRXhwYW5zaW9uRm9ybXMgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnNlUmVzdWx0ID0gdGhpcy5faHRtbFBhcnNlci5wYXJzZShzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNsYXRpb25CdW5kbGUpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBlbmFibGUgaTE4biB3aGVuIG5vIHRyYW5zbGF0aW9uIGJ1bmRsZSBpcyBwcm92aWRlZFxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZVJlc3VsdC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdChwYXJzZVJlc3VsdC5yb290Tm9kZXMsIHBhcnNlUmVzdWx0LmVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlVHJhbnNsYXRpb25zKHBhcnNlUmVzdWx0LnJvb3ROb2RlcywgdGhpcy5fdHJhbnNsYXRpb25CdW5kbGUsIGludGVycG9sYXRpb25Db25maWcsIFtdLCB7fSk7XG4gICAgfTtcbiAgICByZXR1cm4gSTE4Tkh0bWxQYXJzZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez89fSBmb3JtYXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6ZXIoZm9ybWF0KSB7XG4gICAgZm9ybWF0ID0gKGZvcm1hdCB8fCAneGxmJykudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICBjYXNlICd4bWInOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBYbWIoKTtcbiAgICAgICAgY2FzZSAneHRiJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgWHRiKCk7XG4gICAgICAgIGNhc2UgJ3hsaWZmMic6XG4gICAgICAgIGNhc2UgJ3hsZjInOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBYbGlmZjIoKTtcbiAgICAgICAgY2FzZSAneGxpZmYnOlxuICAgICAgICBjYXNlICd4bGYnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBYbGlmZigpO1xuICAgIH1cbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBDT1JFID0gYXNzZXRVcmwoJ2NvcmUnKTtcbnZhciBJZGVudGlmaWVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSWRlbnRpZmllcnMoKSB7XG4gICAgfVxuICAgIHJldHVybiBJZGVudGlmaWVycztcbn0oKSk7XG5JZGVudGlmaWVycy5BTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTID0ge1xuICAgIG5hbWU6ICdBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTJyxcbiAgICBtb2R1bGVVcmw6IENPUkUsXG4gICAgcnVudGltZTogQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UU1xufTtcbklkZW50aWZpZXJzLkVsZW1lbnRSZWYgPSB7IG5hbWU6ICdFbGVtZW50UmVmJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiBFbGVtZW50UmVmIH07XG5JZGVudGlmaWVycy5OZ01vZHVsZVJlZiA9IHsgbmFtZTogJ05nTW9kdWxlUmVmJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiBOZ01vZHVsZVJlZiB9O1xuSWRlbnRpZmllcnMuVmlld0NvbnRhaW5lclJlZiA9IHsgbmFtZTogJ1ZpZXdDb250YWluZXJSZWYnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IFZpZXdDb250YWluZXJSZWYgfTtcbklkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yUmVmID0geyBuYW1lOiAnQ2hhbmdlRGV0ZWN0b3JSZWYnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IENoYW5nZURldGVjdG9yUmVmIH07XG5JZGVudGlmaWVycy5RdWVyeUxpc3QgPSB7IG5hbWU6ICdRdWVyeUxpc3QnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IFF1ZXJ5TGlzdCB9O1xuSWRlbnRpZmllcnMuVGVtcGxhdGVSZWYgPSB7IG5hbWU6ICdUZW1wbGF0ZVJlZicsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogVGVtcGxhdGVSZWYgfTtcbklkZW50aWZpZXJzLkNvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSB7XG4gICAgbmFtZTogJ8m1Q29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcicsXG4gICAgbW9kdWxlVXJsOiBDT1JFLFxuICAgIHJ1bnRpbWU6IMm1Q29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlclxufTtcbklkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IHtcbiAgICBuYW1lOiAnQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyJyxcbiAgICBtb2R1bGVVcmw6IENPUkUsXG4gICAgcnVudGltZTogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG59O1xuSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeSA9IHsgbmFtZTogJ0NvbXBvbmVudEZhY3RvcnknLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IENvbXBvbmVudEZhY3RvcnkgfTtcbklkZW50aWZpZXJzLkNvbXBvbmVudFJlZiA9IHsgbmFtZTogJ0NvbXBvbmVudFJlZicsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogQ29tcG9uZW50UmVmIH07XG5JZGVudGlmaWVycy5OZ01vZHVsZUZhY3RvcnkgPSB7IG5hbWU6ICdOZ01vZHVsZUZhY3RvcnknLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IE5nTW9kdWxlRmFjdG9yeSB9O1xuSWRlbnRpZmllcnMuTmdNb2R1bGVJbmplY3RvciA9IHtcbiAgICBuYW1lOiAnybVOZ01vZHVsZUluamVjdG9yJyxcbiAgICBtb2R1bGVVcmw6IENPUkUsXG4gICAgcnVudGltZTogybVOZ01vZHVsZUluamVjdG9yLFxufTtcbklkZW50aWZpZXJzLlJlZ2lzdGVyTW9kdWxlRmFjdG9yeUZuID0ge1xuICAgIG5hbWU6ICfJtXJlZ2lzdGVyTW9kdWxlRmFjdG9yeScsXG4gICAgbW9kdWxlVXJsOiBDT1JFLFxuICAgIHJ1bnRpbWU6IMm1cmVnaXN0ZXJNb2R1bGVGYWN0b3J5LFxufTtcbklkZW50aWZpZXJzLkluamVjdG9yID0geyBuYW1lOiAnSW5qZWN0b3InLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IEluamVjdG9yIH07XG5JZGVudGlmaWVycy5WaWV3RW5jYXBzdWxhdGlvbiA9IHsgbmFtZTogJ1ZpZXdFbmNhcHN1bGF0aW9uJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiBWaWV3RW5jYXBzdWxhdGlvbiB9O1xuSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSB7XG4gICAgbmFtZTogJ0NoYW5nZURldGVjdGlvblN0cmF0ZWd5JyxcbiAgICBtb2R1bGVVcmw6IENPUkUsXG4gICAgcnVudGltZTogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lcbn07XG5JZGVudGlmaWVycy5TZWN1cml0eUNvbnRleHQgPSB7XG4gICAgbmFtZTogJ1NlY3VyaXR5Q29udGV4dCcsXG4gICAgbW9kdWxlVXJsOiBDT1JFLFxuICAgIHJ1bnRpbWU6IFNlY3VyaXR5Q29udGV4dCxcbn07XG5JZGVudGlmaWVycy5MT0NBTEVfSUQgPSB7IG5hbWU6ICdMT0NBTEVfSUQnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IExPQ0FMRV9JRCB9O1xuSWRlbnRpZmllcnMuVFJBTlNMQVRJT05TX0ZPUk1BVCA9IHsgbmFtZTogJ1RSQU5TTEFUSU9OU19GT1JNQVQnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IFRSQU5TTEFUSU9OU19GT1JNQVQgfTtcbklkZW50aWZpZXJzLmlubGluZUludGVycG9sYXRlID0geyBuYW1lOiAnybVpbmxpbmVJbnRlcnBvbGF0ZScsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogybVpbmxpbmVJbnRlcnBvbGF0ZSB9O1xuSWRlbnRpZmllcnMuaW50ZXJwb2xhdGUgPSB7IG5hbWU6ICfJtWludGVycG9sYXRlJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtWludGVycG9sYXRlIH07XG5JZGVudGlmaWVycy5FTVBUWV9BUlJBWSA9IHsgbmFtZTogJ8m1RU1QVFlfQVJSQVknLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IMm1RU1QVFlfQVJSQVkgfTtcbklkZW50aWZpZXJzLkVNUFRZX01BUCA9IHsgbmFtZTogJ8m1RU1QVFlfTUFQJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtUVNUFRZX01BUCB9O1xuSWRlbnRpZmllcnMuUmVuZGVyZXIgPSB7IG5hbWU6ICdSZW5kZXJlcicsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogUmVuZGVyZXIgfTtcbklkZW50aWZpZXJzLnZpZXdEZWYgPSB7IG5hbWU6ICfJtXZpZCcsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogybV2aWQgfTtcbklkZW50aWZpZXJzLmVsZW1lbnREZWYgPSB7IG5hbWU6ICfJtWVsZCcsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogybVlbGQgfTtcbklkZW50aWZpZXJzLmFuY2hvckRlZiA9IHsgbmFtZTogJ8m1YW5kJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtWFuZCB9O1xuSWRlbnRpZmllcnMudGV4dERlZiA9IHsgbmFtZTogJ8m1dGVkJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtXRlZCB9O1xuSWRlbnRpZmllcnMuZGlyZWN0aXZlRGVmID0geyBuYW1lOiAnybVkaWQnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IMm1ZGlkIH07XG5JZGVudGlmaWVycy5wcm92aWRlckRlZiA9IHsgbmFtZTogJ8m1cHJkJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtXByZCB9O1xuSWRlbnRpZmllcnMucXVlcnlEZWYgPSB7IG5hbWU6ICfJtXF1ZCcsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogybVxdWQgfTtcbklkZW50aWZpZXJzLnB1cmVBcnJheURlZiA9IHsgbmFtZTogJ8m1cGFkJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtXBhZCB9O1xuSWRlbnRpZmllcnMucHVyZU9iamVjdERlZiA9IHsgbmFtZTogJ8m1cG9kJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtXBvZCB9O1xuSWRlbnRpZmllcnMucHVyZVBpcGVEZWYgPSB7IG5hbWU6ICfJtXBwZCcsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogybVwcGQgfTtcbklkZW50aWZpZXJzLnBpcGVEZWYgPSB7IG5hbWU6ICfJtXBpZCcsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogybVwaWQgfTtcbklkZW50aWZpZXJzLm5vZGVWYWx1ZSA9IHsgbmFtZTogJ8m1bm92JywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtW5vdiB9O1xuSWRlbnRpZmllcnMubmdDb250ZW50RGVmID0geyBuYW1lOiAnybVuY2QnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IMm1bmNkIH07XG5JZGVudGlmaWVycy51bndyYXBWYWx1ZSA9IHsgbmFtZTogJ8m1dW52JywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtXVudiB9O1xuSWRlbnRpZmllcnMuY3JlYXRlUmVuZGVyZXJUeXBlMiA9IHsgbmFtZTogJ8m1Y3J0JywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtWNydCB9O1xuSWRlbnRpZmllcnMuUmVuZGVyZXJUeXBlMiA9IHtcbiAgICBuYW1lOiAnUmVuZGVyZXJUeXBlMicsXG4gICAgbW9kdWxlVXJsOiBDT1JFLFxuICAgIC8vIHR5cGUgb25seVxuICAgIHJ1bnRpbWU6IG51bGxcbn07XG5JZGVudGlmaWVycy5WaWV3RGVmaW5pdGlvbiA9IHtcbiAgICBuYW1lOiAnybVWaWV3RGVmaW5pdGlvbicsXG4gICAgbW9kdWxlVXJsOiBDT1JFLFxuICAgIC8vIHR5cGUgb25seVxuICAgIHJ1bnRpbWU6IG51bGxcbn07XG5JZGVudGlmaWVycy5jcmVhdGVDb21wb25lbnRGYWN0b3J5ID0geyBuYW1lOiAnybVjY2YnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IMm1Y2NmIH07XG4vKipcbiAqIEBwYXJhbSB7P30gcGtnXG4gKiBAcGFyYW0gez89fSBwYXRoXG4gKiBAcGFyYW0gez89fSB0eXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBhc3NldFVybChwa2csIHBhdGgsIHR5cGUpIHtcbiAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBudWxsOyB9XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gJ3NyYyc7IH1cbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIkBhbmd1bGFyL1wiICsgcGtnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiQGFuZ3VsYXIvXCIgKyBwa2cgKyBcIi9cIiArIHR5cGUgKyBcIi9cIiArIHBhdGg7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IGlkZW50aWZpZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gaWRlbnRpZmllci5uYW1lO1xuICAgIHJldHVybiDJtXJlZmxlY3Rvci5yZXNvbHZlSWRlbnRpZmllcihuYW1lLCBpZGVudGlmaWVyLm1vZHVsZVVybCwgbnVsbCwgaWRlbnRpZmllci5ydW50aW1lKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpZGVudGlmaWVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4geyByZWZlcmVuY2U6IHJlc29sdmVJZGVudGlmaWVyKGlkZW50aWZpZXIpIH07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaWRlbnRpZmllclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaWRlbnRpZmllclRva2VuKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4geyBpZGVudGlmaWVyOiBpZGVudGlmaWVyIH07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaWRlbnRpZmllclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSWRlbnRpZmllclRva2VuKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllclRva2VuKGNyZWF0ZUlkZW50aWZpZXIoaWRlbnRpZmllcikpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGVudW1UeXBlXG4gKiBAcGFyYW0gez99IG5hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIGh0dHA6Ly9jbGRyLnVuaWNvZGUub3JnL2luZGV4L2NsZHItc3BlYy9wbHVyYWwtcnVsZXNcbnZhciBQTFVSQUxfQ0FTRVMgPSBbJ3plcm8nLCAnb25lJywgJ3R3bycsICdmZXcnLCAnbWFueScsICdvdGhlciddO1xuLyoqXG4gKiBFeHBhbmRzIHNwZWNpYWwgZm9ybXMgaW50byBlbGVtZW50cy5cbiAqXG4gKiBGb3IgZXhhbXBsZSxcbiAqXG4gKiBgYGBcbiAqIHsgbWVzc2FnZXMubGVuZ3RoLCBwbHVyYWwsXG4gKiAgID0wIHt6ZXJvfVxuICogICA9MSB7b25lfVxuICogICBvdGhlciB7bW9yZSB0aGFuIG9uZX1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIHdpbGwgYmUgZXhwYW5kZWQgaW50b1xuICpcbiAqIGBgYFxuICogPG5nLWNvbnRhaW5lciBbbmdQbHVyYWxdPVwibWVzc2FnZXMubGVuZ3RoXCI+XG4gKiAgIDxuZy10ZW1wbGF0ZSBuZ1BsdXJhbENhc2U9XCI9MFwiPnplcm88L25nLXRlbXBsYXRlPlxuICogICA8bmctdGVtcGxhdGUgbmdQbHVyYWxDYXNlPVwiPTFcIj5vbmU8L25nLXRlbXBsYXRlPlxuICogICA8bmctdGVtcGxhdGUgbmdQbHVyYWxDYXNlPVwib3RoZXJcIj5tb3JlIHRoYW4gb25lPC9uZy10ZW1wbGF0ZT5cbiAqIDwvbmctY29udGFpbmVyPlxuICogYGBgXG4gKiBAcGFyYW0gez99IG5vZGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBleHBhbmROb2Rlcyhub2Rlcykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cGFuZGVyID0gbmV3IF9FeHBhbmRlcigpO1xuICAgIHJldHVybiBuZXcgRXhwYW5zaW9uUmVzdWx0KHZpc2l0QWxsKGV4cGFuZGVyLCBub2RlcyksIGV4cGFuZGVyLmlzRXhwYW5kZWQsIGV4cGFuZGVyLmVycm9ycyk7XG59XG52YXIgRXhwYW5zaW9uUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVzXG4gICAgICogQHBhcmFtIHs/fSBleHBhbmRlZFxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXhwYW5zaW9uUmVzdWx0KG5vZGVzLCBleHBhbmRlZCwgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IGV4cGFuZGVkO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG4gICAgcmV0dXJuIEV4cGFuc2lvblJlc3VsdDtcbn0oKSk7XG52YXIgRXhwYW5zaW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHBhbnNpb25FcnJvciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IGVycm9yTXNnXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXhwYW5zaW9uRXJyb3Ioc3BhbiwgZXJyb3JNc2cpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIGVycm9yTXNnKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRXhwYW5zaW9uRXJyb3I7XG59KFBhcnNlRXJyb3IpKTtcbi8qKlxuICogRXhwYW5kIGV4cGFuc2lvbiBmb3JtcyAocGx1cmFsLCBzZWxlY3QpIHRvIGRpcmVjdGl2ZXNcbiAqXG4gKiBcXEBpbnRlcm5hbFxuICovXG52YXIgX0V4cGFuZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfRXhwYW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaXNFeHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KGVsZW1lbnQubmFtZSwgZWxlbWVudC5hdHRycywgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiksIGVsZW1lbnQuc291cmNlU3BhbiwgZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIGVsZW1lbnQuZW5kU291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHsgcmV0dXJuIGF0dHJpYnV0ZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIHRleHQ7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21tZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IHJldHVybiBjb21tZW50OyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmlzRXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gaWN1LnR5cGUgPT0gJ3BsdXJhbCcgPyBfZXhwYW5kUGx1cmFsRm9ybShpY3UsIHRoaXMuZXJyb3JzKSA6XG4gICAgICAgICAgICBfZXhwYW5kRGVmYXVsdEZvcm0oaWN1LCB0aGlzLmVycm9ycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdUNhc2VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGJlIHJlYWNoZWQnKTtcbiAgICB9O1xuICAgIHJldHVybiBfRXhwYW5kZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGFzdFxuICogQHBhcmFtIHs/fSBlcnJvcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9leHBhbmRQbHVyYWxGb3JtKGFzdCwgZXJyb3JzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRyZW4gPSBhc3QuY2FzZXMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChQTFVSQUxfQ0FTRVMuaW5kZXhPZihjLnZhbHVlKSA9PSAtMSAmJiAhYy52YWx1ZS5tYXRjaCgvXj1cXGQrJC8pKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgRXhwYW5zaW9uRXJyb3IoYy52YWx1ZVNvdXJjZVNwYW4sIFwiUGx1cmFsIGNhc2VzIHNob3VsZCBiZSBcXFwiPTxudW1iZXI+XFxcIiBvciBvbmUgb2YgXCIgKyBQTFVSQUxfQ0FTRVMuam9pbihcIiwgXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwYW5zaW9uUmVzdWx0ID0gZXhwYW5kTm9kZXMoYy5leHByZXNzaW9uKTtcbiAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBleHBhbnNpb25SZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KFwibmctdGVtcGxhdGVcIiwgW25ldyBBdHRyaWJ1dGUkMSgnbmdQbHVyYWxDYXNlJywgXCJcIiArIGMudmFsdWUsIGMudmFsdWVTb3VyY2VTcGFuKV0sIGV4cGFuc2lvblJlc3VsdC5ub2RlcywgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4sIGMuc291cmNlU3Bhbik7XG4gICAgfSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3dpdGNoQXR0ciA9IG5ldyBBdHRyaWJ1dGUkMSgnW25nUGx1cmFsXScsIGFzdC5zd2l0Y2hWYWx1ZSwgYXN0LnN3aXRjaFZhbHVlU291cmNlU3Bhbik7XG4gICAgcmV0dXJuIG5ldyBFbGVtZW50KCduZy1jb250YWluZXInLCBbc3dpdGNoQXR0cl0sIGNoaWxkcmVuLCBhc3Quc291cmNlU3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5zb3VyY2VTcGFuKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBhc3RcbiAqIEBwYXJhbSB7P30gZXJyb3JzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfZXhwYW5kRGVmYXVsdEZvcm0oYXN0LCBlcnJvcnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZHJlbiA9IGFzdC5jYXNlcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwYW5zaW9uUmVzdWx0ID0gZXhwYW5kTm9kZXMoYy5leHByZXNzaW9uKTtcbiAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBleHBhbnNpb25SZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgaWYgKGMudmFsdWUgPT09ICdvdGhlcicpIHtcbiAgICAgICAgICAgIC8vIG90aGVyIGlzIHRoZSBkZWZhdWx0IGNhc2Ugd2hlbiBubyB2YWx1ZXMgbWF0Y2hcbiAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudChcIm5nLXRlbXBsYXRlXCIsIFtuZXcgQXR0cmlidXRlJDEoJ25nU3dpdGNoRGVmYXVsdCcsICcnLCBjLnZhbHVlU291cmNlU3BhbildLCBleHBhbnNpb25SZXN1bHQubm9kZXMsIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWxlbWVudChcIm5nLXRlbXBsYXRlXCIsIFtuZXcgQXR0cmlidXRlJDEoJ25nU3dpdGNoQ2FzZScsIFwiXCIgKyBjLnZhbHVlLCBjLnZhbHVlU291cmNlU3BhbildLCBleHBhbnNpb25SZXN1bHQubm9kZXMsIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4pO1xuICAgIH0pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN3aXRjaEF0dHIgPSBuZXcgQXR0cmlidXRlJDEoJ1tuZ1N3aXRjaF0nLCBhc3Quc3dpdGNoVmFsdWUsIGFzdC5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4pO1xuICAgIHJldHVybiBuZXcgRWxlbWVudCgnbmctY29udGFpbmVyJywgW3N3aXRjaEF0dHJdLCBjaGlsZHJlbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Quc291cmNlU3Bhbik7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgUHJvdmlkZXJFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb3ZpZGVyRXJyb3IsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJvdmlkZXJFcnJvcihtZXNzYWdlLCBzcGFuKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUHJvdmlkZXJFcnJvcjtcbn0oUGFyc2VFcnJvcikpO1xudmFyIFByb3ZpZGVyVmlld0NvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJvdmlkZXJWaWV3Q29udGV4dChjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMudmlld1F1ZXJpZXMgPSBfZ2V0Vmlld1F1ZXJpZXMoY29tcG9uZW50KTtcbiAgICAgICAgdGhpcy52aWV3UHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb21wb25lbnQudmlld1Byb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgaWYgKF90aGlzLnZpZXdQcm92aWRlcnMuZ2V0KHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnZpZXdQcm92aWRlcnMuc2V0KHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvdmlkZXJWaWV3Q29udGV4dDtcbn0oKSk7XG52YXIgUHJvdmlkZXJFbGVtZW50Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aWV3Q29udGV4dFxuICAgICAqIEBwYXJhbSB7P30gX3BhcmVudFxuICAgICAqIEBwYXJhbSB7P30gX2lzVmlld1Jvb3RcbiAgICAgKiBAcGFyYW0gez99IF9kaXJlY3RpdmVBc3RzXG4gICAgICogQHBhcmFtIHs/fSBhdHRyc1xuICAgICAqIEBwYXJhbSB7P30gcmVmc1xuICAgICAqIEBwYXJhbSB7P30gaXNUZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFF1ZXJ5U3RhcnRJZFxuICAgICAqIEBwYXJhbSB7P30gX3NvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcm92aWRlckVsZW1lbnRDb250ZXh0KHZpZXdDb250ZXh0LCBfcGFyZW50LCBfaXNWaWV3Um9vdCwgX2RpcmVjdGl2ZUFzdHMsIGF0dHJzLCByZWZzLCBpc1RlbXBsYXRlLCBjb250ZW50UXVlcnlTdGFydElkLCBfc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZpZXdDb250ZXh0ID0gdmlld0NvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuX2lzVmlld1Jvb3QgPSBfaXNWaWV3Um9vdDtcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlQXN0cyA9IF9kaXJlY3RpdmVBc3RzO1xuICAgICAgICB0aGlzLl9zb3VyY2VTcGFuID0gX3NvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zZWVuUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9oYXNWaWV3Q29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3F1ZXJpZWRUb2tlbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2F0dHJzID0ge307XG4gICAgICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHJBc3QpIHsgcmV0dXJuIF90aGlzLl9hdHRyc1thdHRyQXN0Lm5hbWVdID0gYXR0ckFzdC52YWx1ZTsgfSk7XG4gICAgICAgIHZhciBkaXJlY3RpdmVzTWV0YSA9IF9kaXJlY3RpdmVBc3RzLm1hcChmdW5jdGlvbiAoZGlyZWN0aXZlQXN0KSB7IHJldHVybiBkaXJlY3RpdmVBc3QuZGlyZWN0aXZlOyB9KTtcbiAgICAgICAgdGhpcy5fYWxsUHJvdmlkZXJzID1cbiAgICAgICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzRnJvbURpcmVjdGl2ZXMoZGlyZWN0aXZlc01ldGEsIF9zb3VyY2VTcGFuLCB2aWV3Q29udGV4dC5lcnJvcnMpO1xuICAgICAgICB0aGlzLl9jb250ZW50UXVlcmllcyA9IF9nZXRDb250ZW50UXVlcmllcyhjb250ZW50UXVlcnlTdGFydElkLCBkaXJlY3RpdmVzTWV0YSk7XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5fYWxsUHJvdmlkZXJzLnZhbHVlcygpKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgX3RoaXMuX2FkZFF1ZXJ5UmVhZHNUbyhwcm92aWRlci50b2tlbiwgcHJvdmlkZXIudG9rZW4sIF90aGlzLl9xdWVyaWVkVG9rZW5zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1RlbXBsYXRlKSB7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVSZWZJZCA9IGNyZWF0ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5UZW1wbGF0ZVJlZik7XG4gICAgICAgICAgICB0aGlzLl9hZGRRdWVyeVJlYWRzVG8odGVtcGxhdGVSZWZJZCwgdGVtcGxhdGVSZWZJZCwgdGhpcy5fcXVlcmllZFRva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWZBc3QpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0UXVlcnlWYWx1ZSA9IHJlZkFzdC52YWx1ZSB8fCBjcmVhdGVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuRWxlbWVudFJlZik7XG4gICAgICAgICAgICBfdGhpcy5fYWRkUXVlcnlSZWFkc1RvKHsgdmFsdWU6IHJlZkFzdC5uYW1lIH0sIGRlZmF1bHRRdWVyeVZhbHVlLCBfdGhpcy5fcXVlcmllZFRva2Vucyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fcXVlcmllZFRva2Vucy5nZXQocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuVmlld0NvbnRhaW5lclJlZikpKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNWaWV3Q29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgdGhlIHByb3ZpZGVycyB0aGF0IHdlIGtub3cgYXJlIGVhZ2VyIGZpcnN0XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5fYWxsUHJvdmlkZXJzLnZhbHVlcygpKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgdmFyIGVhZ2VyID0gcHJvdmlkZXIuZWFnZXIgfHwgX3RoaXMuX3F1ZXJpZWRUb2tlbnMuZ2V0KHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSk7XG4gICAgICAgICAgICBpZiAoZWFnZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyKHByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgcHJvdmlkZXIudG9rZW4sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5hZnRlckVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGNvbGxlY3QgbGF6eSBwcm92aWRlcnNcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9hbGxQcm92aWRlcnMudmFsdWVzKCkpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBfdGhpcy5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyKHByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgcHJvdmlkZXIudG9rZW4sIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUsIFwidHJhbnNmb3JtUHJvdmlkZXJzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzLnZhbHVlcygpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLCBcInRyYW5zZm9ybWVkRGlyZWN0aXZlQXN0c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3J0ZWRQcm92aWRlclR5cGVzID0gdGhpcy50cmFuc2Zvcm1Qcm92aWRlcnMubWFwKGZ1bmN0aW9uIChwcm92aWRlcikgeyByZXR1cm4gcHJvdmlkZXIudG9rZW4uaWRlbnRpZmllcjsgfSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3J0ZWREaXJlY3RpdmVzID0gdGhpcy5fZGlyZWN0aXZlQXN0cy5zbGljZSgpO1xuICAgICAgICAgICAgc29ydGVkRGlyZWN0aXZlcy5zb3J0KGZ1bmN0aW9uIChkaXIxLCBkaXIyKSB7IHJldHVybiBzb3J0ZWRQcm92aWRlclR5cGVzLmluZGV4T2YoZGlyMS5kaXJlY3RpdmUudHlwZSkgLVxuICAgICAgICAgICAgICAgIHNvcnRlZFByb3ZpZGVyVHlwZXMuaW5kZXhPZihkaXIyLmRpcmVjdGl2ZS50eXBlKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gc29ydGVkRGlyZWN0aXZlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLCBcInRyYW5zZm9ybWVkSGFzVmlld0NvbnRhaW5lclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9oYXNWaWV3Q29udGFpbmVyOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUsIFwicXVlcnlNYXRjaGVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbE1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXJpZWRUb2tlbnMuZm9yRWFjaChmdW5jdGlvbiAobWF0Y2hlcykgeyBhbGxNYXRjaGVzLnB1c2guYXBwbHkoYWxsTWF0Y2hlcywgbWF0Y2hlcyk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFsbE1hdGNoZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcGFyYW0gez99IGRlZmF1bHRWYWx1ZVxuICAgICAqIEBwYXJhbSB7P30gcXVlcnlSZWFkVG9rZW5zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fYWRkUXVlcnlSZWFkc1RvID0gZnVuY3Rpb24gKHRva2VuLCBkZWZhdWx0VmFsdWUsIHF1ZXJ5UmVhZFRva2Vucykge1xuICAgICAgICB0aGlzLl9nZXRRdWVyaWVzRm9yKHRva2VuKS5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcnlWYWx1ZSA9IHF1ZXJ5Lm1ldGEucmVhZCB8fCBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlblJlZiA9IHRva2VuUmVmZXJlbmNlKHF1ZXJ5VmFsdWUpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcnlNYXRjaGVzID0gcXVlcnlSZWFkVG9rZW5zLmdldCh0b2tlblJlZik7XG4gICAgICAgICAgICBpZiAoIXF1ZXJ5TWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHF1ZXJ5UmVhZFRva2Vucy5zZXQodG9rZW5SZWYsIHF1ZXJ5TWF0Y2hlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWVyeU1hdGNoZXMucHVzaCh7IHF1ZXJ5SWQ6IHF1ZXJ5LnF1ZXJ5SWQsIHZhbHVlOiBxdWVyeVZhbHVlIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLl9nZXRRdWVyaWVzRm9yID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50RWwgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXN0YW5jZSA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJpZXM7XG4gICAgICAgIHdoaWxlIChjdXJyZW50RWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHF1ZXJpZXMgPSBjdXJyZW50RWwuX2NvbnRlbnRRdWVyaWVzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICAgICAgaWYgKHF1ZXJpZXMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIHF1ZXJpZXMuZmlsdGVyKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gcXVlcnkubWV0YS5kZXNjZW5kYW50cyB8fCBkaXN0YW5jZSA8PSAxOyB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudEVsLl9kaXJlY3RpdmVBc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEVsID0gY3VycmVudEVsLl9wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcXVlcmllcyA9IHRoaXMudmlld0NvbnRleHQudmlld1F1ZXJpZXMuZ2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSk7XG4gICAgICAgIGlmIChxdWVyaWVzKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIHF1ZXJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RpbmdQcm92aWRlclR5cGVcbiAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICogQHBhcmFtIHs/fSBlYWdlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlciA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCB0b2tlbiwgZWFnZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRQcm92aWRlciA9IHRoaXMuX2FsbFByb3ZpZGVycy5nZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pKTtcbiAgICAgICAgaWYgKCFyZXNvbHZlZFByb3ZpZGVyIHx8ICgocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZSB8fFxuICAgICAgICAgICAgcmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UpICYmXG4gICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLlByaXZhdGVTZXJ2aWNlKSB8fFxuICAgICAgICAgICAgKChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UgfHxcbiAgICAgICAgICAgICAgICByZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSkgJiZcbiAgICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLkJ1aWx0aW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0ID0gdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuZ2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRQcm92aWRlckFzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc2VlblByb3ZpZGVycy5nZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pKSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LmVycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiQ2Fubm90IGluc3RhbnRpYXRlIGN5Y2xpYyBkZXBlbmRlbmN5ISBcIiArIHRva2VuTmFtZSh0b2tlbiksIHRoaXMuX3NvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMuc2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSwgdHJ1ZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVkUHJvdmlkZXJzID0gcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlcnMubWFwKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZWRVc2VWYWx1ZSA9IHByb3ZpZGVyLnVzZVZhbHVlO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9ICgocHJvdmlkZXIudXNlRXhpc3RpbmcpKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVkRGVwcyA9ICgodW5kZWZpbmVkKSk7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXIudXNlRXhpc3RpbmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4aXN0aW5nRGlEZXAgPSAoKF90aGlzLl9nZXREZXBlbmRlbmN5KHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlLCB7IHRva2VuOiBwcm92aWRlci51c2VFeGlzdGluZyB9LCBlYWdlcikpKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdEaURlcC50b2tlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcgPSBleGlzdGluZ0RpRGVwLnRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9ICgobnVsbCkpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZVZhbHVlID0gZXhpc3RpbmdEaURlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VGYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlRmFjdG9yeS5kaURlcHM7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWREZXBzID1cbiAgICAgICAgICAgICAgICAgICAgZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gKChfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgZGVwLCBlYWdlcikpKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VDbGFzcykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcHMgPSBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUNsYXNzLmRpRGVwcztcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZERlcHMgPVxuICAgICAgICAgICAgICAgICAgICBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiAoKF90aGlzLl9nZXREZXBlbmRlbmN5KHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKSkpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdHJhbnNmb3JtUHJvdmlkZXIocHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogdHJhbnNmb3JtZWRVc2VFeGlzdGluZyxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogdHJhbnNmb3JtZWRVc2VWYWx1ZSxcbiAgICAgICAgICAgICAgICBkZXBzOiB0cmFuc2Zvcm1lZERlcHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNmb3JtZWRQcm92aWRlckFzdCA9XG4gICAgICAgICAgICBfdHJhbnNmb3JtUHJvdmlkZXJBc3QocmVzb2x2ZWRQcm92aWRlciwgeyBlYWdlcjogZWFnZXIsIHByb3ZpZGVyczogdHJhbnNmb3JtZWRQcm92aWRlcnMgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzLnNldCh0b2tlblJlZmVyZW5jZSh0b2tlbiksIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QpO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRQcm92aWRlckFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdGluZ1Byb3ZpZGVyVHlwZVxuICAgICAqIEBwYXJhbSB7P30gZGVwXG4gICAgICogQHBhcmFtIHs/PX0gZWFnZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLl9nZXRMb2NhbERlcGVuZGVuY3kgPSBmdW5jdGlvbiAocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwLCBlYWdlcikge1xuICAgICAgICBpZiAoZWFnZXIgPT09IHZvaWQgMCkgeyBlYWdlciA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChkZXAuaXNBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJWYWx1ZSA9IHRoaXMuX2F0dHJzWygoZGVwLnRva2VuKSkudmFsdWVdO1xuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWx1ZTogdHJ1ZSwgdmFsdWU6IGF0dHJWYWx1ZSA9PSBudWxsID8gbnVsbCA6IGF0dHJWYWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXAudG9rZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gYWNjZXNzIGJ1aWx0aW50c1xuICAgICAgICAgICAgaWYgKChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8XG4gICAgICAgICAgICAgICAgcmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLkNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT0gcmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuUmVuZGVyZXIpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikgPT09IHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkVsZW1lbnRSZWYpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikgPT09IHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yUmVmKSB8fFxuICAgICAgICAgICAgICAgICAgICB0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pID09PSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5UZW1wbGF0ZVJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikgPT09IHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlZpZXdDb250YWluZXJSZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhc1ZpZXdDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFjY2VzcyB0aGUgaW5qZWN0b3JcbiAgICAgICAgICAgIGlmICh0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pID09PSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5JbmplY3RvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWNjZXNzIHByb3ZpZGVyc1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlcihyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXAudG9rZW4sIGVhZ2VyKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdGluZ1Byb3ZpZGVyVHlwZVxuICAgICAqIEBwYXJhbSB7P30gZGVwXG4gICAgICogQHBhcmFtIHs/PX0gZWFnZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLl9nZXREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpIHtcbiAgICAgICAgaWYgKGVhZ2VyID09PSB2b2lkIDApIHsgZWFnZXIgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyRWxlbWVudCA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJFYWdlciA9IGVhZ2VyO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZiAoIWRlcC5pc1NraXBTZWxmKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXRMb2NhbERlcGVuZGVuY3kocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwLCBlYWdlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlcC5pc1NlbGYpIHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0ICYmIGRlcC5pc09wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geyBpc1ZhbHVlOiB0cnVlLCB2YWx1ZTogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gY2hlY2sgcGFyZW50IGVsZW1lbnRzXG4gICAgICAgICAgICB3aGlsZSAoIXJlc3VsdCAmJiBjdXJyRWxlbWVudC5fcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldkVsZW1lbnQgPSBjdXJyRWxlbWVudDtcbiAgICAgICAgICAgICAgICBjdXJyRWxlbWVudCA9IGN1cnJFbGVtZW50Ll9wYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZFbGVtZW50Ll9pc1ZpZXdSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJFYWdlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjdXJyRWxlbWVudC5fZ2V0TG9jYWxEZXBlbmRlbmN5KFByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlLCBkZXAsIGN1cnJFYWdlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayBASG9zdCByZXN0cmljdGlvblxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRlcC5pc0hvc3QgfHwgdGhpcy52aWV3Q29udGV4dC5jb21wb25lbnQuaXNIb3N0IHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQuY29tcG9uZW50LnR5cGUucmVmZXJlbmNlID09PSB0b2tlblJlZmVyZW5jZSgvKiogQHR5cGUgez99ICovICgoZGVwLnRva2VuKSkpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQudmlld1Byb3ZpZGVycy5nZXQodG9rZW5SZWZlcmVuY2UoLyoqIEB0eXBlIHs/fSAqLyAoKGRlcC50b2tlbikpKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkZXAuaXNPcHRpb25hbCA/IHJlc3VsdCA9IHsgaXNWYWx1ZTogdHJ1ZSwgdmFsdWU6IG51bGwgfSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LmVycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiTm8gcHJvdmlkZXIgZm9yIFwiICsgdG9rZW5OYW1lKC8qKiBAdHlwZSB7P30gKi8gKChkZXAudG9rZW4pKSksIHRoaXMuX3NvdXJjZVNwYW4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFByb3ZpZGVyRWxlbWVudENvbnRleHQ7XG59KCkpO1xudmFyIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZVxuICAgICAqIEBwYXJhbSB7P30gZXh0cmFQcm92aWRlcnNcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOZ01vZHVsZVByb3ZpZGVyQW5hbHl6ZXIobmdNb2R1bGUsIGV4dHJhUHJvdmlkZXJzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zZWVuUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fYWxsUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobmdNb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICB2YXIgbmdNb2R1bGVQcm92aWRlciA9IHsgdG9rZW46IHsgaWRlbnRpZmllcjogbmdNb2R1bGVUeXBlIH0sIHVzZUNsYXNzOiBuZ01vZHVsZVR5cGUgfTtcbiAgICAgICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzKFtuZ01vZHVsZVByb3ZpZGVyXSwgUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UsIHRydWUsIHNvdXJjZVNwYW4sIF90aGlzLl9lcnJvcnMsIF90aGlzLl9hbGxQcm92aWRlcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3Jlc29sdmVQcm92aWRlcnMobmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5wcm92aWRlcnMubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkucHJvdmlkZXI7IH0pLmNvbmNhdChleHRyYVByb3ZpZGVycyksIFByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlLCBmYWxzZSwgc291cmNlU3BhbiwgdGhpcy5fZXJyb3JzLCB0aGlzLl9hbGxQcm92aWRlcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5fYWxsUHJvdmlkZXJzLnZhbHVlcygpKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgX3RoaXMuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlcihwcm92aWRlci50b2tlbiwgcHJvdmlkZXIuZWFnZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX2Vycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvclN0cmluZyA9IHRoaXMuX2Vycm9ycy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9yU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy52YWx1ZXMoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICogQHBhcmFtIHs/fSBlYWdlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyLnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyID0gZnVuY3Rpb24gKHRva2VuLCBlYWdlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFByb3ZpZGVyID0gdGhpcy5fYWxsUHJvdmlkZXJzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICBpZiAoIXJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QgPSB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy5nZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pKTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zZWVuUHJvdmlkZXJzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiQ2Fubm90IGluc3RhbnRpYXRlIGN5Y2xpYyBkZXBlbmRlbmN5ISBcIiArIHRva2VuTmFtZSh0b2tlbiksIHJlc29sdmVkUHJvdmlkZXIuc291cmNlU3BhbikpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2VlblByb3ZpZGVycy5zZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pLCB0cnVlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZWRQcm92aWRlcnMgPSByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lZFVzZVZhbHVlID0gcHJvdmlkZXIudXNlVmFsdWU7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gKChwcm92aWRlci51c2VFeGlzdGluZykpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZWREZXBzID0gKCh1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlci51c2VFeGlzdGluZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhpc3RpbmdEaURlcCA9IF90aGlzLl9nZXREZXBlbmRlbmN5KHsgdG9rZW46IHByb3ZpZGVyLnVzZUV4aXN0aW5nIH0sIGVhZ2VyLCByZXNvbHZlZFByb3ZpZGVyLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0RpRGVwLnRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IGV4aXN0aW5nRGlEZXAudG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gKChudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkVXNlVmFsdWUgPSBleGlzdGluZ0RpRGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBzID0gcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VGYWN0b3J5LmRpRGVwcztcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZERlcHMgPVxuICAgICAgICAgICAgICAgICAgICBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShkZXAsIGVhZ2VyLCByZXNvbHZlZFByb3ZpZGVyLnNvdXJjZVNwYW4pOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUNsYXNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlQ2xhc3MuZGlEZXBzO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkRGVwcyA9XG4gICAgICAgICAgICAgICAgICAgIGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KGRlcCwgZWFnZXIsIHJlc29sdmVkUHJvdmlkZXIuc291cmNlU3Bhbik7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90cmFuc2Zvcm1Qcm92aWRlcihwcm92aWRlciwge1xuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiB0cmFuc2Zvcm1lZFVzZVZhbHVlLFxuICAgICAgICAgICAgICAgIGRlcHM6IHRyYW5zZm9ybWVkRGVwc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0ID1cbiAgICAgICAgICAgIF90cmFuc2Zvcm1Qcm92aWRlckFzdChyZXNvbHZlZFByb3ZpZGVyLCB7IGVhZ2VyOiBlYWdlciwgcHJvdmlkZXJzOiB0cmFuc2Zvcm1lZFByb3ZpZGVycyB9KTtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuc2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSwgdHJhbnNmb3JtZWRQcm92aWRlckFzdCk7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkZXBcbiAgICAgKiBAcGFyYW0gez89fSBlYWdlclxuICAgICAqIEBwYXJhbSB7Pz19IHJlcXVlc3RvclNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplci5wcm90b3R5cGUuX2dldERlcGVuZGVuY3kgPSBmdW5jdGlvbiAoZGVwLCBlYWdlciwgcmVxdWVzdG9yU291cmNlU3Bhbikge1xuICAgICAgICBpZiAoZWFnZXIgPT09IHZvaWQgMCkgeyBlYWdlciA9IGZhbHNlOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZvdW5kTG9jYWwgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFkZXAuaXNTa2lwU2VsZiAmJiBkZXAudG9rZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gYWNjZXNzIHRoZSBpbmplY3RvclxuICAgICAgICAgICAgaWYgKHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikgPT09IHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkluamVjdG9yKSB8fFxuICAgICAgICAgICAgICAgIHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikgPT09IHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikpIHtcbiAgICAgICAgICAgICAgICBmb3VuZExvY2FsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlcihkZXAudG9rZW4sIGVhZ2VyKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm91bmRMb2NhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gZGVwO1xuICAgICAgICBpZiAoZGVwLmlzU2VsZiAmJiAhZm91bmRMb2NhbCkge1xuICAgICAgICAgICAgaWYgKGRlcC5pc09wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geyBpc1ZhbHVlOiB0cnVlLCB2YWx1ZTogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJObyBwcm92aWRlciBmb3IgXCIgKyB0b2tlbk5hbWUoLyoqIEB0eXBlIHs/fSAqLyAoKGRlcC50b2tlbikpKSwgcmVxdWVzdG9yU291cmNlU3BhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gTmdNb2R1bGVQcm92aWRlckFuYWx5emVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBwcm92aWRlclxuICogQHBhcmFtIHs/fSBfXzFcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF90cmFuc2Zvcm1Qcm92aWRlcihwcm92aWRlciwgX2EpIHtcbiAgICB2YXIgdXNlRXhpc3RpbmcgPSBfYS51c2VFeGlzdGluZywgdXNlVmFsdWUgPSBfYS51c2VWYWx1ZSwgZGVwcyA9IF9hLmRlcHM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW46IHByb3ZpZGVyLnRva2VuLFxuICAgICAgICB1c2VDbGFzczogcHJvdmlkZXIudXNlQ2xhc3MsXG4gICAgICAgIHVzZUV4aXN0aW5nOiB1c2VFeGlzdGluZyxcbiAgICAgICAgdXNlRmFjdG9yeTogcHJvdmlkZXIudXNlRmFjdG9yeSxcbiAgICAgICAgdXNlVmFsdWU6IHVzZVZhbHVlLFxuICAgICAgICBkZXBzOiBkZXBzLFxuICAgICAgICBtdWx0aTogcHJvdmlkZXIubXVsdGlcbiAgICB9O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHByb3ZpZGVyXG4gKiBAcGFyYW0gez99IF9fMVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX3RyYW5zZm9ybVByb3ZpZGVyQXN0KHByb3ZpZGVyLCBfYSkge1xuICAgIHZhciBlYWdlciA9IF9hLmVhZ2VyLCBwcm92aWRlcnMgPSBfYS5wcm92aWRlcnM7XG4gICAgcmV0dXJuIG5ldyBQcm92aWRlckFzdChwcm92aWRlci50b2tlbiwgcHJvdmlkZXIubXVsdGlQcm92aWRlciwgcHJvdmlkZXIuZWFnZXIgfHwgZWFnZXIsIHByb3ZpZGVycywgcHJvdmlkZXIucHJvdmlkZXJUeXBlLCBwcm92aWRlci5saWZlY3ljbGVIb29rcywgcHJvdmlkZXIuc291cmNlU3Bhbik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gKiBAcGFyYW0gez99IHRhcmdldEVycm9yc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX3Jlc29sdmVQcm92aWRlcnNGcm9tRGlyZWN0aXZlcyhkaXJlY3RpdmVzLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlcnNCeVRva2VuID0gbmV3IE1hcCgpO1xuICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpclByb3ZpZGVyID0geyB0b2tlbjogeyBpZGVudGlmaWVyOiBkaXJlY3RpdmUudHlwZSB9LCB1c2VDbGFzczogZGlyZWN0aXZlLnR5cGUgfTtcbiAgICAgICAgX3Jlc29sdmVQcm92aWRlcnMoW2RpclByb3ZpZGVyXSwgZGlyZWN0aXZlLmlzQ29tcG9uZW50ID8gUHJvdmlkZXJBc3RUeXBlLkNvbXBvbmVudCA6IFByb3ZpZGVyQXN0VHlwZS5EaXJlY3RpdmUsIHRydWUsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgcHJvdmlkZXJzQnlUb2tlbik7XG4gICAgfSk7XG4gICAgLy8gTm90ZTogZGlyZWN0aXZlcyBuZWVkIHRvIGJlIGFibGUgdG8gb3ZlcndyaXRlIHByb3ZpZGVycyBvZiBhIGNvbXBvbmVudCFcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJlY3RpdmVzV2l0aENvbXBvbmVudEZpcnN0ID0gZGlyZWN0aXZlcy5maWx0ZXIoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gZGlyLmlzQ29tcG9uZW50OyB9KS5jb25jYXQoZGlyZWN0aXZlcy5maWx0ZXIoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gIWRpci5pc0NvbXBvbmVudDsgfSkpO1xuICAgIGRpcmVjdGl2ZXNXaXRoQ29tcG9uZW50Rmlyc3QuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzKGRpcmVjdGl2ZS5wcm92aWRlcnMsIFByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlLCBmYWxzZSwgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzLCBwcm92aWRlcnNCeVRva2VuKTtcbiAgICAgICAgX3Jlc29sdmVQcm92aWRlcnMoZGlyZWN0aXZlLnZpZXdQcm92aWRlcnMsIFByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSwgZmFsc2UsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgcHJvdmlkZXJzQnlUb2tlbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb3ZpZGVyc0J5VG9rZW47XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcHJvdmlkZXJzXG4gKiBAcGFyYW0gez99IHByb3ZpZGVyVHlwZVxuICogQHBhcmFtIHs/fSBlYWdlclxuICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gKiBAcGFyYW0gez99IHRhcmdldEVycm9yc1xuICogQHBhcmFtIHs/fSB0YXJnZXRQcm92aWRlcnNCeVRva2VuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfcmVzb2x2ZVByb3ZpZGVycyhwcm92aWRlcnMsIHByb3ZpZGVyVHlwZSwgZWFnZXIsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgdGFyZ2V0UHJvdmlkZXJzQnlUb2tlbikge1xuICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFByb3ZpZGVyID0gdGFyZ2V0UHJvdmlkZXJzQnlUb2tlbi5nZXQodG9rZW5SZWZlcmVuY2UocHJvdmlkZXIudG9rZW4pKTtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvdmlkZXIgIT0gbnVsbCAmJiAhIXJlc29sdmVkUHJvdmlkZXIubXVsdGlQcm92aWRlciAhPT0gISFwcm92aWRlci5tdWx0aSkge1xuICAgICAgICAgICAgdGFyZ2V0RXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJNaXhpbmcgbXVsdGkgYW5kIG5vbiBtdWx0aSBwcm92aWRlciBpcyBub3QgcG9zc2libGUgZm9yIHRva2VuIFwiICsgdG9rZW5OYW1lKHJlc29sdmVkUHJvdmlkZXIudG9rZW4pLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNvbHZlZFByb3ZpZGVyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaWZlY3ljbGVIb29rcyA9IHByb3ZpZGVyLnRva2VuLmlkZW50aWZpZXIgJiZcbiAgICAgICAgICAgICAgICAoKHByb3ZpZGVyLnRva2VuLmlkZW50aWZpZXIpKS5saWZlY3ljbGVIb29rcyA/XG4gICAgICAgICAgICAgICAgKChwcm92aWRlci50b2tlbi5pZGVudGlmaWVyKSkubGlmZWN5Y2xlSG9va3MgOlxuICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNVc2VWYWx1ZSA9ICEocHJvdmlkZXIudXNlQ2xhc3MgfHwgcHJvdmlkZXIudXNlRXhpc3RpbmcgfHwgcHJvdmlkZXIudXNlRmFjdG9yeSk7XG4gICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyID0gbmV3IFByb3ZpZGVyQXN0KHByb3ZpZGVyLnRva2VuLCAhIXByb3ZpZGVyLm11bHRpLCBlYWdlciB8fCBpc1VzZVZhbHVlLCBbcHJvdmlkZXJdLCBwcm92aWRlclR5cGUsIGxpZmVjeWNsZUhvb2tzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHRhcmdldFByb3ZpZGVyc0J5VG9rZW4uc2V0KHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSwgcmVzb2x2ZWRQcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLnB1c2gocHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfZ2V0Vmlld1F1ZXJpZXMoY29tcG9uZW50KSB7XG4gICAgLy8gTm90ZTogcXVlcmllcyBzdGFydCB3aXRoIGlkIDEgc28gd2UgY2FuIHVzZSB0aGUgbnVtYmVyIGluIGEgQmxvb20gZmlsdGVyIVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdRdWVyeUlkID0gMTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3UXVlcmllcyA9IG5ldyBNYXAoKTtcbiAgICBpZiAoY29tcG9uZW50LnZpZXdRdWVyaWVzKSB7XG4gICAgICAgIGNvbXBvbmVudC52aWV3UXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gX2FkZFF1ZXJ5VG9Ub2tlbk1hcCh2aWV3UXVlcmllcywgeyBtZXRhOiBxdWVyeSwgcXVlcnlJZDogdmlld1F1ZXJ5SWQrKyB9KTsgfSk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3UXVlcmllcztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb250ZW50UXVlcnlTdGFydElkXG4gKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9nZXRDb250ZW50UXVlcmllcyhjb250ZW50UXVlcnlTdGFydElkLCBkaXJlY3RpdmVzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGVudFF1ZXJ5SWQgPSBjb250ZW50UXVlcnlTdGFydElkO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRlbnRRdWVyaWVzID0gbmV3IE1hcCgpO1xuICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlLCBkaXJlY3RpdmVJbmRleCkge1xuICAgICAgICBpZiAoZGlyZWN0aXZlLnF1ZXJpZXMpIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZS5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBfYWRkUXVlcnlUb1Rva2VuTWFwKGNvbnRlbnRRdWVyaWVzLCB7IG1ldGE6IHF1ZXJ5LCBxdWVyeUlkOiBjb250ZW50UXVlcnlJZCsrIH0pOyB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb250ZW50UXVlcmllcztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBtYXBcbiAqIEBwYXJhbSB7P30gcXVlcnlcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9hZGRRdWVyeVRvVG9rZW5NYXAobWFwLCBxdWVyeSkge1xuICAgIHF1ZXJ5Lm1ldGEuc2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJ5ID0gbWFwLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICBlbnRyeSA9IFtdO1xuICAgICAgICAgICAgbWFwLnNldCh0b2tlblJlZmVyZW5jZSh0b2tlbiksIGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbnRyeS5wdXNoKHF1ZXJ5KTtcbiAgICB9KTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBFbGVtZW50U2NoZW1hUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRTY2hlbWFSZWdpc3RyeSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSB0YWdOYW1lXG4gICAgICogQHBhcmFtIHs/fSBwcm9wTmFtZVxuICAgICAqIEBwYXJhbSB7P30gc2NoZW1hTWV0YXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuaGFzUHJvcGVydHkgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcE5hbWUsIHNjaGVtYU1ldGFzKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSB0YWdOYW1lXG4gICAgICogQHBhcmFtIHs/fSBzY2hlbWFNZXRhc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5oYXNFbGVtZW50ID0gZnVuY3Rpb24gKHRhZ05hbWUsIHNjaGVtYU1ldGFzKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50TmFtZVxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGlzQXR0cmlidXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLnNlY3VyaXR5Q29udGV4dCA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgcHJvcE5hbWUsIGlzQXR0cmlidXRlKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmFsbEtub3duRWxlbWVudE5hbWVzID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuZ2V0TWFwcGVkUHJvcE5hbWUgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuZ2V0RGVmYXVsdENvbXBvbmVudEVsZW1lbnROYW1lID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS52YWxpZGF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUudmFsaWRhdGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUubm9ybWFsaXplQW5pbWF0aW9uU3R5bGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wTmFtZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gY2FtZWxDYXNlUHJvcFxuICAgICAqIEBwYXJhbSB7P30gdXNlclByb3ZpZGVkUHJvcFxuICAgICAqIEBwYXJhbSB7P30gdmFsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLm5vcm1hbGl6ZUFuaW1hdGlvblN0eWxlVmFsdWUgPSBmdW5jdGlvbiAoY2FtZWxDYXNlUHJvcCwgdXNlclByb3ZpZGVkUHJvcCwgdmFsKSB7IH07XG4gICAgcmV0dXJuIEVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgU3R5bGVXaXRoSW1wb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVVcmxzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3R5bGVXaXRoSW1wb3J0cyhzdHlsZSQkMSwgc3R5bGVVcmxzKSB7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZSQkMTtcbiAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBzdHlsZVVybHM7XG4gICAgfVxuICAgIHJldHVybiBTdHlsZVdpdGhJbXBvcnRzO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB1cmxcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzU3R5bGVVcmxSZXNvbHZhYmxlKHVybCkge1xuICAgIGlmICh1cmwgPT0gbnVsbCB8fCB1cmwubGVuZ3RoID09PSAwIHx8IHVybFswXSA9PSAnLycpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY2hlbWVNYXRjaCA9IHVybC5tYXRjaChVUkxfV0lUSF9TQ0hFTUFfUkVHRVhQKTtcbiAgICByZXR1cm4gc2NoZW1lTWF0Y2ggPT09IG51bGwgfHwgc2NoZW1lTWF0Y2hbMV0gPT0gJ3BhY2thZ2UnIHx8IHNjaGVtZU1hdGNoWzFdID09ICdhc3NldCc7XG59XG4vKipcbiAqIFJld3JpdGVzIHN0eWxlc2hlZXRzIGJ5IHJlc29sdmluZyBhbmQgcmVtb3ZpbmcgdGhlIFxcQGltcG9ydCB1cmxzIHRoYXRcbiAqIGFyZSBlaXRoZXIgcmVsYXRpdmUgb3IgZG9uJ3QgaGF2ZSBhIGBwYWNrYWdlOmAgc2NoZW1lXG4gKiBAcGFyYW0gez99IHJlc29sdmVyXG4gKiBAcGFyYW0gez99IGJhc2VVcmxcbiAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFN0eWxlVXJscyhyZXNvbHZlciwgYmFzZVVybCwgY3NzVGV4dCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZvdW5kVXJscyA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZGlmaWVkQ3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZShDU1NfQ09NTUVOVF9SRUdFWFAsICcnKS5yZXBsYWNlKENTU19JTVBPUlRfUkVHRVhQLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBtW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXJsID0gbVsxXSB8fCBtWzJdO1xuICAgICAgICBpZiAoIWlzU3R5bGVVcmxSZXNvbHZhYmxlKHVybCkpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIHJlc29sdmUgbm9uLXBhY2thZ2UgYWJzb2x1dGUgVVJMcyB3aXRoIFVSSSBzY2hlbWVcbiAgICAgICAgICAgIHJldHVybiBtWzBdO1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kVXJscy5wdXNoKHJlc29sdmVyLnJlc29sdmUoYmFzZVVybCwgdXJsKSk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFN0eWxlV2l0aEltcG9ydHMobW9kaWZpZWRDc3NUZXh0LCBmb3VuZFVybHMpO1xufVxudmFyIENTU19JTVBPUlRfUkVHRVhQID0gL0BpbXBvcnRcXHMrKD86dXJsXFwoKT9cXHMqKD86KD86WydcIl0oW14nXCJdKikpfChbXjtcXClcXHNdKikpW147XSo7Py9nO1xudmFyIENTU19DT01NRU5UX1JFR0VYUCA9IC9cXC9cXCouKz9cXCpcXC8vZztcbnZhciBVUkxfV0lUSF9TQ0hFTUFfUkVHRVhQID0gL14oW146Lz8jXSspOi87XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgUFJPUEVSVFlfUEFSVFNfU0VQQVJBVE9SID0gJy4nO1xudmFyIEFUVFJJQlVURV9QUkVGSVggPSAnYXR0cic7XG52YXIgQ0xBU1NfUFJFRklYID0gJ2NsYXNzJztcbnZhciBTVFlMRV9QUkVGSVggPSAnc3R5bGUnO1xudmFyIEFOSU1BVEVfUFJPUF9QUkVGSVggPSAnYW5pbWF0ZS0nO1xudmFyIEJvdW5kUHJvcGVydHlUeXBlID0ge307XG5Cb3VuZFByb3BlcnR5VHlwZS5ERUZBVUxUID0gMDtcbkJvdW5kUHJvcGVydHlUeXBlLkxJVEVSQUxfQVRUUiA9IDE7XG5Cb3VuZFByb3BlcnR5VHlwZS5BTklNQVRJT04gPSAyO1xuQm91bmRQcm9wZXJ0eVR5cGVbQm91bmRQcm9wZXJ0eVR5cGUuREVGQVVMVF0gPSBcIkRFRkFVTFRcIjtcbkJvdW5kUHJvcGVydHlUeXBlW0JvdW5kUHJvcGVydHlUeXBlLkxJVEVSQUxfQVRUUl0gPSBcIkxJVEVSQUxfQVRUUlwiO1xuQm91bmRQcm9wZXJ0eVR5cGVbQm91bmRQcm9wZXJ0eVR5cGUuQU5JTUFUSU9OXSA9IFwiQU5JTUFUSU9OXCI7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBwYXJzZWQgcHJvcGVydHkuXG4gKi9cbnZhciBCb3VuZFByb3BlcnR5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCb3VuZFByb3BlcnR5KG5hbWUsIGV4cHJlc3Npb24sIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvdW5kUHJvcGVydHkucHJvdG90eXBlLCBcImlzTGl0ZXJhbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT09IEJvdW5kUHJvcGVydHlUeXBlLkxJVEVSQUxfQVRUUjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvdW5kUHJvcGVydHkucHJvdG90eXBlLCBcImlzQW5pbWF0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PT0gQm91bmRQcm9wZXJ0eVR5cGUuQU5JTUFUSU9OOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQm91bmRQcm9wZXJ0eTtcbn0oKSk7XG4vKipcbiAqIFBhcnNlcyBiaW5kaW5ncyBpbiB0ZW1wbGF0ZXMgYW5kIGluIHRoZSBkaXJlY3RpdmUgaG9zdCBhcmVhLlxuICovXG52YXIgQmluZGluZ1BhcnNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZXhwclBhcnNlclxuICAgICAqIEBwYXJhbSB7P30gX2ludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcGFyYW0gez99IF9zY2hlbWFSZWdpc3RyeVxuICAgICAqIEBwYXJhbSB7P30gcGlwZXNcbiAgICAgKiBAcGFyYW0gez99IF90YXJnZXRFcnJvcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCaW5kaW5nUGFyc2VyKF9leHByUGFyc2VyLCBfaW50ZXJwb2xhdGlvbkNvbmZpZywgX3NjaGVtYVJlZ2lzdHJ5LCBwaXBlcywgX3RhcmdldEVycm9ycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9leHByUGFyc2VyID0gX2V4cHJQYXJzZXI7XG4gICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgPSBfaW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICAgIHRoaXMuX3RhcmdldEVycm9ycyA9IF90YXJnZXRFcnJvcnM7XG4gICAgICAgIHRoaXMucGlwZXNCeU5hbWUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3VzZWRQaXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgcGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZSkgeyByZXR1cm4gX3RoaXMucGlwZXNCeU5hbWUuc2V0KHBpcGUubmFtZSwgcGlwZSk7IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLmdldFVzZWRQaXBlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fdXNlZFBpcGVzLnZhbHVlcygpKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpck1ldGFcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuY3JlYXRlRGlyZWN0aXZlSG9zdFByb3BlcnR5QXN0cyA9IGZ1bmN0aW9uIChkaXJNZXRhLCBlbGVtZW50U2VsZWN0b3IsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGRpck1ldGEuaG9zdFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvdW5kUHJvcHNfMSA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGlyTWV0YS5ob3N0UHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByZXNzaW9uID0gZGlyTWV0YS5ob3N0UHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXJzZVByb3BlcnR5QmluZGluZyhwcm9wTmFtZSwgZXhwcmVzc2lvbiwgdHJ1ZSwgc291cmNlU3BhbiwgW10sIGJvdW5kUHJvcHNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJWYWx1ZSBvZiB0aGUgaG9zdCBwcm9wZXJ0eSBiaW5kaW5nIFxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiIG5lZWRzIHRvIGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBleHByZXNzaW9uIGJ1dCBnb3QgXFxcIlwiICsgZXhwcmVzc2lvbiArIFwiXFxcIiAoXCIgKyB0eXBlb2YgZXhwcmVzc2lvbiArIFwiKVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBib3VuZFByb3BzXzEubWFwKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBfdGhpcy5jcmVhdGVFbGVtZW50UHJvcGVydHlBc3QoZWxlbWVudFNlbGVjdG9yLCBwcm9wKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpck1ldGFcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLmNyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMgPSBmdW5jdGlvbiAoZGlyTWV0YSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZGlyTWV0YS5ob3N0TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YXJnZXRFdmVudEFzdHNfMSA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGlyTWV0YS5ob3N0TGlzdGVuZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb24gPSBkaXJNZXRhLmhvc3RMaXN0ZW5lcnNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwcmVzc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFyc2VFdmVudChwcm9wTmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgW10sIHRhcmdldEV2ZW50QXN0c18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlZhbHVlIG9mIHRoZSBob3N0IGxpc3RlbmVyIFxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiIG5lZWRzIHRvIGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBleHByZXNzaW9uIGJ1dCBnb3QgXFxcIlwiICsgZXhwcmVzc2lvbiArIFwiXFxcIiAoXCIgKyB0eXBlb2YgZXhwcmVzc2lvbiArIFwiKVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRFdmVudEFzdHNfMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gKCh0aGlzLl9leHByUGFyc2VyLnBhcnNlSW50ZXJwb2xhdGlvbih2YWx1ZSwgc291cmNlSW5mbywgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZykpKTtcbiAgICAgICAgICAgIGlmIChhc3QpXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhhc3QuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGlwZXMoYXN0LCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByZWZpeFRva2VuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0TWF0Y2hhYmxlQXR0cnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFByb3BzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRWYXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyA9IGZ1bmN0aW9uIChwcmVmaXhUb2tlbiwgdmFsdWUsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcywgdGFyZ2V0VmFycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5ncyA9IHRoaXMuX3BhcnNlVGVtcGxhdGVCaW5kaW5ncyhwcmVmaXhUb2tlbiwgdmFsdWUsIHNvdXJjZVNwYW4pO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nLmtleUlzVmFyKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0VmFycy5wdXNoKG5ldyBWYXJpYWJsZUFzdChiaW5kaW5nLmtleSwgYmluZGluZy5uYW1lLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kaW5nLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KGJpbmRpbmcua2V5LCBiaW5kaW5nLmV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtiaW5kaW5nLmtleSwgJyddKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlTGl0ZXJhbEF0dHIoYmluZGluZy5rZXksIG51bGwsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJlZml4VG9rZW5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VUZW1wbGF0ZUJpbmRpbmdzID0gZnVuY3Rpb24gKHByZWZpeFRva2VuLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmluZGluZ3NSZXN1bHQgPSB0aGlzLl9leHByUGFyc2VyLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyhwcmVmaXhUb2tlbiwgdmFsdWUsIHNvdXJjZUluZm8pO1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhiaW5kaW5nc1Jlc3VsdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgYmluZGluZ3NSZXN1bHQudGVtcGxhdGVCaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2hlY2tQaXBlcyhiaW5kaW5nLmV4cHJlc3Npb24sIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmluZGluZ3NSZXN1bHQud2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAod2FybmluZykgeyBfdGhpcy5fcmVwb3J0RXJyb3Iod2FybmluZywgc291cmNlU3BhbiwgUGFyc2VFcnJvckxldmVsLldBUk5JTkcpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBiaW5kaW5nc1Jlc3VsdC50ZW1wbGF0ZUJpbmRpbmdzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlwiICsgZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IHRhcmdldE1hdGNoYWJsZUF0dHJzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRQcm9wc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VMaXRlcmFsQXR0ciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgIGlmIChfaXNBbmltYXRpb25MYWJlbChuYW1lKSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJBc3NpZ25pbmcgYW5pbWF0aW9uIHRyaWdnZXJzIHZpYSBAcHJvcD1cXFwiZXhwXFxcIiBhdHRyaWJ1dGVzIHdpdGggYW4gZXhwcmVzc2lvbiBpcyBpbnZhbGlkLlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgVXNlIHByb3BlcnR5IGJpbmRpbmdzIChlLmcuIFtAcHJvcF09XFxcImV4cFxcXCIpIG9yIHVzZSBhbiBhdHRyaWJ1dGUgd2l0aG91dCBhIHZhbHVlIChlLmcuIEBwcm9wKSBpbnN0ZWFkLlwiLCBzb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGFyc2VBbmltYXRpb24obmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRQcm9wcy5wdXNoKG5ldyBCb3VuZFByb3BlcnR5KG5hbWUsIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUodmFsdWUsICcnKSwgQm91bmRQcm9wZXJ0eVR5cGUuTElURVJBTF9BVFRSLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7P30gaXNIb3N0XG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRNYXRjaGFibGVBdHRyc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0UHJvcHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlCaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIGlzSG9zdCwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzQW5pbWF0aW9uUHJvcCA9IGZhbHNlO1xuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKEFOSU1BVEVfUFJPUF9QUkVGSVgpKSB7XG4gICAgICAgICAgICBpc0FuaW1hdGlvblByb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKEFOSU1BVEVfUFJPUF9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfaXNBbmltYXRpb25MYWJlbChuYW1lKSkge1xuICAgICAgICAgICAgaXNBbmltYXRpb25Qcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBbmltYXRpb25Qcm9wKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUFuaW1hdGlvbihuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eUFzdChuYW1lLCB0aGlzLl9wYXJzZUJpbmRpbmcoZXhwcmVzc2lvbiwgaXNIb3N0LCBzb3VyY2VTcGFuKSwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0TWF0Y2hhYmxlQXR0cnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFByb3BzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByb3BlcnR5SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHIgPSB0aGlzLnBhcnNlSW50ZXJwb2xhdGlvbih2YWx1ZSwgc291cmNlU3Bhbik7XG4gICAgICAgIGlmIChleHByKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KG5hbWUsIGV4cHIsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0TWF0Y2hhYmxlQXR0cnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFByb3BzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VQcm9wZXJ0eUFzdCA9IGZ1bmN0aW9uIChuYW1lLCBhc3QsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xuICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtuYW1lLCAvKiogQHR5cGUgez99ICovICgoYXN0LnNvdXJjZSkpXSk7XG4gICAgICAgIHRhcmdldFByb3BzLnB1c2gobmV3IEJvdW5kUHJvcGVydHkobmFtZSwgYXN0LCBCb3VuZFByb3BlcnR5VHlwZS5ERUZBVUxULCBzb3VyY2VTcGFuKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IHRhcmdldE1hdGNoYWJsZUF0dHJzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRQcm9wc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3BhcnNlQW5pbWF0aW9uID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xuICAgICAgICAvLyBUaGlzIHdpbGwgb2NjdXIgd2hlbiBhIEB0cmlnZ2VyIGlzIG5vdCBwYWlyZWQgd2l0aCBhbiBleHByZXNzaW9uLlxuICAgICAgICAvLyBGb3IgYW5pbWF0aW9ucyBpdCBpcyB2YWxpZCB0byBub3QgaGF2ZSBhbiBleHByZXNzaW9uIHNpbmNlICovdm9pZFxuICAgICAgICAvLyBzdGF0ZXMgd2lsbCBiZSBhcHBsaWVkIGJ5IGFuZ3VsYXIgd2hlbiB0aGUgZWxlbWVudCBpcyBhdHRhY2hlZC9kZXRhY2hlZFxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSB0aGlzLl9wYXJzZUJpbmRpbmcoZXhwcmVzc2lvbiB8fCAnbnVsbCcsIGZhbHNlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChbbmFtZSwgLyoqIEB0eXBlIHs/fSAqLyAoKGFzdC5zb3VyY2UpKV0pO1xuICAgICAgICB0YXJnZXRQcm9wcy5wdXNoKG5ldyBCb3VuZFByb3BlcnR5KG5hbWUsIGFzdCwgQm91bmRQcm9wZXJ0eVR5cGUuQU5JTUFUSU9OLCBzb3VyY2VTcGFuKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBpc0hvc3RCaW5kaW5nXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VCaW5kaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBpc0hvc3RCaW5kaW5nLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZUluZm8gPSBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSBpc0hvc3RCaW5kaW5nID9cbiAgICAgICAgICAgICAgICB0aGlzLl9leHByUGFyc2VyLnBhcnNlU2ltcGxlQmluZGluZyh2YWx1ZSwgc291cmNlSW5mbywgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZykgOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V4cHJQYXJzZXIucGFyc2VCaW5kaW5nKHZhbHVlLCBzb3VyY2VJbmZvLCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgIGlmIChhc3QpXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhhc3QuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGlwZXMoYXN0LCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gYm91bmRQcm9wXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50UHJvcGVydHlBc3QgPSBmdW5jdGlvbiAoZWxlbWVudFNlbGVjdG9yLCBib3VuZFByb3ApIHtcbiAgICAgICAgaWYgKGJvdW5kUHJvcC5pc0FuaW1hdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdChib3VuZFByb3AubmFtZSwgUHJvcGVydHlCaW5kaW5nVHlwZS5BbmltYXRpb24sIFNlY3VyaXR5Q29udGV4dC5OT05FLCBib3VuZFByb3AuZXhwcmVzc2lvbiwgbnVsbCwgYm91bmRQcm9wLnNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVuaXQgPSBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5nVHlwZSA9ICgodW5kZWZpbmVkKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvdW5kUHJvcGVydHlOYW1lID0gbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydHMgPSBib3VuZFByb3AubmFtZS5zcGxpdChQUk9QRVJUWV9QQVJUU19TRVBBUkFUT1IpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWN1cml0eUNvbnRleHRzID0gKCh1bmRlZmluZWQpKTtcbiAgICAgICAgLy8gQ2hlY2sgY2hlY2sgZm9yIHNwZWNpYWwgY2FzZXMgKHByZWZpeCBzdHlsZSwgYXR0ciwgY2xhc3MpXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpZiAocGFydHNbMF0gPT0gQVRUUklCVVRFX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVQcm9wZXJ0eU9yQXR0cmlidXRlTmFtZShib3VuZFByb3BlcnR5TmFtZSwgYm91bmRQcm9wLnNvdXJjZVNwYW4sIHRydWUpO1xuICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dHMgPSBjYWxjUG9zc2libGVTZWN1cml0eUNvbnRleHRzKHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LCBlbGVtZW50U2VsZWN0b3IsIGJvdW5kUHJvcGVydHlOYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuc1NlcGFyYXRvcklkeCA9IGJvdW5kUHJvcGVydHlOYW1lLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAobnNTZXBhcmF0b3JJZHggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBucyA9IGJvdW5kUHJvcGVydHlOYW1lLnN1YnN0cmluZygwLCBuc1NlcGFyYXRvcklkeCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBib3VuZFByb3BlcnR5TmFtZS5zdWJzdHJpbmcobnNTZXBhcmF0b3JJZHggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBtZXJnZU5zQW5kTmFtZShucywgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gUHJvcGVydHlCaW5kaW5nVHlwZS5BdHRyaWJ1dGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0c1swXSA9PSBDTEFTU19QUkVGSVgpIHtcbiAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gUHJvcGVydHlCaW5kaW5nVHlwZS5DbGFzcztcbiAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzID0gW1NlY3VyaXR5Q29udGV4dC5OT05FXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzWzBdID09IFNUWUxFX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSBwYXJ0cy5sZW5ndGggPiAyID8gcGFydHNbMl0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgYmluZGluZ1R5cGUgPSBQcm9wZXJ0eUJpbmRpbmdUeXBlLlN0eWxlO1xuICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dHMgPSBbU2VjdXJpdHlDb250ZXh0LlNUWUxFXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBub3QgYSBzcGVjaWFsIGNhc2UsIHVzZSB0aGUgZnVsbCBwcm9wZXJ0eSBuYW1lXG4gICAgICAgIGlmIChib3VuZFByb3BlcnR5TmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSB0aGlzLl9zY2hlbWFSZWdpc3RyeS5nZXRNYXBwZWRQcm9wTmFtZShib3VuZFByb3AubmFtZSk7XG4gICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzID0gY2FsY1Bvc3NpYmxlU2VjdXJpdHlDb250ZXh0cyh0aGlzLl9zY2hlbWFSZWdpc3RyeSwgZWxlbWVudFNlbGVjdG9yLCBib3VuZFByb3BlcnR5TmFtZSwgZmFsc2UpO1xuICAgICAgICAgICAgYmluZGluZ1R5cGUgPSBQcm9wZXJ0eUJpbmRpbmdUeXBlLlByb3BlcnR5O1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVQcm9wZXJ0eU9yQXR0cmlidXRlTmFtZShib3VuZFByb3BlcnR5TmFtZSwgYm91bmRQcm9wLnNvdXJjZVNwYW4sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kRWxlbWVudFByb3BlcnR5QXN0KGJvdW5kUHJvcGVydHlOYW1lLCBiaW5kaW5nVHlwZSwgc2VjdXJpdHlDb250ZXh0c1swXSwgYm91bmRQcm9wLmV4cHJlc3Npb24sIHVuaXQsIGJvdW5kUHJvcC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0TWF0Y2hhYmxlQXR0cnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldEV2ZW50c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKSB7XG4gICAgICAgIGlmIChfaXNBbmltYXRpb25MYWJlbChuYW1lKSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VBbmltYXRpb25FdmVudChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VFdmVudChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRFdmVudHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9wYXJzZUFuaW1hdGlvbkV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldEV2ZW50cykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVzID0gc3BsaXRBdFBlcmlvZChuYW1lLCBbbmFtZSwgJyddKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnROYW1lID0gbWF0Y2hlc1swXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGhhc2UgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChwaGFzZSkge1xuICAgICAgICAgICAgc3dpdGNoIChwaGFzZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdkb25lJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gdGhpcy5fcGFyc2VBY3Rpb24oZXhwcmVzc2lvbiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEV2ZW50cy5wdXNoKG5ldyBCb3VuZEV2ZW50QXN0KGV2ZW50TmFtZSwgbnVsbCwgcGhhc2UsIGFzdCwgc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlRoZSBwcm92aWRlZCBhbmltYXRpb24gb3V0cHV0IHBoYXNlIHZhbHVlIFxcXCJcIiArIHBoYXNlICsgXCJcXFwiIGZvciBcXFwiQFwiICsgZXZlbnROYW1lICsgXCJcXFwiIGlzIG5vdCBzdXBwb3J0ZWQgKHVzZSBzdGFydCBvciBkb25lKVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlRoZSBhbmltYXRpb24gdHJpZ2dlciBvdXRwdXQgZXZlbnQgKEBcIiArIGV2ZW50TmFtZSArIFwiKSBpcyBtaXNzaW5nIGl0cyBwaGFzZSB2YWx1ZSBuYW1lIChzdGFydCBvciBkb25lIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkKVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRNYXRjaGFibGVBdHRyc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0RXZlbnRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKSB7XG4gICAgICAgIC8vIGxvbmcgZm9ybWF0OiAndGFyZ2V0OiBldmVudE5hbWUnXG4gICAgICAgIHZhciBfYSA9IHNwbGl0QXRDb2xvbihuYW1lLCBbLyoqIEB0eXBlIHs/fSAqLyAoKG51bGwpKSwgbmFtZV0pLCB0YXJnZXQgPSBfYVswXSwgZXZlbnROYW1lID0gX2FbMV07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IHRoaXMuX3BhcnNlQWN0aW9uKGV4cHJlc3Npb24sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFsvKiogQHR5cGUgez99ICovICgobmFtZSkpLCAvKiogQHR5cGUgez99ICovICgoYXN0LnNvdXJjZSkpXSk7XG4gICAgICAgIHRhcmdldEV2ZW50cy5wdXNoKG5ldyBCb3VuZEV2ZW50QXN0KGV2ZW50TmFtZSwgdGFyZ2V0LCBudWxsLCBhc3QsIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgLy8gRG9uJ3QgZGV0ZWN0IGRpcmVjdGl2ZXMgZm9yIGV2ZW50IG5hbWVzIGZvciBub3csXG4gICAgICAgIC8vIHNvIGRvbid0IGFkZCB0aGUgZXZlbnQgbmFtZSB0byB0aGUgbWF0Y2hhYmxlQXR0cnNcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9wYXJzZUFjdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZUFjdGlvbih2YWx1ZSwgc291cmNlSW5mbywgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhhc3QuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXN0IHx8IGFzdC5hc3QgaW5zdGFuY2VvZiBFbXB0eUV4cHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkVtcHR5IGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZFwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGlwZXMoYXN0LCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez89fSBsZXZlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNvdXJjZVNwYW4sIGxldmVsKSB7XG4gICAgICAgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7IGxldmVsID0gUGFyc2VFcnJvckxldmVsLkVSUk9SOyB9XG4gICAgICAgIHRoaXMuX3RhcmdldEVycm9ycy5wdXNoKG5ldyBQYXJzZUVycm9yKHNvdXJjZVNwYW4sIG1lc3NhZ2UsIGxldmVsKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3JlcG9ydEV4cHJlc3Npb25QYXJzZXJFcnJvcnMgPSBmdW5jdGlvbiAoZXJyb3JzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgZXJyb3JzXzEgPSBlcnJvcnM7IF9pIDwgZXJyb3JzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBlcnJvcnNfMVtfaV07XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlcnJvci5tZXNzYWdlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9jaGVja1BpcGVzID0gZnVuY3Rpb24gKGFzdCwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYXN0KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2xsZWN0b3IgPSBuZXcgUGlwZUNvbGxlY3RvcigpO1xuICAgICAgICAgICAgYXN0LnZpc2l0KGNvbGxlY3Rvcik7XG4gICAgICAgICAgICBjb2xsZWN0b3IucGlwZXMuZm9yRWFjaChmdW5jdGlvbiAoYXN0LCBwaXBlTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGVNZXRhID0gX3RoaXMucGlwZXNCeU5hbWUuZ2V0KHBpcGVOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBpcGVNZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlRoZSBwaXBlICdcIiArIHBpcGVOYW1lICsgXCInIGNvdWxkIG5vdCBiZSBmb3VuZFwiLCBuZXcgUGFyc2VTb3VyY2VTcGFuKHNvdXJjZVNwYW4uc3RhcnQubW92ZUJ5KGFzdC5zcGFuLnN0YXJ0KSwgc291cmNlU3Bhbi5zdGFydC5tb3ZlQnkoYXN0LnNwYW4uZW5kKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3VzZWRQaXBlcy5zZXQocGlwZU5hbWUsIHBpcGVNZXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm9wTmFtZSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgLyBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IGlzQXR0ciB0cnVlIHdoZW4gYmluZGluZyB0byBhbiBhdHRyaWJ1dGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl92YWxpZGF0ZVByb3BlcnR5T3JBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKHByb3BOYW1lLCBzb3VyY2VTcGFuLCBpc0F0dHIpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVwb3J0ID0gaXNBdHRyID8gdGhpcy5fc2NoZW1hUmVnaXN0cnkudmFsaWRhdGVBdHRyaWJ1dGUocHJvcE5hbWUpIDpcbiAgICAgICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LnZhbGlkYXRlUHJvcGVydHkocHJvcE5hbWUpO1xuICAgICAgICBpZiAocmVwb3J0LmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcigvKiogQHR5cGUgez99ICovICgocmVwb3J0Lm1zZykpLCBzb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuRVJST1IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQmluZGluZ1BhcnNlcjtcbn0oKSk7XG52YXIgUGlwZUNvbGxlY3RvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBpcGVDb2xsZWN0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGlwZUNvbGxlY3RvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBpcGVDb2xsZWN0b3IucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5waXBlcy5zZXQoYXN0Lm5hbWUsIGFzdCk7XG4gICAgICAgIGFzdC5leHAudmlzaXQodGhpcyk7XG4gICAgICAgIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBQaXBlQ29sbGVjdG9yO1xufShSZWN1cnNpdmVBc3RWaXNpdG9yKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gbmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2lzQW5pbWF0aW9uTGFiZWwobmFtZSkge1xuICAgIHJldHVybiBuYW1lWzBdID09ICdAJztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSByZWdpc3RyeVxuICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICogQHBhcmFtIHs/fSBwcm9wTmFtZVxuICogQHBhcmFtIHs/fSBpc0F0dHJpYnV0ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY2FsY1Bvc3NpYmxlU2VjdXJpdHlDb250ZXh0cyhyZWdpc3RyeSwgc2VsZWN0b3IsIHByb3BOYW1lLCBpc0F0dHJpYnV0ZSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0eHMgPSBbXTtcbiAgICBDc3NTZWxlY3Rvci5wYXJzZShzZWxlY3RvcikuZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudE5hbWVzID0gc2VsZWN0b3IuZWxlbWVudCA/IFtzZWxlY3Rvci5lbGVtZW50XSA6IHJlZ2lzdHJ5LmFsbEtub3duRWxlbWVudE5hbWVzKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vdEVsZW1lbnROYW1lcyA9IG5ldyBTZXQoc2VsZWN0b3Iubm90U2VsZWN0b3JzLmZpbHRlcihmdW5jdGlvbiAoc2VsZWN0b3IpIHsgcmV0dXJuIHNlbGVjdG9yLmlzRWxlbWVudFNlbGVjdG9yKCk7IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzZWxlY3RvcikgeyByZXR1cm4gc2VsZWN0b3IuZWxlbWVudDsgfSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwb3NzaWJsZUVsZW1lbnROYW1lcyA9IGVsZW1lbnROYW1lcy5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnROYW1lKSB7IHJldHVybiAhbm90RWxlbWVudE5hbWVzLmhhcyhlbGVtZW50TmFtZSk7IH0pO1xuICAgICAgICBjdHhzLnB1c2guYXBwbHkoY3R4cywgcG9zc2libGVFbGVtZW50TmFtZXMubWFwKGZ1bmN0aW9uIChlbGVtZW50TmFtZSkgeyByZXR1cm4gcmVnaXN0cnkuc2VjdXJpdHlDb250ZXh0KGVsZW1lbnROYW1lLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpOyB9KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGN0eHMubGVuZ3RoID09PSAwID8gW1NlY3VyaXR5Q29udGV4dC5OT05FXSA6IEFycmF5LmZyb20obmV3IFNldChjdHhzKSkuc29ydCgpO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIE5HX0NPTlRFTlRfU0VMRUNUX0FUVFIgPSAnc2VsZWN0JztcbnZhciBMSU5LX0VMRU1FTlQgPSAnbGluayc7XG52YXIgTElOS19TVFlMRV9SRUxfQVRUUiA9ICdyZWwnO1xudmFyIExJTktfU1RZTEVfSFJFRl9BVFRSID0gJ2hyZWYnO1xudmFyIExJTktfU1RZTEVfUkVMX1ZBTFVFID0gJ3N0eWxlc2hlZXQnO1xudmFyIFNUWUxFX0VMRU1FTlQgPSAnc3R5bGUnO1xudmFyIFNDUklQVF9FTEVNRU5UID0gJ3NjcmlwdCc7XG52YXIgTkdfTk9OX0JJTkRBQkxFX0FUVFIgPSAnbmdOb25CaW5kYWJsZSc7XG52YXIgTkdfUFJPSkVDVF9BUyA9ICduZ1Byb2plY3RBcyc7XG4vKipcbiAqIEBwYXJhbSB7P30gYXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwcmVwYXJzZUVsZW1lbnQoYXN0KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0QXR0ciA9ICgobnVsbCkpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGhyZWZBdHRyID0gKChudWxsKSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVsQXR0ciA9ICgobnVsbCkpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vbkJpbmRhYmxlID0gZmFsc2U7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvamVjdEFzID0gKChudWxsKSk7XG4gICAgYXN0LmF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGNBdHRyTmFtZSA9IGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobGNBdHRyTmFtZSA9PSBOR19DT05URU5UX1NFTEVDVF9BVFRSKSB7XG4gICAgICAgICAgICBzZWxlY3RBdHRyID0gYXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsY0F0dHJOYW1lID09IExJTktfU1RZTEVfSFJFRl9BVFRSKSB7XG4gICAgICAgICAgICBocmVmQXR0ciA9IGF0dHIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGNBdHRyTmFtZSA9PSBMSU5LX1NUWUxFX1JFTF9BVFRSKSB7XG4gICAgICAgICAgICByZWxBdHRyID0gYXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUgPT0gTkdfTk9OX0JJTkRBQkxFX0FUVFIpIHtcbiAgICAgICAgICAgIG5vbkJpbmRhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUgPT0gTkdfUFJPSkVDVF9BUykge1xuICAgICAgICAgICAgaWYgKGF0dHIudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHByb2plY3RBcyA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBzZWxlY3RBdHRyID0gbm9ybWFsaXplTmdDb250ZW50U2VsZWN0KHNlbGVjdEF0dHIpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVOYW1lID0gYXN0Lm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuT1RIRVI7XG4gICAgaWYgKGlzTmdDb250ZW50KG5vZGVOYW1lKSkge1xuICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuTkdfQ09OVEVOVDtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZU5hbWUgPT0gU1RZTEVfRUxFTUVOVCkge1xuICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEU7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGVOYW1lID09IFNDUklQVF9FTEVNRU5UKSB7XG4gICAgICAgIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGVOYW1lID09IExJTktfRUxFTUVOVCAmJiByZWxBdHRyID09IExJTktfU1RZTEVfUkVMX1ZBTFVFKSB7XG4gICAgICAgIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByZXBhcnNlZEVsZW1lbnQodHlwZSwgc2VsZWN0QXR0ciwgaHJlZkF0dHIsIG5vbkJpbmRhYmxlLCBwcm9qZWN0QXMpO1xufVxudmFyIFByZXBhcnNlZEVsZW1lbnRUeXBlID0ge307XG5QcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UID0gMDtcblByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFID0gMTtcblByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQgPSAyO1xuUHJlcGFyc2VkRWxlbWVudFR5cGUuU0NSSVBUID0gMztcblByZXBhcnNlZEVsZW1lbnRUeXBlLk9USEVSID0gNDtcblByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlRdID0gXCJOR19DT05URU5UXCI7XG5QcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRV0gPSBcIlNUWUxFXCI7XG5QcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUXSA9IFwiU1RZTEVTSEVFVFwiO1xuUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGUuU0NSSVBUXSA9IFwiU0NSSVBUXCI7XG5QcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZS5PVEhFUl0gPSBcIk9USEVSXCI7XG52YXIgUHJlcGFyc2VkRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RBdHRyXG4gICAgICogQHBhcmFtIHs/fSBocmVmQXR0clxuICAgICAqIEBwYXJhbSB7P30gbm9uQmluZGFibGVcbiAgICAgKiBAcGFyYW0gez99IHByb2plY3RBc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFByZXBhcnNlZEVsZW1lbnQodHlwZSwgc2VsZWN0QXR0ciwgaHJlZkF0dHIsIG5vbkJpbmRhYmxlLCBwcm9qZWN0QXMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zZWxlY3RBdHRyID0gc2VsZWN0QXR0cjtcbiAgICAgICAgdGhpcy5ocmVmQXR0ciA9IGhyZWZBdHRyO1xuICAgICAgICB0aGlzLm5vbkJpbmRhYmxlID0gbm9uQmluZGFibGU7XG4gICAgICAgIHRoaXMucHJvamVjdEFzID0gcHJvamVjdEFzO1xuICAgIH1cbiAgICByZXR1cm4gUHJlcGFyc2VkRWxlbWVudDtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gc2VsZWN0QXR0clxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplTmdDb250ZW50U2VsZWN0KHNlbGVjdEF0dHIpIHtcbiAgICBpZiAoc2VsZWN0QXR0ciA9PT0gbnVsbCB8fCBzZWxlY3RBdHRyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyonO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0QXR0cjtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBCSU5EX05BTUVfUkVHRVhQID0gL14oPzooPzooPzooYmluZC0pfChsZXQtKXwocmVmLXwjKXwob24tKXwoYmluZG9uLSl8KEApKSguKykpfFxcW1xcKChbXlxcKV0rKVxcKVxcXXxcXFsoW15cXF1dKylcXF18XFwoKFteXFwpXSspXFwpKSQvO1xuLy8gR3JvdXAgMSA9IFwiYmluZC1cIlxudmFyIEtXX0JJTkRfSURYID0gMTtcbi8vIEdyb3VwIDIgPSBcImxldC1cIlxudmFyIEtXX0xFVF9JRFggPSAyO1xuLy8gR3JvdXAgMyA9IFwicmVmLS8jXCJcbnZhciBLV19SRUZfSURYID0gMztcbi8vIEdyb3VwIDQgPSBcIm9uLVwiXG52YXIgS1dfT05fSURYID0gNDtcbi8vIEdyb3VwIDUgPSBcImJpbmRvbi1cIlxudmFyIEtXX0JJTkRPTl9JRFggPSA1O1xuLy8gR3JvdXAgNiA9IFwiQFwiXG52YXIgS1dfQVRfSURYID0gNjtcbi8vIEdyb3VwIDcgPSB0aGUgaWRlbnRpZmllciBhZnRlciBcImJpbmQtXCIsIFwibGV0LVwiLCBcInJlZi0vI1wiLCBcIm9uLVwiLCBcImJpbmRvbi1cIiBvciBcIkBcIlxudmFyIElERU5UX0tXX0lEWCA9IDc7XG4vLyBHcm91cCA4ID0gaWRlbnRpZmllciBpbnNpZGUgWygpXVxudmFyIElERU5UX0JBTkFOQV9CT1hfSURYID0gODtcbi8vIEdyb3VwIDkgPSBpZGVudGlmaWVyIGluc2lkZSBbXVxudmFyIElERU5UX1BST1BFUlRZX0lEWCA9IDk7XG4vLyBHcm91cCAxMCA9IGlkZW50aWZpZXIgaW5zaWRlICgpXG52YXIgSURFTlRfRVZFTlRfSURYID0gMTA7XG4vLyBkZXByZWNhdGVkIGluIDQueFxudmFyIFRFTVBMQVRFX0VMRU1FTlQgPSAndGVtcGxhdGUnO1xuLy8gZGVwcmVjYXRlZCBpbiA0LnhcbnZhciBURU1QTEFURV9BVFRSID0gJ3RlbXBsYXRlJztcbnZhciBURU1QTEFURV9BVFRSX1BSRUZJWCA9ICcqJztcbnZhciBDTEFTU19BVFRSID0gJ2NsYXNzJztcbnZhciBURVhUX0NTU19TRUxFQ1RPUiA9IENzc1NlbGVjdG9yLnBhcnNlKCcqJylbMF07XG52YXIgVEVNUExBVEVfRUxFTUVOVF9ERVBSRUNBVElPTl9XQVJOSU5HID0gJ1RoZSA8dGVtcGxhdGU+IGVsZW1lbnQgaXMgZGVwcmVjYXRlZC4gVXNlIDxuZy10ZW1wbGF0ZT4gaW5zdGVhZCc7XG52YXIgVEVNUExBVEVfQVRUUl9ERVBSRUNBVElPTl9XQVJOSU5HID0gJ1RoZSB0ZW1wbGF0ZSBhdHRyaWJ1dGUgaXMgZGVwcmVjYXRlZC4gVXNlIGFuIG5nLXRlbXBsYXRlIGVsZW1lbnQgaW5zdGVhZC4nO1xudmFyIHdhcm5pbmdDb3VudHMgPSB7fTtcbi8qKlxuICogQHBhcmFtIHs/fSB3YXJuaW5nc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gd2Fybk9ubHlPbmNlKHdhcm5pbmdzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAod2FybmluZ3MuaW5kZXhPZihlcnJvci5tc2cpICE9PSAtMSkge1xuICAgICAgICAgICAgd2FybmluZ0NvdW50c1tlcnJvci5tc2ddID0gKHdhcm5pbmdDb3VudHNbZXJyb3IubXNnXSB8fCAwKSArIDE7XG4gICAgICAgICAgICByZXR1cm4gd2FybmluZ0NvdW50c1tlcnJvci5tc2ddIDw9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuICogUHJvdmlkZXMgYW4gYXJyYXkgb2Yge0BsaW5rIFRlbXBsYXRlQXN0VmlzaXRvcn1zIHdoaWNoIHdpbGwgYmUgdXNlZCB0byB0cmFuc2Zvcm1cbiAqIHBhcnNlZCB0ZW1wbGF0ZXMgYmVmb3JlIGNvbXBpbGF0aW9uIGlzIGludm9rZWQsIGFsbG93aW5nIGN1c3RvbSBleHByZXNzaW9uIHN5bnRheFxuICogYW5kIG90aGVyIGFkdmFuY2VkIHRyYW5zZm9ybWF0aW9ucy5cbiAqXG4gKiBUaGlzIGlzIGN1cnJlbnRseSBhbiBpbnRlcm5hbC1vbmx5IGZlYXR1cmUgYW5kIG5vdCBtZWFudCBmb3IgZ2VuZXJhbCB1c2UuXG4gKi9cbnZhciBURU1QTEFURV9UUkFOU0ZPUk1TID0gbmV3IEluamVjdGlvblRva2VuKCdUZW1wbGF0ZVRyYW5zZm9ybXMnKTtcbnZhciBUZW1wbGF0ZVBhcnNlRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUZW1wbGF0ZVBhcnNlRXJyb3IsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSBsZXZlbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VFcnJvcihtZXNzYWdlLCBzcGFuLCBsZXZlbCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgbWVzc2FnZSwgbGV2ZWwpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBUZW1wbGF0ZVBhcnNlRXJyb3I7XG59KFBhcnNlRXJyb3IpKTtcbnZhciBUZW1wbGF0ZVBhcnNlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSB0ZW1wbGF0ZUFzdFxuICAgICAqIEBwYXJhbSB7Pz19IHVzZWRQaXBlc1xuICAgICAqIEBwYXJhbSB7Pz19IGVycm9yc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VSZXN1bHQodGVtcGxhdGVBc3QsIHVzZWRQaXBlcywgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVBc3QgPSB0ZW1wbGF0ZUFzdDtcbiAgICAgICAgdGhpcy51c2VkUGlwZXMgPSB1c2VkUGlwZXM7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gVGVtcGxhdGVQYXJzZVJlc3VsdDtcbn0oKSk7XG52YXIgVGVtcGxhdGVQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2NvbmZpZ1xuICAgICAqIEBwYXJhbSB7P30gX2V4cHJQYXJzZXJcbiAgICAgKiBAcGFyYW0gez99IF9zY2hlbWFSZWdpc3RyeVxuICAgICAqIEBwYXJhbSB7P30gX2h0bWxQYXJzZXJcbiAgICAgKiBAcGFyYW0gez99IF9jb25zb2xlXG4gICAgICogQHBhcmFtIHs/fSB0cmFuc2Zvcm1zXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVQYXJzZXIoX2NvbmZpZywgX2V4cHJQYXJzZXIsIF9zY2hlbWFSZWdpc3RyeSwgX2h0bWxQYXJzZXIsIF9jb25zb2xlLCB0cmFuc2Zvcm1zKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IF9jb25maWc7XG4gICAgICAgIHRoaXMuX2V4cHJQYXJzZXIgPSBfZXhwclBhcnNlcjtcbiAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgdGhpcy5fY29uc29sZSA9IF9jb25zb2xlO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybXMgPSB0cmFuc2Zvcm1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHBpcGVzXG4gICAgICogQHBhcmFtIHs/fSBzY2hlbWFzXG4gICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZVVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgdGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzLCB0ZW1wbGF0ZVVybCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKGNvbXBvbmVudCwgdGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzLCB0ZW1wbGF0ZVVybCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHdhcm5pbmdzID0gKChyZXN1bHQuZXJyb3JzKSkuZmlsdGVyKGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gZXJyb3IubGV2ZWwgPT09IFBhcnNlRXJyb3JMZXZlbC5XQVJOSU5HOyB9KVxuICAgICAgICAgICAgLmZpbHRlcih3YXJuT25seU9uY2UoW1RFTVBMQVRFX0FUVFJfREVQUkVDQVRJT05fV0FSTklORywgVEVNUExBVEVfRUxFTUVOVF9ERVBSRUNBVElPTl9XQVJOSU5HXSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvcnMgPSAoKHJlc3VsdC5lcnJvcnMpKS5maWx0ZXIoZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBlcnJvci5sZXZlbCA9PT0gUGFyc2VFcnJvckxldmVsLkVSUk9SOyB9KTtcbiAgICAgICAgaWYgKHdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUud2FybihcIlRlbXBsYXRlIHBhcnNlIHdhcm5pbmdzOlxcblwiICsgd2FybmluZ3Muam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JTdHJpbmcgPSBlcnJvcnMuam9pbignXFxuJyk7XG4gICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcIlRlbXBsYXRlIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9yU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0ZW1wbGF0ZTogLyoqIEB0eXBlIHs/fSAqLyAoKHJlc3VsdC50ZW1wbGF0ZUFzdCkpLCBwaXBlczogLyoqIEB0eXBlIHs/fSAqLyAoKHJlc3VsdC51c2VkUGlwZXMpKSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVzXG4gICAgICogQHBhcmFtIHs/fSBwaXBlc1xuICAgICAqIEBwYXJhbSB7P30gc2NoZW1hc1xuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVVcmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS50cnlQYXJzZSA9IGZ1bmN0aW9uIChjb21wb25lbnQsIHRlbXBsYXRlLCBkaXJlY3RpdmVzLCBwaXBlcywgc2NoZW1hcywgdGVtcGxhdGVVcmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJ5UGFyc2VIdG1sKHRoaXMuZXhwYW5kSHRtbCgvKiogQHR5cGUgez99ICovICgodGhpcy5faHRtbFBhcnNlcikpLnBhcnNlKHRlbXBsYXRlLCB0ZW1wbGF0ZVVybCwgdHJ1ZSwgdGhpcy5nZXRJbnRlcnBvbGF0aW9uQ29uZmlnKGNvbXBvbmVudCkpKSwgY29tcG9uZW50LCBkaXJlY3RpdmVzLCBwaXBlcywgc2NoZW1hcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGh0bWxBc3RXaXRoRXJyb3JzXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHBpcGVzXG4gICAgICogQHBhcmFtIHs/fSBzY2hlbWFzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlci5wcm90b3R5cGUudHJ5UGFyc2VIdG1sID0gZnVuY3Rpb24gKGh0bWxBc3RXaXRoRXJyb3JzLCBjb21wb25lbnQsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gaHRtbEFzdFdpdGhFcnJvcnMuZXJyb3JzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1c2VkUGlwZXMgPSBbXTtcbiAgICAgICAgaWYgKGh0bWxBc3RXaXRoRXJyb3JzLnJvb3ROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1bmlxRGlyZWN0aXZlcyA9IHJlbW92ZVN1bW1hcnlEdXBsaWNhdGVzKGRpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdW5pcVBpcGVzID0gcmVtb3ZlU3VtbWFyeUR1cGxpY2F0ZXMocGlwZXMpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvdmlkZXJWaWV3Q29udGV4dCA9IG5ldyBQcm92aWRlclZpZXdDb250ZXh0KGNvbXBvbmVudCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gKCh1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQudGVtcGxhdGUgJiYgY29tcG9uZW50LnRlbXBsYXRlLmludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogY29tcG9uZW50LnRlbXBsYXRlLmludGVycG9sYXRpb25bMF0sXG4gICAgICAgICAgICAgICAgICAgIGVuZDogY29tcG9uZW50LnRlbXBsYXRlLmludGVycG9sYXRpb25bMV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmluZGluZ1BhcnNlciA9IG5ldyBCaW5kaW5nUGFyc2VyKHRoaXMuX2V4cHJQYXJzZXIsIC8qKiBAdHlwZSB7P30gKi8gKChpbnRlcnBvbGF0aW9uQ29uZmlnKSksIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LCB1bmlxUGlwZXMsIGVycm9ycyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJzZVZpc2l0b3IgPSBuZXcgVGVtcGxhdGVQYXJzZVZpc2l0b3IodGhpcy5fY29uZmlnLCBwcm92aWRlclZpZXdDb250ZXh0LCB1bmlxRGlyZWN0aXZlcywgYmluZGluZ1BhcnNlciwgdGhpcy5fc2NoZW1hUmVnaXN0cnksIHNjaGVtYXMsIGVycm9ycyk7XG4gICAgICAgICAgICByZXN1bHQgPSB2aXNpdEFsbChwYXJzZVZpc2l0b3IsIGh0bWxBc3RXaXRoRXJyb3JzLnJvb3ROb2RlcywgRU1QVFlfRUxFTUVOVF9DT05URVhUKTtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgcHJvdmlkZXJWaWV3Q29udGV4dC5lcnJvcnMpO1xuICAgICAgICAgICAgdXNlZFBpcGVzLnB1c2guYXBwbHkodXNlZFBpcGVzLCBiaW5kaW5nUGFyc2VyLmdldFVzZWRQaXBlcygpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Fzc2VydE5vUmVmZXJlbmNlRHVwbGljYXRpb25PblRlbXBsYXRlKHJlc3VsdCwgZXJyb3JzKTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlUGFyc2VSZXN1bHQocmVzdWx0LCB1c2VkUGlwZXMsIGVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3Jtcykge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1zLmZvckVhY2goZnVuY3Rpb24gKHRyYW5zZm9ybSkgeyByZXN1bHQgPSB0ZW1wbGF0ZVZpc2l0QWxsKHRyYW5zZm9ybSwgcmVzdWx0KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZVBhcnNlUmVzdWx0KHJlc3VsdCwgdXNlZFBpcGVzLCBlcnJvcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBodG1sQXN0V2l0aEVycm9yc1xuICAgICAqIEBwYXJhbSB7Pz19IGZvcmNlZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLmV4cGFuZEh0bWwgPSBmdW5jdGlvbiAoaHRtbEFzdFdpdGhFcnJvcnMsIGZvcmNlZCkge1xuICAgICAgICBpZiAoZm9yY2VkID09PSB2b2lkIDApIHsgZm9yY2VkID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gaHRtbEFzdFdpdGhFcnJvcnMuZXJyb3JzO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA9PSAwIHx8IGZvcmNlZCkge1xuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElDVSBtZXNzYWdlcyB0byBhbmd1bGFyIGRpcmVjdGl2ZXNcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cGFuZGVkSHRtbEFzdCA9IGV4cGFuZE5vZGVzKGh0bWxBc3RXaXRoRXJyb3JzLnJvb3ROb2Rlcyk7XG4gICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGV4cGFuZGVkSHRtbEFzdC5lcnJvcnMpO1xuICAgICAgICAgICAgaHRtbEFzdFdpdGhFcnJvcnMgPSBuZXcgUGFyc2VUcmVlUmVzdWx0KGV4cGFuZGVkSHRtbEFzdC5ub2RlcywgZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbEFzdFdpdGhFcnJvcnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLmdldEludGVycG9sYXRpb25Db25maWcgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIGlmIChjb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheShjb21wb25lbnQudGVtcGxhdGUuaW50ZXJwb2xhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSByZXN1bHRcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLl9hc3NlcnROb1JlZmVyZW5jZUR1cGxpY2F0aW9uT25UZW1wbGF0ZSA9IGZ1bmN0aW9uIChyZXN1bHQsIGVycm9ycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleGlzdGluZ1JlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgcmVzdWx0LmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gISEoKGVsZW1lbnQpKS5yZWZlcmVuY2VzOyB9KVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuICgoZWxlbWVudCkpLnJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAocmVmZXJlbmNlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gcmVmZXJlbmNlLm5hbWU7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdSZWZlcmVuY2VzLmluZGV4T2YobmFtZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdSZWZlcmVuY2VzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvciA9IG5ldyBUZW1wbGF0ZVBhcnNlRXJyb3IoXCJSZWZlcmVuY2UgXFxcIiNcIiArIG5hbWUgKyBcIlxcXCIgaXMgZGVmaW5lZCBzZXZlcmFsIHRpbWVzXCIsIHJlZmVyZW5jZS5zb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuRVJST1IpO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRlbXBsYXRlUGFyc2VyO1xufSgpKTtcblRlbXBsYXRlUGFyc2VyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblRlbXBsYXRlUGFyc2VyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJDb25maWcsIH0sXG4gICAgeyB0eXBlOiBQYXJzZXIsIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50U2NoZW1hUmVnaXN0cnksIH0sXG4gICAgeyB0eXBlOiBJMThOSHRtbFBhcnNlciwgfSxcbiAgICB7IHR5cGU6IMm1Q29uc29sZSwgfSxcbiAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW1RFTVBMQVRFX1RSQU5TRk9STVMsXSB9LF0gfSxcbl07IH07XG52YXIgVGVtcGxhdGVQYXJzZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29uZmlnXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlclZpZXdDb250ZXh0XG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVzXG4gICAgICogQHBhcmFtIHs/fSBfYmluZGluZ1BhcnNlclxuICAgICAqIEBwYXJhbSB7P30gX3NjaGVtYVJlZ2lzdHJ5XG4gICAgICogQHBhcmFtIHs/fSBfc2NoZW1hc1xuICAgICAqIEBwYXJhbSB7P30gX3RhcmdldEVycm9yc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VWaXNpdG9yKGNvbmZpZywgcHJvdmlkZXJWaWV3Q29udGV4dCwgZGlyZWN0aXZlcywgX2JpbmRpbmdQYXJzZXIsIF9zY2hlbWFSZWdpc3RyeSwgX3NjaGVtYXMsIF90YXJnZXRFcnJvcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMucHJvdmlkZXJWaWV3Q29udGV4dCA9IHByb3ZpZGVyVmlld0NvbnRleHQ7XG4gICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIgPSBfYmluZGluZ1BhcnNlcjtcbiAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICAgIHRoaXMuX3NjaGVtYXMgPSBfc2NoZW1hcztcbiAgICAgICAgdGhpcy5fdGFyZ2V0RXJyb3JzID0gX3RhcmdldEVycm9ycztcbiAgICAgICAgdGhpcy5zZWxlY3Rvck1hdGNoZXIgPSBuZXcgU2VsZWN0b3JNYXRjaGVyKCk7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlc0luZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm5nQ29udGVudENvdW50ID0gMDtcbiAgICAgICAgLy8gTm90ZTogcXVlcmllcyBzdGFydCB3aXRoIGlkIDEgc28gd2UgY2FuIHVzZSB0aGUgbnVtYmVyIGluIGEgQmxvb20gZmlsdGVyIVxuICAgICAgICB0aGlzLmNvbnRlbnRRdWVyeVN0YXJ0SWQgPSBwcm92aWRlclZpZXdDb250ZXh0LmNvbXBvbmVudC52aWV3UXVlcmllcy5sZW5ndGggKyAxO1xuICAgICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IENzc1NlbGVjdG9yLnBhcnNlKGRpcmVjdGl2ZS5zZWxlY3Rvcik7XG4gICAgICAgICAgICBfdGhpcy5zZWxlY3Rvck1hdGNoZXIuYWRkU2VsZWN0YWJsZXMoc2VsZWN0b3IsIGRpcmVjdGl2ZSk7XG4gICAgICAgICAgICBfdGhpcy5kaXJlY3RpdmVzSW5kZXguc2V0KGRpcmVjdGl2ZSwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHBhbnNpb25cbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24sIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHBhbnNpb25DYXNlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgcGFyZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nQ29udGVudEluZGV4ID0gKChwYXJlbnQuZmluZE5nQ29udGVudEluZGV4KFRFWFRfQ1NTX1NFTEVDVE9SKSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByID0gdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUludGVycG9sYXRpb24odGV4dC52YWx1ZSwgLyoqIEB0eXBlIHs/fSAqLyAoKHRleHQuc291cmNlU3BhbikpKTtcbiAgICAgICAgcmV0dXJuIGV4cHIgPyBuZXcgQm91bmRUZXh0QXN0KGV4cHIsIG5nQ29udGVudEluZGV4LCAvKiogQHR5cGUgez99ICovICgodGV4dC5zb3VyY2VTcGFuKSkpIDpcbiAgICAgICAgICAgIG5ldyBUZXh0QXN0KHRleHQudmFsdWUsIG5nQ29udGVudEluZGV4LCAvKiogQHR5cGUgez99ICovICgodGV4dC5zb3VyY2VTcGFuKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyQXN0KGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUsIGF0dHJpYnV0ZS5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyeVN0YXJ0SW5kZXggPSB0aGlzLmNvbnRlbnRRdWVyeVN0YXJ0SWQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVOYW1lID0gZWxlbWVudC5uYW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFQgfHxcbiAgICAgICAgICAgIHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEUpIHtcbiAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzY3JpcHQ+IGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICAgICAgICAvLyBTa2lwcGluZyA8c3R5bGU+IGFzIHdlIGFscmVhZHkgcHJvY2Vzc2VkIHRoZW1cbiAgICAgICAgICAgIC8vIGluIHRoZSBTdHlsZUNvbXBpbGVyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUICYmXG4gICAgICAgICAgICBpc1N0eWxlVXJsUmVzb2x2YWJsZShwcmVwYXJzZWRFbGVtZW50LmhyZWZBdHRyKSkge1xuICAgICAgICAgICAgLy8gU2tpcHBpbmcgc3R5bGVzaGVldHMgd2l0aCBlaXRoZXIgcmVsYXRpdmUgdXJscyBvciBwYWNrYWdlIHNjaGVtZSBhcyB3ZSBhbHJlYWR5IHByb2Nlc3NlZFxuICAgICAgICAgICAgLy8gdGhlbSBpbiB0aGUgU3R5bGVDb21waWxlclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hhYmxlQXR0cnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudE9yRGlyZWN0aXZlUHJvcHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudE9yRGlyZWN0aXZlUmVmcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50VmFycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVFbGVtZW50T3JEaXJlY3RpdmVQcm9wcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZU1hdGNoYWJsZUF0dHJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlRWxlbWVudFZhcnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFzSW5saW5lVGVtcGxhdGVzID0gZmFsc2U7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzVGVtcGxhdGVFbGVtZW50ID0gaXNUZW1wbGF0ZShlbGVtZW50LCB0aGlzLmNvbmZpZy5lbmFibGVMZWdhY3lUZW1wbGF0ZSwgZnVuY3Rpb24gKG0sIHNwYW4pIHsgcmV0dXJuIF90aGlzLl9yZXBvcnRFcnJvcihtLCBzcGFuLCBQYXJzZUVycm9yTGV2ZWwuV0FSTklORyk7IH0pO1xuICAgICAgICBlbGVtZW50LmF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhc0JpbmRpbmcgPSBfdGhpcy5fcGFyc2VBdHRyKGlzVGVtcGxhdGVFbGVtZW50LCBhdHRyLCBtYXRjaGFibGVBdHRycywgZWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIGV2ZW50cywgZWxlbWVudE9yRGlyZWN0aXZlUmVmcywgZWxlbWVudFZhcnMpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVCaW5kaW5nc1NvdXJjZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZWZpeFRva2VuO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9ybWFsaXplZE5hbWUgPSBfdGhpcy5fbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyLm5hbWUpO1xuICAgICAgICAgICAgaWYgKF90aGlzLmNvbmZpZy5lbmFibGVMZWdhY3lUZW1wbGF0ZSAmJiBub3JtYWxpemVkTmFtZSA9PSBURU1QTEFURV9BVFRSKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFRFTVBMQVRFX0FUVFJfREVQUkVDQVRJT05fV0FSTklORywgYXR0ci5zb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuV0FSTklORyk7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVCaW5kaW5nc1NvdXJjZSA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub3JtYWxpemVkTmFtZS5zdGFydHNXaXRoKFRFTVBMQVRFX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlQmluZGluZ3NTb3VyY2UgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgIHByZWZpeFRva2VuID0gbm9ybWFsaXplZE5hbWUuc3Vic3RyaW5nKFRFTVBMQVRFX0FUVFJfUFJFRklYLmxlbmd0aCkgKyAnOic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoYXNUZW1wbGF0ZUJpbmRpbmcgPSB0ZW1wbGF0ZUJpbmRpbmdzU291cmNlICE9IG51bGw7XG4gICAgICAgICAgICBpZiAoaGFzVGVtcGxhdGVCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0lubGluZVRlbXBsYXRlcykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJDYW4ndCBoYXZlIG11bHRpcGxlIHRlbXBsYXRlIGJpbmRpbmdzIG9uIG9uZSBlbGVtZW50LiBVc2Ugb25seSBvbmUgYXR0cmlidXRlIG5hbWVkICd0ZW1wbGF0ZScgb3IgcHJlZml4ZWQgd2l0aCAqXCIsIGF0dHIuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhc0lubGluZVRlbXBsYXRlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VJbmxpbmVUZW1wbGF0ZUJpbmRpbmcoLyoqIEB0eXBlIHs/fSAqLyAoKHByZWZpeFRva2VuKSksIC8qKiBAdHlwZSB7P30gKi8gKCh0ZW1wbGF0ZUJpbmRpbmdzU291cmNlKSksIGF0dHIuc291cmNlU3BhbiwgdGVtcGxhdGVNYXRjaGFibGVBdHRycywgdGVtcGxhdGVFbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgdGVtcGxhdGVFbGVtZW50VmFycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhc0JpbmRpbmcgJiYgIWhhc1RlbXBsYXRlQmluZGluZykge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGluY2x1ZGUgdGhlIGJpbmRpbmdzIGFzIGF0dHJpYnV0ZXMgYXMgd2VsbCBpbiB0aGUgQVNUXG4gICAgICAgICAgICAgICAgYXR0cnMucHVzaChfdGhpcy52aXNpdEF0dHJpYnV0ZShhdHRyLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgbWF0Y2hhYmxlQXR0cnMucHVzaChbYXR0ci5uYW1lLCBhdHRyLnZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50Q3NzU2VsZWN0b3IgPSBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3Iobm9kZU5hbWUsIG1hdGNoYWJsZUF0dHJzKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fcGFyc2VEaXJlY3RpdmVzKHRoaXMuc2VsZWN0b3JNYXRjaGVyLCBlbGVtZW50Q3NzU2VsZWN0b3IpLCBkaXJlY3RpdmVNZXRhcyA9IF9hLmRpcmVjdGl2ZXMsIG1hdGNoRWxlbWVudCA9IF9hLm1hdGNoRWxlbWVudDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBib3VuZERpcmVjdGl2ZVByb3BOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyZWN0aXZlQXN0cyA9IHRoaXMuX2NyZWF0ZURpcmVjdGl2ZUFzdHMoaXNUZW1wbGF0ZUVsZW1lbnQsIGVsZW1lbnQubmFtZSwgZGlyZWN0aXZlTWV0YXMsIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSksIHJlZmVyZW5jZXMsIGJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudFByb3BzID0gdGhpcy5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0cyhlbGVtZW50Lm5hbWUsIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBib3VuZERpcmVjdGl2ZVByb3BOYW1lcyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzVmlld1Jvb3QgPSBwYXJlbnQuaXNUZW1wbGF0ZUVsZW1lbnQgfHwgaGFzSW5saW5lVGVtcGxhdGVzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlckNvbnRleHQgPSBuZXcgUHJvdmlkZXJFbGVtZW50Q29udGV4dCh0aGlzLnByb3ZpZGVyVmlld0NvbnRleHQsIC8qKiBAdHlwZSB7P30gKi8gKChwYXJlbnQucHJvdmlkZXJDb250ZXh0KSksIGlzVmlld1Jvb3QsIGRpcmVjdGl2ZUFzdHMsIGF0dHJzLCByZWZlcmVuY2VzLCBpc1RlbXBsYXRlRWxlbWVudCwgcXVlcnlTdGFydEluZGV4LCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZHJlbiA9IHZpc2l0QWxsKHByZXBhcnNlZEVsZW1lbnQubm9uQmluZGFibGUgPyBOT05fQklOREFCTEVfVklTSVRPUiA6IHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIEVsZW1lbnRDb250ZXh0LmNyZWF0ZShpc1RlbXBsYXRlRWxlbWVudCwgZGlyZWN0aXZlQXN0cywgaXNUZW1wbGF0ZUVsZW1lbnQgPyAoKHBhcmVudC5wcm92aWRlckNvbnRleHQpKSA6IHByb3ZpZGVyQ29udGV4dCkpO1xuICAgICAgICBwcm92aWRlckNvbnRleHQuYWZ0ZXJFbGVtZW50KCk7XG4gICAgICAgIC8vIE92ZXJyaWRlIHRoZSBhY3R1YWwgc2VsZWN0b3Igd2hlbiB0aGUgYG5nUHJvamVjdEFzYCBhdHRyaWJ1dGUgaXMgcHJvdmlkZWRcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvamVjdGlvblNlbGVjdG9yID0gcHJlcGFyc2VkRWxlbWVudC5wcm9qZWN0QXMgIT0gbnVsbCA/XG4gICAgICAgICAgICBDc3NTZWxlY3Rvci5wYXJzZShwcmVwYXJzZWRFbGVtZW50LnByb2plY3RBcylbMF0gOlxuICAgICAgICAgICAgZWxlbWVudENzc1NlbGVjdG9yO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ0NvbnRlbnRJbmRleCA9ICgocGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChwcm9qZWN0aW9uU2VsZWN0b3IpKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnNlZEVsZW1lbnQ7XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmNoaWxkcmVuICYmICFlbGVtZW50LmNoaWxkcmVuLmV2ZXJ5KF9pc0VtcHR5VGV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCI8bmctY29udGVudD4gZWxlbWVudCBjYW5ub3QgaGF2ZSBjb250ZW50LlwiLCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBOZ0NvbnRlbnRBc3QodGhpcy5uZ0NvbnRlbnRDb3VudCsrLCBoYXNJbmxpbmVUZW1wbGF0ZXMgPyAoKG51bGwpKSA6IG5nQ29udGVudEluZGV4LCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9hc3NlcnRBbGxFdmVudHNQdWJsaXNoZWRCeURpcmVjdGl2ZXMoZGlyZWN0aXZlQXN0cywgZXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMuX2Fzc2VydE5vQ29tcG9uZW50c05vckVsZW1lbnRCaW5kaW5nc09uVGVtcGxhdGUoZGlyZWN0aXZlQXN0cywgZWxlbWVudFByb3BzLCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbWJlZGRlZFRlbXBsYXRlQXN0KGF0dHJzLCBldmVudHMsIHJlZmVyZW5jZXMsIGVsZW1lbnRWYXJzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWREaXJlY3RpdmVBc3RzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtUHJvdmlkZXJzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyLCBwcm92aWRlckNvbnRleHQucXVlcnlNYXRjaGVzLCBjaGlsZHJlbiwgaGFzSW5saW5lVGVtcGxhdGVzID8gKChudWxsKSkgOiBuZ0NvbnRlbnRJbmRleCwgLyoqIEB0eXBlIHs/fSAqLyAoKGVsZW1lbnQuc291cmNlU3BhbikpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Fzc2VydEVsZW1lbnRFeGlzdHMobWF0Y2hFbGVtZW50LCBlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX2Fzc2VydE9ubHlPbmVDb21wb25lbnQoZGlyZWN0aXZlQXN0cywgLyoqIEB0eXBlIHs/fSAqLyAoKGVsZW1lbnQuc291cmNlU3BhbikpKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nQ29udGVudEluZGV4XzEgPSBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChwcm9qZWN0aW9uU2VsZWN0b3IpO1xuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbGVtZW50QXN0KG5vZGVOYW1lLCBhdHRycywgZWxlbWVudFByb3BzLCBldmVudHMsIHJlZmVyZW5jZXMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZERpcmVjdGl2ZUFzdHMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1Qcm92aWRlcnMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZEhhc1ZpZXdDb250YWluZXIsIHByb3ZpZGVyQ29udGV4dC5xdWVyeU1hdGNoZXMsIGNoaWxkcmVuLCBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogbmdDb250ZW50SW5kZXhfMSwgZWxlbWVudC5zb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4gfHwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0lubGluZVRlbXBsYXRlcykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVRdWVyeVN0YXJ0SW5kZXggPSB0aGlzLmNvbnRlbnRRdWVyeVN0YXJ0SWQ7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZVNlbGVjdG9yID0gY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yKFRFTVBMQVRFX0VMRU1FTlQsIHRlbXBsYXRlTWF0Y2hhYmxlQXR0cnMpO1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlRGlyZWN0aXZlTWV0YXMgPSB0aGlzLl9wYXJzZURpcmVjdGl2ZXModGhpcy5zZWxlY3Rvck1hdGNoZXIsIHRlbXBsYXRlU2VsZWN0b3IpLmRpcmVjdGl2ZXM7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZUJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVEaXJlY3RpdmVBc3RzID0gdGhpcy5fY3JlYXRlRGlyZWN0aXZlQXN0cyh0cnVlLCBlbGVtZW50Lm5hbWUsIHRlbXBsYXRlRGlyZWN0aXZlTWV0YXMsIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIFtdLCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSksIFtdLCB0ZW1wbGF0ZUJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlRWxlbWVudFByb3BzID0gdGhpcy5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0cyhlbGVtZW50Lm5hbWUsIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIHRlbXBsYXRlQm91bmREaXJlY3RpdmVQcm9wTmFtZXMpO1xuICAgICAgICAgICAgdGhpcy5fYXNzZXJ0Tm9Db21wb25lbnRzTm9yRWxlbWVudEJpbmRpbmdzT25UZW1wbGF0ZSh0ZW1wbGF0ZURpcmVjdGl2ZUFzdHMsIHRlbXBsYXRlRWxlbWVudFByb3BzLCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVQcm92aWRlckNvbnRleHQgPSBuZXcgUHJvdmlkZXJFbGVtZW50Q29udGV4dCh0aGlzLnByb3ZpZGVyVmlld0NvbnRleHQsIC8qKiBAdHlwZSB7P30gKi8gKChwYXJlbnQucHJvdmlkZXJDb250ZXh0KSksIHBhcmVudC5pc1RlbXBsYXRlRWxlbWVudCwgdGVtcGxhdGVEaXJlY3RpdmVBc3RzLCBbXSwgW10sIHRydWUsIHRlbXBsYXRlUXVlcnlTdGFydEluZGV4LCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICAgICAgdGVtcGxhdGVQcm92aWRlckNvbnRleHQuYWZ0ZXJFbGVtZW50KCk7XG4gICAgICAgICAgICBwYXJzZWRFbGVtZW50ID0gbmV3IEVtYmVkZGVkVGVtcGxhdGVBc3QoW10sIFtdLCBbXSwgdGVtcGxhdGVFbGVtZW50VmFycywgdGVtcGxhdGVQcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWREaXJlY3RpdmVBc3RzLCB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1Qcm92aWRlcnMsIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybWVkSGFzVmlld0NvbnRhaW5lciwgdGVtcGxhdGVQcm92aWRlckNvbnRleHQucXVlcnlNYXRjaGVzLCBbcGFyc2VkRWxlbWVudF0sIG5nQ29udGVudEluZGV4LCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWRFbGVtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpc1RlbXBsYXRlRWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gYXR0clxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0TWF0Y2hhYmxlQXR0cnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFByb3BzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRFdmVudHNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFJlZnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFZhcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VBdHRyID0gZnVuY3Rpb24gKGlzVGVtcGxhdGVFbGVtZW50LCBhdHRyLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIHRhcmdldEV2ZW50cywgdGFyZ2V0UmVmcywgdGFyZ2V0VmFycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gdGhpcy5fbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyLm5hbWUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNyY1NwYW4gPSBhdHRyLnNvdXJjZVNwYW47XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpbmRQYXJ0cyA9IG5hbWUubWF0Y2goQklORF9OQU1FX1JFR0VYUCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhc0JpbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGJpbmRQYXJ0cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaGFzQmluZGluZyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoYmluZFBhcnRzW0tXX0JJTkRfSURYXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5QmluZGluZyhiaW5kUGFydHNbSURFTlRfS1dfSURYXSwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX0xFVF9JRFhdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkZW50aWZpZXIgPSBiaW5kUGFydHNbSURFTlRfS1dfSURYXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VWYXJpYWJsZShpZGVudGlmaWVyLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0VmFycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlxcXCJsZXQtXFxcIiBpcyBvbmx5IHN1cHBvcnRlZCBvbiB0ZW1wbGF0ZSBlbGVtZW50cy5cIiwgc3JjU3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX1JFRl9JRFhdKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWRlbnRpZmllciA9IGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlUmVmZXJlbmNlKGlkZW50aWZpZXIsIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRSZWZzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19PTl9JRFhdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUV2ZW50KGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfQklORE9OX0lEWF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlCaW5kaW5nKGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdLCB2YWx1ZSwgZmFsc2UsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBc3NpZ25tZW50RXZlbnQoYmluZFBhcnRzW0lERU5UX0tXX0lEWF0sIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19BVF9JRFhdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUxpdGVyYWxBdHRyKG5hbWUsIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0lERU5UX0JBTkFOQV9CT1hfSURYXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUJpbmRpbmcoYmluZFBhcnRzW0lERU5UX0JBTkFOQV9CT1hfSURYXSwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlQXNzaWdubWVudEV2ZW50KGJpbmRQYXJ0c1tJREVOVF9CQU5BTkFfQk9YX0lEWF0sIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tJREVOVF9QUk9QRVJUWV9JRFhdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5QmluZGluZyhiaW5kUGFydHNbSURFTlRfUFJPUEVSVFlfSURYXSwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0lERU5UX0VWRU5UX0lEWF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlRXZlbnQoYmluZFBhcnRzW0lERU5UX0VWRU5UX0lEWF0sIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhc0JpbmRpbmcgPSB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlJbnRlcnBvbGF0aW9uKG5hbWUsIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzQmluZGluZykge1xuICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUxpdGVyYWxBdHRyKG5hbWUsIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNCaW5kaW5nO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhdHRyTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9ub3JtYWxpemVBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgIHJldHVybiAvXmRhdGEtL2kudGVzdChhdHRyTmFtZSkgPyBhdHRyTmFtZS5zdWJzdHJpbmcoNSkgOiBhdHRyTmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFZhcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VWYXJpYWJsZSA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0VmFycykge1xuICAgICAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcXFwiLVxcXCIgaXMgbm90IGFsbG93ZWQgaW4gdmFyaWFibGUgbmFtZXNcIiwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0VmFycy5wdXNoKG5ldyBWYXJpYWJsZUFzdChpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0UmVmc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZVJlZmVyZW5jZSA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0UmVmcykge1xuICAgICAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcXFwiLVxcXCIgaXMgbm90IGFsbG93ZWQgaW4gcmVmZXJlbmNlIG5hbWVzXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldFJlZnMucHVzaChuZXcgRWxlbWVudE9yRGlyZWN0aXZlUmVmKGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IHRhcmdldE1hdGNoYWJsZUF0dHJzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRFdmVudHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VBc3NpZ25tZW50RXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cykge1xuICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlRXZlbnQobmFtZSArIFwiQ2hhbmdlXCIsIGV4cHJlc3Npb24gKyBcIj0kZXZlbnRcIiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yTWF0Y2hlclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudENzc1NlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlRGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChzZWxlY3Rvck1hdGNoZXIsIGVsZW1lbnRDc3NTZWxlY3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBOZWVkIHRvIHNvcnQgdGhlIGRpcmVjdGl2ZXMgc28gdGhhdCB3ZSBnZXQgY29uc2lzdGVudCByZXN1bHRzIHRocm91Z2hvdXQsXG4gICAgICAgIC8vIGFzIHNlbGVjdG9yTWF0Y2hlciB1c2VzIE1hcHMgaW5zaWRlLlxuICAgICAgICAvLyBBbHNvIGRlZHVwbGljYXRlIGRpcmVjdGl2ZXMgYXMgdGhleSBtaWdodCBtYXRjaCBtb3JlIHRoYW4gb25lIHRpbWUhXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpcmVjdGl2ZXMgPSBuZXcgQXJyYXkodGhpcy5kaXJlY3RpdmVzSW5kZXguc2l6ZSk7XG4gICAgICAgIC8vIFdoZXRoZXIgYW55IGRpcmVjdGl2ZSBzZWxlY3RvciBtYXRjaGVzIG9uIHRoZSBlbGVtZW50IG5hbWVcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIHNlbGVjdG9yTWF0Y2hlci5tYXRjaChlbGVtZW50Q3NzU2VsZWN0b3IsIGZ1bmN0aW9uIChzZWxlY3RvciwgZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICBkaXJlY3RpdmVzWygoX3RoaXMuZGlyZWN0aXZlc0luZGV4LmdldChkaXJlY3RpdmUpKSldID0gZGlyZWN0aXZlO1xuICAgICAgICAgICAgbWF0Y2hFbGVtZW50ID0gbWF0Y2hFbGVtZW50IHx8IHNlbGVjdG9yLmhhc0VsZW1lbnRTZWxlY3RvcigpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuICEhZGlyOyB9KSxcbiAgICAgICAgICAgIG1hdGNoRWxlbWVudDogbWF0Y2hFbGVtZW50LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpc1RlbXBsYXRlRWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHByb3BzXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50T3JEaXJlY3RpdmVSZWZzXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50U291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0UmVmZXJlbmNlc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wTmFtZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY3JlYXRlRGlyZWN0aXZlQXN0cyA9IGZ1bmN0aW9uIChpc1RlbXBsYXRlRWxlbWVudCwgZWxlbWVudE5hbWUsIGRpcmVjdGl2ZXMsIHByb3BzLCBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLCBlbGVtZW50U291cmNlU3BhbiwgdGFyZ2V0UmVmZXJlbmNlcywgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wTmFtZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlZFJlZmVyZW5jZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudCA9ICgobnVsbCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJlY3RpdmVBc3RzID0gZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4oZWxlbWVudFNvdXJjZVNwYW4uc3RhcnQsIGVsZW1lbnRTb3VyY2VTcGFuLmVuZCwgXCJEaXJlY3RpdmUgXCIgKyBpZGVudGlmaWVyTmFtZShkaXJlY3RpdmUudHlwZSkpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IGRpcmVjdGl2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpcmVjdGl2ZVByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RQcm9wZXJ0aWVzID0gKChfdGhpcy5fYmluZGluZ1BhcnNlci5jcmVhdGVEaXJlY3RpdmVIb3N0UHJvcGVydHlBc3RzKGRpcmVjdGl2ZSwgZWxlbWVudE5hbWUsIHNvdXJjZVNwYW4pKSk7XG4gICAgICAgICAgICAvLyBOb3RlOiBXZSBuZWVkIHRvIGNoZWNrIHRoZSBob3N0IHByb3BlcnRpZXMgaGVyZSBhcyB3ZWxsLFxuICAgICAgICAgICAgLy8gYXMgd2UgZG9uJ3Qga25vdyB0aGUgZWxlbWVudCBuYW1lIGluIHRoZSBEaXJlY3RpdmVXcmFwcGVyQ29tcGlsZXIgeWV0LlxuICAgICAgICAgICAgaG9zdFByb3BlcnRpZXMgPSBfdGhpcy5fY2hlY2tQcm9wZXJ0aWVzSW5TY2hlbWEoZWxlbWVudE5hbWUsIGhvc3RQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RFdmVudHMgPSAoKF90aGlzLl9iaW5kaW5nUGFyc2VyLmNyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMoZGlyZWN0aXZlLCBzb3VyY2VTcGFuKSkpO1xuICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZURpcmVjdGl2ZVByb3BlcnR5QXN0cyhkaXJlY3RpdmUuaW5wdXRzLCBwcm9wcywgZGlyZWN0aXZlUHJvcGVydGllcywgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wTmFtZXMpO1xuICAgICAgICAgICAgZWxlbWVudE9yRGlyZWN0aXZlUmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChlbE9yRGlyUmVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKChlbE9yRGlyUmVmLnZhbHVlLmxlbmd0aCA9PT0gMCAmJiBkaXJlY3RpdmUuaXNDb21wb25lbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChkaXJlY3RpdmUuZXhwb3J0QXMgPT0gZWxPckRpclJlZi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UmVmZXJlbmNlcy5wdXNoKG5ldyBSZWZlcmVuY2VBc3QoZWxPckRpclJlZi5uYW1lLCBpZGVudGlmaWVyVG9rZW4oZGlyZWN0aXZlLnR5cGUpLCBlbE9yRGlyUmVmLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFJlZmVyZW5jZXMuYWRkKGVsT3JEaXJSZWYubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZW50UXVlcnlTdGFydElkID0gX3RoaXMuY29udGVudFF1ZXJ5U3RhcnRJZDtcbiAgICAgICAgICAgIF90aGlzLmNvbnRlbnRRdWVyeVN0YXJ0SWQgKz0gZGlyZWN0aXZlLnF1ZXJpZXMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaXJlY3RpdmVBc3QoZGlyZWN0aXZlLCBkaXJlY3RpdmVQcm9wZXJ0aWVzLCBob3N0UHJvcGVydGllcywgaG9zdEV2ZW50cywgY29udGVudFF1ZXJ5U3RhcnRJZCwgc291cmNlU3Bhbik7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLmZvckVhY2goZnVuY3Rpb24gKGVsT3JEaXJSZWYpIHtcbiAgICAgICAgICAgIGlmIChlbE9yRGlyUmVmLnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRSZWZlcmVuY2VzLmhhcyhlbE9yRGlyUmVmLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlRoZXJlIGlzIG5vIGRpcmVjdGl2ZSB3aXRoIFxcXCJleHBvcnRBc1xcXCIgc2V0IHRvIFxcXCJcIiArIGVsT3JEaXJSZWYudmFsdWUgKyBcIlxcXCJcIiwgZWxPckRpclJlZi5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVmVG9rZW4gPSAoKG51bGwpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmVG9rZW4gPSBjcmVhdGVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuVGVtcGxhdGVSZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXRSZWZlcmVuY2VzLnB1c2gobmV3IFJlZmVyZW5jZUFzdChlbE9yRGlyUmVmLm5hbWUsIHJlZlRva2VuLCBlbE9yRGlyUmVmLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkaXJlY3RpdmVBc3RzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVQcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHs/fSBib3VuZFByb3BzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BOYW1lc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jcmVhdGVEaXJlY3RpdmVQcm9wZXJ0eUFzdHMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlUHJvcGVydGllcywgYm91bmRQcm9wcywgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wcywgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wTmFtZXMpIHtcbiAgICAgICAgaWYgKGRpcmVjdGl2ZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvdW5kUHJvcHNCeU5hbWVfMSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGJvdW5kUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoYm91bmRQcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldlZhbHVlID0gYm91bmRQcm9wc0J5TmFtZV8xLmdldChib3VuZFByb3AubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2VmFsdWUgfHwgcHJldlZhbHVlLmlzTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBnaXZlIFthXT1cImJcIiBhIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gYT1cImJcIiBvbiB0aGUgc2FtZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcHNCeU5hbWVfMS5zZXQoYm91bmRQcm9wLm5hbWUsIGJvdW5kUHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkaXJlY3RpdmVQcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJQcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxQcm9wID0gZGlyZWN0aXZlUHJvcGVydGllc1tkaXJQcm9wXTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBib3VuZFByb3AgPSBib3VuZFByb3BzQnlOYW1lXzEuZ2V0KGVsUHJvcCk7XG4gICAgICAgICAgICAgICAgLy8gQmluZGluZ3MgYXJlIG9wdGlvbmFsLCBzbyB0aGlzIGJpbmRpbmcgb25seSBuZWVkcyB0byBiZSBzZXQgdXAgaWYgYW4gZXhwcmVzc2lvbiBpcyBnaXZlbi5cbiAgICAgICAgICAgICAgICBpZiAoYm91bmRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzLmFkZChib3VuZFByb3AubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eUV4cHJlc3Npb24oYm91bmRQcm9wLmV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BzLnB1c2gobmV3IEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QoZGlyUHJvcCwgYm91bmRQcm9wLm5hbWUsIGJvdW5kUHJvcC5leHByZXNzaW9uLCBib3VuZFByb3Auc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IHByb3BzXG4gICAgICogQHBhcmFtIHs/fSBib3VuZERpcmVjdGl2ZVByb3BOYW1lc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jcmVhdGVFbGVtZW50UHJvcGVydHlBc3RzID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lLCBwcm9wcywgYm91bmREaXJlY3RpdmVQcm9wTmFtZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm91bmRFbGVtZW50UHJvcHMgPSBbXTtcbiAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgaWYgKCFwcm9wLmlzTGl0ZXJhbCAmJiAhYm91bmREaXJlY3RpdmVQcm9wTmFtZXMuaGFzKHByb3AubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBib3VuZEVsZW1lbnRQcm9wcy5wdXNoKF90aGlzLl9iaW5kaW5nUGFyc2VyLmNyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdChlbGVtZW50TmFtZSwgcHJvcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrUHJvcGVydGllc0luU2NoZW1hKGVsZW1lbnROYW1lLCBib3VuZEVsZW1lbnRQcm9wcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fZmluZENvbXBvbmVudERpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcykge1xuICAgICAgICByZXR1cm4gZGlyZWN0aXZlcy5maWx0ZXIoZnVuY3Rpb24gKGRpcmVjdGl2ZSkgeyByZXR1cm4gZGlyZWN0aXZlLmRpcmVjdGl2ZS5pc0NvbXBvbmVudDsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fZmluZENvbXBvbmVudERpcmVjdGl2ZU5hbWVzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRDb21wb25lbnREaXJlY3RpdmVzKGRpcmVjdGl2ZXMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuICgoaWRlbnRpZmllck5hbWUoZGlyZWN0aXZlLmRpcmVjdGl2ZS50eXBlKSkpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9hc3NlcnRPbmx5T25lQ29tcG9uZW50ID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcG9uZW50VHlwZU5hbWVzID0gdGhpcy5fZmluZENvbXBvbmVudERpcmVjdGl2ZU5hbWVzKGRpcmVjdGl2ZXMpO1xuICAgICAgICBpZiAoY29tcG9uZW50VHlwZU5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiTW9yZSB0aGFuIG9uZSBjb21wb25lbnQgbWF0Y2hlZCBvbiB0aGlzIGVsZW1lbnQuXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiTWFrZSBzdXJlIHRoYXQgb25seSBvbmUgY29tcG9uZW50J3Mgc2VsZWN0b3IgY2FuIG1hdGNoIGEgZ2l2ZW4gZWxlbWVudC5cXG5cIiArXG4gICAgICAgICAgICAgICAgKFwiQ29uZmxpY3RpbmcgY29tcG9uZW50czogXCIgKyBjb21wb25lbnRUeXBlTmFtZXMuam9pbignLCcpKSwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ha2Ugc3VyZSB0aGF0IG5vbi1hbmd1bGFyIHRhZ3MgY29uZm9ybSB0byB0aGUgc2NoZW1hcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IEFuIGVsZW1lbnQgaXMgY29uc2lkZXJlZCBhbiBhbmd1bGFyIHRhZyB3aGVuIGF0IGxlYXN0IG9uZSBkaXJlY3RpdmUgc2VsZWN0b3IgbWF0Y2hlcyB0aGVcbiAgICAgKiB0YWcgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gbWF0Y2hFbGVtZW50IFdoZXRoZXIgYW55IGRpcmVjdGl2ZSBoYXMgbWF0Y2hlZCBvbiB0aGUgdGFnIG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnQgdGhlIGh0bWwgZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9hc3NlcnRFbGVtZW50RXhpc3RzID0gZnVuY3Rpb24gKG1hdGNoRWxlbWVudCwgZWxlbWVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbE5hbWUgPSBlbGVtZW50Lm5hbWUucmVwbGFjZSgvXjp4aHRtbDovLCAnJyk7XG4gICAgICAgIGlmICghbWF0Y2hFbGVtZW50ICYmICF0aGlzLl9zY2hlbWFSZWdpc3RyeS5oYXNFbGVtZW50KGVsTmFtZSwgdGhpcy5fc2NoZW1hcykpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yTXNnID0gXCInXCIgKyBlbE5hbWUgKyBcIicgaXMgbm90IGEga25vd24gZWxlbWVudDpcXG5cIjtcbiAgICAgICAgICAgIGVycm9yTXNnICs9XG4gICAgICAgICAgICAgICAgXCIxLiBJZiAnXCIgKyBlbE5hbWUgKyBcIicgaXMgYW4gQW5ndWxhciBjb21wb25lbnQsIHRoZW4gdmVyaWZ5IHRoYXQgaXQgaXMgcGFydCBvZiB0aGlzIG1vZHVsZS5cXG5cIjtcbiAgICAgICAgICAgIGlmIChlbE5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBlcnJvck1zZyArPVxuICAgICAgICAgICAgICAgICAgICBcIjIuIElmICdcIiArIGVsTmFtZSArIFwiJyBpcyBhIFdlYiBDb21wb25lbnQgdGhlbiBhZGQgJ0NVU1RPTV9FTEVNRU5UU19TQ0hFTUEnIHRvIHRoZSAnQE5nTW9kdWxlLnNjaGVtYXMnIG9mIHRoaXMgY29tcG9uZW50IHRvIHN1cHByZXNzIHRoaXMgbWVzc2FnZS5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yTXNnICs9XG4gICAgICAgICAgICAgICAgICAgIFwiMi4gVG8gYWxsb3cgYW55IGVsZW1lbnQgYWRkICdOT19FUlJPUlNfU0NIRU1BJyB0byB0aGUgJ0BOZ01vZHVsZS5zY2hlbWFzJyBvZiB0aGlzIGNvbXBvbmVudC5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVycm9yTXNnLCAvKiogQHR5cGUgez99ICovICgoZWxlbWVudC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRQcm9wc1xuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9hc3NlcnROb0NvbXBvbmVudHNOb3JFbGVtZW50QmluZGluZ3NPblRlbXBsYXRlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMsIGVsZW1lbnRQcm9wcywgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnRUeXBlTmFtZXMgPSB0aGlzLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlTmFtZXMoZGlyZWN0aXZlcyk7XG4gICAgICAgIGlmIChjb21wb25lbnRUeXBlTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJDb21wb25lbnRzIG9uIGFuIGVtYmVkZGVkIHRlbXBsYXRlOiBcIiArIGNvbXBvbmVudFR5cGVOYW1lcy5qb2luKCcsJyksIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJQcm9wZXJ0eSBiaW5kaW5nIFwiICsgcHJvcC5uYW1lICsgXCIgbm90IHVzZWQgYnkgYW55IGRpcmVjdGl2ZSBvbiBhbiBlbWJlZGRlZCB0ZW1wbGF0ZS4gTWFrZSBzdXJlIHRoYXQgdGhlIHByb3BlcnR5IG5hbWUgaXMgc3BlbGxlZCBjb3JyZWN0bHkgYW5kIGFsbCBkaXJlY3RpdmVzIGFyZSBsaXN0ZWQgaW4gdGhlIFxcXCJATmdNb2R1bGUuZGVjbGFyYXRpb25zXFxcIi5cIiwgc291cmNlU3Bhbik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVzXG4gICAgICogQHBhcmFtIHs/fSBldmVudHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fYXNzZXJ0QWxsRXZlbnRzUHVibGlzaGVkQnlEaXJlY3RpdmVzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMsIGV2ZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxEaXJlY3RpdmVFdmVudHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkaXJlY3RpdmUuZGlyZWN0aXZlLm91dHB1dHMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudE5hbWUgPSBkaXJlY3RpdmUuZGlyZWN0aXZlLm91dHB1dHNba107XG4gICAgICAgICAgICAgICAgYWxsRGlyZWN0aXZlRXZlbnRzLmFkZChldmVudE5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgIT0gbnVsbCB8fCAhYWxsRGlyZWN0aXZlRXZlbnRzLmhhcyhldmVudC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIkV2ZW50IGJpbmRpbmcgXCIgKyBldmVudC5mdWxsTmFtZSArIFwiIG5vdCBlbWl0dGVkIGJ5IGFueSBkaXJlY3RpdmUgb24gYW4gZW1iZWRkZWQgdGVtcGxhdGUuIE1ha2Ugc3VyZSB0aGF0IHRoZSBldmVudCBuYW1lIGlzIHNwZWxsZWQgY29ycmVjdGx5IGFuZCBhbGwgZGlyZWN0aXZlcyBhcmUgbGlzdGVkIGluIHRoZSBcXFwiQE5nTW9kdWxlLmRlY2xhcmF0aW9uc1xcXCIuXCIsIGV2ZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGJvdW5kUHJvcHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY2hlY2tQcm9wZXJ0aWVzSW5TY2hlbWEgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUsIGJvdW5kUHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gTm90ZTogV2UgY2FuJ3QgZmlsdGVyIG91dCBlbXB0eSBleHByZXNzaW9ucyBiZWZvcmUgdGhpcyBtZXRob2QsXG4gICAgICAgIC8vIGFzIHdlIHN0aWxsIHdhbnQgdG8gdmFsaWRhdGUgdGhlbSFcbiAgICAgICAgcmV0dXJuIGJvdW5kUHJvcHMuZmlsdGVyKGZ1bmN0aW9uIChib3VuZFByb3ApIHtcbiAgICAgICAgICAgIGlmIChib3VuZFByb3AudHlwZSA9PT0gUHJvcGVydHlCaW5kaW5nVHlwZS5Qcm9wZXJ0eSAmJlxuICAgICAgICAgICAgICAgICFfdGhpcy5fc2NoZW1hUmVnaXN0cnkuaGFzUHJvcGVydHkoZWxlbWVudE5hbWUsIGJvdW5kUHJvcC5uYW1lLCBfdGhpcy5fc2NoZW1hcykpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvck1zZyA9IFwiQ2FuJ3QgYmluZCB0byAnXCIgKyBib3VuZFByb3AubmFtZSArIFwiJyBzaW5jZSBpdCBpc24ndCBhIGtub3duIHByb3BlcnR5IG9mICdcIiArIGVsZW1lbnROYW1lICsgXCInLlwiO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50TmFtZS5zdGFydHNXaXRoKCduZy0nKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1zZyArPVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4xLiBJZiAnXCIgKyBib3VuZFByb3AubmFtZSArIFwiJyBpcyBhbiBBbmd1bGFyIGRpcmVjdGl2ZSwgdGhlbiBhZGQgJ0NvbW1vbk1vZHVsZScgdG8gdGhlICdATmdNb2R1bGUuaW1wb3J0cycgb2YgdGhpcyBjb21wb25lbnQuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuMi4gVG8gYWxsb3cgYW55IHByb3BlcnR5IGFkZCAnTk9fRVJST1JTX1NDSEVNQScgdG8gdGhlICdATmdNb2R1bGUuc2NoZW1hcycgb2YgdGhpcyBjb21wb25lbnQuXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsZW1lbnROYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTXNnICs9XG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcbjEuIElmICdcIiArIGVsZW1lbnROYW1lICsgXCInIGlzIGFuIEFuZ3VsYXIgY29tcG9uZW50IGFuZCBpdCBoYXMgJ1wiICsgYm91bmRQcm9wLm5hbWUgKyBcIicgaW5wdXQsIHRoZW4gdmVyaWZ5IHRoYXQgaXQgaXMgcGFydCBvZiB0aGlzIG1vZHVsZS5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiXFxuMi4gSWYgJ1wiICsgZWxlbWVudE5hbWUgKyBcIicgaXMgYSBXZWIgQ29tcG9uZW50IHRoZW4gYWRkICdDVVNUT01fRUxFTUVOVFNfU0NIRU1BJyB0byB0aGUgJ0BOZ01vZHVsZS5zY2hlbWFzJyBvZiB0aGlzIGNvbXBvbmVudCB0byBzdXBwcmVzcyB0aGlzIG1lc3NhZ2UuXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbjMuIFRvIGFsbG93IGFueSBwcm9wZXJ0eSBhZGQgJ05PX0VSUk9SU19TQ0hFTUEnIHRvIHRoZSAnQE5nTW9kdWxlLnNjaGVtYXMnIG9mIHRoaXMgY29tcG9uZW50LlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoZXJyb3JNc2csIGJvdW5kUHJvcC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhaXNFbXB0eUV4cHJlc3Npb24oYm91bmRQcm9wLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez89fSBsZXZlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBzb3VyY2VTcGFuLCBsZXZlbCkge1xuICAgICAgICBpZiAobGV2ZWwgPT09IHZvaWQgMCkgeyBsZXZlbCA9IFBhcnNlRXJyb3JMZXZlbC5FUlJPUjsgfVxuICAgICAgICB0aGlzLl90YXJnZXRFcnJvcnMucHVzaChuZXcgUGFyc2VFcnJvcihzb3VyY2VTcGFuLCBtZXNzYWdlLCBsZXZlbCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRlbXBsYXRlUGFyc2VWaXNpdG9yO1xufSgpKTtcbnZhciBOb25CaW5kYWJsZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vbkJpbmRhYmxlVmlzaXRvcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlcGFyc2VkRWxlbWVudCA9IHByZXBhcnNlRWxlbWVudChhc3QpO1xuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFQgfHxcbiAgICAgICAgICAgIHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEUgfHxcbiAgICAgICAgICAgIHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVCkge1xuICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHNjcmlwdD4gZm9yIHNlY3VyaXR5IHJlYXNvbnNcbiAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzdHlsZT4gYW5kIHN0eWxlc2hlZXRzIGFzIHdlIGFscmVhZHkgcHJvY2Vzc2VkIHRoZW1cbiAgICAgICAgICAgIC8vIGluIHRoZSBTdHlsZUNvbXBpbGVyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRyTmFtZUFuZFZhbHVlcyA9IGFzdC5hdHRycy5tYXAoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIFthdHRyLm5hbWUsIGF0dHIudmFsdWVdOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0b3IgPSBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3IoYXN0Lm5hbWUsIGF0dHJOYW1lQW5kVmFsdWVzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdDb250ZW50SW5kZXggPSBwYXJlbnQuZmluZE5nQ29udGVudEluZGV4KHNlbGVjdG9yKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRyZW4gPSB2aXNpdEFsbCh0aGlzLCBhc3QuY2hpbGRyZW4sIEVNUFRZX0VMRU1FTlRfQ09OVEVYVCk7XG4gICAgICAgIHJldHVybiBuZXcgRWxlbWVudEFzdChhc3QubmFtZSwgdmlzaXRBbGwodGhpcywgYXN0LmF0dHJzKSwgW10sIFtdLCBbXSwgW10sIFtdLCBmYWxzZSwgW10sIGNoaWxkcmVuLCBuZ0NvbnRlbnRJbmRleCwgYXN0LnNvdXJjZVNwYW4sIGFzdC5lbmRTb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyQXN0KGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUsIGF0dHJpYnV0ZS5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdDb250ZW50SW5kZXggPSAoKHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgoVEVYVF9DU1NfU0VMRUNUT1IpKSk7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEFzdCh0ZXh0LnZhbHVlLCBuZ0NvbnRlbnRJbmRleCwgLyoqIEB0eXBlIHs/fSAqLyAoKHRleHQuc291cmNlU3BhbikpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwYW5zaW9uXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkgeyByZXR1cm4gZXhwYW5zaW9uOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwYW5zaW9uQ2FzZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoZXhwYW5zaW9uQ2FzZSwgY29udGV4dCkgeyByZXR1cm4gZXhwYW5zaW9uQ2FzZTsgfTtcbiAgICByZXR1cm4gTm9uQmluZGFibGVWaXNpdG9yO1xufSgpKTtcbnZhciBFbGVtZW50T3JEaXJlY3RpdmVSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbGVtZW50T3JEaXJlY3RpdmVSZWYobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICByZXR1cm4gRWxlbWVudE9yRGlyZWN0aXZlUmVmO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBjbGFzc0F0dHJWYWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3BsaXRDbGFzc2VzKGNsYXNzQXR0clZhbHVlKSB7XG4gICAgcmV0dXJuIGNsYXNzQXR0clZhbHVlLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbn1cbnZhciBFbGVtZW50Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpc1RlbXBsYXRlRWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gX25nQ29udGVudEluZGV4TWF0Y2hlclxuICAgICAqIEBwYXJhbSB7P30gX3dpbGRjYXJkTmdDb250ZW50SW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyQ29udGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRDb250ZXh0KGlzVGVtcGxhdGVFbGVtZW50LCBfbmdDb250ZW50SW5kZXhNYXRjaGVyLCBfd2lsZGNhcmROZ0NvbnRlbnRJbmRleCwgcHJvdmlkZXJDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuaXNUZW1wbGF0ZUVsZW1lbnQgPSBpc1RlbXBsYXRlRWxlbWVudDtcbiAgICAgICAgdGhpcy5fbmdDb250ZW50SW5kZXhNYXRjaGVyID0gX25nQ29udGVudEluZGV4TWF0Y2hlcjtcbiAgICAgICAgdGhpcy5fd2lsZGNhcmROZ0NvbnRlbnRJbmRleCA9IF93aWxkY2FyZE5nQ29udGVudEluZGV4O1xuICAgICAgICB0aGlzLnByb3ZpZGVyQ29udGV4dCA9IHByb3ZpZGVyQ29udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpc1RlbXBsYXRlRWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJDb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50Q29udGV4dC5jcmVhdGUgPSBmdW5jdGlvbiAoaXNUZW1wbGF0ZUVsZW1lbnQsIGRpcmVjdGl2ZXMsIHByb3ZpZGVyQ29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVyID0gbmV3IFNlbGVjdG9yTWF0Y2hlcigpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3aWxkY2FyZE5nQ29udGVudEluZGV4ID0gKChudWxsKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudCA9IGRpcmVjdGl2ZXMuZmluZChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7IHJldHVybiBkaXJlY3RpdmUuZGlyZWN0aXZlLmlzQ29tcG9uZW50OyB9KTtcbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdDb250ZW50U2VsZWN0b3JzID0gKChjb21wb25lbnQuZGlyZWN0aXZlLnRlbXBsYXRlKSkubmdDb250ZW50U2VsZWN0b3JzO1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IG5nQ29udGVudFNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdG9yID0gbmdDb250ZW50U2VsZWN0b3JzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbGRjYXJkTmdDb250ZW50SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlci5hZGRTZWxlY3RhYmxlcyhDc3NTZWxlY3Rvci5wYXJzZShuZ0NvbnRlbnRTZWxlY3RvcnNbaV0pLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50Q29udGV4dChpc1RlbXBsYXRlRWxlbWVudCwgbWF0Y2hlciwgd2lsZGNhcmROZ0NvbnRlbnRJbmRleCwgcHJvdmlkZXJDb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5maW5kTmdDb250ZW50SW5kZXggPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdDb250ZW50SW5kaWNlcyA9IFtdO1xuICAgICAgICB0aGlzLl9uZ0NvbnRlbnRJbmRleE1hdGNoZXIubWF0Y2goc2VsZWN0b3IsIGZ1bmN0aW9uIChzZWxlY3RvciwgbmdDb250ZW50SW5kZXgpIHsgbmdDb250ZW50SW5kaWNlcy5wdXNoKG5nQ29udGVudEluZGV4KTsgfSk7XG4gICAgICAgIG5nQ29udGVudEluZGljZXMuc29ydCgpO1xuICAgICAgICBpZiAodGhpcy5fd2lsZGNhcmROZ0NvbnRlbnRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZ0NvbnRlbnRJbmRpY2VzLnB1c2godGhpcy5fd2lsZGNhcmROZ0NvbnRlbnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5nQ29udGVudEluZGljZXMubGVuZ3RoID4gMCA/IG5nQ29udGVudEluZGljZXNbMF0gOiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRDb250ZXh0O1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50TmFtZVxuICogQHBhcmFtIHs/fSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3IoZWxlbWVudE5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjc3NTZWxlY3RvciA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsTmFtZU5vTnMgPSBzcGxpdE5zTmFtZShlbGVtZW50TmFtZSlbMV07XG4gICAgY3NzU2VsZWN0b3Iuc2V0RWxlbWVudChlbE5hbWVOb05zKTtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRyTmFtZSA9IGF0dHJpYnV0ZXNbaV1bMF07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJOYW1lTm9OcyA9IHNwbGl0TnNOYW1lKGF0dHJOYW1lKVsxXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0clZhbHVlID0gYXR0cmlidXRlc1tpXVsxXTtcbiAgICAgICAgY3NzU2VsZWN0b3IuYWRkQXR0cmlidXRlKGF0dHJOYW1lTm9OcywgYXR0clZhbHVlKTtcbiAgICAgICAgaWYgKGF0dHJOYW1lLnRvTG93ZXJDYXNlKCkgPT0gQ0xBU1NfQVRUUikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NlcyA9IHNwbGl0Q2xhc3NlcyhhdHRyVmFsdWUpO1xuICAgICAgICAgICAgY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHsgcmV0dXJuIGNzc1NlbGVjdG9yLmFkZENsYXNzTmFtZShjbGFzc05hbWUpOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3NzU2VsZWN0b3I7XG59XG52YXIgRU1QVFlfRUxFTUVOVF9DT05URVhUID0gbmV3IEVsZW1lbnRDb250ZXh0KHRydWUsIG5ldyBTZWxlY3Rvck1hdGNoZXIoKSwgbnVsbCwgbnVsbCk7XG52YXIgTk9OX0JJTkRBQkxFX1ZJU0lUT1IgPSBuZXcgTm9uQmluZGFibGVWaXNpdG9yKCk7XG4vKipcbiAqIEBwYXJhbSB7P30gbm9kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2lzRW1wdHlUZXh0Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUZXh0ICYmIG5vZGUudmFsdWUudHJpbSgpLmxlbmd0aCA9PSAwO1xufVxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHs/fSBpdGVtc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlU3VtbWFyeUR1cGxpY2F0ZXMoaXRlbXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXAgPSBuZXcgTWFwKCk7XG4gICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoIW1hcC5nZXQoaXRlbS50eXBlLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIG1hcC5zZXQoaXRlbS50eXBlLnJlZmVyZW5jZSwgaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShtYXAudmFsdWVzKCkpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGFzdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNFbXB0eUV4cHJlc3Npb24oYXN0KSB7XG4gICAgaWYgKGFzdCBpbnN0YW5jZW9mIEFTVFdpdGhTb3VyY2UpIHtcbiAgICAgICAgYXN0ID0gYXN0LmFzdDtcbiAgICB9XG4gICAgcmV0dXJuIGFzdCBpbnN0YW5jZW9mIEVtcHR5RXhwcjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlbFxuICogQHBhcmFtIHs/fSBlbmFibGVMZWdhY3lUZW1wbGF0ZVxuICogQHBhcmFtIHs/fSByZXBvcnREZXByZWNhdGlvblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNUZW1wbGF0ZShlbCwgZW5hYmxlTGVnYWN5VGVtcGxhdGUsIHJlcG9ydERlcHJlY2F0aW9uKSB7XG4gICAgaWYgKGlzTmdUZW1wbGF0ZShlbC5uYW1lKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFnTm9OcyA9IHNwbGl0TnNOYW1lKGVsLm5hbWUpWzFdO1xuICAgIC8vIGA8dGVtcGxhdGU+YCBpcyBIVE1MIGFuZCBjYXNlIGluc2Vuc2l0aXZlXG4gICAgaWYgKHRhZ05vTnMudG9Mb3dlckNhc2UoKSA9PT0gVEVNUExBVEVfRUxFTUVOVCkge1xuICAgICAgICBpZiAoZW5hYmxlTGVnYWN5VGVtcGxhdGUgJiYgdGFnTm9Ocy50b0xvd2VyQ2FzZSgpID09PSBURU1QTEFURV9FTEVNRU5UKSB7XG4gICAgICAgICAgICByZXBvcnREZXByZWNhdGlvbihURU1QTEFURV9FTEVNRU5UX0RFUFJFQ0FUSU9OX1dBUk5JTkcsIC8qKiBAdHlwZSB7P30gKi8gKChlbC5zb3VyY2VTcGFuKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBBbiBpbnRlcmZhY2UgZm9yIHJldHJpZXZpbmcgZG9jdW1lbnRzIGJ5IFVSTCB0aGF0IHRoZSBjb21waWxlciB1c2VzXG4gKiB0byBsb2FkIHRlbXBsYXRlcy5cbiAqL1xudmFyIFJlc291cmNlTG9hZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNvdXJjZUxvYWRlcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlc291cmNlTG9hZGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBudWxsOyB9O1xuICAgIHJldHVybiBSZXNvdXJjZUxvYWRlcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIENyZWF0ZSBhIHtcXEBsaW5rIFVybFJlc29sdmVyfSB3aXRoIG5vIHBhY2thZ2UgcHJlZml4LlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVXJsUmVzb2x2ZXJXaXRob3V0UGFja2FnZVByZWZpeCgpIHtcbiAgICByZXR1cm4gbmV3IFVybFJlc29sdmVyKCk7XG59XG4vKipcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU9mZmxpbmVDb21waWxlVXJsUmVzb2x2ZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBVcmxSZXNvbHZlcignLicpO1xufVxuLyoqXG4gKiBBIGRlZmF1bHQgcHJvdmlkZXIgZm9yIHtAbGluayBQQUNLQUdFX1JPT1RfVVJMfSB0aGF0IG1hcHMgdG8gJy8nLlxuICovXG52YXIgREVGQVVMVF9QQUNLQUdFX1VSTF9QUk9WSURFUiA9IHtcbiAgICBwcm92aWRlOiBQQUNLQUdFX1JPT1RfVVJMLFxuICAgIHVzZVZhbHVlOiAnLydcbn07XG4vKipcbiAqIFVzZWQgYnkgdGhlIHtcXEBsaW5rIENvbXBpbGVyfSB3aGVuIHJlc29sdmluZyBIVE1MIGFuZCBDU1MgdGVtcGxhdGUgVVJMcy5cbiAqXG4gKiBUaGlzIGNsYXNzIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgdG8gY3JlYXRlIGN1c3RvbSBiZWhhdmlvci5cbiAqXG4gKiBTZWUge1xcQGxpbmsgQ29tcGlsZXJ9XG4gKlxuICogIyMgRXhhbXBsZVxuICpcbiAqIHtcXEBleGFtcGxlIGNvbXBpbGVyL3RzL3VybF9yZXNvbHZlci91cmxfcmVzb2x2ZXIudHMgcmVnaW9uPSd1cmxfcmVzb2x2ZXInfVxuICpcbiAqIFxcQHNlY3VyaXR5IFdoZW4gY29tcGlsaW5nIHRlbXBsYXRlcyBhdCBydW50aW1lLCB5b3UgbXVzdFxuICogZW5zdXJlIHRoYXQgdGhlIGVudGlyZSB0ZW1wbGF0ZSBjb21lcyBmcm9tIGEgdHJ1c3RlZCBzb3VyY2UuXG4gKiBBdHRhY2tlci1jb250cm9sbGVkIGRhdGEgaW50cm9kdWNlZCBieSBhIHRlbXBsYXRlIGNvdWxkIGV4cG9zZSB5b3VyXG4gKiBhcHBsaWNhdGlvbiB0byBYU1Mgcmlza3MuIEZvciBtb3JlIGRldGFpbCwgc2VlIHRoZSBbU2VjdXJpdHkgR3VpZGVdKGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5KS5cbiAqL1xudmFyIFVybFJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBfcGFja2FnZVByZWZpeFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVybFJlc29sdmVyKF9wYWNrYWdlUHJlZml4KSB7XG4gICAgICAgIGlmIChfcGFja2FnZVByZWZpeCA9PT0gdm9pZCAwKSB7IF9wYWNrYWdlUHJlZml4ID0gbnVsbDsgfVxuICAgICAgICB0aGlzLl9wYWNrYWdlUHJlZml4ID0gX3BhY2thZ2VQcmVmaXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSBgdXJsYCBnaXZlbiB0aGUgYGJhc2VVcmxgOlxuICAgICAqIC0gd2hlbiB0aGUgYHVybGAgaXMgbnVsbCwgdGhlIGBiYXNlVXJsYCBpcyByZXR1cm5lZCxcbiAgICAgKiAtIGlmIGB1cmxgIGlzIHJlbGF0aXZlICgncGF0aC90by9oZXJlJywgJy4vcGF0aC90by9oZXJlJyksIHRoZSByZXNvbHZlZCB1cmwgaXMgYSBjb21iaW5hdGlvbiBvZlxuICAgICAqIGBiYXNlVXJsYCBhbmQgYHVybGAsXG4gICAgICogLSBpZiBgdXJsYCBpcyBhYnNvbHV0ZSAoaXQgaGFzIGEgc2NoZW1lOiAnaHR0cDovLycsICdodHRwczovLycgb3Igc3RhcnQgd2l0aCAnLycpLCB0aGUgYHVybGAgaXNcbiAgICAgKiByZXR1cm5lZCBhcyBpcyAoaWdub3JpbmcgdGhlIGBiYXNlVXJsYClcbiAgICAgKiBAcGFyYW0gez99IGJhc2VVcmxcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVXJsUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoYmFzZVVybCwgdXJsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkVXJsID0gdXJsO1xuICAgICAgICBpZiAoYmFzZVVybCAhPSBudWxsICYmIGJhc2VVcmwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZWRVcmwgPSBfcmVzb2x2ZVVybChiYXNlVXJsLCByZXNvbHZlZFVybCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRQYXJ0cyA9IF9zcGxpdChyZXNvbHZlZFVybCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZWZpeCA9IHRoaXMuX3BhY2thZ2VQcmVmaXg7XG4gICAgICAgIGlmIChwcmVmaXggIT0gbnVsbCAmJiByZXNvbHZlZFBhcnRzICE9IG51bGwgJiZcbiAgICAgICAgICAgIHJlc29sdmVkUGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0gPT0gJ3BhY2thZ2UnKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXRoID0gcmVzb2x2ZWRQYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF07XG4gICAgICAgICAgICBwcmVmaXggPSBwcmVmaXgucmVwbGFjZSgvXFwvKyQvLCAnJyk7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eXFwvKy8sICcnKTtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBcIi9cIiArIHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkVXJsO1xuICAgIH07XG4gICAgcmV0dXJuIFVybFJlc29sdmVyO1xufSgpKTtcblVybFJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblVybFJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtQQUNLQUdFX1JPT1RfVVJMLF0gfSxdIH0sXG5dOyB9O1xuLyoqXG4gKiBFeHRyYWN0IHRoZSBzY2hlbWUgb2YgYSBVUkwuXG4gKiBAcGFyYW0gez99IHVybFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0VXJsU2NoZW1lKHVybCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hdGNoID0gX3NwbGl0KHVybCk7XG4gICAgcmV0dXJuIChtYXRjaCAmJiBtYXRjaFtfQ29tcG9uZW50SW5kZXguU2NoZW1lXSkgfHwgJyc7XG59XG4vKipcbiAqIEJ1aWxkcyBhIFVSSSBzdHJpbmcgZnJvbSBhbHJlYWR5LWVuY29kZWQgcGFydHMuXG4gKlxuICogTm8gZW5jb2RpbmcgaXMgcGVyZm9ybWVkLiAgQW55IGNvbXBvbmVudCBtYXkgYmUgb21pdHRlZCBhcyBlaXRoZXIgbnVsbCBvclxuICogdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7Pz19IG9wdF9zY2hlbWUgVGhlIHNjaGVtZSBzdWNoIGFzICdodHRwJy5cbiAqIEBwYXJhbSB7Pz19IG9wdF91c2VySW5mbyBUaGUgdXNlciBuYW1lIGJlZm9yZSB0aGUgJ1xcQCcuXG4gKiBAcGFyYW0gez89fSBvcHRfZG9tYWluIFRoZSBkb21haW4gc3VjaCBhcyAnd3d3Lmdvb2dsZS5jb20nLCBhbHJlYWR5XG4gKiAgICAgVVJJLWVuY29kZWQuXG4gKiBAcGFyYW0gez89fSBvcHRfcG9ydCBUaGUgcG9ydCBudW1iZXIuXG4gKiBAcGFyYW0gez89fSBvcHRfcGF0aCBUaGUgcGF0aCwgYWxyZWFkeSBVUkktZW5jb2RlZC4gIElmIGl0IGlzIG5vdFxuICogICAgIGVtcHR5LCBpdCBtdXN0IGJlZ2luIHdpdGggYSBzbGFzaC5cbiAqIEBwYXJhbSB7Pz19IG9wdF9xdWVyeURhdGEgVGhlIFVSSS1lbmNvZGVkIHF1ZXJ5IGRhdGEuXG4gKiBAcGFyYW0gez89fSBvcHRfZnJhZ21lbnQgVGhlIFVSSS1lbmNvZGVkIGZyYWdtZW50IGlkZW50aWZpZXIuXG4gKiBAcmV0dXJuIHs/fSBUaGUgZnVsbHkgY29tYmluZWQgVVJJLlxuICovXG5mdW5jdGlvbiBfYnVpbGRGcm9tRW5jb2RlZFBhcnRzKG9wdF9zY2hlbWUsIG9wdF91c2VySW5mbywgb3B0X2RvbWFpbiwgb3B0X3BvcnQsIG9wdF9wYXRoLCBvcHRfcXVlcnlEYXRhLCBvcHRfZnJhZ21lbnQpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXQgPSBbXTtcbiAgICBpZiAob3B0X3NjaGVtZSAhPSBudWxsKSB7XG4gICAgICAgIG91dC5wdXNoKG9wdF9zY2hlbWUgKyAnOicpO1xuICAgIH1cbiAgICBpZiAob3B0X2RvbWFpbiAhPSBudWxsKSB7XG4gICAgICAgIG91dC5wdXNoKCcvLycpO1xuICAgICAgICBpZiAob3B0X3VzZXJJbmZvICE9IG51bGwpIHtcbiAgICAgICAgICAgIG91dC5wdXNoKG9wdF91c2VySW5mbyArICdAJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0LnB1c2gob3B0X2RvbWFpbik7XG4gICAgICAgIGlmIChvcHRfcG9ydCAhPSBudWxsKSB7XG4gICAgICAgICAgICBvdXQucHVzaCgnOicgKyBvcHRfcG9ydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdF9wYXRoICE9IG51bGwpIHtcbiAgICAgICAgb3V0LnB1c2gob3B0X3BhdGgpO1xuICAgIH1cbiAgICBpZiAob3B0X3F1ZXJ5RGF0YSAhPSBudWxsKSB7XG4gICAgICAgIG91dC5wdXNoKCc/JyArIG9wdF9xdWVyeURhdGEpO1xuICAgIH1cbiAgICBpZiAob3B0X2ZyYWdtZW50ICE9IG51bGwpIHtcbiAgICAgICAgb3V0LnB1c2goJyMnICsgb3B0X2ZyYWdtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dC5qb2luKCcnKTtcbn1cbi8qKlxuICogQSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIGJyZWFraW5nIGEgVVJJIGludG8gaXRzIGNvbXBvbmVudCBwYXJ0cy5cbiAqXG4gKiB7XFxAbGluayBodHRwOi8vd3d3LmdiaXYuY29tL3Byb3RvY29scy91cmkvcmZjL3JmYzM5ODYuaHRtbCNSRkMyMjM0fSBzYXlzXG4gKiBBcyB0aGUgXCJmaXJzdC1tYXRjaC13aW5zXCIgYWxnb3JpdGhtIGlzIGlkZW50aWNhbCB0byB0aGUgXCJncmVlZHlcIlxuICogZGlzYW1iaWd1YXRpb24gbWV0aG9kIHVzZWQgYnkgUE9TSVggcmVndWxhciBleHByZXNzaW9ucywgaXQgaXMgbmF0dXJhbCBhbmRcbiAqIGNvbW1vbnBsYWNlIHRvIHVzZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgcGFyc2luZyB0aGUgcG90ZW50aWFsIGZpdmVcbiAqIGNvbXBvbmVudHMgb2YgYSBVUkkgcmVmZXJlbmNlLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgbGluZSBpcyB0aGUgcmVndWxhciBleHByZXNzaW9uIGZvciBicmVha2luZy1kb3duIGFcbiAqIHdlbGwtZm9ybWVkIFVSSSByZWZlcmVuY2UgaW50byBpdHMgY29tcG9uZW50cy5cbiAqXG4gKiA8cHJlPlxuICogXigoW146Lz8jXSspOik/KC8vKFteLz8jXSopKT8oW14/I10qKShcXD8oW14jXSopKT8oIyguKikpP1xuICogIDEyICAgICAgICAgICAgMyAgNCAgICAgICAgICA1ICAgICAgIDYgIDcgICAgICAgIDggOVxuICogPC9wcmU+XG4gKlxuICogVGhlIG51bWJlcnMgaW4gdGhlIHNlY29uZCBsaW5lIGFib3ZlIGFyZSBvbmx5IHRvIGFzc2lzdCByZWFkYWJpbGl0eTsgdGhleVxuICogaW5kaWNhdGUgdGhlIHJlZmVyZW5jZSBwb2ludHMgZm9yIGVhY2ggc3ViZXhwcmVzc2lvbiAoaS5lLiwgZWFjaCBwYWlyZWRcbiAqIHBhcmVudGhlc2lzKS4gV2UgcmVmZXIgdG8gdGhlIHZhbHVlIG1hdGNoZWQgZm9yIHN1YmV4cHJlc3Npb24gPG4+IGFzICQ8bj4uXG4gKiBGb3IgZXhhbXBsZSwgbWF0Y2hpbmcgdGhlIGFib3ZlIGV4cHJlc3Npb24gdG9cbiAqIDxwcmU+XG4gKiAgICAgaHR0cDovL3d3dy5pY3MudWNpLmVkdS9wdWIvaWV0Zi91cmkvI1JlbGF0ZWRcbiAqIDwvcHJlPlxuICogcmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nIHN1YmV4cHJlc3Npb24gbWF0Y2hlczpcbiAqIDxwcmU+XG4gKiAgICAkMSA9IGh0dHA6XG4gKiAgICAkMiA9IGh0dHBcbiAqICAgICQzID0gLy93d3cuaWNzLnVjaS5lZHVcbiAqICAgICQ0ID0gd3d3Lmljcy51Y2kuZWR1XG4gKiAgICAkNSA9IC9wdWIvaWV0Zi91cmkvXG4gKiAgICAkNiA9IDx1bmRlZmluZWQ+XG4gKiAgICAkNyA9IDx1bmRlZmluZWQ+XG4gKiAgICAkOCA9ICNSZWxhdGVkXG4gKiAgICAkOSA9IFJlbGF0ZWRcbiAqIDwvcHJlPlxuICogd2hlcmUgPHVuZGVmaW5lZD4gaW5kaWNhdGVzIHRoYXQgdGhlIGNvbXBvbmVudCBpcyBub3QgcHJlc2VudCwgYXMgaXMgdGhlXG4gKiBjYXNlIGZvciB0aGUgcXVlcnkgY29tcG9uZW50IGluIHRoZSBhYm92ZSBleGFtcGxlLiBUaGVyZWZvcmUsIHdlIGNhblxuICogZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiB0aGUgZml2ZSBjb21wb25lbnRzIGFzXG4gKiA8cHJlPlxuICogICAgc2NoZW1lICAgID0gJDJcbiAqICAgIGF1dGhvcml0eSA9ICQ0XG4gKiAgICBwYXRoICAgICAgPSAkNVxuICogICAgcXVlcnkgICAgID0gJDdcbiAqICAgIGZyYWdtZW50ICA9ICQ5XG4gKiA8L3ByZT5cbiAqXG4gKiBUaGUgcmVndWxhciBleHByZXNzaW9uIGhhcyBiZWVuIG1vZGlmaWVkIHNsaWdodGx5IHRvIGV4cG9zZSB0aGVcbiAqIHVzZXJJbmZvLCBkb21haW4sIGFuZCBwb3J0IHNlcGFyYXRlbHkgZnJvbSB0aGUgYXV0aG9yaXR5LlxuICogVGhlIG1vZGlmaWVkIHZlcnNpb24geWllbGRzXG4gKiA8cHJlPlxuICogICAgJDEgPSBodHRwICAgICAgICAgICAgICBzY2hlbWVcbiAqICAgICQyID0gPHVuZGVmaW5lZD4gICAgICAgdXNlckluZm8gLVxcXG4gKiAgICAkMyA9IHd3dy5pY3MudWNpLmVkdSAgIGRvbWFpbiAgICAgfCBhdXRob3JpdHlcbiAqICAgICQ0ID0gPHVuZGVmaW5lZD4gICAgICAgcG9ydCAgICAgLS9cbiAqICAgICQ1ID0gL3B1Yi9pZXRmL3VyaS8gICAgcGF0aFxuICogICAgJDYgPSA8dW5kZWZpbmVkPiAgICAgICBxdWVyeSB3aXRob3V0ID9cbiAqICAgICQ3ID0gUmVsYXRlZCAgICAgICAgICAgZnJhZ21lbnQgd2l0aG91dCAjXG4gKiA8L3ByZT5cbiAqIFxcQGludGVybmFsXG4gKi9cbnZhciBfc3BsaXRSZSA9IG5ldyBSZWdFeHAoJ14nICtcbiAgICAnKD86JyArXG4gICAgJyhbXjovPyMuXSspJyArXG4gICAgLy8gdXNlZCBieSBvdGhlciBVUkwgcGFydHMgc3VjaCBhcyA6LFxuICAgIC8vID8sIC8sICMsIGFuZCAuXG4gICAgJzopPycgK1xuICAgICcoPzovLycgK1xuICAgICcoPzooW14vPyNdKilAKT8nICtcbiAgICAnKFtcXFxcd1xcXFxkXFxcXC1cXFxcdTAxMDAtXFxcXHVmZmZmLiVdKiknICtcbiAgICAvLyBkaWdpdHMsIGRhc2hlcywgZG90cywgcGVyY2VudFxuICAgIC8vIGVzY2FwZXMsIGFuZCB1bmljb2RlIGNoYXJhY3RlcnMuXG4gICAgJyg/OjooWzAtOV0rKSk/JyArXG4gICAgJyk/JyArXG4gICAgJyhbXj8jXSspPycgK1xuICAgICcoPzpcXFxcPyhbXiNdKikpPycgK1xuICAgICcoPzojKC4qKSk/JyArXG4gICAgJyQnKTtcbnZhciBfQ29tcG9uZW50SW5kZXggPSB7fTtcbl9Db21wb25lbnRJbmRleC5TY2hlbWUgPSAxO1xuX0NvbXBvbmVudEluZGV4LlVzZXJJbmZvID0gMjtcbl9Db21wb25lbnRJbmRleC5Eb21haW4gPSAzO1xuX0NvbXBvbmVudEluZGV4LlBvcnQgPSA0O1xuX0NvbXBvbmVudEluZGV4LlBhdGggPSA1O1xuX0NvbXBvbmVudEluZGV4LlF1ZXJ5RGF0YSA9IDY7XG5fQ29tcG9uZW50SW5kZXguRnJhZ21lbnQgPSA3O1xuX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleC5TY2hlbWVdID0gXCJTY2hlbWVcIjtcbl9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXguVXNlckluZm9dID0gXCJVc2VySW5mb1wiO1xuX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleC5Eb21haW5dID0gXCJEb21haW5cIjtcbl9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXguUG9ydF0gPSBcIlBvcnRcIjtcbl9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXguUGF0aF0gPSBcIlBhdGhcIjtcbl9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXguUXVlcnlEYXRhXSA9IFwiUXVlcnlEYXRhXCI7XG5fQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4LkZyYWdtZW50XSA9IFwiRnJhZ21lbnRcIjtcbi8qKlxuICogU3BsaXRzIGEgVVJJIGludG8gaXRzIGNvbXBvbmVudCBwYXJ0cy5cbiAqXG4gKiBFYWNoIGNvbXBvbmVudCBjYW4gYmUgYWNjZXNzZWQgdmlhIHRoZSBjb21wb25lbnQgaW5kaWNlczsgZm9yIGV4YW1wbGU6XG4gKiA8cHJlPlxuICogZ29vZy51cmkudXRpbHMuc3BsaXQoc29tZVN0cilbZ29vZy51cmkudXRpbHMuQ29tcG9udGVudEluZGV4LlFVRVJZX0RBVEFdO1xuICogPC9wcmU+XG4gKlxuICogQHBhcmFtIHs/fSB1cmkgVGhlIFVSSSBzdHJpbmcgdG8gZXhhbWluZS5cbiAqIEByZXR1cm4gez99IEVhY2ggY29tcG9uZW50IHN0aWxsIFVSSS1lbmNvZGVkLlxuICogICAgIEVhY2ggY29tcG9uZW50IHRoYXQgaXMgcHJlc2VudCB3aWxsIGNvbnRhaW4gdGhlIGVuY29kZWQgdmFsdWUsIHdoZXJlYXNcbiAqICAgICBjb21wb25lbnRzIHRoYXQgYXJlIG5vdCBwcmVzZW50IHdpbGwgYmUgdW5kZWZpbmVkIG9yIGVtcHR5LCBkZXBlbmRpbmdcbiAqICAgICBvbiB0aGUgYnJvd3NlcidzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpbXBsZW1lbnRhdGlvbi4gIE5ldmVyIG51bGwsIHNpbmNlXG4gKiAgICAgYXJiaXRyYXJ5IHN0cmluZ3MgbWF5IHN0aWxsIGxvb2sgbGlrZSBwYXRoIG5hbWVzLlxuICovXG5mdW5jdGlvbiBfc3BsaXQodXJpKSB7XG4gICAgcmV0dXJuICgodXJpLm1hdGNoKF9zcGxpdFJlKSkpO1xufVxuLyoqXG4gKiBSZW1vdmVzIGRvdCBzZWdtZW50cyBpbiBnaXZlbiBwYXRoIGNvbXBvbmVudCwgYXMgZGVzY3JpYmVkIGluXG4gKiBSRkMgMzk4Niwgc2VjdGlvbiA1LjIuNC5cbiAqXG4gKiBAcGFyYW0gez99IHBhdGggQSBub24tZW1wdHkgcGF0aCBjb21wb25lbnQuXG4gKiBAcmV0dXJuIHs/fSBQYXRoIGNvbXBvbmVudCB3aXRoIHJlbW92ZWQgZG90IHNlZ21lbnRzLlxuICovXG5mdW5jdGlvbiBfcmVtb3ZlRG90U2VnbWVudHMocGF0aCkge1xuICAgIGlmIChwYXRoID09ICcvJylcbiAgICAgICAgcmV0dXJuICcvJztcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZWFkaW5nU2xhc2ggPSBwYXRoWzBdID09ICcvJyA/ICcvJyA6ICcnO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYWlsaW5nU2xhc2ggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICcvJyA/ICcvJyA6ICcnO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dCA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwID0gMDtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHBvcyA9IDA7IHBvcyA8IHNlZ21lbnRzLmxlbmd0aDsgcG9zKyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VnbWVudCA9IHNlZ21lbnRzW3Bvc107XG4gICAgICAgIHN3aXRjaCAoc2VnbWVudCkge1xuICAgICAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLi4nOlxuICAgICAgICAgICAgICAgIGlmIChvdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBvdXQucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goc2VnbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlYWRpbmdTbGFzaCA9PSAnJykge1xuICAgICAgICB3aGlsZSAodXAtLSA+IDApIHtcbiAgICAgICAgICAgIG91dC51bnNoaWZ0KCcuLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgb3V0LnB1c2goJy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlYWRpbmdTbGFzaCArIG91dC5qb2luKCcvJykgKyB0cmFpbGluZ1NsYXNoO1xufVxuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiB0aGUgcGFydHMgZnJvbSBzcGxpdCBhbmQgY2Fub25pY2FsaXplcyB0aGUgcGF0aCBwYXJ0XG4gKiBhbmQgdGhlbiBqb2lucyBhbGwgdGhlIHBhcnRzLlxuICogQHBhcmFtIHs/fSBwYXJ0c1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGF0aCA9IHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcbiAgICBwYXRoID0gcGF0aCA9PSBudWxsID8gJycgOiBfcmVtb3ZlRG90U2VnbWVudHMocGF0aCk7XG4gICAgcGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdID0gcGF0aDtcbiAgICByZXR1cm4gX2J1aWxkRnJvbUVuY29kZWRQYXJ0cyhwYXJ0c1tfQ29tcG9uZW50SW5kZXguU2NoZW1lXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LlVzZXJJbmZvXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LkRvbWFpbl0sIHBhcnRzW19Db21wb25lbnRJbmRleC5Qb3J0XSwgcGF0aCwgcGFydHNbX0NvbXBvbmVudEluZGV4LlF1ZXJ5RGF0YV0sIHBhcnRzW19Db21wb25lbnRJbmRleC5GcmFnbWVudF0pO1xufVxuLyoqXG4gKiBSZXNvbHZlcyBhIFVSTC5cbiAqIEBwYXJhbSB7P30gYmFzZSBUaGUgVVJMIGFjdGluZyBhcyB0aGUgYmFzZSBVUkwuXG4gKiBAcGFyYW0gez99IHVybFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX3Jlc29sdmVVcmwoYmFzZSwgdXJsKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydHMgPSBfc3BsaXQoZW5jb2RlVVJJKHVybCkpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VQYXJ0cyA9IF9zcGxpdChiYXNlKTtcbiAgICBpZiAocGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdID0gYmFzZVBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdO1xuICAgIH1cbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBfQ29tcG9uZW50SW5kZXguU2NoZW1lOyBpIDw9IF9Db21wb25lbnRJbmRleC5Qb3J0OyBpKyspIHtcbiAgICAgICAgaWYgKHBhcnRzW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcnRzW2ldID0gYmFzZVBhcnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF1bMF0gPT0gJy8nKSB7XG4gICAgICAgIHJldHVybiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXRoID0gYmFzZVBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcbiAgICBpZiAocGF0aCA9PSBudWxsKVxuICAgICAgICBwYXRoID0gJy8nO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBpbmRleCArIDEpICsgcGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdO1xuICAgIHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXSA9IHBhdGg7XG4gICAgcmV0dXJuIF9qb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cyk7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgRGlyZWN0aXZlTm9ybWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfcmVzb3VyY2VMb2FkZXJcbiAgICAgKiBAcGFyYW0gez99IF91cmxSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gX2h0bWxQYXJzZXJcbiAgICAgKiBAcGFyYW0gez99IF9jb25maWdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEaXJlY3RpdmVOb3JtYWxpemVyKF9yZXNvdXJjZUxvYWRlciwgX3VybFJlc29sdmVyLCBfaHRtbFBhcnNlciwgX2NvbmZpZykge1xuICAgICAgICB0aGlzLl9yZXNvdXJjZUxvYWRlciA9IF9yZXNvdXJjZUxvYWRlcjtcbiAgICAgICAgdGhpcy5fdXJsUmVzb2x2ZXIgPSBfdXJsUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLmNsZWFyKCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub3JtYWxpemVkRGlyZWN0aXZlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5jbGVhckNhY2hlRm9yID0gZnVuY3Rpb24gKG5vcm1hbGl6ZWREaXJlY3RpdmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFub3JtYWxpemVkRGlyZWN0aXZlLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGUgPSAoKG5vcm1hbGl6ZWREaXJlY3RpdmUudGVtcGxhdGUpKTtcbiAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZS5kZWxldGUoLyoqIEB0eXBlIHs/fSAqLyAoKHRlbXBsYXRlLnRlbXBsYXRlVXJsKSkpO1xuICAgICAgICB0ZW1wbGF0ZS5leHRlcm5hbFN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlc2hlZXQpIHsgX3RoaXMuX3Jlc291cmNlTG9hZGVyQ2FjaGUuZGVsZXRlKC8qKiBAdHlwZSB7P30gKi8gKChzdHlsZXNoZWV0Lm1vZHVsZVVybCkpKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuX2ZldGNoID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLmdldCh1cmwpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gKCh0aGlzLl9yZXNvdXJjZUxvYWRlci5nZXQodXJsKSkpO1xuICAgICAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZS5zZXQodXJsLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByZW5vcm1EYXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVUZW1wbGF0ZSA9IGZ1bmN0aW9uIChwcmVub3JtRGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub3JtYWxpemVkVGVtcGxhdGVTeW5jID0gKChudWxsKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vcm1hbGl6ZWRUZW1wbGF0ZUFzeW5jID0gKCh1bmRlZmluZWQpKTtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChwcmVub3JtRGF0YS50ZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQocHJlbm9ybURhdGEudGVtcGxhdGVVcmwpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXCInXCIgKyDJtXN0cmluZ2lmeShwcmVub3JtRGF0YS5jb21wb25lbnRUeXBlKSArIFwiJyBjb21wb25lbnQgY2Fubm90IGRlZmluZSBib3RoIHRlbXBsYXRlIGFuZCB0ZW1wbGF0ZVVybFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlbm9ybURhdGEudGVtcGxhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXCJUaGUgdGVtcGxhdGUgc3BlY2lmaWVkIGZvciBjb21wb25lbnQgXCIgKyDJtXN0cmluZ2lmeShwcmVub3JtRGF0YS5jb21wb25lbnRUeXBlKSArIFwiIGlzIG5vdCBhIHN0cmluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vcm1hbGl6ZWRUZW1wbGF0ZVN5bmMgPSB0aGlzLm5vcm1hbGl6ZVRlbXBsYXRlU3luYyhwcmVub3JtRGF0YSk7XG4gICAgICAgICAgICBub3JtYWxpemVkVGVtcGxhdGVBc3luYyA9IFByb21pc2UucmVzb2x2ZSgvKiogQHR5cGUgez99ICovICgobm9ybWFsaXplZFRlbXBsYXRlU3luYykpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0RlZmluZWQocHJlbm9ybURhdGEudGVtcGxhdGVVcmwpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZW5vcm1EYXRhLnRlbXBsYXRlVXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKFwiVGhlIHRlbXBsYXRlVXJsIHNwZWNpZmllZCBmb3IgY29tcG9uZW50IFwiICsgybVzdHJpbmdpZnkocHJlbm9ybURhdGEuY29tcG9uZW50VHlwZSkgKyBcIiBpcyBub3QgYSBzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3JtYWxpemVkVGVtcGxhdGVBc3luYyA9IHRoaXMubm9ybWFsaXplVGVtcGxhdGVBc3luYyhwcmVub3JtRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcIk5vIHRlbXBsYXRlIHNwZWNpZmllZCBmb3IgY29tcG9uZW50IFwiICsgybVzdHJpbmdpZnkocHJlbm9ybURhdGEuY29tcG9uZW50VHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3JtYWxpemVkVGVtcGxhdGVTeW5jICYmIG5vcm1hbGl6ZWRUZW1wbGF0ZVN5bmMuc3R5bGVVcmxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gc3luYyBjYXNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IFN5bmNBc3luY1Jlc3VsdChub3JtYWxpemVkVGVtcGxhdGVTeW5jKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFzeW5jIGNhc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3luY0FzeW5jUmVzdWx0KG51bGwsIG5vcm1hbGl6ZWRUZW1wbGF0ZUFzeW5jLnRoZW4oZnVuY3Rpb24gKG5vcm1hbGl6ZWRUZW1wbGF0ZSkgeyByZXR1cm4gX3RoaXMubm9ybWFsaXplRXh0ZXJuYWxTdHlsZXNoZWV0cyhub3JtYWxpemVkVGVtcGxhdGUpOyB9KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJlbm9tRGF0YVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplVGVtcGxhdGVTeW5jID0gZnVuY3Rpb24gKHByZW5vbURhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplTG9hZGVkVGVtcGxhdGUocHJlbm9tRGF0YSwgLyoqIEB0eXBlIHs/fSAqLyAoKHByZW5vbURhdGEudGVtcGxhdGUpKSwgcHJlbm9tRGF0YS5tb2R1bGVVcmwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcmVub21EYXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVUZW1wbGF0ZUFzeW5jID0gZnVuY3Rpb24gKHByZW5vbURhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVVcmwgPSB0aGlzLl91cmxSZXNvbHZlci5yZXNvbHZlKHByZW5vbURhdGEubW9kdWxlVXJsLCAvKiogQHR5cGUgez99ICovICgocHJlbm9tRGF0YS50ZW1wbGF0ZVVybCkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoKHRlbXBsYXRlVXJsKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBfdGhpcy5ub3JtYWxpemVMb2FkZWRUZW1wbGF0ZShwcmVub21EYXRhLCB2YWx1ZSwgdGVtcGxhdGVVcmwpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJlbm9ybURhdGFcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZUFic1VybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplTG9hZGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAocHJlbm9ybURhdGEsIHRlbXBsYXRlLCB0ZW1wbGF0ZUFic1VybCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0lubGluZSA9ICEhcHJlbm9ybURhdGEudGVtcGxhdGU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGludGVycG9sYXRpb25Db25maWcgPSBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheSgvKiogQHR5cGUgez99ICovICgocHJlbm9ybURhdGEuaW50ZXJwb2xhdGlvbikpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcm9vdE5vZGVzQW5kRXJyb3JzID0gdGhpcy5faHRtbFBhcnNlci5wYXJzZSh0ZW1wbGF0ZSwgdGVtcGxhdGVTb3VyY2VVcmwoeyByZWZlcmVuY2U6IHByZW5vcm1EYXRhLm5nTW9kdWxlVHlwZSB9LCB7IHR5cGU6IHsgcmVmZXJlbmNlOiBwcmVub3JtRGF0YS5jb21wb25lbnRUeXBlIH0gfSwgeyBpc0lubGluZTogaXNJbmxpbmUsIHRlbXBsYXRlVXJsOiB0ZW1wbGF0ZUFic1VybCB9KSwgdHJ1ZSwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIGlmIChyb290Tm9kZXNBbmRFcnJvcnMuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yU3RyaW5nID0gcm9vdE5vZGVzQW5kRXJyb3JzLmVycm9ycy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKFwiVGVtcGxhdGUgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlTWV0YWRhdGFTdHlsZXMgPSB0aGlzLm5vcm1hbGl6ZVN0eWxlc2hlZXQobmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoe1xuICAgICAgICAgICAgc3R5bGVzOiBwcmVub3JtRGF0YS5zdHlsZXMsXG4gICAgICAgICAgICBzdHlsZVVybHM6IHByZW5vcm1EYXRhLnN0eWxlVXJscyxcbiAgICAgICAgICAgIG1vZHVsZVVybDogcHJlbm9ybURhdGEubW9kdWxlVXJsXG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvcigpO1xuICAgICAgICB2aXNpdEFsbCh2aXNpdG9yLCByb290Tm9kZXNBbmRFcnJvcnMucm9vdE5vZGVzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVTdHlsZXMgPSB0aGlzLm5vcm1hbGl6ZVN0eWxlc2hlZXQobmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoeyBzdHlsZXM6IHZpc2l0b3Iuc3R5bGVzLCBzdHlsZVVybHM6IHZpc2l0b3Iuc3R5bGVVcmxzLCBtb2R1bGVVcmw6IHRlbXBsYXRlQWJzVXJsIH0pKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5jYXBzdWxhdGlvbiA9IHByZW5vcm1EYXRhLmVuY2Fwc3VsYXRpb247XG4gICAgICAgIGlmIChlbmNhcHN1bGF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb24gPSB0aGlzLl9jb25maWcuZGVmYXVsdEVuY2Fwc3VsYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzID0gdGVtcGxhdGVNZXRhZGF0YVN0eWxlcy5zdHlsZXMuY29uY2F0KHRlbXBsYXRlU3R5bGVzLnN0eWxlcyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlVXJscyA9IHRlbXBsYXRlTWV0YWRhdGFTdHlsZXMuc3R5bGVVcmxzLmNvbmNhdCh0ZW1wbGF0ZVN0eWxlcy5zdHlsZVVybHMpO1xuICAgICAgICBpZiAoZW5jYXBzdWxhdGlvbiA9PT0gVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQgJiYgc3R5bGVzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgc3R5bGVVcmxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbiA9IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSh7XG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBlbmNhcHN1bGF0aW9uLFxuICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IHRlbXBsYXRlQWJzVXJsLCBzdHlsZXM6IHN0eWxlcywgc3R5bGVVcmxzOiBzdHlsZVVybHMsXG4gICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IHZpc2l0b3IubmdDb250ZW50U2VsZWN0b3JzLFxuICAgICAgICAgICAgYW5pbWF0aW9uczogcHJlbm9ybURhdGEuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgIGludGVycG9sYXRpb246IHByZW5vcm1EYXRhLmludGVycG9sYXRpb24sIGlzSW5saW5lOiBpc0lubGluZSxcbiAgICAgICAgICAgIGV4dGVybmFsU3R5bGVzaGVldHM6IFtdXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZU1ldGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZUV4dGVybmFsU3R5bGVzaGVldHMgPSBmdW5jdGlvbiAodGVtcGxhdGVNZXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkTWlzc2luZ0V4dGVybmFsU3R5bGVzaGVldHModGVtcGxhdGVNZXRhLnN0eWxlVXJscylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChleHRlcm5hbFN0eWxlc2hlZXRzKSB7IHJldHVybiBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogdGVtcGxhdGVNZXRhLmVuY2Fwc3VsYXRpb24sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGVNZXRhLnRlbXBsYXRlLFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IHRlbXBsYXRlTWV0YS50ZW1wbGF0ZVVybCxcbiAgICAgICAgICAgIHN0eWxlczogdGVtcGxhdGVNZXRhLnN0eWxlcyxcbiAgICAgICAgICAgIHN0eWxlVXJsczogdGVtcGxhdGVNZXRhLnN0eWxlVXJscyxcbiAgICAgICAgICAgIGV4dGVybmFsU3R5bGVzaGVldHM6IGV4dGVybmFsU3R5bGVzaGVldHMsXG4gICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IHRlbXBsYXRlTWV0YS5uZ0NvbnRlbnRTZWxlY3RvcnMsXG4gICAgICAgICAgICBhbmltYXRpb25zOiB0ZW1wbGF0ZU1ldGEuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgIGludGVycG9sYXRpb246IHRlbXBsYXRlTWV0YS5pbnRlcnBvbGF0aW9uLFxuICAgICAgICAgICAgaXNJbmxpbmU6IHRlbXBsYXRlTWV0YS5pc0lubGluZSxcbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVVybHNcbiAgICAgKiBAcGFyYW0gez89fSBsb2FkZWRTdHlsZXNoZWV0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuX2xvYWRNaXNzaW5nRXh0ZXJuYWxTdHlsZXNoZWV0cyA9IGZ1bmN0aW9uIChzdHlsZVVybHMsIGxvYWRlZFN0eWxlc2hlZXRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChsb2FkZWRTdHlsZXNoZWV0cyA9PT0gdm9pZCAwKSB7IGxvYWRlZFN0eWxlc2hlZXRzID0gbmV3IE1hcCgpOyB9XG4gICAgICAgIHJldHVybiBQcm9taXNlXG4gICAgICAgICAgICAuYWxsKHN0eWxlVXJscy5maWx0ZXIoZnVuY3Rpb24gKHN0eWxlVXJsKSB7IHJldHVybiAhbG9hZGVkU3R5bGVzaGVldHMuaGFzKHN0eWxlVXJsKTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHN0eWxlVXJsKSB7IHJldHVybiBfdGhpcy5fZmV0Y2goc3R5bGVVcmwpLnRoZW4oZnVuY3Rpb24gKGxvYWRlZFN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXNoZWV0ID0gX3RoaXMubm9ybWFsaXplU3R5bGVzaGVldChuZXcgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSh7IHN0eWxlczogW2xvYWRlZFN0eWxlXSwgbW9kdWxlVXJsOiBzdHlsZVVybCB9KSk7XG4gICAgICAgICAgICBsb2FkZWRTdHlsZXNoZWV0cy5zZXQoc3R5bGVVcmwsIHN0eWxlc2hlZXQpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9sb2FkTWlzc2luZ0V4dGVybmFsU3R5bGVzaGVldHMoc3R5bGVzaGVldC5zdHlsZVVybHMsIGxvYWRlZFN0eWxlc2hlZXRzKTtcbiAgICAgICAgfSk7IH0pKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuIEFycmF5LmZyb20obG9hZGVkU3R5bGVzaGVldHMudmFsdWVzKCkpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVzaGVldFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplU3R5bGVzaGVldCA9IGZ1bmN0aW9uIChzdHlsZXNoZWV0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZVVybCA9ICgoc3R5bGVzaGVldC5tb2R1bGVVcmwpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsU3R5bGVVcmxzID0gc3R5bGVzaGVldC5zdHlsZVVybHMuZmlsdGVyKGlzU3R5bGVVcmxSZXNvbHZhYmxlKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodXJsKSB7IHJldHVybiBfdGhpcy5fdXJsUmVzb2x2ZXIucmVzb2x2ZShtb2R1bGVVcmwsIHVybCk7IH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxTdHlsZXMgPSBzdHlsZXNoZWV0LnN0eWxlcy5tYXAoZnVuY3Rpb24gKHN0eWxlJCQxKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZVdpdGhJbXBvcnRzID0gZXh0cmFjdFN0eWxlVXJscyhfdGhpcy5fdXJsUmVzb2x2ZXIsIG1vZHVsZVVybCwgc3R5bGUkJDEpO1xuICAgICAgICAgICAgYWxsU3R5bGVVcmxzLnB1c2guYXBwbHkoYWxsU3R5bGVVcmxzLCBzdHlsZVdpdGhJbXBvcnRzLnN0eWxlVXJscyk7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGVXaXRoSW1wb3J0cy5zdHlsZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSh7IHN0eWxlczogYWxsU3R5bGVzLCBzdHlsZVVybHM6IGFsbFN0eWxlVXJscywgbW9kdWxlVXJsOiBtb2R1bGVVcmwgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGlyZWN0aXZlTm9ybWFsaXplcjtcbn0oKSk7XG5EaXJlY3RpdmVOb3JtYWxpemVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkRpcmVjdGl2ZU5vcm1hbGl6ZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBSZXNvdXJjZUxvYWRlciwgfSxcbiAgICB7IHR5cGU6IFVybFJlc29sdmVyLCB9LFxuICAgIHsgdHlwZTogSHRtbFBhcnNlciwgfSxcbiAgICB7IHR5cGU6IENvbXBpbGVyQ29uZmlnLCB9LFxuXTsgfTtcbnZhciBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IoKSB7XG4gICAgICAgIHRoaXMubmdDb250ZW50U2VsZWN0b3JzID0gW107XG4gICAgICAgIHRoaXMuc3R5bGVzID0gW107XG4gICAgICAgIHRoaXMuc3R5bGVVcmxzID0gW107XG4gICAgICAgIHRoaXMubmdOb25CaW5kYWJsZVN0YWNrQ291bnQgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlcGFyc2VkRWxlbWVudCA9IHByZXBhcnNlRWxlbWVudChhc3QpO1xuICAgICAgICBzd2l0Y2ggKHByZXBhcnNlZEVsZW1lbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBQcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmdDb250ZW50U2VsZWN0b3JzLnB1c2gocHJlcGFyc2VkRWxlbWVudC5zZWxlY3RBdHRyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFOlxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRleHRDb250ZW50XzEgPSAnJztcbiAgICAgICAgICAgICAgICBhc3QuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbnRlbnRfMSArPSBjaGlsZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzLnB1c2godGV4dENvbnRlbnRfMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZVVybHMucHVzaChwcmVwYXJzZWRFbGVtZW50LmhyZWZBdHRyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQubm9uQmluZGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMubmdOb25CaW5kYWJsZVN0YWNrQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICB2aXNpdEFsbCh0aGlzLCBhc3QuY2hpbGRyZW4pO1xuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC5ub25CaW5kYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5uZ05vbkJpbmRhYmxlU3RhY2tDb3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdmlzaXRBbGwodGhpcywgYXN0LmNhc2VzKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmlzaXRBbGwodGhpcywgYXN0LmV4cHJlc3Npb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICByZXR1cm4gVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3I7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9fYXNzaWduID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24pIHx8IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIERpcmVjdGl2ZVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBfcmVmbGVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGlyZWN0aXZlUmVzb2x2ZXIoX3JlZmxlY3Rvcikge1xuICAgICAgICBpZiAoX3JlZmxlY3RvciA9PT0gdm9pZCAwKSB7IF9yZWZsZWN0b3IgPSDJtXJlZmxlY3RvcjsgfVxuICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBfcmVmbGVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5pc0RpcmVjdGl2ZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGVNZXRhZGF0YSA9IHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyhyZXNvbHZlRm9yd2FyZFJlZih0eXBlKSk7XG4gICAgICAgIHJldHVybiB0eXBlTWV0YWRhdGEgJiYgdHlwZU1ldGFkYXRhLnNvbWUoaXNEaXJlY3RpdmVNZXRhZGF0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSB0aHJvd0lmTm90Rm91bmRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHR5cGUsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlTWV0YWRhdGEgPSB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnMocmVzb2x2ZUZvcndhcmRSZWYodHlwZSkpO1xuICAgICAgICBpZiAodHlwZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXRhZGF0YSA9IGZpbmRMYXN0KHR5cGVNZXRhZGF0YSwgaXNEaXJlY3RpdmVNZXRhZGF0YSk7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wZXJ0eU1ldGFkYXRhID0gdGhpcy5fcmVmbGVjdG9yLnByb3BNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVyZ2VXaXRoUHJvcGVydHlNZXRhZGF0YShtZXRhZGF0YSwgcHJvcGVydHlNZXRhZGF0YSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gRGlyZWN0aXZlIGFubm90YXRpb24gZm91bmQgb24gXCIgKyDJtXN0cmluZ2lmeSh0eXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRtXG4gICAgICogQHBhcmFtIHs/fSBwcm9wZXJ0eU1ldGFkYXRhXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUuX21lcmdlV2l0aFByb3BlcnR5TWV0YWRhdGEgPSBmdW5jdGlvbiAoZG0sIHByb3BlcnR5TWV0YWRhdGEsIGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5wdXRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dHB1dHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdCA9IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyaWVzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BlcnR5TWV0YWRhdGEpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnB1dCA9IGZpbmRMYXN0KHByb3BlcnR5TWV0YWRhdGFbcHJvcE5hbWVdLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSBpbnN0YW5jZW9mIElucHV0OyB9KTtcbiAgICAgICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5iaW5kaW5nUHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0cy5wdXNoKHByb3BOYW1lICsgXCI6IFwiICsgaW5wdXQuYmluZGluZ1Byb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHMucHVzaChwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3V0cHV0ID0gZmluZExhc3QocHJvcGVydHlNZXRhZGF0YVtwcm9wTmFtZV0sIGZ1bmN0aW9uIChhKSB7IHJldHVybiBhIGluc3RhbmNlb2YgT3V0cHV0OyB9KTtcbiAgICAgICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0LmJpbmRpbmdQcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHByb3BOYW1lICsgXCI6IFwiICsgb3V0cHV0LmJpbmRpbmdQcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0QmluZGluZ3MgPSBwcm9wZXJ0eU1ldGFkYXRhW3Byb3BOYW1lXS5maWx0ZXIoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgJiYgYSBpbnN0YW5jZW9mIEhvc3RCaW5kaW5nOyB9KTtcbiAgICAgICAgICAgIGhvc3RCaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChob3N0QmluZGluZykge1xuICAgICAgICAgICAgICAgIGlmIChob3N0QmluZGluZy5ob3N0UHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0V2l0aCA9IGhvc3RCaW5kaW5nLmhvc3RQcm9wZXJ0eU5hbWVbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydFdpdGggPT09ICcoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQEhvc3RCaW5kaW5nIGNhbiBub3QgYmluZCB0byBldmVudHMuIFVzZSBASG9zdExpc3RlbmVyIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0V2l0aCA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJASG9zdEJpbmRpbmcgcGFyYW1ldGVyIHNob3VsZCBiZSBhIHByb3BlcnR5IG5hbWUsICdjbGFzcy48bmFtZT4nLCBvciAnYXR0ci48bmFtZT4nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBob3N0W1wiW1wiICsgaG9zdEJpbmRpbmcuaG9zdFByb3BlcnR5TmFtZSArIFwiXVwiXSA9IHByb3BOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdFtcIltcIiArIHByb3BOYW1lICsgXCJdXCJdID0gcHJvcE5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0TGlzdGVuZXJzID0gcHJvcGVydHlNZXRhZGF0YVtwcm9wTmFtZV0uZmlsdGVyKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhICYmIGEgaW5zdGFuY2VvZiBIb3N0TGlzdGVuZXI7IH0pO1xuICAgICAgICAgICAgaG9zdExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChob3N0TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gaG9zdExpc3RlbmVyLmFyZ3MgfHwgW107XG4gICAgICAgICAgICAgICAgaG9zdFtcIihcIiArIGhvc3RMaXN0ZW5lci5ldmVudE5hbWUgKyBcIilcIl0gPSBwcm9wTmFtZSArIFwiKFwiICsgYXJncy5qb2luKCcsJykgKyBcIilcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcnkgPSBmaW5kTGFzdChwcm9wZXJ0eU1ldGFkYXRhW3Byb3BOYW1lXSwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgaW5zdGFuY2VvZiBRdWVyeTsgfSk7XG4gICAgICAgICAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgICAgICAgICBxdWVyaWVzW3Byb3BOYW1lXSA9IHF1ZXJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lcmdlKGRtLCBpbnB1dHMsIG91dHB1dHMsIGhvc3QsIHF1ZXJpZXMsIGRpcmVjdGl2ZVR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkZWZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5fZXh0cmFjdFB1YmxpY05hbWUgPSBmdW5jdGlvbiAoZGVmKSB7IHJldHVybiBzcGxpdEF0Q29sb24oZGVmLCBbLyoqIEB0eXBlIHs/fSAqLyAoKG51bGwpKSwgZGVmXSlbMV0udHJpbSgpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYmluZGluZ3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5fZGVkdXBlQmluZGluZ3MgPSBmdW5jdGlvbiAoYmluZGluZ3MpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJldmVyc2VkUmVzdWx0ID0gW107XG4gICAgICAgIC8vIGdvIGxhc3QgdG8gZmlyc3QgdG8gYWxsb3cgbGF0ZXIgZW50cmllcyB0byBvdmVyd3JpdGUgcHJldmlvdXMgZW50cmllc1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBiaW5kaW5ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IHRoaXMuX2V4dHJhY3RQdWJsaWNOYW1lKGJpbmRpbmcpO1xuICAgICAgICAgICAgaWYgKCFuYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBuYW1lcy5hZGQobmFtZSk7XG4gICAgICAgICAgICAgICAgcmV2ZXJzZWRSZXN1bHQucHVzaChiaW5kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV2ZXJzZWRSZXN1bHQucmV2ZXJzZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVcbiAgICAgKiBAcGFyYW0gez99IGlucHV0c1xuICAgICAqIEBwYXJhbSB7P30gb3V0cHV0c1xuICAgICAqIEBwYXJhbSB7P30gaG9zdFxuICAgICAqIEBwYXJhbSB7P30gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGlyZWN0aXZlUmVzb2x2ZXIucHJvdG90eXBlLl9tZXJnZSA9IGZ1bmN0aW9uIChkaXJlY3RpdmUsIGlucHV0cywgb3V0cHV0cywgaG9zdCwgcXVlcmllcywgZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXJnZWRJbnB1dHMgPSB0aGlzLl9kZWR1cGVCaW5kaW5ncyhkaXJlY3RpdmUuaW5wdXRzID8gZGlyZWN0aXZlLmlucHV0cy5jb25jYXQoaW5wdXRzKSA6IGlucHV0cyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lcmdlZE91dHB1dHMgPSB0aGlzLl9kZWR1cGVCaW5kaW5ncyhkaXJlY3RpdmUub3V0cHV0cyA/IGRpcmVjdGl2ZS5vdXRwdXRzLmNvbmNhdChvdXRwdXRzKSA6IG91dHB1dHMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXJnZWRIb3N0ID0gZGlyZWN0aXZlLmhvc3QgPyBfX2Fzc2lnbih7fSwgZGlyZWN0aXZlLmhvc3QsIGhvc3QpIDogaG9zdDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVyZ2VkUXVlcmllcyA9IGRpcmVjdGl2ZS5xdWVyaWVzID8gX19hc3NpZ24oe30sIGRpcmVjdGl2ZS5xdWVyaWVzLCBxdWVyaWVzKSA6IHF1ZXJpZXM7XG4gICAgICAgIGlmIChkaXJlY3RpdmUgaW5zdGFuY2VvZiBDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50KHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogZGlyZWN0aXZlLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGlucHV0czogbWVyZ2VkSW5wdXRzLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IG1lcmdlZE91dHB1dHMsXG4gICAgICAgICAgICAgICAgaG9zdDogbWVyZ2VkSG9zdCxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogZGlyZWN0aXZlLmV4cG9ydEFzLFxuICAgICAgICAgICAgICAgIG1vZHVsZUlkOiBkaXJlY3RpdmUubW9kdWxlSWQsXG4gICAgICAgICAgICAgICAgcXVlcmllczogbWVyZ2VkUXVlcmllcyxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IGRpcmVjdGl2ZS5jaGFuZ2VEZXRlY3Rpb24sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBkaXJlY3RpdmUucHJvdmlkZXJzLFxuICAgICAgICAgICAgICAgIHZpZXdQcm92aWRlcnM6IGRpcmVjdGl2ZS52aWV3UHJvdmlkZXJzLFxuICAgICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogZGlyZWN0aXZlLmVudHJ5Q29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogZGlyZWN0aXZlLnRlbXBsYXRlLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBkaXJlY3RpdmUudGVtcGxhdGVVcmwsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBkaXJlY3RpdmUuc3R5bGVzLFxuICAgICAgICAgICAgICAgIHN0eWxlVXJsczogZGlyZWN0aXZlLnN0eWxlVXJscyxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBkaXJlY3RpdmUuZW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBkaXJlY3RpdmUuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBkaXJlY3RpdmUuaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERpcmVjdGl2ZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IGRpcmVjdGl2ZS5zZWxlY3RvcixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IG1lcmdlZElucHV0cyxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBtZXJnZWRPdXRwdXRzLFxuICAgICAgICAgICAgICAgIGhvc3Q6IG1lcmdlZEhvc3QsXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6IGRpcmVjdGl2ZS5leHBvcnRBcyxcbiAgICAgICAgICAgICAgICBxdWVyaWVzOiBtZXJnZWRRdWVyaWVzLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogZGlyZWN0aXZlLnByb3ZpZGVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEaXJlY3RpdmVSZXNvbHZlcjtcbn0oKSk7XG5EaXJlY3RpdmVSZXNvbHZlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5EaXJlY3RpdmVSZXNvbHZlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IMm1UmVmbGVjdG9yUmVhZGVyLCB9LFxuXTsgfTtcbi8qKlxuICogQHBhcmFtIHs/fSB0eXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0RpcmVjdGl2ZU1ldGFkYXRhKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIERpcmVjdGl2ZTtcbn1cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7P30gYXJyXG4gKiBAcGFyYW0gez99IGNvbmRpdGlvblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZmluZExhc3QoYXJyLCBjb25kaXRpb24pIHtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihhcnJbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFNUUklQX1NSQ19GSUxFX1NVRkZJWEVTID0gLyhcXC50c3xcXC5kXFwudHN8XFwuanN8XFwuanN4fFxcLnRzeCkkLztcbnZhciBOR19GQUNUT1JZID0gL1xcLm5nZmFjdG9yeVxcLi87XG4vKipcbiAqIEBwYXJhbSB7P30gZmlsZVBhdGhcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5nZmFjdG9yeUZpbGVQYXRoKGZpbGVQYXRoKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXJsV2l0aFN1ZmZpeCA9IHNwbGl0VHlwZXNjcmlwdFN1ZmZpeChmaWxlUGF0aCk7XG4gICAgcmV0dXJuIHVybFdpdGhTdWZmaXhbMF0gKyBcIi5uZ2ZhY3RvcnlcIiArIHVybFdpdGhTdWZmaXhbMV07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZmlsZVBhdGhcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHN0cmlwTmdGYWN0b3J5KGZpbGVQYXRoKSB7XG4gICAgcmV0dXJuIGZpbGVQYXRoLnJlcGxhY2UoTkdfRkFDVE9SWSwgJy4nKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBmaWxlUGF0aFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNOZ0ZhY3RvcnlGaWxlKGZpbGVQYXRoKSB7XG4gICAgcmV0dXJuIE5HX0ZBQ1RPUlkudGVzdChmaWxlUGF0aCk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcGF0aFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3BsaXRUeXBlc2NyaXB0U3VmZml4KHBhdGgpIHtcbiAgICBpZiAocGF0aC5lbmRzV2l0aCgnLmQudHMnKSkge1xuICAgICAgICByZXR1cm4gW3BhdGguc2xpY2UoMCwgLTUpLCAnLnRzJ107XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3REb3QgPSBwYXRoLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKGxhc3REb3QgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbcGF0aC5zdWJzdHJpbmcoMCwgbGFzdERvdCksIHBhdGguc3Vic3RyaW5nKGxhc3REb3QpXTtcbiAgICB9XG4gICAgcmV0dXJuIFtwYXRoLCAnJ107XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZmlsZU5hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHN1bW1hcnlGaWxlTmFtZShmaWxlTmFtZSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbGVOYW1lV2l0aG91dFN1ZmZpeCA9IGZpbGVOYW1lLnJlcGxhY2UoU1RSSVBfU1JDX0ZJTEVfU1VGRklYRVMsICcnKTtcbiAgICByZXR1cm4gZmlsZU5hbWVXaXRob3V0U3VmZml4ICsgXCIubmdzdW1tYXJ5Lmpzb25cIjtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQHBhcmFtIHs/fSBob29rXG4gKiBAcGFyYW0gez99IHRva2VuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBoYXNMaWZlY3ljbGVIb29rKGhvb2ssIHRva2VuKSB7XG4gICAgcmV0dXJuIMm1cmVmbGVjdG9yLmhhc0xpZmVjeWNsZUhvb2sodG9rZW4sIGdldEhvb2tOYW1lKGhvb2spKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBob29rXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRIb29rTmFtZShob29rKSB7XG4gICAgc3dpdGNoIChob29rKSB7XG4gICAgICAgIGNhc2UgybVMaWZlY3ljbGVIb29rcy5PbkluaXQ6XG4gICAgICAgICAgICByZXR1cm4gJ25nT25Jbml0JztcbiAgICAgICAgY2FzZSDJtUxpZmVjeWNsZUhvb2tzLk9uRGVzdHJveTpcbiAgICAgICAgICAgIHJldHVybiAnbmdPbkRlc3Ryb3knO1xuICAgICAgICBjYXNlIMm1TGlmZWN5Y2xlSG9va3MuRG9DaGVjazpcbiAgICAgICAgICAgIHJldHVybiAnbmdEb0NoZWNrJztcbiAgICAgICAgY2FzZSDJtUxpZmVjeWNsZUhvb2tzLk9uQ2hhbmdlczpcbiAgICAgICAgICAgIHJldHVybiAnbmdPbkNoYW5nZXMnO1xuICAgICAgICBjYXNlIMm1TGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50SW5pdDpcbiAgICAgICAgICAgIHJldHVybiAnbmdBZnRlckNvbnRlbnRJbml0JztcbiAgICAgICAgY2FzZSDJtUxpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudENoZWNrZWQ6XG4gICAgICAgICAgICByZXR1cm4gJ25nQWZ0ZXJDb250ZW50Q2hlY2tlZCc7XG4gICAgICAgIGNhc2UgybVMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdJbml0OlxuICAgICAgICAgICAgcmV0dXJuICduZ0FmdGVyVmlld0luaXQnO1xuICAgICAgICBjYXNlIMm1TGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3Q2hlY2tlZDpcbiAgICAgICAgICAgIHJldHVybiAnbmdBZnRlclZpZXdDaGVja2VkJztcbiAgICB9XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBwYXJhbSB7P30gb2JqXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfaXNOZ01vZHVsZU1ldGFkYXRhKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBOZ01vZHVsZTtcbn1cbi8qKlxuICogUmVzb2x2ZXMgdHlwZXMgdG8ge1xcQGxpbmsgTmdNb2R1bGV9LlxuICovXG52YXIgTmdNb2R1bGVSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX3JlZmxlY3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5nTW9kdWxlUmVzb2x2ZXIoX3JlZmxlY3Rvcikge1xuICAgICAgICBpZiAoX3JlZmxlY3RvciA9PT0gdm9pZCAwKSB7IF9yZWZsZWN0b3IgPSDJtXJlZmxlY3RvcjsgfVxuICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBfcmVmbGVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5nTW9kdWxlUmVzb2x2ZXIucHJvdG90eXBlLmlzTmdNb2R1bGUgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdGhpcy5fcmVmbGVjdG9yLmFubm90YXRpb25zKHR5cGUpLnNvbWUoX2lzTmdNb2R1bGVNZXRhZGF0YSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gdGhyb3dJZk5vdEZvdW5kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOZ01vZHVsZVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHR5cGUsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ01vZHVsZU1ldGEgPSBmaW5kTGFzdCh0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnModHlwZSksIF9pc05nTW9kdWxlTWV0YWRhdGEpO1xuICAgICAgICBpZiAobmdNb2R1bGVNZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmdNb2R1bGVNZXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE5nTW9kdWxlIG1ldGFkYXRhIGZvdW5kIGZvciAnXCIgKyDJtXN0cmluZ2lmeSh0eXBlKSArIFwiJy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE5nTW9kdWxlUmVzb2x2ZXI7XG59KCkpO1xuTmdNb2R1bGVSZXNvbHZlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5OZ01vZHVsZVJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogybVSZWZsZWN0b3JSZWFkZXIsIH0sXG5dOyB9O1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IHR5cGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9pc1BpcGVNZXRhZGF0YSh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgaW5zdGFuY2VvZiBQaXBlO1xufVxuLyoqXG4gKiBSZXNvbHZlIGEgYFR5cGVgIGZvciB7XFxAbGluayBQaXBlfS5cbiAqXG4gKiBUaGlzIGludGVyZmFjZSBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgYXBwbGljYXRpb24gZGV2ZWxvcGVyIHRvIGNyZWF0ZSBjdXN0b20gYmVoYXZpb3IuXG4gKlxuICogU2VlIHtcXEBsaW5rIENvbXBpbGVyfVxuICovXG52YXIgUGlwZVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBfcmVmbGVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGlwZVJlc29sdmVyKF9yZWZsZWN0b3IpIHtcbiAgICAgICAgaWYgKF9yZWZsZWN0b3IgPT09IHZvaWQgMCkgeyBfcmVmbGVjdG9yID0gybVyZWZsZWN0b3I7IH1cbiAgICAgICAgdGhpcy5fcmVmbGVjdG9yID0gX3JlZmxlY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQaXBlUmVzb2x2ZXIucHJvdG90eXBlLmlzUGlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGVNZXRhZGF0YSA9IHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyhyZXNvbHZlRm9yd2FyZFJlZih0eXBlKSk7XG4gICAgICAgIHJldHVybiB0eXBlTWV0YWRhdGEgJiYgdHlwZU1ldGFkYXRhLnNvbWUoX2lzUGlwZU1ldGFkYXRhKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB7XFxAbGluayBQaXBlfSBmb3IgYSBnaXZlbiBgVHlwZWAuXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gdGhyb3dJZk5vdEZvdW5kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQaXBlUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAodHlwZSwgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQgPT09IHZvaWQgMCkgeyB0aHJvd0lmTm90Rm91bmQgPSB0cnVlOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1ldGFzID0gdGhpcy5fcmVmbGVjdG9yLmFubm90YXRpb25zKHJlc29sdmVGb3J3YXJkUmVmKHR5cGUpKTtcbiAgICAgICAgaWYgKG1ldGFzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbm5vdGF0aW9uID0gZmluZExhc3QobWV0YXMsIF9pc1BpcGVNZXRhZGF0YSk7XG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFBpcGUgZGVjb3JhdG9yIGZvdW5kIG9uIFwiICsgybVzdHJpbmdpZnkodHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFBpcGVSZXNvbHZlcjtcbn0oKSk7XG5QaXBlUmVzb2x2ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBpbGVySW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuUGlwZVJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogybVSZWZsZWN0b3JSZWFkZXIsIH0sXG5dOyB9O1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFN1bW1hcnlSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3VtbWFyeVJlc29sdmVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZpbGVOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmlzTGlicmFyeUZpbGUgPSBmdW5jdGlvbiAoZmlsZU5hbWUpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZpbGVOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmdldExpYnJhcnlGaWxlTmFtZSA9IGZ1bmN0aW9uIChmaWxlTmFtZSkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlZmVyZW5jZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlU3VtbWFyeSA9IGZ1bmN0aW9uIChyZWZlcmVuY2UpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZVBhdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuZ2V0U3ltYm9sc09mID0gZnVuY3Rpb24gKGZpbGVQYXRoKSB7IHJldHVybiBbXTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlZmVyZW5jZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5nZXRJbXBvcnRBcyA9IGZ1bmN0aW9uIChyZWZlcmVuY2UpIHsgcmV0dXJuIHJlZmVyZW5jZTsgfTtcbiAgICByZXR1cm4gU3VtbWFyeVJlc29sdmVyO1xufSgpKTtcblN1bW1hcnlSZXNvbHZlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5TdW1tYXJ5UmVzb2x2ZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBFUlJPUl9DT0xMRUNUT1JfVE9LRU4gPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0Vycm9yQ29sbGVjdG9yJyk7XG52YXIgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2NvbmZpZ1xuICAgICAqIEBwYXJhbSB7P30gX25nTW9kdWxlUmVzb2x2ZXJcbiAgICAgKiBAcGFyYW0gez99IF9kaXJlY3RpdmVSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gX3BpcGVSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gX3N1bW1hcnlSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gX3NjaGVtYVJlZ2lzdHJ5XG4gICAgICogQHBhcmFtIHs/fSBfZGlyZWN0aXZlTm9ybWFsaXplclxuICAgICAqIEBwYXJhbSB7P30gX2NvbnNvbGVcbiAgICAgKiBAcGFyYW0gez99IF9zdGF0aWNTeW1ib2xDYWNoZVxuICAgICAqIEBwYXJhbSB7Pz19IF9yZWZsZWN0b3JcbiAgICAgKiBAcGFyYW0gez89fSBfZXJyb3JDb2xsZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlTWV0YWRhdGFSZXNvbHZlcihfY29uZmlnLCBfbmdNb2R1bGVSZXNvbHZlciwgX2RpcmVjdGl2ZVJlc29sdmVyLCBfcGlwZVJlc29sdmVyLCBfc3VtbWFyeVJlc29sdmVyLCBfc2NoZW1hUmVnaXN0cnksIF9kaXJlY3RpdmVOb3JtYWxpemVyLCBfY29uc29sZSwgX3N0YXRpY1N5bWJvbENhY2hlLCBfcmVmbGVjdG9yLCBfZXJyb3JDb2xsZWN0b3IpIHtcbiAgICAgICAgaWYgKF9yZWZsZWN0b3IgPT09IHZvaWQgMCkgeyBfcmVmbGVjdG9yID0gybVyZWZsZWN0b3I7IH1cbiAgICAgICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVSZXNvbHZlciA9IF9uZ01vZHVsZVJlc29sdmVyO1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVSZXNvbHZlciA9IF9kaXJlY3RpdmVSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fcGlwZVJlc29sdmVyID0gX3BpcGVSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fc3VtbWFyeVJlc29sdmVyID0gX3N1bW1hcnlSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZU5vcm1hbGl6ZXIgPSBfZGlyZWN0aXZlTm9ybWFsaXplcjtcbiAgICAgICAgdGhpcy5fY29uc29sZSA9IF9jb25zb2xlO1xuICAgICAgICB0aGlzLl9zdGF0aWNTeW1ib2xDYWNoZSA9IF9zdGF0aWNTeW1ib2xDYWNoZTtcbiAgICAgICAgdGhpcy5fcmVmbGVjdG9yID0gX3JlZmxlY3RvcjtcbiAgICAgICAgdGhpcy5fZXJyb3JDb2xsZWN0b3IgPSBfZXJyb3JDb2xsZWN0b3I7XG4gICAgICAgIHRoaXMuX25vbk5vcm1hbGl6ZWREaXJlY3RpdmVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3N1bW1hcnlDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcGlwZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9uZ01vZHVsZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9uZ01vZHVsZU9mVHlwZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGVGb3IgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJNZXRhID0gdGhpcy5fZGlyZWN0aXZlQ2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgIHRoaXMuX25vbk5vcm1hbGl6ZWREaXJlY3RpdmVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgIHRoaXMuX3N1bW1hcnlDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgIHRoaXMuX3BpcGVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlT2ZUeXBlcy5kZWxldGUodHlwZSk7XG4gICAgICAgIC8vIENsZWFyIGFsbCBvZiB0aGUgTmdNb2R1bGUgYXMgdGhleSBjb250YWluIHRyYW5zaXRpdmUgaW5mb3JtYXRpb24hXG4gICAgICAgIHRoaXMuX25nTW9kdWxlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgaWYgKGRpck1ldGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZU5vcm1hbGl6ZXIuY2xlYXJDYWNoZUZvcihkaXJNZXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fbm9uTm9ybWFsaXplZERpcmVjdGl2ZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3N1bW1hcnlDYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9waXBlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVDYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9uZ01vZHVsZU9mVHlwZXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlTm9ybWFsaXplci5jbGVhckNhY2hlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGJhc2VUeXBlXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2NyZWF0ZVByb3h5Q2xhc3MgPSBmdW5jdGlvbiAoYmFzZVR5cGUsIG5hbWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm94eUNsYXNzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghZGVsZWdhdGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBDbGFzcyBcIiArIG5hbWUgKyBcIiBmb3IgdHlwZSBcIiArIMm1c3RyaW5naWZ5KGJhc2VUeXBlKSArIFwiIGlzIG5vdCBjb21waWxlZCB5ZXQhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm94eUNsYXNzLnNldERlbGVnYXRlID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGRlbGVnYXRlID0gZDtcbiAgICAgICAgICAgICgocHJveHlDbGFzcykpLnByb3RvdHlwZSA9IGQucHJvdG90eXBlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBNYWtlIHN0cmluZ2lmeSB3b3JrIGNvcnJlY3RseVxuICAgICAgICAoKHByb3h5Q2xhc3MpKS5vdmVycmlkZGVuTmFtZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiBwcm94eUNsYXNzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJUeXBlXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0R2VuZXJhdGVkQ2xhc3MgPSBmdW5jdGlvbiAoZGlyVHlwZSwgbmFtZSkge1xuICAgICAgICBpZiAoZGlyVHlwZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRpY1N5bWJvbENhY2hlLmdldChuZ2ZhY3RvcnlGaWxlUGF0aChkaXJUeXBlLmZpbGVQYXRoKSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlUHJveHlDbGFzcyhkaXJUeXBlLCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0Q29tcG9uZW50Vmlld0NsYXNzID0gZnVuY3Rpb24gKGRpclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R2VuZXJhdGVkQ2xhc3MoZGlyVHlwZSwgdmlld0NsYXNzTmFtZShkaXJUeXBlLCAwKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpclR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRIb3N0Q29tcG9uZW50Vmlld0NsYXNzID0gZnVuY3Rpb24gKGRpclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R2VuZXJhdGVkQ2xhc3MoZGlyVHlwZSwgaG9zdFZpZXdDbGFzc05hbWUoZGlyVHlwZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0SG9zdENvbXBvbmVudFR5cGUgPSBmdW5jdGlvbiAoZGlyVHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gaWRlbnRpZmllck5hbWUoeyByZWZlcmVuY2U6IGRpclR5cGUgfSkgKyBcIl9Ib3N0XCI7XG4gICAgICAgIGlmIChkaXJUeXBlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGljU3ltYm9sQ2FjaGUuZ2V0KGRpclR5cGUuZmlsZVBhdGgsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gSG9zdENsYXNzID0gKGZ1bmN0aW9uIEhvc3RDbGFzcygpIHsgfSk7XG4gICAgICAgICAgICBIb3N0Q2xhc3Mub3ZlcnJpZGRlbk5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIEhvc3RDbGFzcztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0UmVuZGVyZXJUeXBlID0gZnVuY3Rpb24gKGRpclR5cGUpIHtcbiAgICAgICAgaWYgKGRpclR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0aWNTeW1ib2xDYWNoZS5nZXQobmdmYWN0b3J5RmlsZVBhdGgoZGlyVHlwZS5maWxlUGF0aCksIHJlbmRlcmVyVHlwZU5hbWUoZGlyVHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmV0dXJuaW5nIGFuIG9iamVjdCBhcyBwcm94eSxcbiAgICAgICAgICAgIC8vIHRoYXQgd2UgZmlsbCBsYXRlciBkdXJpbmcgcnVudGltZSBjb21waWxhdGlvbi5cbiAgICAgICAgICAgIHJldHVybiAoe30pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBkaXJUeXBlXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dHNcbiAgICAgKiBAcGFyYW0gez99IG91dHB1dHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRDb21wb25lbnRGYWN0b3J5ID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBkaXJUeXBlLCBpbnB1dHMsIG91dHB1dHMpIHtcbiAgICAgICAgaWYgKGRpclR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0aWNTeW1ib2xDYWNoZS5nZXQobmdmYWN0b3J5RmlsZVBhdGgoZGlyVHlwZS5maWxlUGF0aCksIGNvbXBvbmVudEZhY3RvcnlOYW1lKGRpclR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RWaWV3ID0gdGhpcy5nZXRIb3N0Q29tcG9uZW50Vmlld0NsYXNzKGRpclR5cGUpO1xuICAgICAgICAgICAgLy8gTm90ZTogbmdDb250ZW50U2VsZWN0b3JzIHdpbGwgYmUgZmlsbGVkIGxhdGVyIG9uY2UgdGhlIHRlbXBsYXRlIGlzXG4gICAgICAgICAgICAvLyBsb2FkZWQuXG4gICAgICAgICAgICByZXR1cm4gybVjY2Yoc2VsZWN0b3IsIGRpclR5cGUsIC8qKiBAdHlwZSB7P30gKi8gKGhvc3RWaWV3KSwgaW5wdXRzLCBvdXRwdXRzLCBbXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmFjdG9yeVxuICAgICAqIEBwYXJhbSB7P30gbmdDb250ZW50U2VsZWN0b3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuaW5pdENvbXBvbmVudEZhY3RvcnkgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbmdDb250ZW50U2VsZWN0b3JzKSB7XG4gICAgICAgIGlmICghKGZhY3RvcnkgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpKSB7XG4gICAgICAgICAgICAoX2EgPSBmYWN0b3J5Lm5nQ29udGVudFNlbGVjdG9ycykucHVzaC5hcHBseShfYSwgbmdDb250ZW50U2VsZWN0b3JzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2E7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IGtpbmRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fbG9hZFN1bW1hcnkgPSBmdW5jdGlvbiAodHlwZSwga2luZCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlU3VtbWFyeSA9IHRoaXMuX3N1bW1hcnlDYWNoZS5nZXQodHlwZSk7XG4gICAgICAgIGlmICghdHlwZVN1bW1hcnkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1bW1hcnkgPSB0aGlzLl9zdW1tYXJ5UmVzb2x2ZXIucmVzb2x2ZVN1bW1hcnkodHlwZSk7XG4gICAgICAgICAgICB0eXBlU3VtbWFyeSA9IHN1bW1hcnkgPyBzdW1tYXJ5LnR5cGUgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy5fc3VtbWFyeUNhY2hlLnNldCh0eXBlLCB0eXBlU3VtbWFyeSB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZVN1bW1hcnkgJiYgdHlwZVN1bW1hcnkuc3VtbWFyeUtpbmQgPT09IGtpbmQgPyB0eXBlU3VtbWFyeSA6IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlVHlwZVxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlVHlwZVxuICAgICAqIEBwYXJhbSB7P30gaXNTeW5jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2xvYWREaXJlY3RpdmVNZXRhZGF0YSA9IGZ1bmN0aW9uIChuZ01vZHVsZVR5cGUsIGRpcmVjdGl2ZVR5cGUsIGlzU3luYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aXZlQ2FjaGUuaGFzKGRpcmVjdGl2ZVR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkaXJlY3RpdmVUeXBlID0gcmVzb2x2ZUZvcndhcmRSZWYoZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgIHZhciBfYSA9ICgodGhpcy5nZXROb25Ob3JtYWxpemVkRGlyZWN0aXZlTWV0YWRhdGEoZGlyZWN0aXZlVHlwZSkpKSwgYW5ub3RhdGlvbiA9IF9hLmFubm90YXRpb24sIG1ldGFkYXRhID0gX2EubWV0YWRhdGE7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNyZWF0ZURpcmVjdGl2ZU1ldGFkYXRhID0gZnVuY3Rpb24gKHRlbXBsYXRlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vcm1hbGl6ZWREaXJNZXRhID0gbmV3IENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgaXNIb3N0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBtZXRhZGF0YS50eXBlLFxuICAgICAgICAgICAgICAgIGlzQ29tcG9uZW50OiBtZXRhZGF0YS5pc0NvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogbWV0YWRhdGEuc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6IG1ldGFkYXRhLmV4cG9ydEFzLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogbWV0YWRhdGEuY2hhbmdlRGV0ZWN0aW9uLFxuICAgICAgICAgICAgICAgIGlucHV0czogbWV0YWRhdGEuaW5wdXRzLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IG1ldGFkYXRhLm91dHB1dHMsXG4gICAgICAgICAgICAgICAgaG9zdExpc3RlbmVyczogbWV0YWRhdGEuaG9zdExpc3RlbmVycyxcbiAgICAgICAgICAgICAgICBob3N0UHJvcGVydGllczogbWV0YWRhdGEuaG9zdFByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgaG9zdEF0dHJpYnV0ZXM6IG1ldGFkYXRhLmhvc3RBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogbWV0YWRhdGEucHJvdmlkZXJzLFxuICAgICAgICAgICAgICAgIHZpZXdQcm92aWRlcnM6IG1ldGFkYXRhLnZpZXdQcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcmllczogbWV0YWRhdGEucXVlcmllcyxcbiAgICAgICAgICAgICAgICB2aWV3UXVlcmllczogbWV0YWRhdGEudmlld1F1ZXJpZXMsXG4gICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBtZXRhZGF0YS5lbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50Vmlld1R5cGU6IG1ldGFkYXRhLmNvbXBvbmVudFZpZXdUeXBlLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVyVHlwZTogbWV0YWRhdGEucmVuZGVyZXJUeXBlLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudEZhY3Rvcnk6IG1ldGFkYXRhLmNvbXBvbmVudEZhY3RvcnksXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlTWV0YWRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbml0Q29tcG9uZW50RmFjdG9yeSgvKiogQHR5cGUgez99ICovICgobWV0YWRhdGEuY29tcG9uZW50RmFjdG9yeSkpLCB0ZW1wbGF0ZU1ldGFkYXRhLm5nQ29udGVudFNlbGVjdG9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fZGlyZWN0aXZlQ2FjaGUuc2V0KGRpcmVjdGl2ZVR5cGUsIG5vcm1hbGl6ZWREaXJNZXRhKTtcbiAgICAgICAgICAgIF90aGlzLl9zdW1tYXJ5Q2FjaGUuc2V0KGRpcmVjdGl2ZVR5cGUsIG5vcm1hbGl6ZWREaXJNZXRhLnRvU3VtbWFyeSgpKTtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkRGlyTWV0YTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1ldGFkYXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZSA9ICgobWV0YWRhdGEudGVtcGxhdGUpKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlTWV0YSA9IHRoaXMuX2RpcmVjdGl2ZU5vcm1hbGl6ZXIubm9ybWFsaXplVGVtcGxhdGUoe1xuICAgICAgICAgICAgICAgIG5nTW9kdWxlVHlwZTogbmdNb2R1bGVUeXBlLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6IGRpcmVjdGl2ZVR5cGUsXG4gICAgICAgICAgICAgICAgbW9kdWxlVXJsOiBjb21wb25lbnRNb2R1bGVVcmwodGhpcy5fcmVmbGVjdG9yLCBkaXJlY3RpdmVUeXBlLCBhbm5vdGF0aW9uKSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiB0ZW1wbGF0ZS5lbmNhcHN1bGF0aW9uLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZS50ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogdGVtcGxhdGUudGVtcGxhdGVVcmwsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiB0ZW1wbGF0ZS5zdHlsZXMsXG4gICAgICAgICAgICAgICAgc3R5bGVVcmxzOiB0ZW1wbGF0ZS5zdHlsZVVybHMsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczogdGVtcGxhdGUuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiB0ZW1wbGF0ZS5pbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZU1ldGEuc3luY1Jlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZURpcmVjdGl2ZU1ldGFkYXRhKHRlbXBsYXRlTWV0YS5zeW5jUmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3IoZGlyZWN0aXZlVHlwZSksIGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICgodGVtcGxhdGVNZXRhLmFzeW5jUmVzdWx0KSkudGhlbihjcmVhdGVEaXJlY3RpdmVNZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBkaXJlY3RpdmVcbiAgICAgICAgICAgIGNyZWF0ZURpcmVjdGl2ZU1ldGFkYXRhKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldE5vbk5vcm1hbGl6ZWREaXJlY3RpdmVNZXRhZGF0YSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGRpcmVjdGl2ZVR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZihkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgaWYgKCFkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYWNoZUVudHJ5ID0gdGhpcy5fbm9uTm9ybWFsaXplZERpcmVjdGl2ZUNhY2hlLmdldChkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgaWYgKGNhY2hlRW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZUVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpck1ldGEgPSB0aGlzLl9kaXJlY3RpdmVSZXNvbHZlci5yZXNvbHZlKGRpcmVjdGl2ZVR5cGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKCFkaXJNZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub25Ob3JtYWxpemVkVGVtcGxhdGVNZXRhZGF0YSA9ICgodW5kZWZpbmVkKSk7XG4gICAgICAgIGlmIChkaXJNZXRhIGluc3RhbmNlb2YgQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBjb21wb25lbnRcbiAgICAgICAgICAgIGFzc2VydEFycmF5T2ZTdHJpbmdzKCdzdHlsZXMnLCBkaXJNZXRhLnN0eWxlcyk7XG4gICAgICAgICAgICBhc3NlcnRBcnJheU9mU3RyaW5ncygnc3R5bGVVcmxzJywgZGlyTWV0YS5zdHlsZVVybHMpO1xuICAgICAgICAgICAgYXNzZXJ0SW50ZXJwb2xhdGlvblN5bWJvbHMoJ2ludGVycG9sYXRpb24nLCBkaXJNZXRhLmludGVycG9sYXRpb24pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5pbWF0aW9ucyA9IGRpck1ldGEuYW5pbWF0aW9ucztcbiAgICAgICAgICAgIG5vbk5vcm1hbGl6ZWRUZW1wbGF0ZU1ldGFkYXRhID0gbmV3IENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBub1VuZGVmaW5lZChkaXJNZXRhLmVuY2Fwc3VsYXRpb24pLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBub1VuZGVmaW5lZChkaXJNZXRhLnRlbXBsYXRlKSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogbm9VbmRlZmluZWQoZGlyTWV0YS50ZW1wbGF0ZVVybCksXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBkaXJNZXRhLnN0eWxlcyB8fCBbXSxcbiAgICAgICAgICAgICAgICBzdHlsZVVybHM6IGRpck1ldGEuc3R5bGVVcmxzIHx8IFtdLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IGFuaW1hdGlvbnMgfHwgW10sXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogbm9VbmRlZmluZWQoZGlyTWV0YS5pbnRlcnBvbGF0aW9uKSxcbiAgICAgICAgICAgICAgICBpc0lubGluZTogISFkaXJNZXRhLnRlbXBsYXRlLFxuICAgICAgICAgICAgICAgIGV4dGVybmFsU3R5bGVzaGVldHM6IFtdLFxuICAgICAgICAgICAgICAgIG5nQ29udGVudFNlbGVjdG9yczogW11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0gKChudWxsKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdQcm92aWRlcnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50cnlDb21wb25lbnRNZXRhZGF0YSA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxlY3RvciA9IGRpck1ldGEuc2VsZWN0b3I7XG4gICAgICAgIGlmIChkaXJNZXRhIGluc3RhbmNlb2YgQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBDb21wb25lbnRcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0gKChkaXJNZXRhLmNoYW5nZURldGVjdGlvbikpO1xuICAgICAgICAgICAgaWYgKGRpck1ldGEudmlld1Byb3ZpZGVycykge1xuICAgICAgICAgICAgICAgIHZpZXdQcm92aWRlcnMgPSB0aGlzLl9nZXRQcm92aWRlcnNNZXRhZGF0YShkaXJNZXRhLnZpZXdQcm92aWRlcnMsIGVudHJ5Q29tcG9uZW50TWV0YWRhdGEsIFwidmlld1Byb3ZpZGVycyBmb3IgXFxcIlwiICsgc3RyaW5naWZ5VHlwZShkaXJlY3RpdmVUeXBlKSArIFwiXFxcIlwiLCBbXSwgZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlyTWV0YS5lbnRyeUNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudE1ldGFkYXRhID0gZmxhdHRlbkFuZERlZHVwZUFycmF5KGRpck1ldGEuZW50cnlDb21wb25lbnRzKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiAoKF90aGlzLl9nZXRFbnRyeUNvbXBvbmVudE1ldGFkYXRhKHR5cGUpKSk7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoZW50cnlDb21wb25lbnRNZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB0aGlzLl9zY2hlbWFSZWdpc3RyeS5nZXREZWZhdWx0Q29tcG9uZW50RWxlbWVudE5hbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIERpcmVjdGl2ZVxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiRGlyZWN0aXZlIFwiICsgc3RyaW5naWZ5VHlwZShkaXJlY3RpdmVUeXBlKSArIFwiIGhhcyBubyBzZWxlY3RvciwgcGxlYXNlIGFkZCBpdCFcIiksIGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gJ2Vycm9yJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlcnMgPSBbXTtcbiAgICAgICAgaWYgKGRpck1ldGEucHJvdmlkZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHByb3ZpZGVycyA9IHRoaXMuX2dldFByb3ZpZGVyc01ldGFkYXRhKGRpck1ldGEucHJvdmlkZXJzLCBlbnRyeUNvbXBvbmVudE1ldGFkYXRhLCBcInByb3ZpZGVycyBmb3IgXFxcIlwiICsgc3RyaW5naWZ5VHlwZShkaXJlY3RpdmVUeXBlKSArIFwiXFxcIlwiLCBbXSwgZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcmllcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3UXVlcmllcyA9IFtdO1xuICAgICAgICBpZiAoZGlyTWV0YS5xdWVyaWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHF1ZXJpZXMgPSB0aGlzLl9nZXRRdWVyaWVzTWV0YWRhdGEoZGlyTWV0YS5xdWVyaWVzLCBmYWxzZSwgZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgICAgICB2aWV3UXVlcmllcyA9IHRoaXMuX2dldFF1ZXJpZXNNZXRhZGF0YShkaXJNZXRhLnF1ZXJpZXMsIHRydWUsIGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1ldGFkYXRhID0gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLmNyZWF0ZSh7XG4gICAgICAgICAgICBpc0hvc3Q6IGZhbHNlLFxuICAgICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgICAgICAgZXhwb3J0QXM6IG5vVW5kZWZpbmVkKGRpck1ldGEuZXhwb3J0QXMpLFxuICAgICAgICAgICAgaXNDb21wb25lbnQ6ICEhbm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLl9nZXRUeXBlTWV0YWRhdGEoZGlyZWN0aXZlVHlwZSksXG4gICAgICAgICAgICB0ZW1wbGF0ZTogbm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IGNoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgICAgICAgICAgaW5wdXRzOiBkaXJNZXRhLmlucHV0cyB8fCBbXSxcbiAgICAgICAgICAgIG91dHB1dHM6IGRpck1ldGEub3V0cHV0cyB8fCBbXSxcbiAgICAgICAgICAgIGhvc3Q6IGRpck1ldGEuaG9zdCB8fCB7fSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogcHJvdmlkZXJzIHx8IFtdLFxuICAgICAgICAgICAgdmlld1Byb3ZpZGVyczogdmlld1Byb3ZpZGVycyB8fCBbXSxcbiAgICAgICAgICAgIHF1ZXJpZXM6IHF1ZXJpZXMgfHwgW10sXG4gICAgICAgICAgICB2aWV3UXVlcmllczogdmlld1F1ZXJpZXMgfHwgW10sXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGVudHJ5Q29tcG9uZW50TWV0YWRhdGEsXG4gICAgICAgICAgICBjb21wb25lbnRWaWV3VHlwZTogbm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEgPyB0aGlzLmdldENvbXBvbmVudFZpZXdDbGFzcyhkaXJlY3RpdmVUeXBlKSA6XG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZTogbm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEgPyB0aGlzLmdldFJlbmRlcmVyVHlwZShkaXJlY3RpdmVUeXBlKSA6IG51bGwsXG4gICAgICAgICAgICBjb21wb25lbnRGYWN0b3J5OiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhLmNvbXBvbmVudEZhY3RvcnkgPVxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50RmFjdG9yeShzZWxlY3RvciwgZGlyZWN0aXZlVHlwZSwgbWV0YWRhdGEuaW5wdXRzLCBtZXRhZGF0YS5vdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZUVudHJ5ID0geyBtZXRhZGF0YTogbWV0YWRhdGEsIGFubm90YXRpb246IGRpck1ldGEgfTtcbiAgICAgICAgdGhpcy5fbm9uTm9ybWFsaXplZERpcmVjdGl2ZUNhY2hlLnNldChkaXJlY3RpdmVUeXBlLCBjYWNoZUVudHJ5KTtcbiAgICAgICAgcmV0dXJuIGNhY2hlRW50cnk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSBmb3IgdGhlIGdpdmVuIGRpcmVjdGl2ZS5cbiAgICAgKiBUaGlzIGFzc3VtZXMgYGxvYWROZ01vZHVsZURpcmVjdGl2ZUFuZFBpcGVNZXRhZGF0YWAgaGFzIGJlZW4gY2FsbGVkIGZpcnN0LlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldERpcmVjdGl2ZU1ldGFkYXRhID0gZnVuY3Rpb24gKGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyTWV0YSA9ICgodGhpcy5fZGlyZWN0aXZlQ2FjaGUuZ2V0KGRpcmVjdGl2ZVR5cGUpKSk7XG4gICAgICAgIGlmICghZGlyTWV0YSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBnZXREaXJlY3RpdmVNZXRhZGF0YSBjYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgbG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhIGZvciBhIG1vZHVsZSB0aGF0IGRlY2xhcmVzIGl0LiBEaXJlY3RpdmUgXCIgKyBzdHJpbmdpZnlUeXBlKGRpcmVjdGl2ZVR5cGUpICsgXCIuXCIpLCBkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlyTWV0YTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldERpcmVjdGl2ZVN1bW1hcnkgPSBmdW5jdGlvbiAoZGlyVHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJTdW1tYXJ5ID0gKHRoaXMuX2xvYWRTdW1tYXJ5KGRpclR5cGUsIENvbXBpbGVTdW1tYXJ5S2luZC5EaXJlY3RpdmUpKTtcbiAgICAgICAgaWYgKCFkaXJTdW1tYXJ5KSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIklsbGVnYWwgc3RhdGU6IENvdWxkIG5vdCBsb2FkIHRoZSBzdW1tYXJ5IGZvciBkaXJlY3RpdmUgXCIgKyBzdHJpbmdpZnlUeXBlKGRpclR5cGUpICsgXCIuXCIpLCBkaXJUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlyU3VtbWFyeTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmlzRGlyZWN0aXZlID0gZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyLmlzRGlyZWN0aXZlKHR5cGUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmlzUGlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0aGlzLl9waXBlUmVzb2x2ZXIuaXNQaXBlKHR5cGUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldE5nTW9kdWxlU3VtbWFyeSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZVN1bW1hcnkgPSAodGhpcy5fbG9hZFN1bW1hcnkobW9kdWxlVHlwZSwgQ29tcGlsZVN1bW1hcnlLaW5kLk5nTW9kdWxlKSk7XG4gICAgICAgIGlmICghbW9kdWxlU3VtbWFyeSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlTWV0YSA9IHRoaXMuZ2V0TmdNb2R1bGVNZXRhZGF0YShtb2R1bGVUeXBlLCBmYWxzZSk7XG4gICAgICAgICAgICBtb2R1bGVTdW1tYXJ5ID0gbW9kdWxlTWV0YSA/IG1vZHVsZU1ldGEudG9TdW1tYXJ5KCkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKG1vZHVsZVN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdW1tYXJ5Q2FjaGUuc2V0KG1vZHVsZVR5cGUsIG1vZHVsZVN1bW1hcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVTdW1tYXJ5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIGRlY2xhcmVkIGRpcmVjdGl2ZXMgYW5kIHBpcGVzIG9mIGFuIE5nTW9kdWxlLlxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEBwYXJhbSB7P30gaXNTeW5jXG4gICAgICogQHBhcmFtIHs/PX0gdGhyb3dJZk5vdEZvdW5kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUubG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGlzU3luYywgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQgPT09IHZvaWQgMCkgeyB0aHJvd0lmTm90Rm91bmQgPSB0cnVlOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlID0gdGhpcy5nZXROZ01vZHVsZU1ldGFkYXRhKG1vZHVsZVR5cGUsIHRocm93SWZOb3RGb3VuZCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvYWRpbmcgPSBbXTtcbiAgICAgICAgaWYgKG5nTW9kdWxlKSB7XG4gICAgICAgICAgICBuZ01vZHVsZS5kZWNsYXJlZERpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9taXNlID0gX3RoaXMuX2xvYWREaXJlY3RpdmVNZXRhZGF0YShtb2R1bGVUeXBlLCBpZC5yZWZlcmVuY2UsIGlzU3luYyk7XG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmdNb2R1bGUuZGVjbGFyZWRQaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gX3RoaXMuX2xvYWRQaXBlTWV0YWRhdGEoaWQucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGxvYWRpbmcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHBhcmFtIHs/PX0gdGhyb3dJZk5vdEZvdW5kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0TmdNb2R1bGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgbW9kdWxlVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmKG1vZHVsZVR5cGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21waWxlTWV0YSA9IHRoaXMuX25nTW9kdWxlQ2FjaGUuZ2V0KG1vZHVsZVR5cGUpO1xuICAgICAgICBpZiAoY29tcGlsZU1ldGEpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21waWxlTWV0YTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXRhID0gdGhpcy5fbmdNb2R1bGVSZXNvbHZlci5yZXNvbHZlKG1vZHVsZVR5cGUsIHRocm93SWZOb3RGb3VuZCk7XG4gICAgICAgIGlmICghbWV0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVjbGFyZWREaXJlY3RpdmVzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cG9ydGVkTm9uTW9kdWxlSWRlbnRpZmllcnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVjbGFyZWRQaXBlcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbXBvcnRlZE1vZHVsZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwb3J0ZWRNb2R1bGVzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3ZpZGVycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRyeUNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm9vdHN0cmFwQ29tcG9uZW50cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY2hlbWFzID0gW107XG4gICAgICAgIGlmIChtZXRhLmltcG9ydHMpIHtcbiAgICAgICAgICAgIGZsYXR0ZW5BbmREZWR1cGVBcnJheShtZXRhLmltcG9ydHMpLmZvckVhY2goZnVuY3Rpb24gKGltcG9ydGVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGltcG9ydGVkTW9kdWxlVHlwZSA9ICgodW5kZWZpbmVkKSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRUeXBlKGltcG9ydGVkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWRNb2R1bGVUeXBlID0gaW1wb3J0ZWRUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbXBvcnRlZFR5cGUgJiYgaW1wb3J0ZWRUeXBlLm5nTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZVdpdGhQcm92aWRlcnMgPSBpbXBvcnRlZFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGVkTW9kdWxlVHlwZSA9IG1vZHVsZVdpdGhQcm92aWRlcnMubmdNb2R1bGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2R1bGVXaXRoUHJvdmlkZXJzLnByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2guYXBwbHkocHJvdmlkZXJzLCBfdGhpcy5fZ2V0UHJvdmlkZXJzTWV0YWRhdGEobW9kdWxlV2l0aFByb3ZpZGVycy5wcm92aWRlcnMsIGVudHJ5Q29tcG9uZW50cywgXCJwcm92aWRlciBmb3IgdGhlIE5nTW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUoaW1wb3J0ZWRNb2R1bGVUeXBlKSArIFwiJ1wiLCBbXSwgaW1wb3J0ZWRUeXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltcG9ydGVkTW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2NoZWNrU2VsZkltcG9ydChtb2R1bGVUeXBlLCBpbXBvcnRlZE1vZHVsZVR5cGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbXBvcnRlZE1vZHVsZVN1bW1hcnkgPSBfdGhpcy5nZXROZ01vZHVsZVN1bW1hcnkoaW1wb3J0ZWRNb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbXBvcnRlZE1vZHVsZVN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgXCIgKyBfdGhpcy5fZ2V0VHlwZURlc2NyaXB0b3IoaW1wb3J0ZWRUeXBlKSArIFwiICdcIiArIHN0cmluZ2lmeVR5cGUoaW1wb3J0ZWRUeXBlKSArIFwiJyBpbXBvcnRlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIicuIFBsZWFzZSBhZGQgYSBATmdNb2R1bGUgYW5ub3RhdGlvbi5cIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGVkTW9kdWxlcy5wdXNoKGltcG9ydGVkTW9kdWxlU3VtbWFyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlICdcIiArIHN0cmluZ2lmeVR5cGUoaW1wb3J0ZWRUeXBlKSArIFwiJyBpbXBvcnRlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIidcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuZXhwb3J0cykge1xuICAgICAgICAgICAgZmxhdHRlbkFuZERlZHVwZUFycmF5KG1ldGEuZXhwb3J0cykuZm9yRWFjaChmdW5jdGlvbiAoZXhwb3J0ZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkVHlwZShleHBvcnRlZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgJ1wiICsgc3RyaW5naWZ5VHlwZShleHBvcnRlZFR5cGUpICsgXCInIGV4cG9ydGVkIGJ5IHRoZSBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiJ1wiKSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwb3J0ZWRNb2R1bGVTdW1tYXJ5ID0gX3RoaXMuZ2V0TmdNb2R1bGVTdW1tYXJ5KGV4cG9ydGVkVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9ydGVkTW9kdWxlU3VtbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRlZE1vZHVsZXMucHVzaChleHBvcnRlZE1vZHVsZVN1bW1hcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWROb25Nb2R1bGVJZGVudGlmaWVycy5wdXNoKF90aGlzLl9nZXRJZGVudGlmaWVyTWV0YWRhdGEoZXhwb3J0ZWRUeXBlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogVGhpcyB3aWxsIGJlIG1vZGlmaWVkIGxhdGVyLCBzbyB3ZSByZWx5IG9uXG4gICAgICAgIC8vIGdldHRpbmcgYSBuZXcgaW5zdGFuY2UgZXZlcnkgdGltZSFcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNpdGl2ZU1vZHVsZSA9IHRoaXMuX2dldFRyYW5zaXRpdmVOZ01vZHVsZU1ldGFkYXRhKGltcG9ydGVkTW9kdWxlcywgZXhwb3J0ZWRNb2R1bGVzKTtcbiAgICAgICAgaWYgKG1ldGEuZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICBmbGF0dGVuQW5kRGVkdXBlQXJyYXkobWV0YS5kZWNsYXJhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGRlY2xhcmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFR5cGUoZGVjbGFyZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlICdcIiArIHN0cmluZ2lmeVR5cGUoZGVjbGFyZWRUeXBlKSArIFwiJyBkZWNsYXJlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIidcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlY2xhcmVkSWRlbnRpZmllciA9IF90aGlzLl9nZXRJZGVudGlmaWVyTWV0YWRhdGEoZGVjbGFyZWRUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2RpcmVjdGl2ZVJlc29sdmVyLmlzRGlyZWN0aXZlKGRlY2xhcmVkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5hZGREaXJlY3RpdmUoZGVjbGFyZWRJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyZWREaXJlY3RpdmVzLnB1c2goZGVjbGFyZWRJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZFR5cGVUb01vZHVsZShkZWNsYXJlZFR5cGUsIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5fcGlwZVJlc29sdmVyLmlzUGlwZShkZWNsYXJlZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGUuYWRkUGlwZShkZWNsYXJlZElkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLnBpcGVzLnB1c2goZGVjbGFyZWRJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyZWRQaXBlcy5wdXNoKGRlY2xhcmVkSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGRUeXBlVG9Nb2R1bGUoZGVjbGFyZWRUeXBlLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgXCIgKyBfdGhpcy5fZ2V0VHlwZURlc2NyaXB0b3IoZGVjbGFyZWRUeXBlKSArIFwiICdcIiArIHN0cmluZ2lmeVR5cGUoZGVjbGFyZWRUeXBlKSArIFwiJyBkZWNsYXJlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIicuIFBsZWFzZSBhZGQgYSBAUGlwZS9ARGlyZWN0aXZlL0BDb21wb25lbnQgYW5ub3RhdGlvbi5cIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwb3J0ZWREaXJlY3RpdmVzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cG9ydGVkUGlwZXMgPSBbXTtcbiAgICAgICAgZXhwb3J0ZWROb25Nb2R1bGVJZGVudGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChleHBvcnRlZElkKSB7XG4gICAgICAgICAgICBpZiAodHJhbnNpdGl2ZU1vZHVsZS5kaXJlY3RpdmVzU2V0LmhhcyhleHBvcnRlZElkLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICBleHBvcnRlZERpcmVjdGl2ZXMucHVzaChleHBvcnRlZElkKTtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLmFkZEV4cG9ydGVkRGlyZWN0aXZlKGV4cG9ydGVkSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNpdGl2ZU1vZHVsZS5waXBlc1NldC5oYXMoZXhwb3J0ZWRJZC5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0ZWRQaXBlcy5wdXNoKGV4cG9ydGVkSWQpO1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGUuYWRkRXhwb3J0ZWRQaXBlKGV4cG9ydGVkSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiQ2FuJ3QgZXhwb3J0IFwiICsgX3RoaXMuX2dldFR5cGVEZXNjcmlwdG9yKGV4cG9ydGVkSWQucmVmZXJlbmNlKSArIFwiIFwiICsgc3RyaW5naWZ5VHlwZShleHBvcnRlZElkLnJlZmVyZW5jZSkgKyBcIiBmcm9tIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiIGFzIGl0IHdhcyBuZWl0aGVyIGRlY2xhcmVkIG5vciBpbXBvcnRlZCFcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoZSBwcm92aWRlcnMgb2YgdGhlIG1vZHVsZSBoYXZlIHRvIGdvIGxhc3RcbiAgICAgICAgLy8gc28gdGhhdCB0aGV5IG92ZXJ3cml0ZSBhbnkgb3RoZXIgcHJvdmlkZXIgd2UgYWxyZWFkeSBhZGRlZC5cbiAgICAgICAgaWYgKG1ldGEucHJvdmlkZXJzKSB7XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaC5hcHBseShwcm92aWRlcnMsIHRoaXMuX2dldFByb3ZpZGVyc01ldGFkYXRhKG1ldGEucHJvdmlkZXJzLCBlbnRyeUNvbXBvbmVudHMsIFwicHJvdmlkZXIgZm9yIHRoZSBOZ01vZHVsZSAnXCIgKyBzdHJpbmdpZnlUeXBlKG1vZHVsZVR5cGUpICsgXCInXCIsIFtdLCBtb2R1bGVUeXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuZW50cnlDb21wb25lbnRzKSB7XG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHMucHVzaC5hcHBseShlbnRyeUNvbXBvbmVudHMsIGZsYXR0ZW5BbmREZWR1cGVBcnJheShtZXRhLmVudHJ5Q29tcG9uZW50cylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiAoKF90aGlzLl9nZXRFbnRyeUNvbXBvbmVudE1ldGFkYXRhKHR5cGUpKSk7IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5ib290c3RyYXApIHtcbiAgICAgICAgICAgIGZsYXR0ZW5BbmREZWR1cGVBcnJheShtZXRhLmJvb3RzdHJhcCkuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSAnXCIgKyBzdHJpbmdpZnlUeXBlKHR5cGUpICsgXCInIHVzZWQgaW4gdGhlIGJvb3RzdHJhcCBwcm9wZXJ0eSBvZiBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiJ1wiKSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYm9vdHN0cmFwQ29tcG9uZW50cy5wdXNoKF90aGlzLl9nZXRJZGVudGlmaWVyTWV0YWRhdGEodHlwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZW50cnlDb21wb25lbnRzLnB1c2guYXBwbHkoZW50cnlDb21wb25lbnRzLCBib290c3RyYXBDb21wb25lbnRzLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gKChfdGhpcy5fZ2V0RW50cnlDb21wb25lbnRNZXRhZGF0YSh0eXBlLnJlZmVyZW5jZSkpKTsgfSkpO1xuICAgICAgICBpZiAobWV0YS5zY2hlbWFzKSB7XG4gICAgICAgICAgICBzY2hlbWFzLnB1c2guYXBwbHkoc2NoZW1hcywgZmxhdHRlbkFuZERlZHVwZUFycmF5KG1ldGEuc2NoZW1hcykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBpbGVNZXRhID0gbmV3IENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhKHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuX2dldFR5cGVNZXRhZGF0YShtb2R1bGVUeXBlKSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogcHJvdmlkZXJzLFxuICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBlbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICBib290c3RyYXBDb21wb25lbnRzOiBib290c3RyYXBDb21wb25lbnRzLFxuICAgICAgICAgICAgc2NoZW1hczogc2NoZW1hcyxcbiAgICAgICAgICAgIGRlY2xhcmVkRGlyZWN0aXZlczogZGVjbGFyZWREaXJlY3RpdmVzLFxuICAgICAgICAgICAgZXhwb3J0ZWREaXJlY3RpdmVzOiBleHBvcnRlZERpcmVjdGl2ZXMsXG4gICAgICAgICAgICBkZWNsYXJlZFBpcGVzOiBkZWNsYXJlZFBpcGVzLFxuICAgICAgICAgICAgZXhwb3J0ZWRQaXBlczogZXhwb3J0ZWRQaXBlcyxcbiAgICAgICAgICAgIGltcG9ydGVkTW9kdWxlczogaW1wb3J0ZWRNb2R1bGVzLFxuICAgICAgICAgICAgZXhwb3J0ZWRNb2R1bGVzOiBleHBvcnRlZE1vZHVsZXMsXG4gICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlOiB0cmFuc2l0aXZlTW9kdWxlLFxuICAgICAgICAgICAgaWQ6IG1ldGEuaWQgfHwgbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGVudHJ5Q29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gdHJhbnNpdGl2ZU1vZHVsZS5hZGRFbnRyeUNvbXBvbmVudChpZCk7IH0pO1xuICAgICAgICBwcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIHRyYW5zaXRpdmVNb2R1bGUuYWRkUHJvdmlkZXIocHJvdmlkZXIsIC8qKiBAdHlwZSB7P30gKi8gKChjb21waWxlTWV0YSkpLnR5cGUpOyB9KTtcbiAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5hZGRNb2R1bGUoY29tcGlsZU1ldGEudHlwZSk7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlQ2FjaGUuc2V0KG1vZHVsZVR5cGUsIGNvbXBpbGVNZXRhKTtcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVNZXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHBhcmFtIHs/fSBpbXBvcnRlZE1vZHVsZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fY2hlY2tTZWxmSW1wb3J0ID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGltcG9ydGVkTW9kdWxlVHlwZSkge1xuICAgICAgICBpZiAobW9kdWxlVHlwZSA9PT0gaW1wb3J0ZWRNb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIidcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIicgbW9kdWxlIGNhbid0IGltcG9ydCBpdHNlbGZcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldFR5cGVEZXNjcmlwdG9yID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyLmlzRGlyZWN0aXZlKHR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2RpcmVjdGl2ZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BpcGVSZXNvbHZlci5pc1BpcGUodHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAncGlwZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX25nTW9kdWxlUmVzb2x2ZXIuaXNOZ01vZHVsZSh0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdtb2R1bGUnO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKHR5cGUpKS5wcm92aWRlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Byb3ZpZGVyJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ3ZhbHVlJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9hZGRUeXBlVG9Nb2R1bGUgPSBmdW5jdGlvbiAodHlwZSwgbW9kdWxlVHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRNb2R1bGUgPSB0aGlzLl9uZ01vZHVsZU9mVHlwZXMuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAob2xkTW9kdWxlICYmIG9sZE1vZHVsZSAhPT0gbW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJUeXBlIFwiICsgc3RyaW5naWZ5VHlwZSh0eXBlKSArIFwiIGlzIHBhcnQgb2YgdGhlIGRlY2xhcmF0aW9ucyBvZiAyIG1vZHVsZXM6IFwiICsgc3RyaW5naWZ5VHlwZShvbGRNb2R1bGUpICsgXCIgYW5kIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiISBcIiArXG4gICAgICAgICAgICAgICAgKFwiUGxlYXNlIGNvbnNpZGVyIG1vdmluZyBcIiArIHN0cmluZ2lmeVR5cGUodHlwZSkgKyBcIiB0byBhIGhpZ2hlciBtb2R1bGUgdGhhdCBpbXBvcnRzIFwiICsgc3RyaW5naWZ5VHlwZShvbGRNb2R1bGUpICsgXCIgYW5kIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiLiBcIikgK1xuICAgICAgICAgICAgICAgIChcIllvdSBjYW4gYWxzbyBjcmVhdGUgYSBuZXcgTmdNb2R1bGUgdGhhdCBleHBvcnRzIGFuZCBpbmNsdWRlcyBcIiArIHN0cmluZ2lmeVR5cGUodHlwZSkgKyBcIiB0aGVuIGltcG9ydCB0aGF0IE5nTW9kdWxlIGluIFwiICsgc3RyaW5naWZ5VHlwZShvbGRNb2R1bGUpICsgXCIgYW5kIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiLlwiKSksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25nTW9kdWxlT2ZUeXBlcy5zZXQodHlwZSwgbW9kdWxlVHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGltcG9ydGVkTW9kdWxlc1xuICAgICAqIEBwYXJhbSB7P30gZXhwb3J0ZWRNb2R1bGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldFRyYW5zaXRpdmVOZ01vZHVsZU1ldGFkYXRhID0gZnVuY3Rpb24gKGltcG9ydGVkTW9kdWxlcywgZXhwb3J0ZWRNb2R1bGVzKSB7XG4gICAgICAgIC8vIGNvbGxlY3QgYHByb3ZpZGVyc2AgLyBgZW50cnlDb21wb25lbnRzYCBmcm9tIGFsbCBpbXBvcnRlZCBhbmQgYWxsIGV4cG9ydGVkIG1vZHVsZXNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gbmV3IFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVzQnlUb2tlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgaW1wb3J0ZWRNb2R1bGVzLmNvbmNhdChleHBvcnRlZE1vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKG1vZFN1bW1hcnkpIHtcbiAgICAgICAgICAgIG1vZFN1bW1hcnkubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2QpIHsgcmV0dXJuIHJlc3VsdC5hZGRNb2R1bGUobW9kKTsgfSk7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LmVudHJ5Q29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wKSB7IHJldHVybiByZXN1bHQuYWRkRW50cnlDb21wb25lbnQoY29tcCk7IH0pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWRkZWRUb2tlbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LnByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VuUmVmID0gdG9rZW5SZWZlcmVuY2UoZW50cnkucHJvdmlkZXIudG9rZW4pO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZNb2R1bGVzID0gbW9kdWxlc0J5VG9rZW4uZ2V0KHRva2VuUmVmKTtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZNb2R1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZNb2R1bGVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVzQnlUb2tlbi5zZXQodG9rZW5SZWYsIHByZXZNb2R1bGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlUmVmID0gZW50cnkubW9kdWxlLnJlZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiB0aGUgcHJvdmlkZXJzIG9mIG9uZSBtb2R1bGUgbWF5IHN0aWxsIGNvbnRhaW4gbXVsdGlwbGUgcHJvdmlkZXJzXG4gICAgICAgICAgICAgICAgLy8gcGVyIHRva2VuIChlLmcuIGZvciBtdWx0aSBwcm92aWRlcnMpLCBhbmQgd2UgbmVlZCB0byBwcmVzZXJ2ZSB0aGVzZS5cbiAgICAgICAgICAgICAgICBpZiAoYWRkZWRUb2tlbnMuaGFzKHRva2VuUmVmKSB8fCAhcHJldk1vZHVsZXMuaGFzKG1vZHVsZVJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldk1vZHVsZXMuYWRkKG1vZHVsZVJlZik7XG4gICAgICAgICAgICAgICAgICAgIGFkZGVkVG9rZW5zLmFkZCh0b2tlblJlZik7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGRQcm92aWRlcihlbnRyeS5wcm92aWRlciwgZW50cnkubW9kdWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cG9ydGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RTdW1tYXJ5KSB7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LmV4cG9ydGVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gcmVzdWx0LmFkZEV4cG9ydGVkRGlyZWN0aXZlKGlkKTsgfSk7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LmV4cG9ydGVkUGlwZXMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIHJlc3VsdC5hZGRFeHBvcnRlZFBpcGUoaWQpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGltcG9ydGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RTdW1tYXJ5KSB7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LmV4cG9ydGVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gcmVzdWx0LmFkZERpcmVjdGl2ZShpZCk7IH0pO1xuICAgICAgICAgICAgbW9kU3VtbWFyeS5leHBvcnRlZFBpcGVzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7IHJldHVybiByZXN1bHQuYWRkUGlwZShpZCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRJZGVudGlmaWVyTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB0eXBlID0gcmVzb2x2ZUZvcndhcmRSZWYodHlwZSk7XG4gICAgICAgIHJldHVybiB7IHJlZmVyZW5jZTogdHlwZSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuaXNJbmplY3RhYmxlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5ub3RhdGlvbnMgPSB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnModHlwZSk7XG4gICAgICAgIC8vIE5vdGU6IFdlIG5lZWQgYW4gZXhhY3QgY2hlY2sgaGVyZSBhcyBAQ29tcG9uZW50IC8gQERpcmVjdGl2ZSAvIC4uLiBpbmhlcml0XG4gICAgICAgIC8vIGZyb20gQENvbXBpbGVySW5qZWN0YWJsZSFcbiAgICAgICAgcmV0dXJuIGFubm90YXRpb25zLnNvbWUoZnVuY3Rpb24gKGFubikgeyByZXR1cm4gYW5uLmNvbnN0cnVjdG9yID09PSBJbmplY3RhYmxlOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldEluamVjdGFibGVTdW1tYXJ5ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1bW1hcnlLaW5kOiBDb21waWxlU3VtbWFyeUtpbmQuSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuX2dldFR5cGVNZXRhZGF0YSh0eXBlLCBudWxsLCBmYWxzZSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlcGVuZGVuY2llc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRJbmplY3RhYmxlTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZSwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGlmIChkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCkgeyBkZXBlbmRlbmNpZXMgPSBudWxsOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGVTdW1tYXJ5ID0gdGhpcy5fbG9hZFN1bW1hcnkodHlwZSwgQ29tcGlsZVN1bW1hcnlLaW5kLkluamVjdGFibGUpO1xuICAgICAgICBpZiAodHlwZVN1bW1hcnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlU3VtbWFyeS50eXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRUeXBlTWV0YWRhdGEodHlwZSwgZGVwZW5kZW5jaWVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IGRlcGVuZGVuY2llc1xuICAgICAqIEBwYXJhbSB7Pz19IHRocm93T25Vbmtub3duRGVwc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRUeXBlTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZSwgZGVwZW5kZW5jaWVzLCB0aHJvd09uVW5rbm93bkRlcHMpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY2llcyA9PT0gdm9pZCAwKSB7IGRlcGVuZGVuY2llcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKHRocm93T25Vbmtub3duRGVwcyA9PT0gdm9pZCAwKSB7IHRocm93T25Vbmtub3duRGVwcyA9IHRydWU7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWRlbnRpZmllciA9IHRoaXMuX2dldElkZW50aWZpZXJNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZTogaWRlbnRpZmllci5yZWZlcmVuY2UsXG4gICAgICAgICAgICBkaURlcHM6IHRoaXMuX2dldERlcGVuZGVuY2llc01ldGFkYXRhKGlkZW50aWZpZXIucmVmZXJlbmNlLCBkZXBlbmRlbmNpZXMsIHRocm93T25Vbmtub3duRGVwcyksXG4gICAgICAgICAgICBsaWZlY3ljbGVIb29rczogybVMSUZFQ1lDTEVfSE9PS1NfVkFMVUVTLmZpbHRlcihmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gaGFzTGlmZWN5Y2xlSG9vayhob29rLCBpZGVudGlmaWVyLnJlZmVyZW5jZSk7IH0pLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmYWN0b3J5XG4gICAgICogQHBhcmFtIHs/PX0gZGVwZW5kZW5jaWVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldEZhY3RvcnlNZXRhZGF0YSA9IGZ1bmN0aW9uIChmYWN0b3J5LCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY2llcyA9PT0gdm9pZCAwKSB7IGRlcGVuZGVuY2llcyA9IG51bGw7IH1cbiAgICAgICAgZmFjdG9yeSA9IHJlc29sdmVGb3J3YXJkUmVmKGZhY3RvcnkpO1xuICAgICAgICByZXR1cm4geyByZWZlcmVuY2U6IGZhY3RvcnksIGRpRGVwczogdGhpcy5fZ2V0RGVwZW5kZW5jaWVzTWV0YWRhdGEoZmFjdG9yeSwgZGVwZW5kZW5jaWVzKSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWV0YWRhdGEgZm9yIHRoZSBnaXZlbiBwaXBlLlxuICAgICAqIFRoaXMgYXNzdW1lcyBgbG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhYCBoYXMgYmVlbiBjYWxsZWQgZmlyc3QuXG4gICAgICogQHBhcmFtIHs/fSBwaXBlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldFBpcGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChwaXBlVHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaXBlTWV0YSA9IHRoaXMuX3BpcGVDYWNoZS5nZXQocGlwZVR5cGUpO1xuICAgICAgICBpZiAoIXBpcGVNZXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIklsbGVnYWwgc3RhdGU6IGdldFBpcGVNZXRhZGF0YSBjYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgbG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhIGZvciBhIG1vZHVsZSB0aGF0IGRlY2xhcmVzIGl0LiBQaXBlIFwiICsgc3RyaW5naWZ5VHlwZShwaXBlVHlwZSkgKyBcIi5cIiksIHBpcGVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZU1ldGEgfHwgbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGlwZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRQaXBlU3VtbWFyeSA9IGZ1bmN0aW9uIChwaXBlVHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaXBlU3VtbWFyeSA9ICh0aGlzLl9sb2FkU3VtbWFyeShwaXBlVHlwZSwgQ29tcGlsZVN1bW1hcnlLaW5kLlBpcGUpKTtcbiAgICAgICAgaWYgKCFwaXBlU3VtbWFyeSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBDb3VsZCBub3QgbG9hZCB0aGUgc3VtbWFyeSBmb3IgcGlwZSBcIiArIHN0cmluZ2lmeVR5cGUocGlwZVR5cGUpICsgXCIuXCIpLCBwaXBlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpcGVTdW1tYXJ5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaXBlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldE9yTG9hZFBpcGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChwaXBlVHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaXBlTWV0YSA9IHRoaXMuX3BpcGVDYWNoZS5nZXQocGlwZVR5cGUpO1xuICAgICAgICBpZiAoIXBpcGVNZXRhKSB7XG4gICAgICAgICAgICBwaXBlTWV0YSA9IHRoaXMuX2xvYWRQaXBlTWV0YWRhdGEocGlwZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaXBlTWV0YTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGlwZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fbG9hZFBpcGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChwaXBlVHlwZSkge1xuICAgICAgICBwaXBlVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmKHBpcGVUeXBlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGlwZUFubm90YXRpb24gPSAoKHRoaXMuX3BpcGVSZXNvbHZlci5yZXNvbHZlKHBpcGVUeXBlKSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaXBlTWV0YSA9IG5ldyBDb21waWxlUGlwZU1ldGFkYXRhKHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuX2dldFR5cGVNZXRhZGF0YShwaXBlVHlwZSksXG4gICAgICAgICAgICBuYW1lOiBwaXBlQW5ub3RhdGlvbi5uYW1lLFxuICAgICAgICAgICAgcHVyZTogISFwaXBlQW5ub3RhdGlvbi5wdXJlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9waXBlQ2FjaGUuc2V0KHBpcGVUeXBlLCBwaXBlTWV0YSk7XG4gICAgICAgIHRoaXMuX3N1bW1hcnlDYWNoZS5zZXQocGlwZVR5cGUsIHBpcGVNZXRhLnRvU3VtbWFyeSgpKTtcbiAgICAgICAgcmV0dXJuIHBpcGVNZXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlT3JGdW5jXG4gICAgICogQHBhcmFtIHs/fSBkZXBlbmRlbmNpZXNcbiAgICAgKiBAcGFyYW0gez89fSB0aHJvd09uVW5rbm93bkRlcHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0RGVwZW5kZW5jaWVzTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZU9yRnVuYywgZGVwZW5kZW5jaWVzLCB0aHJvd09uVW5rbm93bkRlcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRocm93T25Vbmtub3duRGVwcyA9PT0gdm9pZCAwKSB7IHRocm93T25Vbmtub3duRGVwcyA9IHRydWU7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFzVW5rbm93bkRlcHMgPSBmYWxzZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1zID0gZGVwZW5kZW5jaWVzIHx8IHRoaXMuX3JlZmxlY3Rvci5wYXJhbWV0ZXJzKHR5cGVPckZ1bmMpIHx8IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBlbmRlbmNpZXNNZXRhZGF0YSA9IHBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0F0dHJpYnV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNIb3N0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1NlbGYgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzU2tpcFNlbGYgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzT3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VuID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBIb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0hvc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBTZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NlbGYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBTa2lwU2VsZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTa2lwU2VsZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIE9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc09wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0F0dHJpYnV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtRW50cnkuYXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgSW5qZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtRW50cnkudG9rZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIEluamVjdGlvblRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtRW50cnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWxpZFR5cGUocGFyYW1FbnRyeSkgJiYgdG9rZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbUVudHJ5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoYXNVbmtub3duRGVwcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgobnVsbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpc0F0dHJpYnV0ZTogaXNBdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgaXNIb3N0OiBpc0hvc3QsXG4gICAgICAgICAgICAgICAgaXNTZWxmOiBpc1NlbGYsXG4gICAgICAgICAgICAgICAgaXNTa2lwU2VsZjogaXNTa2lwU2VsZixcbiAgICAgICAgICAgICAgICBpc09wdGlvbmFsOiBpc09wdGlvbmFsLFxuICAgICAgICAgICAgICAgIHRva2VuOiBfdGhpcy5fZ2V0VG9rZW5NZXRhZGF0YSh0b2tlbilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzVW5rbm93bkRlcHMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcHNUb2tlbnMgPSBkZXBlbmRlbmNpZXNNZXRhZGF0YS5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gZGVwID8gc3RyaW5naWZ5VHlwZShkZXAudG9rZW4pIDogJz8nOyB9KS5qb2luKCcsICcpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVzc2FnZSA9IFwiQ2FuJ3QgcmVzb2x2ZSBhbGwgcGFyYW1ldGVycyBmb3IgXCIgKyBzdHJpbmdpZnlUeXBlKHR5cGVPckZ1bmMpICsgXCI6IChcIiArIGRlcHNUb2tlbnMgKyBcIikuXCI7XG4gICAgICAgICAgICBpZiAodGhyb3dPblVua25vd25EZXBzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IobWVzc2FnZSksIHR5cGVPckZ1bmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc29sZS53YXJuKFwiV2FybmluZzogXCIgKyBtZXNzYWdlICsgXCIgVGhpcyB3aWxsIGJlY29tZSBhbiBlcnJvciBpbiBBbmd1bGFyIHY1LnhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlcGVuZGVuY2llc01ldGFkYXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRUb2tlbk1ldGFkYXRhID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHRva2VuID0gcmVzb2x2ZUZvcndhcmRSZWYodG9rZW4pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21waWxlVG9rZW47XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb21waWxlVG9rZW4gPSB7IHZhbHVlOiB0b2tlbiB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29tcGlsZVRva2VuID0geyBpZGVudGlmaWVyOiB7IHJlZmVyZW5jZTogdG9rZW4gfSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21waWxlVG9rZW47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0RW50cnlDb21wb25lbnRzXG4gICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXG4gICAgICogQHBhcmFtIHs/PX0gY29tcGlsZVByb3ZpZGVyc1xuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0UHJvdmlkZXJzTWV0YWRhdGEgPSBmdW5jdGlvbiAocHJvdmlkZXJzLCB0YXJnZXRFbnRyeUNvbXBvbmVudHMsIGRlYnVnSW5mbywgY29tcGlsZVByb3ZpZGVycywgdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29tcGlsZVByb3ZpZGVycyA9PT0gdm9pZCAwKSB7IGNvbXBpbGVQcm92aWRlcnMgPSBbXTsgfVxuICAgICAgICBwcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIsIHByb3ZpZGVySWR4KSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZ2V0UHJvdmlkZXJzTWV0YWRhdGEocHJvdmlkZXIsIHRhcmdldEVudHJ5Q29tcG9uZW50cywgZGVidWdJbmZvLCBjb21waWxlUHJvdmlkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gcmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3ZpZGVyTWV0YSA9ICgodW5kZWZpbmVkKSk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyICYmIHR5cGVvZiBwcm92aWRlciA9PT0gJ29iamVjdCcgJiYgcHJvdmlkZXIuaGFzT3duUHJvcGVydHkoJ3Byb3ZpZGUnKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdmFsaWRhdGVQcm92aWRlcihwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YSA9IG5ldyBQcm92aWRlck1ldGEocHJvdmlkZXIucHJvdmlkZSwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbGlkVHlwZShwcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhID0gbmV3IFByb3ZpZGVyTWV0YShwcm92aWRlciwgeyB1c2VDbGFzczogcHJvdmlkZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiRW5jb3VudGVyZWQgdW5kZWZpbmVkIHByb3ZpZGVyISBVc3VhbGx5IHRoaXMgbWVhbnMgeW91IGhhdmUgYSBjaXJjdWxhciBkZXBlbmRlbmNpZXMgKG1pZ2h0IGJlIGNhdXNlZCBieSB1c2luZyAnYmFycmVsJyBpbmRleC50cyBmaWxlcy5cIikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlcnNJbmZvID0gKChwcm92aWRlcnMucmVkdWNlKGZ1bmN0aW9uIChzb0Zhciwgc2VlblByb3ZpZGVyLCBzZWVuUHJvdmlkZXJJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWVuUHJvdmlkZXJJZHggPCBwcm92aWRlcklkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvRmFyLnB1c2goXCJcIiArIHN0cmluZ2lmeVR5cGUoc2VlblByb3ZpZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWVuUHJvdmlkZXJJZHggPT0gcHJvdmlkZXJJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb0Zhci5wdXNoKFwiP1wiICsgc3RyaW5naWZ5VHlwZShzZWVuUHJvdmlkZXIpICsgXCI/XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VlblByb3ZpZGVySWR4ID09IHByb3ZpZGVySWR4ICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvRmFyLnB1c2goJy4uLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvRmFyO1xuICAgICAgICAgICAgICAgICAgICB9LCBbXSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIkludmFsaWQgXCIgKyAoZGVidWdJbmZvID8gZGVidWdJbmZvIDogJ3Byb3ZpZGVyJykgKyBcIiAtIG9ubHkgaW5zdGFuY2VzIG9mIFByb3ZpZGVyIGFuZCBUeXBlIGFyZSBhbGxvd2VkLCBnb3Q6IFtcIiArIHByb3ZpZGVyc0luZm8gKyBcIl1cIiksIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlck1ldGEudG9rZW4gPT09IHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEVudHJ5Q29tcG9uZW50cy5wdXNoLmFwcGx5KHRhcmdldEVudHJ5Q29tcG9uZW50cywgX3RoaXMuX2dldEVudHJ5Q29tcG9uZW50c0Zyb21Qcm92aWRlcihwcm92aWRlck1ldGEsIHR5cGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBpbGVQcm92aWRlcnMucHVzaChfdGhpcy5nZXRQcm92aWRlck1ldGFkYXRhKHByb3ZpZGVyTWV0YSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb21waWxlUHJvdmlkZXJzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl92YWxpZGF0ZVByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgIGlmIChwcm92aWRlci5oYXNPd25Qcm9wZXJ0eSgndXNlQ2xhc3MnKSAmJiBwcm92aWRlci51c2VDbGFzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIkludmFsaWQgcHJvdmlkZXIgZm9yIFwiICsgc3RyaW5naWZ5VHlwZShwcm92aWRlci5wcm92aWRlKSArIFwiLiB1c2VDbGFzcyBjYW5ub3QgYmUgXCIgKyBwcm92aWRlci51c2VDbGFzcyArIFwiLlxcbiAgICAgICAgICAgVXN1YWxseSBpdCBoYXBwZW5zIHdoZW46XFxuICAgICAgICAgICAxLiBUaGVyZSdzIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSAobWlnaHQgYmUgY2F1c2VkIGJ5IHVzaW5nIGluZGV4LnRzIChiYXJyZWwpIGZpbGVzKS5cXG4gICAgICAgICAgIDIuIENsYXNzIHdhcyB1c2VkIGJlZm9yZSBpdCB3YXMgZGVjbGFyZWQuIFVzZSBmb3J3YXJkUmVmIGluIHRoaXMgY2FzZS5cIikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRFbnRyeUNvbXBvbmVudHNGcm9tUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIsIHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcG9uZW50cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2xsZWN0ZWRJZGVudGlmaWVycyA9IFtdO1xuICAgICAgICBpZiAocHJvdmlkZXIudXNlRmFjdG9yeSB8fCBwcm92aWRlci51c2VFeGlzdGluZyB8fCBwcm92aWRlci51c2VDbGFzcykge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJUaGUgQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUyB0b2tlbiBvbmx5IHN1cHBvcnRzIHVzZVZhbHVlIVwiKSwgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm92aWRlci5tdWx0aSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJUaGUgQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUyB0b2tlbiBvbmx5IHN1cHBvcnRzICdtdWx0aSA9IHRydWUnIVwiKSwgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHByb3ZpZGVyLnVzZVZhbHVlLCBjb2xsZWN0ZWRJZGVudGlmaWVycyk7XG4gICAgICAgIGNvbGxlY3RlZElkZW50aWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJ5ID0gX3RoaXMuX2dldEVudHJ5Q29tcG9uZW50TWV0YWRhdGEoaWRlbnRpZmllci5yZWZlcmVuY2UsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyVHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHRocm93SWZOb3RGb3VuZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRFbnRyeUNvbXBvbmVudE1ldGFkYXRhID0gZnVuY3Rpb24gKGRpclR5cGUsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJNZXRhID0gdGhpcy5nZXROb25Ob3JtYWxpemVkRGlyZWN0aXZlTWV0YWRhdGEoZGlyVHlwZSk7XG4gICAgICAgIGlmIChkaXJNZXRhICYmIGRpck1ldGEubWV0YWRhdGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvbXBvbmVudFR5cGU6IGRpclR5cGUsIGNvbXBvbmVudEZhY3Rvcnk6IC8qKiBAdHlwZSB7P30gKi8gKChkaXJNZXRhLm1ldGFkYXRhLmNvbXBvbmVudEZhY3RvcnkpKSB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpclN1bW1hcnkgPSAodGhpcy5fbG9hZFN1bW1hcnkoZGlyVHlwZSwgQ29tcGlsZVN1bW1hcnlLaW5kLkRpcmVjdGl2ZSkpO1xuICAgICAgICBpZiAoZGlyU3VtbWFyeSAmJiBkaXJTdW1tYXJ5LmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4geyBjb21wb25lbnRUeXBlOiBkaXJUeXBlLCBjb21wb25lbnRGYWN0b3J5OiAvKiogQHR5cGUgez99ICovICgoZGlyU3VtbWFyeS5jb21wb25lbnRGYWN0b3J5KSkgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihkaXJUeXBlLm5hbWUgKyBcIiBjYW5ub3QgYmUgdXNlZCBhcyBhbiBlbnRyeSBjb21wb25lbnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldFByb3ZpZGVyTWV0YWRhdGEgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcGlsZURlcHMgPSAoKHVuZGVmaW5lZCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21waWxlVHlwZU1ldGFkYXRhID0gKChudWxsKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBpbGVGYWN0b3J5TWV0YWRhdGEgPSAoKG51bGwpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9rZW4gPSB0aGlzLl9nZXRUb2tlbk1ldGFkYXRhKHByb3ZpZGVyLnRva2VuKTtcbiAgICAgICAgaWYgKHByb3ZpZGVyLnVzZUNsYXNzKSB7XG4gICAgICAgICAgICBjb21waWxlVHlwZU1ldGFkYXRhID0gdGhpcy5fZ2V0SW5qZWN0YWJsZU1ldGFkYXRhKHByb3ZpZGVyLnVzZUNsYXNzLCBwcm92aWRlci5kZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgY29tcGlsZURlcHMgPSBjb21waWxlVHlwZU1ldGFkYXRhLmRpRGVwcztcbiAgICAgICAgICAgIGlmIChwcm92aWRlci50b2tlbiA9PT0gcHJvdmlkZXIudXNlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIGNvbXBpbGVUeXBlTWV0YWRhdGEgYXMgaXQgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgbGlmZWN5Y2xlSG9va3MuLi5cbiAgICAgICAgICAgICAgICB0b2tlbiA9IHsgaWRlbnRpZmllcjogY29tcGlsZVR5cGVNZXRhZGF0YSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUZhY3RvcnkpIHtcbiAgICAgICAgICAgIGNvbXBpbGVGYWN0b3J5TWV0YWRhdGEgPSB0aGlzLl9nZXRGYWN0b3J5TWV0YWRhdGEocHJvdmlkZXIudXNlRmFjdG9yeSwgcHJvdmlkZXIuZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgIGNvbXBpbGVEZXBzID0gY29tcGlsZUZhY3RvcnlNZXRhZGF0YS5kaURlcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuOiB0b2tlbixcbiAgICAgICAgICAgIHVzZUNsYXNzOiBjb21waWxlVHlwZU1ldGFkYXRhLFxuICAgICAgICAgICAgdXNlVmFsdWU6IHByb3ZpZGVyLnVzZVZhbHVlLFxuICAgICAgICAgICAgdXNlRmFjdG9yeTogY29tcGlsZUZhY3RvcnlNZXRhZGF0YSxcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBwcm92aWRlci51c2VFeGlzdGluZyA/IHRoaXMuX2dldFRva2VuTWV0YWRhdGEocHJvdmlkZXIudXNlRXhpc3RpbmcpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGVwczogY29tcGlsZURlcHMsXG4gICAgICAgICAgICBtdWx0aTogcHJvdmlkZXIubXVsdGlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7P30gaXNWaWV3UXVlcnlcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0UXVlcmllc01ldGFkYXRhID0gZnVuY3Rpb24gKHF1ZXJpZXMsIGlzVmlld1F1ZXJ5LCBkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhxdWVyaWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJ5ID0gcXVlcmllc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5LmlzVmlld1F1ZXJ5ID09PSBpc1ZpZXdRdWVyeSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKF90aGlzLl9nZXRRdWVyeU1ldGFkYXRhKHF1ZXJ5LCBwcm9wZXJ0eU5hbWUsIGRpcmVjdGl2ZVR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX3F1ZXJ5VmFyQmluZGluZ3MgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHsgcmV0dXJuIHNlbGVjdG9yLnNwbGl0KC9cXHMqLFxccyovKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHFcbiAgICAgKiBAcGFyYW0gez99IHByb3BlcnR5TmFtZVxuICAgICAqIEBwYXJhbSB7P30gdHlwZU9yRnVuY1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRRdWVyeU1ldGFkYXRhID0gZnVuY3Rpb24gKHEsIHByb3BlcnR5TmFtZSwgdHlwZU9yRnVuYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxlY3RvcnM7XG4gICAgICAgIGlmICh0eXBlb2YgcS5zZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNlbGVjdG9ycyA9XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVlcnlWYXJCaW5kaW5ncyhxLnNlbGVjdG9yKS5tYXAoZnVuY3Rpb24gKHZhck5hbWUpIHsgcmV0dXJuIF90aGlzLl9nZXRUb2tlbk1ldGFkYXRhKHZhck5hbWUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcS5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiQ2FuJ3QgY29uc3RydWN0IGEgcXVlcnkgZm9yIHRoZSBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIlxcXCIgb2YgXFxcIlwiICsgc3RyaW5naWZ5VHlwZSh0eXBlT3JGdW5jKSArIFwiXFxcIiBzaW5jZSB0aGUgcXVlcnkgc2VsZWN0b3Igd2Fzbid0IGRlZmluZWQuXCIpLCB0eXBlT3JGdW5jKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IFt0aGlzLl9nZXRUb2tlbk1ldGFkYXRhKHEuc2VsZWN0b3IpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VsZWN0b3JzOiBzZWxlY3RvcnMsXG4gICAgICAgICAgICBmaXJzdDogcS5maXJzdCxcbiAgICAgICAgICAgIGRlc2NlbmRhbnRzOiBxLmRlc2NlbmRhbnRzLCBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgIHJlYWQ6IHEucmVhZCA/IHRoaXMuX2dldFRva2VuTWV0YWRhdGEocS5yZWFkKSA6ICgobnVsbCkpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IG90aGVyVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgdHlwZSwgb3RoZXJUeXBlKSB7XG4gICAgICAgIGlmICh0aGlzLl9lcnJvckNvbGxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JDb2xsZWN0b3IoZXJyb3IsIHR5cGUpO1xuICAgICAgICAgICAgaWYgKG90aGVyVHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yQ29sbGVjdG9yKGVycm9yLCBvdGhlclR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb21waWxlTWV0YWRhdGFSZXNvbHZlcjtcbn0oKSk7XG5Db21waWxlTWV0YWRhdGFSZXNvbHZlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5Db21waWxlTWV0YWRhdGFSZXNvbHZlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IENvbXBpbGVyQ29uZmlnLCB9LFxuICAgIHsgdHlwZTogTmdNb2R1bGVSZXNvbHZlciwgfSxcbiAgICB7IHR5cGU6IERpcmVjdGl2ZVJlc29sdmVyLCB9LFxuICAgIHsgdHlwZTogUGlwZVJlc29sdmVyLCB9LFxuICAgIHsgdHlwZTogU3VtbWFyeVJlc29sdmVyLCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCB9LFxuICAgIHsgdHlwZTogRGlyZWN0aXZlTm9ybWFsaXplciwgfSxcbiAgICB7IHR5cGU6IMm1Q29uc29sZSwgfSxcbiAgICB7IHR5cGU6IFN0YXRpY1N5bWJvbENhY2hlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICB7IHR5cGU6IMm1UmVmbGVjdG9yUmVhZGVyLCB9LFxuICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW0VSUk9SX0NPTExFQ1RPUl9UT0tFTixdIH0sXSB9LFxuXTsgfTtcbi8qKlxuICogQHBhcmFtIHs/fSB0cmVlXG4gKiBAcGFyYW0gez89fSBvdXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5BcnJheSh0cmVlLCBvdXQpIHtcbiAgICBpZiAob3V0ID09PSB2b2lkIDApIHsgb3V0ID0gW107IH1cbiAgICBpZiAodHJlZSkge1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXRlbSA9IHJlc29sdmVGb3J3YXJkUmVmKHRyZWVbaV0pO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBmbGF0dGVuQXJyYXkoaXRlbSwgb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gYXJyYXlcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGRlZHVwZUFycmF5KGFycmF5KSB7XG4gICAgaWYgKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoYXJyYXkpKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHRyZWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5BbmREZWR1cGVBcnJheSh0cmVlKSB7XG4gICAgcmV0dXJuIGRlZHVwZUFycmF5KGZsYXR0ZW5BcnJheSh0cmVlKSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRUeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkgfHwgKHZhbHVlIGluc3RhbmNlb2YgVHlwZSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcmVmbGVjdG9yXG4gKiBAcGFyYW0gez99IHR5cGVcbiAqIEBwYXJhbSB7P30gY21wTWV0YWRhdGFcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbXBvbmVudE1vZHVsZVVybChyZWZsZWN0b3IsIHR5cGUsIGNtcE1ldGFkYXRhKSB7XG4gICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHJlZmxlY3Rvci5yZXNvdXJjZVVyaSh0eXBlKTtcbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlSWQgPSBjbXBNZXRhZGF0YS5tb2R1bGVJZDtcbiAgICBpZiAodHlwZW9mIG1vZHVsZUlkID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY2hlbWUgPSBnZXRVcmxTY2hlbWUobW9kdWxlSWQpO1xuICAgICAgICByZXR1cm4gc2NoZW1lID8gbW9kdWxlSWQgOiBcInBhY2thZ2U6XCIgKyBtb2R1bGVJZCArIE1PRFVMRV9TVUZGSVg7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1vZHVsZUlkICE9PSBudWxsICYmIG1vZHVsZUlkICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXCJtb2R1bGVJZCBzaG91bGQgYmUgYSBzdHJpbmcgaW4gXFxcIlwiICsgc3RyaW5naWZ5VHlwZSh0eXBlKSArIFwiXFxcIi4gU2VlIGh0dHBzOi8vZ29vLmdsL3dJRERpTCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cXG5cIiArXG4gICAgICAgICAgICBcIklmIHlvdSdyZSB1c2luZyBXZWJwYWNrIHlvdSBzaG91bGQgaW5saW5lIHRoZSB0ZW1wbGF0ZSBhbmQgdGhlIHN0eWxlcywgc2VlIGh0dHBzOi8vZ29vLmdsL1gySjh6Yy5cIik7XG4gICAgfVxuICAgIHJldHVybiAoKHJlZmxlY3Rvci5pbXBvcnRVcmkodHlwZSkpKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHBhcmFtIHs/fSB0YXJnZXRJZGVudGlmaWVyc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdElkZW50aWZpZXJzKHZhbHVlLCB0YXJnZXRJZGVudGlmaWVycykge1xuICAgIHZpc2l0VmFsdWUodmFsdWUsIG5ldyBfQ29tcGlsZVZhbHVlQ29udmVydGVyKCksIHRhcmdldElkZW50aWZpZXJzKTtcbn1cbnZhciBfQ29tcGlsZVZhbHVlQ29udmVydGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoX0NvbXBpbGVWYWx1ZUNvbnZlcnRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBfQ29tcGlsZVZhbHVlQ29udmVydGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldElkZW50aWZpZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQ29tcGlsZVZhbHVlQ29udmVydGVyLnByb3RvdHlwZS52aXNpdE90aGVyID0gZnVuY3Rpb24gKHZhbHVlLCB0YXJnZXRJZGVudGlmaWVycykge1xuICAgICAgICB0YXJnZXRJZGVudGlmaWVycy5wdXNoKHsgcmVmZXJlbmNlOiB2YWx1ZSB9KTtcbiAgICB9O1xuICAgIHJldHVybiBfQ29tcGlsZVZhbHVlQ29udmVydGVyO1xufShWYWx1ZVRyYW5zZm9ybWVyKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gdHlwZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5VHlwZSh0eXBlKSB7XG4gICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUubmFtZSArIFwiIGluIFwiICsgdHlwZS5maWxlUGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiDJtXN0cmluZ2lmeSh0eXBlKTtcbiAgICB9XG59XG4vKipcbiAqIEluZGljYXRlcyB0aGF0IGEgY29tcG9uZW50IGlzIHN0aWxsIGJlaW5nIGxvYWRlZCBpbiBhIHN5bmNocm9ub3VzIGNvbXBpbGUuXG4gKiBAcGFyYW0gez99IGNvbXBUeXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb21wb25lbnRTdGlsbExvYWRpbmdFcnJvcihjb21wVHlwZSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yID0gRXJyb3IoXCJDYW4ndCBjb21waWxlIHN5bmNocm9ub3VzbHkgYXMgXCIgKyDJtXN0cmluZ2lmeShjb21wVHlwZSkgKyBcIiBpcyBzdGlsbCBiZWluZyBsb2FkZWQhXCIpO1xuICAgICgoZXJyb3IpKVvJtUVSUk9SX0NPTVBPTkVOVF9UWVBFXSA9IGNvbXBUeXBlO1xuICAgIHJldHVybiBlcnJvcjtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUeXBlTW9kaWZpZXIgPSB7fTtcblR5cGVNb2RpZmllci5Db25zdCA9IDA7XG5UeXBlTW9kaWZpZXJbVHlwZU1vZGlmaWVyLkNvbnN0XSA9IFwiQ29uc3RcIjtcbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBUeXBlJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IG1vZGlmaWVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFR5cGUkMShtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgIGlmICghbW9kaWZpZXJzKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWVycyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHlwZSQxLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kaWZpZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFR5cGUkMS5wcm90b3R5cGUuaGFzTW9kaWZpZXIgPSBmdW5jdGlvbiAobW9kaWZpZXIpIHsgcmV0dXJuICgodGhpcy5tb2RpZmllcnMpKS5pbmRleE9mKG1vZGlmaWVyKSAhPT0gLTE7IH07XG4gICAgcmV0dXJuIFR5cGUkMTtcbn0oKSk7XG52YXIgQnVpbHRpblR5cGVOYW1lID0ge307XG5CdWlsdGluVHlwZU5hbWUuRHluYW1pYyA9IDA7XG5CdWlsdGluVHlwZU5hbWUuQm9vbCA9IDE7XG5CdWlsdGluVHlwZU5hbWUuU3RyaW5nID0gMjtcbkJ1aWx0aW5UeXBlTmFtZS5JbnQgPSAzO1xuQnVpbHRpblR5cGVOYW1lLk51bWJlciA9IDQ7XG5CdWlsdGluVHlwZU5hbWUuRnVuY3Rpb24gPSA1O1xuQnVpbHRpblR5cGVOYW1lLkluZmVycmVkID0gNjtcbkJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWUuRHluYW1pY10gPSBcIkR5bmFtaWNcIjtcbkJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWUuQm9vbF0gPSBcIkJvb2xcIjtcbkJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWUuU3RyaW5nXSA9IFwiU3RyaW5nXCI7XG5CdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lLkludF0gPSBcIkludFwiO1xuQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZS5OdW1iZXJdID0gXCJOdW1iZXJcIjtcbkJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWUuRnVuY3Rpb25dID0gXCJGdW5jdGlvblwiO1xuQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZS5JbmZlcnJlZF0gPSBcIkluZmVycmVkXCI7XG52YXIgQnVpbHRpblR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdWlsdGluVHlwZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCdWlsdGluVHlwZShuYW1lLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJ1aWx0aW5UeXBlLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJ1aWx0aW50VHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBCdWlsdGluVHlwZTtcbn0oVHlwZSQxKSk7XG52YXIgRXhwcmVzc2lvblR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHByZXNzaW9uVHlwZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXhwcmVzc2lvblR5cGUodmFsdWUsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uVHlwZS5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHByZXNzaW9uVHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBFeHByZXNzaW9uVHlwZTtcbn0oVHlwZSQxKSk7XG52YXIgQXJyYXlUeXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXlUeXBlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb2ZcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBcnJheVR5cGUob2YsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9mID0gb2Y7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBcnJheVR5cGUucHJvdG90eXBlLnZpc2l0VHlwZSA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXJyYXlUeXBlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5VHlwZTtcbn0oVHlwZSQxKSk7XG52YXIgTWFwVHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcFR5cGUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXBUeXBlKHZhbHVlVHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1vZGlmaWVycykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWVUeXBlID0gdmFsdWVUeXBlIHx8IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNYXBUeXBlLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdE1hcFR5cGUodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIE1hcFR5cGU7XG59KFR5cGUkMSkpO1xudmFyIERZTkFNSUNfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuRHluYW1pYyk7XG52YXIgSU5GRVJSRURfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuSW5mZXJyZWQpO1xudmFyIEJPT0xfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuQm9vbCk7XG52YXIgSU5UX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLkludCk7XG52YXIgTlVNQkVSX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLk51bWJlcik7XG52YXIgU1RSSU5HX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLlN0cmluZyk7XG52YXIgRlVOQ1RJT05fVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuRnVuY3Rpb24pO1xudmFyIEJpbmFyeU9wZXJhdG9yID0ge307XG5CaW5hcnlPcGVyYXRvci5FcXVhbHMgPSAwO1xuQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzID0gMTtcbkJpbmFyeU9wZXJhdG9yLklkZW50aWNhbCA9IDI7XG5CaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWwgPSAzO1xuQmluYXJ5T3BlcmF0b3IuTWludXMgPSA0O1xuQmluYXJ5T3BlcmF0b3IuUGx1cyA9IDU7XG5CaW5hcnlPcGVyYXRvci5EaXZpZGUgPSA2O1xuQmluYXJ5T3BlcmF0b3IuTXVsdGlwbHkgPSA3O1xuQmluYXJ5T3BlcmF0b3IuTW9kdWxvID0gODtcbkJpbmFyeU9wZXJhdG9yLkFuZCA9IDk7XG5CaW5hcnlPcGVyYXRvci5PciA9IDEwO1xuQmluYXJ5T3BlcmF0b3IuTG93ZXIgPSAxMTtcbkJpbmFyeU9wZXJhdG9yLkxvd2VyRXF1YWxzID0gMTI7XG5CaW5hcnlPcGVyYXRvci5CaWdnZXIgPSAxMztcbkJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFscyA9IDE0O1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuRXF1YWxzXSA9IFwiRXF1YWxzXCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHNdID0gXCJOb3RFcXVhbHNcIjtcbkJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yLklkZW50aWNhbF0gPSBcIklkZW50aWNhbFwiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuTm90SWRlbnRpY2FsXSA9IFwiTm90SWRlbnRpY2FsXCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5NaW51c10gPSBcIk1pbnVzXCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5QbHVzXSA9IFwiUGx1c1wiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuRGl2aWRlXSA9IFwiRGl2aWRlXCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5NdWx0aXBseV0gPSBcIk11bHRpcGx5XCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5Nb2R1bG9dID0gXCJNb2R1bG9cIjtcbkJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yLkFuZF0gPSBcIkFuZFwiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuT3JdID0gXCJPclwiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuTG93ZXJdID0gXCJMb3dlclwiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHNdID0gXCJMb3dlckVxdWFsc1wiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuQmlnZ2VyXSA9IFwiQmlnZ2VyXCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHNdID0gXCJCaWdnZXJFcXVhbHNcIjtcbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXhwcmVzc2lvbih0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbiB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUucHJvcCA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZFByb3BFeHByKHRoaXMsIG5hbWUsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5rZXkgPSBmdW5jdGlvbiAoaW5kZXgsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkS2V5RXhwcih0aGlzLCBpbmRleCwgdHlwZSwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmNhbGxNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgcGFyYW1zLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW52b2tlTWV0aG9kRXhwcih0aGlzLCBuYW1lLCBwYXJhbXMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5jYWxsRm4gPSBmdW5jdGlvbiAocGFyYW1zLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW52b2tlRnVuY3Rpb25FeHByKHRoaXMsIHBhcmFtcywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uIChwYXJhbXMsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW50aWF0ZUV4cHIodGhpcywgcGFyYW1zLCB0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHJ1ZUNhc2VcbiAgICAgKiBAcGFyYW0gez89fSBmYWxzZUNhc2VcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5jb25kaXRpb25hbCA9IGZ1bmN0aW9uICh0cnVlQ2FzZSwgZmFsc2VDYXNlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmIChmYWxzZUNhc2UgPT09IHZvaWQgMCkgeyBmYWxzZUNhc2UgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWxFeHByKHRoaXMsIHRydWVDYXNlLCBmYWxzZUNhc2UsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkVxdWFscywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHMsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJoc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmlkZW50aWNhbCA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5ub3RJZGVudGljYWwgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbCwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubWludXMgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk1pbnVzLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5wbHVzID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5QbHVzLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkRpdmlkZSwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk11bHRpcGx5LCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk1vZHVsbywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5BbmQsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJoc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5PciwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubG93ZXIgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkxvd2VyLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5sb3dlckVxdWFscyA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHMsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJoc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmJpZ2dlciA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuQmlnZ2VyLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5iaWdnZXJFcXVhbHMgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFscywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmlzQmxhbmsgPSBmdW5jdGlvbiAoc291cmNlU3Bhbikge1xuICAgICAgICAvLyBOb3RlOiBXZSB1c2UgZXF1YWxzIGJ5IHB1cnBvc2UgaGVyZSB0byBjb21wYXJlIHRvIG51bGwgYW5kIHVuZGVmaW5lZCBpbiBKUy5cbiAgICAgICAgLy8gV2UgdXNlIHRoZSB0eXBlZCBudWxsIHRvIGFsbG93IHN0cmljdE51bGxDaGVja3MgdG8gbmFycm93IHR5cGVzLlxuICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoVFlQRURfTlVMTF9FWFBSLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbiAodHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IENhc3RFeHByKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS50b1N0bXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRXhwcmVzc2lvblN0YXRlbWVudCh0aGlzLCBudWxsKTsgfTtcbiAgICByZXR1cm4gRXhwcmVzc2lvbjtcbn0oKSk7XG52YXIgQnVpbHRpblZhciA9IHt9O1xuQnVpbHRpblZhci5UaGlzID0gMDtcbkJ1aWx0aW5WYXIuU3VwZXIgPSAxO1xuQnVpbHRpblZhci5DYXRjaEVycm9yID0gMjtcbkJ1aWx0aW5WYXIuQ2F0Y2hTdGFjayA9IDM7XG5CdWlsdGluVmFyW0J1aWx0aW5WYXIuVGhpc10gPSBcIlRoaXNcIjtcbkJ1aWx0aW5WYXJbQnVpbHRpblZhci5TdXBlcl0gPSBcIlN1cGVyXCI7XG5CdWlsdGluVmFyW0J1aWx0aW5WYXIuQ2F0Y2hFcnJvcl0gPSBcIkNhdGNoRXJyb3JcIjtcbkJ1aWx0aW5WYXJbQnVpbHRpblZhci5DYXRjaFN0YWNrXSA9IFwiQ2F0Y2hTdGFja1wiO1xudmFyIFJlYWRWYXJFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVhZFZhckV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZWFkVmFyRXhwcihuYW1lLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgX3RoaXMuYnVpbHRpbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLmJ1aWx0aW4gPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWFkVmFyRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWFkVmFyRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlYWRWYXJFeHByLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1aWx0IGluIHZhcmlhYmxlIFwiICsgdGhpcy5idWlsdGluICsgXCIgY2FuIG5vdCBiZSBhc3NpZ25lZCB0by5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBXcml0ZVZhckV4cHIodGhpcy5uYW1lLCB2YWx1ZSwgbnVsbCwgdGhpcy5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWFkVmFyRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIFdyaXRlVmFyRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdyaXRlVmFyRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBXcml0ZVZhckV4cHIobmFtZSwgdmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSB8fCB2YWx1ZS50eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdyaXRlVmFyRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRXcml0ZVZhckV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBXcml0ZVZhckV4cHIucHJvdG90eXBlLnRvRGVjbFN0bXQgPSBmdW5jdGlvbiAodHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjbGFyZVZhclN0bXQodGhpcy5uYW1lLCB0aGlzLnZhbHVlLCB0eXBlLCBtb2RpZmllcnMsIHRoaXMuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICByZXR1cm4gV3JpdGVWYXJFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgV3JpdGVLZXlFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV3JpdGVLZXlFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gV3JpdGVLZXlFeHByKHJlY2VpdmVyLCBpbmRleCwgdmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSB8fCB2YWx1ZS50eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV3JpdGVLZXlFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFdyaXRlS2V5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBXcml0ZUtleUV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBXcml0ZVByb3BFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV3JpdGVQcm9wRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gV3JpdGVQcm9wRXhwcihyZWNlaXZlciwgbmFtZSwgdmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSB8fCB2YWx1ZS50eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdyaXRlUHJvcEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0V3JpdGVQcm9wRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBXcml0ZVByb3BFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgQnVpbHRpbk1ldGhvZCA9IHt9O1xuQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheSA9IDA7XG5CdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGUgPSAxO1xuQnVpbHRpbk1ldGhvZC5CaW5kID0gMjtcbkJ1aWx0aW5NZXRob2RbQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheV0gPSBcIkNvbmNhdEFycmF5XCI7XG5CdWlsdGluTWV0aG9kW0J1aWx0aW5NZXRob2QuU3Vic2NyaWJlT2JzZXJ2YWJsZV0gPSBcIlN1YnNjcmliZU9ic2VydmFibGVcIjtcbkJ1aWx0aW5NZXRob2RbQnVpbHRpbk1ldGhvZC5CaW5kXSA9IFwiQmluZFwiO1xudmFyIEludm9rZU1ldGhvZEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnZva2VNZXRob2RFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0gez99IG1ldGhvZFxuICAgICAqIEBwYXJhbSB7P30gYXJnc1xuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW52b2tlTWV0aG9kRXhwcihyZWNlaXZlciwgbWV0aG9kLCBhcmdzLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIF90aGlzLm5hbWUgPSBtZXRob2Q7XG4gICAgICAgICAgICBfdGhpcy5idWlsdGluID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuYnVpbHRpbiA9IG1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW52b2tlTWV0aG9kRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnZva2VNZXRob2RFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEludm9rZU1ldGhvZEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBJbnZva2VGdW5jdGlvbkV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnZva2VGdW5jdGlvbkV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEBwYXJhbSB7P30gYXJnc1xuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW52b2tlRnVuY3Rpb25FeHByKGZuLCBhcmdzLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmZuID0gZm47XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW52b2tlRnVuY3Rpb25FeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEludm9rZUZ1bmN0aW9uRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBJbnZva2VGdW5jdGlvbkV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBJbnN0YW50aWF0ZUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnN0YW50aWF0ZUV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjbGFzc0V4cHJcbiAgICAgKiBAcGFyYW0gez99IGFyZ3NcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluc3RhbnRpYXRlRXhwcihjbGFzc0V4cHIsIGFyZ3MsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2xhc3NFeHByID0gY2xhc3NFeHByO1xuICAgICAgICBfdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEluc3RhbnRpYXRlRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnN0YW50aWF0ZUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5zdGFudGlhdGVFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgTGl0ZXJhbEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaXRlcmFsRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaXRlcmFsRXhwcih2YWx1ZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGl0ZXJhbEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGl0ZXJhbEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBFeHRlcm5hbEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlcm5hbEV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlUGFyYW1zXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEV4dGVybmFsRXhwcih2YWx1ZSwgdHlwZSwgdHlwZVBhcmFtcywgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAodHlwZVBhcmFtcyA9PT0gdm9pZCAwKSB7IHR5cGVQYXJhbXMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIF90aGlzLnR5cGVQYXJhbXMgPSB0eXBlUGFyYW1zO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXh0ZXJuYWxFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4dGVybmFsRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBFeHRlcm5hbEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBDb25kaXRpb25hbEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25kaXRpb25hbEV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb25kaXRpb25cbiAgICAgKiBAcGFyYW0gez99IHRydWVDYXNlXG4gICAgICogQHBhcmFtIHs/PX0gZmFsc2VDYXNlXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb25kaXRpb25hbEV4cHIoY29uZGl0aW9uLCB0cnVlQ2FzZSwgZmFsc2VDYXNlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmIChmYWxzZUNhc2UgPT09IHZvaWQgMCkgeyBmYWxzZUNhc2UgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUgfHwgdHJ1ZUNhc2UudHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICBfdGhpcy5mYWxzZUNhc2UgPSBmYWxzZUNhc2U7XG4gICAgICAgIF90aGlzLnRydWVDYXNlID0gdHJ1ZUNhc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25kaXRpb25hbEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29uZGl0aW9uYWxFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbmRpdGlvbmFsRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIE5vdEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb3RFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29uZGl0aW9uXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5vdEV4cHIoY29uZGl0aW9uLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIEJPT0xfVFlQRSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm90RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXROb3RFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vdEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBDYXN0RXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhc3RFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENhc3RFeHByKHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDYXN0RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDYXN0RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBDYXN0RXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIEZuUGFyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBGblBhcmFtKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gRm5QYXJhbTtcbn0oKSk7XG52YXIgRnVuY3Rpb25FeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnVuY3Rpb25FeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1zXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZW1lbnRzXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBGdW5jdGlvbkV4cHIocGFyYW1zLCBzdGF0ZW1lbnRzLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgX3RoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGdW5jdGlvbkV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RnVuY3Rpb25FeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBGdW5jdGlvbkV4cHIucHJvdG90eXBlLnRvRGVjbFN0bXQgPSBmdW5jdGlvbiAobmFtZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBuZXcgRGVjbGFyZUZ1bmN0aW9uU3RtdChuYW1lLCB0aGlzLnBhcmFtcywgdGhpcy5zdGF0ZW1lbnRzLCB0aGlzLnR5cGUsIG1vZGlmaWVycywgdGhpcy5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIHJldHVybiBGdW5jdGlvbkV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBCaW5hcnlPcGVyYXRvckV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCaW5hcnlPcGVyYXRvckV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvcGVyYXRvclxuICAgICAqIEBwYXJhbSB7P30gbGhzXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJpbmFyeU9wZXJhdG9yRXhwcihvcGVyYXRvciwgbGhzLCByaHMsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSB8fCBsaHMudHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgX3RoaXMucmhzID0gcmhzO1xuICAgICAgICBfdGhpcy5saHMgPSBsaHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5hcnlPcGVyYXRvckV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEJpbmFyeU9wZXJhdG9yRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIFJlYWRQcm9wRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlYWRQcm9wRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZWFkUHJvcEV4cHIocmVjZWl2ZXIsIG5hbWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWFkUHJvcEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmVhZFByb3BFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVhZFByb3BFeHByLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcml0ZVByb3BFeHByKHRoaXMucmVjZWl2ZXIsIHRoaXMubmFtZSwgdmFsdWUsIG51bGwsIHRoaXMuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICByZXR1cm4gUmVhZFByb3BFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgUmVhZEtleUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWFkS2V5RXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVhZEtleUV4cHIocmVjZWl2ZXIsIGluZGV4LCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWFkS2V5RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWFkS2V5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlYWRLZXlFeHByLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcml0ZUtleUV4cHIodGhpcy5yZWNlaXZlciwgdGhpcy5pbmRleCwgdmFsdWUsIG51bGwsIHRoaXMuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICByZXR1cm4gUmVhZEtleUV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBMaXRlcmFsQXJyYXlFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGl0ZXJhbEFycmF5RXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVudHJpZXNcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpdGVyYWxBcnJheUV4cHIoZW50cmllcywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIExpdGVyYWxBcnJheUV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbEFycmF5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBMaXRlcmFsQXJyYXlFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgTGl0ZXJhbE1hcEVudHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSBxdW90ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaXRlcmFsTWFwRW50cnkoa2V5LCB2YWx1ZSwgcXVvdGVkKSB7XG4gICAgICAgIGlmIChxdW90ZWQgPT09IHZvaWQgMCkgeyBxdW90ZWQgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnF1b3RlZCA9IHF1b3RlZDtcbiAgICB9XG4gICAgcmV0dXJuIExpdGVyYWxNYXBFbnRyeTtcbn0oKSk7XG52YXIgTGl0ZXJhbE1hcEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaXRlcmFsTWFwRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVudHJpZXNcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpdGVyYWxNYXBFeHByKGVudHJpZXMsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgICAgIF90aGlzLnZhbHVlVHlwZSA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICBfdGhpcy52YWx1ZVR5cGUgPSB0eXBlLnZhbHVlVHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGl0ZXJhbE1hcEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbE1hcEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGl0ZXJhbE1hcEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBDb21tYUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21tYUV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJ0c1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21tYUV4cHIocGFydHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0udHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGFydHMgPSBwYXJ0cztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbW1hRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb21tYUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tbWFFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgVEhJU19FWFBSID0gbmV3IFJlYWRWYXJFeHByKEJ1aWx0aW5WYXIuVGhpcywgbnVsbCwgbnVsbCk7XG52YXIgU1VQRVJfRVhQUiA9IG5ldyBSZWFkVmFyRXhwcihCdWlsdGluVmFyLlN1cGVyLCBudWxsLCBudWxsKTtcbnZhciBDQVRDSF9FUlJPUl9WQVIgPSBuZXcgUmVhZFZhckV4cHIoQnVpbHRpblZhci5DYXRjaEVycm9yLCBudWxsLCBudWxsKTtcbnZhciBDQVRDSF9TVEFDS19WQVIgPSBuZXcgUmVhZFZhckV4cHIoQnVpbHRpblZhci5DYXRjaFN0YWNrLCBudWxsLCBudWxsKTtcbnZhciBOVUxMX0VYUFIgPSBuZXcgTGl0ZXJhbEV4cHIobnVsbCwgbnVsbCwgbnVsbCk7XG52YXIgVFlQRURfTlVMTF9FWFBSID0gbmV3IExpdGVyYWxFeHByKG51bGwsIElORkVSUkVEX1RZUEUsIG51bGwpO1xudmFyIFN0bXRNb2RpZmllciA9IHt9O1xuU3RtdE1vZGlmaWVyLkZpbmFsID0gMDtcblN0bXRNb2RpZmllci5Qcml2YXRlID0gMTtcblN0bXRNb2RpZmllcltTdG10TW9kaWZpZXIuRmluYWxdID0gXCJGaW5hbFwiO1xuU3RtdE1vZGlmaWVyW1N0bXRNb2RpZmllci5Qcml2YXRlXSA9IFwiUHJpdmF0ZVwiO1xuLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIFN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0YXRlbWVudChtb2RpZmllcnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgW107XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW4gfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1vZGlmaWVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnQucHJvdG90eXBlLmhhc01vZGlmaWVyID0gZnVuY3Rpb24gKG1vZGlmaWVyKSB7IHJldHVybiAoKHRoaXMubW9kaWZpZXJzKSkuaW5kZXhPZihtb2RpZmllcikgIT09IC0xOyB9O1xuICAgIHJldHVybiBTdGF0ZW1lbnQ7XG59KCkpO1xudmFyIERlY2xhcmVWYXJTdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVjbGFyZVZhclN0bXQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVjbGFyZVZhclN0bXQobmFtZSwgdmFsdWUsIHR5cGUsIG1vZGlmaWVycywgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBfdGhpcy50eXBlID0gdHlwZSB8fCB2YWx1ZS50eXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVjbGFyZVZhclN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJlVmFyU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBEZWNsYXJlVmFyU3RtdDtcbn0oU3RhdGVtZW50KSk7XG52YXIgRGVjbGFyZUZ1bmN0aW9uU3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlY2xhcmVGdW5jdGlvblN0bXQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlY2xhcmVGdW5jdGlvblN0bXQobmFtZSwgcGFyYW1zLCBzdGF0ZW1lbnRzLCB0eXBlLCBtb2RpZmllcnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICBfdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgX3RoaXMudHlwZSA9IHR5cGUgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlY2xhcmVGdW5jdGlvblN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIERlY2xhcmVGdW5jdGlvblN0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIEV4cHJlc3Npb25TdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHByZXNzaW9uU3RhdGVtZW50LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbnVsbCwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXhwciA9IGV4cHI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uU3RhdGVtZW50LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXhwcmVzc2lvblN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gRXhwcmVzc2lvblN0YXRlbWVudDtcbn0oU3RhdGVtZW50KSk7XG52YXIgUmV0dXJuU3RhdGVtZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmV0dXJuU3RhdGVtZW50LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmV0dXJuU3RhdGVtZW50KHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG51bGwsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZXR1cm5TdGF0ZW1lbnQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZXR1cm5TdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFJldHVyblN0YXRlbWVudDtcbn0oU3RhdGVtZW50KSk7XG52YXIgQWJzdHJhY3RDbGFzc1BhcnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gbW9kaWZpZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQWJzdHJhY3RDbGFzc1BhcnQodHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIHRoaXMubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICAgICAgICBpZiAoIW1vZGlmaWVycykge1xuICAgICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kaWZpZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0Q2xhc3NQYXJ0LnByb3RvdHlwZS5oYXNNb2RpZmllciA9IGZ1bmN0aW9uIChtb2RpZmllcikgeyByZXR1cm4gKCh0aGlzLm1vZGlmaWVycykpLmluZGV4T2YobW9kaWZpZXIpICE9PSAtMTsgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RDbGFzc1BhcnQ7XG59KCkpO1xudmFyIENsYXNzRmllbGQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDbGFzc0ZpZWxkLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDbGFzc0ZpZWxkKG5hbWUsIHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBtb2RpZmllcnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDbGFzc0ZpZWxkO1xufShBYnN0cmFjdENsYXNzUGFydCkpO1xudmFyIENsYXNzTWV0aG9kID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2xhc3NNZXRob2QsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez99IGJvZHlcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2xhc3NNZXRob2QobmFtZSwgcGFyYW1zLCBib2R5LCB0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgbW9kaWZpZXJzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICBfdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ2xhc3NNZXRob2Q7XG59KEFic3RyYWN0Q2xhc3NQYXJ0KSk7XG52YXIgQ2xhc3NHZXR0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDbGFzc0dldHRlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGJvZHlcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2xhc3NHZXR0ZXIobmFtZSwgYm9keSwgdHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIG1vZGlmaWVycykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDbGFzc0dldHRlcjtcbn0oQWJzdHJhY3RDbGFzc1BhcnQpKTtcbnZhciBDbGFzc1N0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDbGFzc1N0bXQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IGZpZWxkc1xuICAgICAqIEBwYXJhbSB7P30gZ2V0dGVyc1xuICAgICAqIEBwYXJhbSB7P30gY29uc3RydWN0b3JNZXRob2RcbiAgICAgKiBAcGFyYW0gez99IG1ldGhvZHNcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2xhc3NTdG10KG5hbWUsIHBhcmVudCwgZmllbGRzLCBnZXR0ZXJzLCBjb25zdHJ1Y3Rvck1ldGhvZCwgbWV0aG9kcywgbW9kaWZpZXJzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1vZGlmaWVycywgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgX3RoaXMuZmllbGRzID0gZmllbGRzO1xuICAgICAgICBfdGhpcy5nZXR0ZXJzID0gZ2V0dGVycztcbiAgICAgICAgX3RoaXMuY29uc3RydWN0b3JNZXRob2QgPSBjb25zdHJ1Y3Rvck1ldGhvZDtcbiAgICAgICAgX3RoaXMubWV0aG9kcyA9IG1ldGhvZHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDbGFzc1N0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJlQ2xhc3NTdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENsYXNzU3RtdDtcbn0oU3RhdGVtZW50KSk7XG52YXIgSWZTdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSWZTdG10LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29uZGl0aW9uXG4gICAgICogQHBhcmFtIHs/fSB0cnVlQ2FzZVxuICAgICAqIEBwYXJhbSB7Pz19IGZhbHNlQ2FzZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJZlN0bXQoY29uZGl0aW9uLCB0cnVlQ2FzZSwgZmFsc2VDYXNlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmIChmYWxzZUNhc2UgPT09IHZvaWQgMCkgeyBmYWxzZUNhc2UgPSBbXTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgIF90aGlzLnRydWVDYXNlID0gdHJ1ZUNhc2U7XG4gICAgICAgIF90aGlzLmZhbHNlQ2FzZSA9IGZhbHNlQ2FzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIElmU3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdElmU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBJZlN0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIFRyeUNhdGNoU3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRyeUNhdGNoU3RtdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGJvZHlTdG10c1xuICAgICAqIEBwYXJhbSB7P30gY2F0Y2hTdG10c1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcnlDYXRjaFN0bXQoYm9keVN0bXRzLCBjYXRjaFN0bXRzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG51bGwsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJvZHlTdG10cyA9IGJvZHlTdG10cztcbiAgICAgICAgX3RoaXMuY2F0Y2hTdG10cyA9IGNhdGNoU3RtdHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcnlDYXRjaFN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUcnlDYXRjaFN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJ5Q2F0Y2hTdG10O1xufShTdGF0ZW1lbnQpKTtcbnZhciBUaHJvd1N0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaHJvd1N0bXQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlcnJvclxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUaHJvd1N0bXQoZXJyb3IsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbnVsbCwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRocm93U3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRocm93U3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBUaHJvd1N0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIEFzdFRyYW5zZm9ybWVyJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzdFRyYW5zZm9ybWVyJDEoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudHJhbnNmb3JtRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7IHJldHVybiBleHByOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudHJhbnNmb3JtU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7IHJldHVybiBzdG10OyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKGFzdCwgY29udGV4dCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdFdyaXRlVmFyRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IFdyaXRlVmFyRXhwcihleHByLm5hbWUsIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLnR5cGUsIGV4cHIuc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdFdyaXRlS2V5RXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IFdyaXRlS2V5RXhwcihleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgZXhwci5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLnR5cGUsIGV4cHIuc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdFdyaXRlUHJvcEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBXcml0ZVByb3BFeHByKGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLm5hbWUsIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLnR5cGUsIGV4cHIuc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0SW52b2tlTWV0aG9kRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWV0aG9kID0gYXN0LmJ1aWx0aW4gfHwgYXN0Lm5hbWU7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IEludm9rZU1ldGhvZEV4cHIoYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgLyoqIEB0eXBlIHs/fSAqLyAoKG1ldGhvZCkpLCB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgSW52b2tlRnVuY3Rpb25FeHByKGFzdC5mbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCksIGFzdC50eXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBJbnN0YW50aWF0ZUV4cHIoYXN0LmNsYXNzRXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCksIGFzdC50eXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIoYXN0LCBjb250ZXh0KTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIoYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgQ29uZGl0aW9uYWxFeHByKGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCAvKiogQHR5cGUgez99ICovICgoYXN0LmZhbHNlQ2FzZSkpLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LnR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXROb3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBOb3RFeHByKGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IENhc3RFeHByKGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50eXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBGdW5jdGlvbkV4cHIoYXN0LnBhcmFtcywgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoYXN0LnN0YXRlbWVudHMsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdEJpbmFyeU9wZXJhdG9yRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgQmluYXJ5T3BlcmF0b3JFeHByKGFzdC5vcGVyYXRvciwgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5yaHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgUmVhZFByb3BFeHByKGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5uYW1lLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdFJlYWRLZXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBSZWFkS2V5RXhwcihhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IExpdGVyYWxBcnJheUV4cHIodGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjb250ZXh0KSwgYXN0LnR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50cmllcyA9IGFzdC5lbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRW50cnkoZW50cnkua2V5LCBlbnRyeS52YWx1ZS52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGNvbnRleHQpLCBlbnRyeS5xdW90ZWQpOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWFwVHlwZSA9IG5ldyBNYXBUeXBlKGFzdC52YWx1ZVR5cGUsIG51bGwpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBMaXRlcmFsTWFwRXhwcihlbnRyaWVzLCBtYXBUeXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0Q29tbWFFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBDb21tYUV4cHIodGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5wYXJ0cywgY29udGV4dCksIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJzXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdEFsbEV4cHJlc3Npb25zID0gZnVuY3Rpb24gKGV4cHJzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBleHBycy5tYXAoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1TdG10KG5ldyBEZWNsYXJlVmFyU3RtdChzdG10Lm5hbWUsIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBzdG10LnR5cGUsIHN0bXQubW9kaWZpZXJzLCBzdG10LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgRGVjbGFyZUZ1bmN0aW9uU3RtdChzdG10Lm5hbWUsIHN0bXQucGFyYW1zLCB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnN0YXRlbWVudHMsIGNvbnRleHQpLCBzdG10LnR5cGUsIHN0bXQubW9kaWZpZXJzLCBzdG10LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVN0bXQobmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQoc3RtdC5leHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0UmV0dXJuU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVN0bXQobmV3IFJldHVyblN0YXRlbWVudChzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudCA9ICgoc3RtdC5wYXJlbnQpKS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGdldHRlcnMgPSBzdG10LmdldHRlcnMubWFwKGZ1bmN0aW9uIChnZXR0ZXIpIHsgcmV0dXJuIG5ldyBDbGFzc0dldHRlcihnZXR0ZXIubmFtZSwgX3RoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGdldHRlci5ib2R5LCBjb250ZXh0KSwgZ2V0dGVyLnR5cGUsIGdldHRlci5tb2RpZmllcnMpOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3Rvck1ldGhvZCA9IHN0bXQuY29uc3RydWN0b3JNZXRob2QgJiZcbiAgICAgICAgICAgIG5ldyBDbGFzc01ldGhvZChzdG10LmNvbnN0cnVjdG9yTWV0aG9kLm5hbWUsIHN0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLCB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGNvbnRleHQpLCBzdG10LmNvbnN0cnVjdG9yTWV0aG9kLnR5cGUsIHN0bXQuY29uc3RydWN0b3JNZXRob2QubW9kaWZpZXJzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWV0aG9kcyA9IHN0bXQubWV0aG9kcy5tYXAoZnVuY3Rpb24gKG1ldGhvZCkgeyByZXR1cm4gbmV3IENsYXNzTWV0aG9kKG1ldGhvZC5uYW1lLCBtZXRob2QucGFyYW1zLCBfdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGNvbnRleHQpLCBtZXRob2QudHlwZSwgbWV0aG9kLm1vZGlmaWVycyk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1TdG10KG5ldyBDbGFzc1N0bXQoc3RtdC5uYW1lLCBwYXJlbnQsIHN0bXQuZmllbGRzLCBnZXR0ZXJzLCBjdG9yTWV0aG9kLCBtZXRob2RzLCBzdG10Lm1vZGlmaWVycywgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0SWZTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgSWZTdG10KHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC50cnVlQ2FzZSwgY29udGV4dCksIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjb250ZXh0KSwgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgVHJ5Q2F0Y2hTdG10KHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjb250ZXh0KSwgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jYXRjaFN0bXRzLCBjb250ZXh0KSwgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0VGhyb3dTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgVGhyb3dTdG10KHN0bXQuZXJyb3IudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBzdG10LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRDb21tZW50U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVN0bXQoc3RtdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRzXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RtdHMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHN0bXRzLm1hcChmdW5jdGlvbiAoc3RtdCkgeyByZXR1cm4gc3RtdC52aXNpdFN0YXRlbWVudChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFzdFRyYW5zZm9ybWVyJDE7XG59KCkpO1xudmFyIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVjdXJzaXZlQXN0VmlzaXRvciQxKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdFdyaXRlVmFyRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdFdyaXRlS2V5RXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBleHByLmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0V3JpdGVQcm9wRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmZuLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpOyAvKiogQHR5cGUgez99ICovXG4gICAgICAgICgoYXN0LmZhbHNlQ2FzZSkpLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGFzdC5zdGF0ZW1lbnRzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QubGhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LnJocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0UmVhZEtleUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIGFzdC5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuZW50cmllcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBhc3QuZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkudmFsdWUudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdENvbW1hRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5wYXJ0cywgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJzXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0QWxsRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoZXhwcnMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZXhwcnMuZm9yRWFjaChmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuc3RhdGVtZW50cywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICBzdG10LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdFJldHVyblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgKChzdG10LnBhcmVudCkpLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgc3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikgeyByZXR1cm4gX3RoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGdldHRlci5ib2R5LCBjb250ZXh0KTsgfSk7XG4gICAgICAgIGlmIChzdG10LmNvbnN0cnVjdG9yTWV0aG9kKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHN0bXQubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgcmV0dXJuIF90aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhtZXRob2QuYm9keSwgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdElmU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC50cnVlQ2FzZSwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY2F0Y2hTdG10cywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0VGhyb3dTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgc3RtdC5lcnJvci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0Q29tbWVudFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkgeyByZXR1cm4gc3RtdDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRzXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0QWxsU3RhdGVtZW50cyA9IGZ1bmN0aW9uIChzdG10cywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzdG10cy5mb3JFYWNoKGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBzdG10LnZpc2l0U3RhdGVtZW50KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVjdXJzaXZlQXN0VmlzaXRvciQxO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBzdG10c1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZmluZFJlYWRWYXJOYW1lcyhzdG10cykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX1JlYWRWYXJWaXNpdG9yKCk7XG4gICAgdmlzaXRvci52aXNpdEFsbFN0YXRlbWVudHMoc3RtdHMsIG51bGwpO1xuICAgIHJldHVybiB2aXNpdG9yLnZhck5hbWVzO1xufVxudmFyIF9SZWFkVmFyVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9SZWFkVmFyVmlzaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBfUmVhZFZhclZpc2l0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhck5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1JlYWRWYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAvLyBEb24ndCBkZXNjZW5kIGludG8gbmVzdGVkIGZ1bmN0aW9uc1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1JlYWRWYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAvLyBEb24ndCBkZXNjZW5kIGludG8gbmVzdGVkIGNsYXNzZXNcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1JlYWRWYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBpZiAoYXN0Lm5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFyTmFtZXMuYWRkKGFzdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBfUmVhZFZhclZpc2l0b3I7XG59KFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMSkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHN0bXRcbiAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYXBwbHlTb3VyY2VTcGFuVG9TdGF0ZW1lbnRJZk5lZWRlZChzdG10LCBzb3VyY2VTcGFuKSB7XG4gICAgaWYgKCFzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lciA9IG5ldyBfQXBwbHlTb3VyY2VTcGFuVHJhbnNmb3JtZXIoc291cmNlU3Bhbik7XG4gICAgcmV0dXJuIHN0bXQudmlzaXRTdGF0ZW1lbnQodHJhbnNmb3JtZXIsIG51bGwpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGV4cHJcbiAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYXBwbHlTb3VyY2VTcGFuVG9FeHByZXNzaW9uSWZOZWVkZWQoZXhwciwgc291cmNlU3Bhbikge1xuICAgIGlmICghc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZXIgPSBuZXcgX0FwcGx5U291cmNlU3BhblRyYW5zZm9ybWVyKHNvdXJjZVNwYW4pO1xuICAgIHJldHVybiBleHByLnZpc2l0RXhwcmVzc2lvbih0cmFuc2Zvcm1lciwgbnVsbCk7XG59XG52YXIgX0FwcGx5U291cmNlU3BhblRyYW5zZm9ybWVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoX0FwcGx5U291cmNlU3BhblRyYW5zZm9ybWVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lcihzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb2JqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXBwbHlTb3VyY2VTcGFuVHJhbnNmb3JtZXIucHJvdG90eXBlLl9jbG9uZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xvbmUgPSBPYmplY3QuY3JlYXRlKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICBjbG9uZVtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghZXhwci5zb3VyY2VTcGFuKSB7XG4gICAgICAgICAgICBleHByID0gdGhpcy5fY2xvbmUoZXhwcik7XG4gICAgICAgICAgICBleHByLnNvdXJjZVNwYW4gPSB0aGlzLnNvdXJjZVNwYW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghc3RtdC5zb3VyY2VTcGFuKSB7XG4gICAgICAgICAgICBzdG10ID0gdGhpcy5fY2xvbmUoc3RtdCk7XG4gICAgICAgICAgICBzdG10LnNvdXJjZVNwYW4gPSB0aGlzLnNvdXJjZVNwYW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICByZXR1cm4gX0FwcGx5U291cmNlU3BhblRyYW5zZm9ybWVyO1xufShBc3RUcmFuc2Zvcm1lciQxKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gbmFtZVxuICogQHBhcmFtIHs/PX0gdHlwZVxuICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdmFyaWFibGUobmFtZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgUmVhZFZhckV4cHIobmFtZSwgdHlwZSwgc291cmNlU3Bhbik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaWRcbiAqIEBwYXJhbSB7Pz19IHR5cGVQYXJhbXNcbiAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGltcG9ydEV4cHIoaWQsIHR5cGVQYXJhbXMsIHNvdXJjZVNwYW4pIHtcbiAgICBpZiAodHlwZVBhcmFtcyA9PT0gdm9pZCAwKSB7IHR5cGVQYXJhbXMgPSBudWxsOyB9XG4gICAgcmV0dXJuIG5ldyBFeHRlcm5hbEV4cHIoaWQsIG51bGwsIHR5cGVQYXJhbXMsIHNvdXJjZVNwYW4pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGlkXG4gKiBAcGFyYW0gez89fSB0eXBlUGFyYW1zXG4gKiBAcGFyYW0gez89fSB0eXBlTW9kaWZpZXJzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpbXBvcnRUeXBlKGlkLCB0eXBlUGFyYW1zLCB0eXBlTW9kaWZpZXJzKSB7XG4gICAgaWYgKHR5cGVQYXJhbXMgPT09IHZvaWQgMCkgeyB0eXBlUGFyYW1zID0gbnVsbDsgfVxuICAgIGlmICh0eXBlTW9kaWZpZXJzID09PSB2b2lkIDApIHsgdHlwZU1vZGlmaWVycyA9IG51bGw7IH1cbiAgICByZXR1cm4gaWQgIT0gbnVsbCA/IGV4cHJlc3Npb25UeXBlKGltcG9ydEV4cHIoaWQsIHR5cGVQYXJhbXMsIG51bGwpLCB0eXBlTW9kaWZpZXJzKSA6IG51bGw7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZXhwclxuICogQHBhcmFtIHs/PX0gdHlwZU1vZGlmaWVyc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXhwcmVzc2lvblR5cGUoZXhwciwgdHlwZU1vZGlmaWVycykge1xuICAgIGlmICh0eXBlTW9kaWZpZXJzID09PSB2b2lkIDApIHsgdHlwZU1vZGlmaWVycyA9IG51bGw7IH1cbiAgICByZXR1cm4gZXhwciAhPSBudWxsID8gKChuZXcgRXhwcmVzc2lvblR5cGUoZXhwciwgdHlwZU1vZGlmaWVycykpKSA6IG51bGw7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVzXG4gKiBAcGFyYW0gez89fSB0eXBlXG4gKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBsaXRlcmFsQXJyKHZhbHVlcywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5RXhwcih2YWx1ZXMsIHR5cGUsIHNvdXJjZVNwYW4pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlc1xuICogQHBhcmFtIHs/PX0gdHlwZVxuICogQHBhcmFtIHs/PX0gcXVvdGVkXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBsaXRlcmFsTWFwKHZhbHVlcywgdHlwZSwgcXVvdGVkKSB7XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgIGlmIChxdW90ZWQgPT09IHZvaWQgMCkgeyBxdW90ZWQgPSBmYWxzZTsgfVxuICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcEV4cHIodmFsdWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRW50cnkoZW50cnlbMF0sIGVudHJ5WzFdLCBxdW90ZWQpOyB9KSwgdHlwZSwgbnVsbCk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZXhwclxuICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbm90KGV4cHIsIHNvdXJjZVNwYW4pIHtcbiAgICByZXR1cm4gbmV3IE5vdEV4cHIoZXhwciwgc291cmNlU3Bhbik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcGFyYW1zXG4gKiBAcGFyYW0gez99IGJvZHlcbiAqIEBwYXJhbSB7Pz19IHR5cGVcbiAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGZuKHBhcmFtcywgYm9keSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb25FeHByKHBhcmFtcywgYm9keSwgdHlwZSwgc291cmNlU3Bhbik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEBwYXJhbSB7Pz19IHR5cGVcbiAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGxpdGVyYWwodmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByKHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGNsYXNzIHN0bXRzIGJhc2VkIG9uIHRoZSBnaXZlbiBkYXRhLlxuICogQHBhcmFtIHs/fSBjb25maWdcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzU3RtdChjb25maWcpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRBcmdzID0gY29uZmlnLnBhcmVudEFyZ3MgfHwgW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VwZXJDdG9yU3RtdHMgPSBjb25maWcucGFyZW50ID8gW1NVUEVSX0VYUFIuY2FsbEZuKHBhcmVudEFyZ3MpLnRvU3RtdCgpXSA6IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGJ1aWxkZXIgPSBjb25jYXRDbGFzc0J1aWxkZXJQYXJ0cyhBcnJheS5pc0FycmF5KGNvbmZpZy5idWlsZGVycykgPyBjb25maWcuYnVpbGRlcnMgOiBbY29uZmlnLmJ1aWxkZXJzXSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3RvciA9IG5ldyBDbGFzc01ldGhvZChudWxsLCBjb25maWcuY3RvclBhcmFtcyB8fCBbXSwgc3VwZXJDdG9yU3RtdHMuY29uY2F0KGJ1aWxkZXIuY3RvclN0bXRzKSk7XG4gICAgcmV0dXJuIG5ldyBDbGFzc1N0bXQoY29uZmlnLm5hbWUsIGNvbmZpZy5wYXJlbnQgfHwgbnVsbCwgYnVpbGRlci5maWVsZHMsIGJ1aWxkZXIuZ2V0dGVycywgY3RvciwgYnVpbGRlci5tZXRob2RzLCBjb25maWcubW9kaWZpZXJzIHx8IFtdLCBjb25maWcuc291cmNlU3Bhbik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gYnVpbGRlcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbmNhdENsYXNzQnVpbGRlclBhcnRzKGJ1aWxkZXJzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmllbGRzOiBbXS5jb25jYXQuYXBwbHkoW10sICgoYnVpbGRlcnMubWFwKChmdW5jdGlvbiAoYnVpbGRlcikgeyByZXR1cm4gYnVpbGRlci5maWVsZHMgfHwgW107IH0pKSkpKSxcbiAgICAgICAgbWV0aG9kczogW10uY29uY2F0LmFwcGx5KFtdLCAoKGJ1aWxkZXJzLm1hcChmdW5jdGlvbiAoYnVpbGRlcikgeyByZXR1cm4gYnVpbGRlci5tZXRob2RzIHx8IFtdOyB9KSkpKSxcbiAgICAgICAgZ2V0dGVyczogW10uY29uY2F0LmFwcGx5KFtdLCAoKGJ1aWxkZXJzLm1hcChmdW5jdGlvbiAoYnVpbGRlcikgeyByZXR1cm4gYnVpbGRlci5nZXR0ZXJzIHx8IFtdOyB9KSkpKSxcbiAgICAgICAgY3RvclN0bXRzOiBbXS5jb25jYXQuYXBwbHkoW10sICgoYnVpbGRlcnMubWFwKGZ1bmN0aW9uIChidWlsZGVyKSB7IHJldHVybiBidWlsZGVyLmN0b3JTdG10cyB8fCBbXTsgfSkpKSksXG4gICAgfTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBRVU9URURfS0VZUyA9ICckcXVvdGVkJCc7XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEBwYXJhbSB7Pz19IHR5cGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRWYWx1ZVRvT3V0cHV0QXN0KHZhbHVlLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgIHJldHVybiB2aXNpdFZhbHVlKHZhbHVlLCBuZXcgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIoKSwgdHlwZSk7XG59XG52YXIgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFyclxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QXJyYXkgPSBmdW5jdGlvbiAoYXJyLCB0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBsaXRlcmFsQXJyKGFyci5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2aXNpdFZhbHVlKHZhbHVlLCBfdGhpcywgbnVsbCk7IH0pLCB0eXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWFwXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRTdHJpbmdNYXAgPSBmdW5jdGlvbiAobWFwLCB0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJpZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVvdGVkU2V0ID0gbmV3IFNldChtYXAgJiYgbWFwW1FVT1RFRF9LRVlTXSk7XG4gICAgICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2gobmV3IExpdGVyYWxNYXBFbnRyeShrZXksIHZpc2l0VmFsdWUobWFwW2tleV0sIF90aGlzLCBudWxsKSwgcXVvdGVkU2V0LmhhcyhrZXkpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXBFeHByKGVudHJpZXMsIHR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJpbWl0aXZlID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlKSB7IHJldHVybiBsaXRlcmFsKHZhbHVlLCB0eXBlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRPdGhlciA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcih7IHJlZmVyZW5jZTogdmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFRoaXMgaXMgY3VycmVudGx5IG5vdCByZWFkLCBidXQgd2lsbCBwcm9iYWJseSBiZSB1c2VkIGluIHRoZSBmdXR1cmUuXG4gKiBXZSBrZWVwIGl0IGFzIHdlIGFscmVhZHkgcGFzcyBpdCB0aHJvdWdoIGFsbCB0aGUgcmlndGggcGxhY2VzLi4uXG4gKi9cbnZhciBDb21wb25lbnRGYWN0b3J5RGVwZW5kZW5jeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wVHlwZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudEZhY3RvcnlEZXBlbmRlbmN5KGNvbXBUeXBlKSB7XG4gICAgICAgIHRoaXMuY29tcFR5cGUgPSBjb21wVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIENvbXBvbmVudEZhY3RvcnlEZXBlbmRlbmN5O1xufSgpKTtcbnZhciBOZ01vZHVsZUNvbXBpbGVSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGVtZW50c1xuICAgICAqIEBwYXJhbSB7P30gbmdNb2R1bGVGYWN0b3J5VmFyXG4gICAgICogQHBhcmFtIHs/fSBkZXBlbmRlbmNpZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOZ01vZHVsZUNvbXBpbGVSZXN1bHQoc3RhdGVtZW50cywgbmdNb2R1bGVGYWN0b3J5VmFyLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgdGhpcy5uZ01vZHVsZUZhY3RvcnlWYXIgPSBuZ01vZHVsZUZhY3RvcnlWYXI7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgIH1cbiAgICByZXR1cm4gTmdNb2R1bGVDb21waWxlUmVzdWx0O1xufSgpKTtcbnZhciBOZ01vZHVsZUNvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZ01vZHVsZUNvbXBpbGVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlTWV0YVxuICAgICAqIEBwYXJhbSB7P30gZXh0cmFQcm92aWRlcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5nTW9kdWxlQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAobmdNb2R1bGVNZXRhLCBleHRyYVByb3ZpZGVycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VTcGFuID0gdHlwZVNvdXJjZVNwYW4oJ05nTW9kdWxlJywgbmdNb2R1bGVNZXRhLnR5cGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvb3RzdHJhcENvbXBvbmVudEZhY3RvcmllcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRyeUNvbXBvbmVudEZhY3RvcmllcyA9IG5nTW9kdWxlTWV0YS50cmFuc2l0aXZlTW9kdWxlLmVudHJ5Q29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5Q29tcG9uZW50KSB7XG4gICAgICAgICAgICBpZiAobmdNb2R1bGVNZXRhLmJvb3RzdHJhcENvbXBvbmVudHMuc29tZShmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGlkLnJlZmVyZW5jZSA9PT0gZW50cnlDb21wb25lbnQuY29tcG9uZW50VHlwZTsgfSkpIHtcbiAgICAgICAgICAgICAgICBib290c3RyYXBDb21wb25lbnRGYWN0b3JpZXMucHVzaCh7IHJlZmVyZW5jZTogZW50cnlDb21wb25lbnQuY29tcG9uZW50RmFjdG9yeSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlcHMucHVzaChuZXcgQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3koZW50cnlDb21wb25lbnQuY29tcG9uZW50VHlwZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVmZXJlbmNlOiBlbnRyeUNvbXBvbmVudC5jb21wb25lbnRGYWN0b3J5IH07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBidWlsZGVyID0gbmV3IF9JbmplY3RvckJ1aWxkZXIobmdNb2R1bGVNZXRhLCBlbnRyeUNvbXBvbmVudEZhY3RvcmllcywgYm9vdHN0cmFwQ29tcG9uZW50RmFjdG9yaWVzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvdmlkZXJQYXJzZXIgPSBuZXcgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyKG5nTW9kdWxlTWV0YSwgZXh0cmFQcm92aWRlcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICBwcm92aWRlclBhcnNlci5wYXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiBidWlsZGVyLmFkZFByb3ZpZGVyKHByb3ZpZGVyKTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluamVjdG9yQ2xhc3MgPSBidWlsZGVyLmJ1aWxkKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlRmFjdG9yeVZhciA9IGlkZW50aWZpZXJOYW1lKG5nTW9kdWxlTWV0YS50eXBlKSArIFwiTmdGYWN0b3J5XCI7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlRmFjdG9yeVN0bXQgPSB2YXJpYWJsZShuZ01vZHVsZUZhY3RvcnlWYXIpXG4gICAgICAgICAgICAuc2V0KGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5OZ01vZHVsZUZhY3RvcnkpKVxuICAgICAgICAgICAgLmluc3RhbnRpYXRlKFt2YXJpYWJsZShpbmplY3RvckNsYXNzLm5hbWUpLCBpbXBvcnRFeHByKG5nTW9kdWxlTWV0YS50eXBlKV0sIGltcG9ydFR5cGUoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5OZ01vZHVsZUZhY3RvcnkpLCBbLyoqIEB0eXBlIHs/fSAqLyAoKGltcG9ydFR5cGUobmdNb2R1bGVNZXRhLnR5cGUpKSldLCBbVHlwZU1vZGlmaWVyLkNvbnN0XSkpKVxuICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdG10cyA9IFtpbmplY3RvckNsYXNzLCBuZ01vZHVsZUZhY3RvcnlTdG10XTtcbiAgICAgICAgaWYgKG5nTW9kdWxlTWV0YS5pZCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVnaXN0ZXJGYWN0b3J5U3RtdCA9IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5SZWdpc3Rlck1vZHVsZUZhY3RvcnlGbikpXG4gICAgICAgICAgICAgICAgLmNhbGxGbihbbGl0ZXJhbChuZ01vZHVsZU1ldGEuaWQpLCB2YXJpYWJsZShuZ01vZHVsZUZhY3RvcnlWYXIpXSlcbiAgICAgICAgICAgICAgICAudG9TdG10KCk7XG4gICAgICAgICAgICBzdG10cy5wdXNoKHJlZ2lzdGVyRmFjdG9yeVN0bXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTmdNb2R1bGVDb21waWxlUmVzdWx0KHN0bXRzLCBuZ01vZHVsZUZhY3RvcnlWYXIsIGRlcHMpO1xuICAgIH07XG4gICAgcmV0dXJuIE5nTW9kdWxlQ29tcGlsZXI7XG59KCkpO1xuTmdNb2R1bGVDb21waWxlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5OZ01vZHVsZUNvbXBpbGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG52YXIgX0luamVjdG9yQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfbmdNb2R1bGVNZXRhXG4gICAgICogQHBhcmFtIHs/fSBfZW50cnlDb21wb25lbnRGYWN0b3JpZXNcbiAgICAgKiBAcGFyYW0gez99IF9ib290c3RyYXBDb21wb25lbnRGYWN0b3JpZXNcbiAgICAgKiBAcGFyYW0gez99IF9zb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX0luamVjdG9yQnVpbGRlcihfbmdNb2R1bGVNZXRhLCBfZW50cnlDb21wb25lbnRGYWN0b3JpZXMsIF9ib290c3RyYXBDb21wb25lbnRGYWN0b3JpZXMsIF9zb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlTWV0YSA9IF9uZ01vZHVsZU1ldGE7XG4gICAgICAgIHRoaXMuX2VudHJ5Q29tcG9uZW50RmFjdG9yaWVzID0gX2VudHJ5Q29tcG9uZW50RmFjdG9yaWVzO1xuICAgICAgICB0aGlzLl9ib290c3RyYXBDb21wb25lbnRGYWN0b3JpZXMgPSBfYm9vdHN0cmFwQ29tcG9uZW50RmFjdG9yaWVzO1xuICAgICAgICB0aGlzLl9zb3VyY2VTcGFuID0gX3NvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuZmllbGRzID0gW107XG4gICAgICAgIHRoaXMuZ2V0dGVycyA9IFtdO1xuICAgICAgICB0aGlzLm1ldGhvZHMgPSBbXTtcbiAgICAgICAgdGhpcy5jdG9yU3RtdHMgPSBbXTtcbiAgICAgICAgdGhpcy5fbGF6eVByb3BzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl90b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jcmVhdGVTdG10cyA9IFtdO1xuICAgICAgICB0aGlzLl9kZXN0cm95U3RtdHMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXNvbHZlZFByb3ZpZGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfSW5qZWN0b3JCdWlsZGVyLnByb3RvdHlwZS5hZGRQcm92aWRlciA9IGZ1bmN0aW9uIChyZXNvbHZlZFByb3ZpZGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucyA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIF90aGlzLl9nZXRQcm92aWRlclZhbHVlKHByb3ZpZGVyKTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3BOYW1lID0gXCJfXCIgKyB0b2tlbk5hbWUocmVzb2x2ZWRQcm92aWRlci50b2tlbikgKyBcIl9cIiArIHRoaXMuX2luc3RhbmNlcy5zaXplO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnN0YW5jZSA9IHRoaXMuX2NyZWF0ZVByb3ZpZGVyUHJvcGVydHkocHJvcE5hbWUsIHJlc29sdmVkUHJvdmlkZXIsIHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucywgcmVzb2x2ZWRQcm92aWRlci5tdWx0aVByb3ZpZGVyLCByZXNvbHZlZFByb3ZpZGVyLmVhZ2VyKTtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvdmlkZXIubGlmZWN5Y2xlSG9va3MuaW5kZXhPZijJtUxpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSkgIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYWxsTmdPbkRlc3Ryb3kgPSBpbnN0YW5jZS5jYWxsTWV0aG9kKCduZ09uRGVzdHJveScsIFtdKTtcbiAgICAgICAgICAgIGlmICghcmVzb2x2ZWRQcm92aWRlci5lYWdlcikge1xuICAgICAgICAgICAgICAgIGNhbGxOZ09uRGVzdHJveSA9ICgodGhpcy5fbGF6eVByb3BzLmdldChpbnN0YW5jZS5uYW1lKSkpLmFuZChjYWxsTmdPbkRlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVzdHJveVN0bXRzLnB1c2goY2FsbE5nT25EZXN0cm95LnRvU3RtdCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90b2tlbnMucHVzaChyZXNvbHZlZFByb3ZpZGVyLnRva2VuKTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2VzLnNldCh0b2tlblJlZmVyZW5jZShyZXNvbHZlZFByb3ZpZGVyLnRva2VuKSwgaW5zdGFuY2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfSW5qZWN0b3JCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZ2V0TWV0aG9kU3RtdHMgPSB0aGlzLl90b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvdmlkZXJFeHByID0gKChfdGhpcy5faW5zdGFuY2VzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElmU3RtdChJbmplY3RNZXRob2RWYXJzLnRva2VuLmlkZW50aWNhbChjcmVhdGVEaVRva2VuRXhwcmVzc2lvbih0b2tlbikpLCBbbmV3IFJldHVyblN0YXRlbWVudChwcm92aWRlckV4cHIpXSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXRob2RzID0gW1xuICAgICAgICAgICAgbmV3IENsYXNzTWV0aG9kKCdjcmVhdGVJbnRlcm5hbCcsIFtdLCB0aGlzLl9jcmVhdGVTdG10cy5jb25jYXQobmV3IFJldHVyblN0YXRlbWVudCgvKiogQHR5cGUgez99ICovICgodGhpcy5faW5zdGFuY2VzLmdldCh0aGlzLl9uZ01vZHVsZU1ldGEudHlwZS5yZWZlcmVuY2UpKSkpKSwgaW1wb3J0VHlwZSh0aGlzLl9uZ01vZHVsZU1ldGEudHlwZSkpLFxuICAgICAgICAgICAgbmV3IENsYXNzTWV0aG9kKCdnZXRJbnRlcm5hbCcsIFtcbiAgICAgICAgICAgICAgICBuZXcgRm5QYXJhbSgvKiogQHR5cGUgez99ICovICgoSW5qZWN0TWV0aG9kVmFycy50b2tlbi5uYW1lKSksIERZTkFNSUNfVFlQRSksXG4gICAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oLyoqIEB0eXBlIHs/fSAqLyAoKEluamVjdE1ldGhvZFZhcnMubm90Rm91bmRSZXN1bHQubmFtZSkpLCBEWU5BTUlDX1RZUEUpXG4gICAgICAgICAgICBdLCBnZXRNZXRob2RTdG10cy5jb25jYXQoW25ldyBSZXR1cm5TdGF0ZW1lbnQoSW5qZWN0TWV0aG9kVmFycy5ub3RGb3VuZFJlc3VsdCldKSwgRFlOQU1JQ19UWVBFKSxcbiAgICAgICAgICAgIG5ldyBDbGFzc01ldGhvZCgnZGVzdHJveUludGVybmFsJywgW10sIHRoaXMuX2Rlc3Ryb3lTdG10cyksXG4gICAgICAgIF07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudEFyZ3MgPSBbXG4gICAgICAgICAgICB2YXJpYWJsZShJbmplY3RvclByb3BzLnBhcmVudC5uYW1lKSxcbiAgICAgICAgICAgIGxpdGVyYWxBcnIodGhpcy5fZW50cnlDb21wb25lbnRGYWN0b3JpZXMubWFwKGZ1bmN0aW9uIChjb21wb25lbnRGYWN0b3J5KSB7IHJldHVybiBpbXBvcnRFeHByKGNvbXBvbmVudEZhY3RvcnkpOyB9KSksXG4gICAgICAgICAgICBsaXRlcmFsQXJyKHRoaXMuX2Jvb3RzdHJhcENvbXBvbmVudEZhY3Rvcmllcy5tYXAoZnVuY3Rpb24gKGNvbXBvbmVudEZhY3RvcnkpIHsgcmV0dXJuIGltcG9ydEV4cHIoY29tcG9uZW50RmFjdG9yeSk7IH0pKVxuICAgICAgICBdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmpDbGFzc05hbWUgPSBpZGVudGlmaWVyTmFtZSh0aGlzLl9uZ01vZHVsZU1ldGEudHlwZSkgKyBcIkluamVjdG9yXCI7XG4gICAgICAgIHJldHVybiBjcmVhdGVDbGFzc1N0bXQoe1xuICAgICAgICAgICAgbmFtZTogaW5qQ2xhc3NOYW1lLFxuICAgICAgICAgICAgY3RvclBhcmFtczogW25ldyBGblBhcmFtKEluamVjdG9yUHJvcHMucGFyZW50Lm5hbWUsIGltcG9ydFR5cGUoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5JbmplY3RvcikpKV0sXG4gICAgICAgICAgICBwYXJlbnQ6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5OZ01vZHVsZUluamVjdG9yKSwgWy8qKiBAdHlwZSB7P30gKi8gKChpbXBvcnRUeXBlKHRoaXMuX25nTW9kdWxlTWV0YS50eXBlKSkpXSksXG4gICAgICAgICAgICBwYXJlbnRBcmdzOiBwYXJlbnRBcmdzLFxuICAgICAgICAgICAgYnVpbGRlcnM6IFt7IG1ldGhvZHM6IG1ldGhvZHMgfSwgdGhpc11cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfSW5qZWN0b3JCdWlsZGVyLnByb3RvdHlwZS5fZ2V0UHJvdmlkZXJWYWx1ZSA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQ7XG4gICAgICAgIGlmIChwcm92aWRlci51c2VFeGlzdGluZyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXREZXBlbmRlbmN5KHsgdG9rZW46IHByb3ZpZGVyLnVzZUV4aXN0aW5nIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUZhY3RvcnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlRmFjdG9yeS5kaURlcHM7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBzRXhwciA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KGRlcCk7IH0pO1xuICAgICAgICAgICAgcmVzdWx0ID0gaW1wb3J0RXhwcihwcm92aWRlci51c2VGYWN0b3J5KS5jYWxsRm4oZGVwc0V4cHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUNsYXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcHMgPSBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUNsYXNzLmRpRGVwcztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcHNFeHByID0gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3koZGVwKTsgfSk7XG4gICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgIGltcG9ydEV4cHIocHJvdmlkZXIudXNlQ2xhc3MpLmluc3RhbnRpYXRlKGRlcHNFeHByLCBpbXBvcnRUeXBlKHByb3ZpZGVyLnVzZUNsYXNzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb252ZXJ0VmFsdWVUb091dHB1dEFzdChwcm92aWRlci51c2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnNcbiAgICAgKiBAcGFyYW0gez99IGlzTXVsdGlcbiAgICAgKiBAcGFyYW0gez99IGlzRWFnZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JbmplY3RvckJ1aWxkZXIucHJvdG90eXBlLl9jcmVhdGVQcm92aWRlclByb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BOYW1lLCBwcm92aWRlciwgcHJvdmlkZXJWYWx1ZUV4cHJlc3Npb25zLCBpc011bHRpLCBpc0VhZ2VyKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkUHJvdmlkZXJWYWx1ZUV4cHI7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGU7XG4gICAgICAgIGlmIChpc011bHRpKSB7XG4gICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByID0gbGl0ZXJhbEFycihwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgdHlwZSA9IG5ldyBBcnJheVR5cGUoRFlOQU1JQ19UWVBFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXJWYWx1ZUV4cHIgPSBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnNbMF07XG4gICAgICAgICAgICB0eXBlID0gKChwcm92aWRlclZhbHVlRXhwcmVzc2lvbnNbMF0udHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgdHlwZSA9IERZTkFNSUNfVFlQRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFYWdlcikge1xuICAgICAgICAgICAgdGhpcy5maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChwcm9wTmFtZSwgdHlwZSkpO1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlU3RtdHMucHVzaChUSElTX0VYUFIucHJvcChwcm9wTmFtZSkuc2V0KHJlc29sdmVkUHJvdmlkZXJWYWx1ZUV4cHIpLnRvU3RtdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGludGVybmFsRmllbGRQcm9wID0gVEhJU19FWFBSLnByb3AoXCJfXCIgKyBwcm9wTmFtZSk7XG4gICAgICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKGludGVybmFsRmllbGRQcm9wLm5hbWUsIHR5cGUpKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IEVxdWFscyBpcyBpbXBvcnRhbnQgZm9yIEpTIHNvIHRoYXQgaXQgYWxzbyBjaGVja3MgdGhlIHVuZGVmaW5lZCBjYXNlIVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZ2V0dGVyU3RtdHMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IElmU3RtdChpbnRlcm5hbEZpZWxkUHJvcC5pc0JsYW5rKCksIFtpbnRlcm5hbEZpZWxkUHJvcC5zZXQocmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwcikudG9TdG10KCldKSxcbiAgICAgICAgICAgICAgICBuZXcgUmV0dXJuU3RhdGVtZW50KGludGVybmFsRmllbGRQcm9wKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHRoaXMuZ2V0dGVycy5wdXNoKG5ldyBDbGFzc0dldHRlcihwcm9wTmFtZSwgZ2V0dGVyU3RtdHMsIHR5cGUpKTtcbiAgICAgICAgICAgIHRoaXMuX2xhenlQcm9wcy5zZXQocHJvcE5hbWUsIGludGVybmFsRmllbGRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVEhJU19FWFBSLnByb3AocHJvcE5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkZXBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JbmplY3RvckJ1aWxkZXIucHJvdG90eXBlLl9nZXREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSAoKG51bGwpKTtcbiAgICAgICAgaWYgKGRlcC5pc1ZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBsaXRlcmFsKGRlcC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXAuaXNTa2lwU2VsZikge1xuICAgICAgICAgICAgaWYgKGRlcC50b2tlbikge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pID09PSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5JbmplY3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gVEhJU19FWFBSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pID09PSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFRISVNfRVhQUi5wcm9wKCdjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICgodGhpcy5faW5zdGFuY2VzLmdldCh0b2tlblJlZmVyZW5jZSgvKiogQHR5cGUgez99ICovICgoZGVwLnRva2VuKSkpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gW2NyZWF0ZURpVG9rZW5FeHByZXNzaW9uKC8qKiBAdHlwZSB7P30gKi8gKChkZXAudG9rZW4pKSldO1xuICAgICAgICAgICAgaWYgKGRlcC5pc09wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKE5VTExfRVhQUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBJbmplY3RvclByb3BzLnBhcmVudC5jYWxsTWV0aG9kKCdnZXQnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIF9JbmplY3RvckJ1aWxkZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHRva2VuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVEaVRva2VuRXhwcmVzc2lvbih0b2tlbikge1xuICAgIGlmICh0b2tlbi52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsKHRva2VuLnZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBpbXBvcnRFeHByKC8qKiBAdHlwZSB7P30gKi8gKCh0b2tlbi5pZGVudGlmaWVyKSkpO1xuICAgIH1cbn1cbnZhciBJbmplY3RvclByb3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbmplY3RvclByb3BzKCkge1xuICAgIH1cbiAgICByZXR1cm4gSW5qZWN0b3JQcm9wcztcbn0oKSk7XG5JbmplY3RvclByb3BzLnBhcmVudCA9IFRISVNfRVhQUi5wcm9wKCdwYXJlbnQnKTtcbnZhciBJbmplY3RNZXRob2RWYXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbmplY3RNZXRob2RWYXJzKCkge1xuICAgIH1cbiAgICByZXR1cm4gSW5qZWN0TWV0aG9kVmFycztcbn0oKSk7XG5JbmplY3RNZXRob2RWYXJzLnRva2VuID0gdmFyaWFibGUoJ3Rva2VuJyk7XG5JbmplY3RNZXRob2RWYXJzLm5vdEZvdW5kUmVzdWx0ID0gdmFyaWFibGUoJ25vdEZvdW5kUmVzdWx0Jyk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLyBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXRcbnZhciBWRVJTSU9OJDEgPSAzO1xudmFyIEpTX0I2NF9QUkVGSVggPSAnIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJztcbnZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IGZpbGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoZmlsZSkge1xuICAgICAgICBpZiAoZmlsZSA9PT0gdm9pZCAwKSB7IGZpbGUgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgIHRoaXMuc291cmNlc0NvbnRlbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5sYXN0Q29sMCA9IDA7XG4gICAgICAgIHRoaXMuaGFzTWFwcGluZ3MgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZFNvdXJjZSA9IGZ1bmN0aW9uICh1cmwsIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT09IHZvaWQgMCkgeyBjb250ZW50ID0gbnVsbDsgfVxuICAgICAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQuaGFzKHVybCkpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlc0NvbnRlbnQuc2V0KHVybCwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5saW5lcy5wdXNoKFtdKTtcbiAgICAgICAgdGhpcy5sYXN0Q29sMCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb2wwXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlVXJsXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlTGluZTBcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VDb2wwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPSBmdW5jdGlvbiAoY29sMCwgc291cmNlVXJsLCBzb3VyY2VMaW5lMCwgc291cmNlQ29sMCkge1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudExpbmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgbGluZSBtdXN0IGJlIGFkZGVkIGJlZm9yZSBtYXBwaW5ncyBjYW4gYmUgYWRkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVVybCAhPSBudWxsICYmICF0aGlzLnNvdXJjZXNDb250ZW50Lmhhcyhzb3VyY2VVcmwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHNvdXJjZSBmaWxlIFxcXCJcIiArIHNvdXJjZVVybCArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sMCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29sdW1uIGluIHRoZSBnZW5lcmF0ZWQgY29kZSBtdXN0IGJlIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2wwIDwgdGhpcy5sYXN0Q29sMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFwcGluZyBzaG91bGQgYmUgYWRkZWQgaW4gb3V0cHV0IG9yZGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VVcmwgJiYgKHNvdXJjZUxpbmUwID09IG51bGwgfHwgc291cmNlQ29sMCA9PSBudWxsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNvdXJjZSBsb2NhdGlvbiBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gYSBzb3VyY2UgdXJsIGlzIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzTWFwcGluZ3MgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhc3RDb2wwID0gY29sMDtcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZS5wdXNoKHsgY29sMDogY29sMCwgc291cmNlVXJsOiBzb3VyY2VVcmwsIHNvdXJjZUxpbmUwOiBzb3VyY2VMaW5lMCwgc291cmNlQ29sMDogc291cmNlQ29sMCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZSwgXCJjdXJyZW50TGluZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmxpbmVzLnNsaWNlKC0xKVswXTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmhhc01hcHBpbmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VzSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlc0NvbnRlbnQgPSBbXTtcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnNvdXJjZXNDb250ZW50LmtleXMoKSkuZm9yRWFjaChmdW5jdGlvbiAodXJsLCBpKSB7XG4gICAgICAgICAgICBzb3VyY2VzSW5kZXguc2V0KHVybCwgaSk7XG4gICAgICAgICAgICBzb3VyY2VzLnB1c2godXJsKTtcbiAgICAgICAgICAgIHNvdXJjZXNDb250ZW50LnB1c2goX3RoaXMuc291cmNlc0NvbnRlbnQuZ2V0KHVybCkgfHwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXBwaW5ncyA9ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYXN0Q29sMCA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3RTb3VyY2VJbmRleCA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3RTb3VyY2VMaW5lMCA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3RTb3VyY2VDb2wwID0gMDtcbiAgICAgICAgdGhpcy5saW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50cykge1xuICAgICAgICAgICAgbGFzdENvbDAgPSAwO1xuICAgICAgICAgICAgbWFwcGluZ3MgKz0gc2VnbWVudHNcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gemVyby1iYXNlZCBzdGFydGluZyBjb2x1bW4gb2YgdGhlIGxpbmUgaW4gdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VnQXNTdHIgPSB0b0Jhc2U2NFZMUShzZWdtZW50LmNvbDAgLSBsYXN0Q29sMCk7XG4gICAgICAgICAgICAgICAgbGFzdENvbDAgPSBzZWdtZW50LmNvbDA7XG4gICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQuc291cmNlVXJsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gemVyby1iYXNlZCBpbmRleCBpbnRvIHRoZSDigJxzb3VyY2Vz4oCdIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgc2VnQXNTdHIgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQmFzZTY0VkxRKC8qKiBAdHlwZSB7P30gKi8gKChzb3VyY2VzSW5kZXguZ2V0KHNlZ21lbnQuc291cmNlVXJsKSkpIC0gbGFzdFNvdXJjZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFNvdXJjZUluZGV4ID0gKChzb3VyY2VzSW5kZXguZ2V0KHNlZ21lbnQuc291cmNlVXJsKSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgemVyby1iYXNlZCBzdGFydGluZyBsaW5lIGluIHRoZSBvcmlnaW5hbCBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgc2VnQXNTdHIgKz0gdG9CYXNlNjRWTFEoLyoqIEB0eXBlIHs/fSAqLyAoKHNlZ21lbnQuc291cmNlTGluZTApKSAtIGxhc3RTb3VyY2VMaW5lMCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTb3VyY2VMaW5lMCA9ICgoc2VnbWVudC5zb3VyY2VMaW5lMCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgemVyby1iYXNlZCBzdGFydGluZyBjb2x1bW4gaW4gdGhlIG9yaWdpbmFsIHNvdXJjZVxuICAgICAgICAgICAgICAgICAgICBzZWdBc1N0ciArPSB0b0Jhc2U2NFZMUSgvKiogQHR5cGUgez99ICovICgoc2VnbWVudC5zb3VyY2VDb2wwKSkgLSBsYXN0U291cmNlQ29sMCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTb3VyY2VDb2wwID0gKChzZWdtZW50LnNvdXJjZUNvbDApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlZ0FzU3RyO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignLCcpO1xuICAgICAgICAgICAgbWFwcGluZ3MgKz0gJzsnO1xuICAgICAgICB9KTtcbiAgICAgICAgbWFwcGluZ3MgPSBtYXBwaW5ncy5zbGljZSgwLCAtMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnZmlsZSc6IHRoaXMuZmlsZSB8fCAnJyxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogVkVSU0lPTiQxLFxuICAgICAgICAgICAgJ3NvdXJjZVJvb3QnOiAnJyxcbiAgICAgICAgICAgICdzb3VyY2VzJzogc291cmNlcyxcbiAgICAgICAgICAgICdzb3VyY2VzQ29udGVudCc6IHNvdXJjZXNDb250ZW50LFxuICAgICAgICAgICAgJ21hcHBpbmdzJzogbWFwcGluZ3MsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9Kc0NvbW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc01hcHBpbmdzID8gJy8vJyArIEpTX0I2NF9QUkVGSVggKyB0b0Jhc2U2NFN0cmluZyhKU09OLnN0cmluZ2lmeSh0aGlzLCBudWxsLCAwKSkgOlxuICAgICAgICAgICAgJyc7XG4gICAgfTtcbiAgICByZXR1cm4gU291cmNlTWFwR2VuZXJhdG9yO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdG9CYXNlNjRTdHJpbmcodmFsdWUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiNjQgPSAnJztcbiAgICB2YWx1ZSA9IHV0ZjhFbmNvZGUodmFsdWUpO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxID0gdmFsdWUuY2hhckNvZGVBdChpKyspO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpMiA9IHZhbHVlLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTMgPSB2YWx1ZS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGI2NCArPSB0b0Jhc2U2NERpZ2l0KGkxID4+IDIpO1xuICAgICAgICBiNjQgKz0gdG9CYXNlNjREaWdpdCgoKGkxICYgMykgPDwgNCkgfCAoaXNOYU4oaTIpID8gMCA6IGkyID4+IDQpKTtcbiAgICAgICAgYjY0ICs9IGlzTmFOKGkyKSA/ICc9JyA6IHRvQmFzZTY0RGlnaXQoKChpMiAmIDE1KSA8PCAyKSB8IChpMyA+PiA2KSk7XG4gICAgICAgIGI2NCArPSBpc05hTihpMikgfHwgaXNOYU4oaTMpID8gJz0nIDogdG9CYXNlNjREaWdpdChpMyAmIDYzKTtcbiAgICB9XG4gICAgcmV0dXJuIGI2NDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdG9CYXNlNjRWTFEodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHZhbHVlIDwgMCA/ICgoLXZhbHVlKSA8PCAxKSArIDEgOiB2YWx1ZSA8PCAxO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dCA9ICcnO1xuICAgIGRvIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlnaXQgPSB2YWx1ZSAmIDMxO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDU7XG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgIGRpZ2l0ID0gZGlnaXQgfCAzMjtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gdG9CYXNlNjREaWdpdChkaWdpdCk7XG4gICAgfSB3aGlsZSAodmFsdWUgPiAwKTtcbiAgICByZXR1cm4gb3V0O1xufVxudmFyIEI2NF9ESUdJVFMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRvQmFzZTY0RGlnaXQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDY0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBvbmx5IGVuY29kZSB2YWx1ZSBpbiB0aGUgcmFuZ2UgWzAsIDYzXVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIEI2NF9ESUdJVFNbdmFsdWVdO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9TSU5HTEVfUVVPVEVfRVNDQVBFX1NUUklOR19SRSA9IC8nfFxcXFx8XFxufFxccnxcXCQvZztcbnZhciBfTEVHQUxfSURFTlRJRklFUl9SRSA9IC9eWyRBLVpfXVswLTlBLVpfJF0qJC9pO1xudmFyIF9JTkRFTlRfV0lUSCA9ICcgICc7XG52YXIgQ0FUQ0hfRVJST1JfVkFSJDEgPSB2YXJpYWJsZSgnZXJyb3InLCBudWxsLCBudWxsKTtcbnZhciBDQVRDSF9TVEFDS19WQVIkMSA9IHZhcmlhYmxlKCdzdGFjaycsIG51bGwsIG51bGwpO1xuLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIF9FbWl0dGVkTGluZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbmRlbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfRW1pdHRlZExpbmUoaW5kZW50KSB7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gaW5kZW50O1xuICAgICAgICB0aGlzLnBhcnRzID0gW107XG4gICAgICAgIHRoaXMuc3JjU3BhbnMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIF9FbWl0dGVkTGluZTtcbn0oKSk7XG52YXIgRW1pdHRlclZpc2l0b3JDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9leHBvcnRlZFZhcnNcbiAgICAgKiBAcGFyYW0gez99IF9pbmRlbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbWl0dGVyVmlzaXRvckNvbnRleHQoX2V4cG9ydGVkVmFycywgX2luZGVudCkge1xuICAgICAgICB0aGlzLl9leHBvcnRlZFZhcnMgPSBfZXhwb3J0ZWRWYXJzO1xuICAgICAgICB0aGlzLl9pbmRlbnQgPSBfaW5kZW50O1xuICAgICAgICB0aGlzLl9jbGFzc2VzID0gW107XG4gICAgICAgIHRoaXMuX2xpbmVzID0gW25ldyBfRW1pdHRlZExpbmUoX2luZGVudCldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cG9ydGVkVmFyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LmNyZWF0ZVJvb3QgPSBmdW5jdGlvbiAoZXhwb3J0ZWRWYXJzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1pdHRlclZpc2l0b3JDb250ZXh0KGV4cG9ydGVkVmFycywgMCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZSwgXCJfY3VycmVudExpbmVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbGluZXNbdGhpcy5fbGluZXMubGVuZ3RoIC0gMV07IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFyTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5pc0V4cG9ydGVkVmFyID0gZnVuY3Rpb24gKHZhck5hbWUpIHsgcmV0dXJuIHRoaXMuX2V4cG9ydGVkVmFycy5pbmRleE9mKHZhck5hbWUpICE9PSAtMTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBmcm9tXG4gICAgICogQHBhcmFtIHs/PX0gbGFzdFBhcnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucHJpbnRsbiA9IGZ1bmN0aW9uIChmcm9tLCBsYXN0UGFydCkge1xuICAgICAgICBpZiAobGFzdFBhcnQgPT09IHZvaWQgMCkgeyBsYXN0UGFydCA9ICcnOyB9XG4gICAgICAgIHRoaXMucHJpbnQoZnJvbSB8fCBudWxsLCBsYXN0UGFydCwgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUubGluZUlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jdXJyZW50TGluZS5wYXJ0cy5sZW5ndGggPT09IDA7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmcm9tXG4gICAgICogQHBhcmFtIHs/fSBwYXJ0XG4gICAgICogQHBhcmFtIHs/PX0gbmV3TGluZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIChmcm9tLCBwYXJ0LCBuZXdMaW5lKSB7XG4gICAgICAgIGlmIChuZXdMaW5lID09PSB2b2lkIDApIHsgbmV3TGluZSA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLnBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5zcmNTcGFucy5wdXNoKGZyb20gJiYgZnJvbS5zb3VyY2VTcGFuIHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lcy5wdXNoKG5ldyBfRW1pdHRlZExpbmUodGhpcy5faW5kZW50KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5yZW1vdmVFbXB0eUxhc3RMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5saW5lSXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLmluY0luZGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faW5kZW50Kys7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLmluZGVudCA9IHRoaXMuX2luZGVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5kZWNJbmRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2luZGVudC0tO1xuICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5pbmRlbnQgPSB0aGlzLl9pbmRlbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNsYXp6XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnB1c2hDbGFzcyA9IGZ1bmN0aW9uIChjbGF6eikgeyB0aGlzLl9jbGFzc2VzLnB1c2goY2xhenopOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5wb3BDbGFzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICgodGhpcy5fY2xhc3Nlcy5wb3AoKSkpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLCBcImN1cnJlbnRDbGFzc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xhc3Nlcy5sZW5ndGggPiAwID8gdGhpcy5fY2xhc3Nlc1t0aGlzLl9jbGFzc2VzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnRvU291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VMaW5lc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobCkgeyByZXR1cm4gbC5wYXJ0cy5sZW5ndGggPiAwID8gX2NyZWF0ZUluZGVudChsLmluZGVudCkgKyBsLnBhcnRzLmpvaW4oJycpIDogJyc7IH0pXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZUZpbGVQYXRoXG4gICAgICogQHBhcmFtIHs/fSBnZW5GaWxlUGF0aFxuICAgICAqIEBwYXJhbSB7Pz19IHN0YXJ0c0F0TGluZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS50b1NvdXJjZU1hcEdlbmVyYXRvciA9IGZ1bmN0aW9uIChzb3VyY2VGaWxlUGF0aCwgZ2VuRmlsZVBhdGgsIHN0YXJ0c0F0TGluZSkge1xuICAgICAgICBpZiAoc3RhcnRzQXRMaW5lID09PSB2b2lkIDApIHsgc3RhcnRzQXRMaW5lID0gMDsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGdlbkZpbGVQYXRoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlyc3RPZmZzZXRNYXBwZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWFwRmlyc3RPZmZzZXRJZk5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghZmlyc3RPZmZzZXRNYXBwZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBzaW5nbGUgc3BhY2Ugc28gdGhhdCB0b29scyB3b24ndCB0cnkgdG8gbG9hZCB0aGUgZmlsZSBmcm9tIGRpc2suXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogV2UgYXJlIHVzaW5nIHZpcnR1YWwgdXJscyBsaWtlIGBuZzovLy9gLCBzbyB3ZSBoYXZlIHRvXG4gICAgICAgICAgICAgICAgLy8gcHJvdmlkZSBhIGNvbnRlbnQgaGVyZS5cbiAgICAgICAgICAgICAgICBtYXAuYWRkU291cmNlKHNvdXJjZUZpbGVQYXRoLCAnICcpLmFkZE1hcHBpbmcoMCwgc291cmNlRmlsZVBhdGgsIDAsIDApO1xuICAgICAgICAgICAgICAgIGZpcnN0T2Zmc2V0TWFwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHN0YXJ0c0F0TGluZTsgaSsrKSB7XG4gICAgICAgICAgICBtYXAuYWRkTGluZSgpO1xuICAgICAgICAgICAgbWFwRmlyc3RPZmZzZXRJZk5lZWRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc291cmNlTGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSwgbGluZUlkeCkge1xuICAgICAgICAgICAgbWFwLmFkZExpbmUoKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNwYW5zID0gbGluZS5zcmNTcGFucztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRzID0gbGluZS5wYXJ0cztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbDAgPSBsaW5lLmluZGVudCAqIF9JTkRFTlRfV0lUSC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcGFuSWR4ID0gMDtcbiAgICAgICAgICAgIC8vIHNraXAgbGVhZGluZyBwYXJ0cyB3aXRob3V0IHNvdXJjZSBzcGFuc1xuICAgICAgICAgICAgd2hpbGUgKHNwYW5JZHggPCBzcGFucy5sZW5ndGggJiYgIXNwYW5zW3NwYW5JZHhdKSB7XG4gICAgICAgICAgICAgICAgY29sMCArPSBwYXJ0c1tzcGFuSWR4XS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgc3BhbklkeCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNwYW5JZHggPCBzcGFucy5sZW5ndGggJiYgbGluZUlkeCA9PT0gMCAmJiBjb2wwID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RPZmZzZXRNYXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwRmlyc3RPZmZzZXRJZk5lZWRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHNwYW5JZHggPCBzcGFucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcGFuID0gKChzcGFuc1tzcGFuSWR4XSkpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZSA9IHNwYW4uc3RhcnQuZmlsZTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VMaW5lID0gc3Bhbi5zdGFydC5saW5lO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZUNvbCA9IHNwYW4uc3RhcnQuY29sO1xuICAgICAgICAgICAgICAgIG1hcC5hZGRTb3VyY2Uoc291cmNlLnVybCwgc291cmNlLmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRNYXBwaW5nKGNvbDAsIHNvdXJjZS51cmwsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbCk7XG4gICAgICAgICAgICAgICAgY29sMCArPSBwYXJ0c1tzcGFuSWR4XS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgc3BhbklkeCsrO1xuICAgICAgICAgICAgICAgIC8vIGFzc2lnbiBwYXJ0cyB3aXRob3V0IHNwYW4gb3IgdGhlIHNhbWUgc3BhbiB0byB0aGUgcHJldmlvdXMgc2VnbWVudFxuICAgICAgICAgICAgICAgIHdoaWxlIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoICYmIChzcGFuID09PSBzcGFuc1tzcGFuSWR4XSB8fCAhc3BhbnNbc3BhbklkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbDAgKz0gcGFydHNbc3BhbklkeF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBzcGFuSWR4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLCBcInNvdXJjZUxpbmVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9saW5lcy5sZW5ndGggJiYgdGhpcy5fbGluZXNbdGhpcy5fbGluZXMubGVuZ3RoIC0gMV0ucGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEVtaXR0ZXJWaXNpdG9yQ29udGV4dDtcbn0oKSk7XG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQWJzdHJhY3RFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZXNjYXBlRG9sbGFySW5TdHJpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQWJzdHJhY3RFbWl0dGVyVmlzaXRvcihfZXNjYXBlRG9sbGFySW5TdHJpbmdzKSB7XG4gICAgICAgIHRoaXMuX2VzY2FwZURvbGxhckluU3RyaW5ncyA9IF9lc2NhcGVEb2xsYXJJblN0cmluZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBzdG10LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsICc7Jyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmV0dXJuU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwicmV0dXJuIFwiKTtcbiAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgJzsnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdElmU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiaWYgKFwiKTtcbiAgICAgICAgc3RtdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcIikge1wiKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFzRWxzZUNhc2UgPSBzdG10LmZhbHNlQ2FzZSAhPSBudWxsICYmIHN0bXQuZmFsc2VDYXNlLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmIChzdG10LnRydWVDYXNlLmxlbmd0aCA8PSAxICYmICFoYXNFbHNlQ2FzZSkge1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiIFwiKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGN0eCk7XG4gICAgICAgICAgICBjdHgucmVtb3ZlRW1wdHlMYXN0TGluZSgpO1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludGxuKCk7XG4gICAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjdHgpO1xuICAgICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgICAgaWYgKGhhc0Vsc2VDYXNlKSB7XG4gICAgICAgICAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9IGVsc2Uge1wiKTtcbiAgICAgICAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5mYWxzZUNhc2UsIGN0eCk7XG4gICAgICAgICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGhyb3dTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJ0aHJvdyBcIik7XG4gICAgICAgIHN0bXQuZXJyb3IudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiO1wiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGluZXMgPSBzdG10LmNvbW1lbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7IGN0eC5wcmludGxuKHN0bXQsIFwiLy8gXCIgKyBsaW5lKTsgfSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVWYXJFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaW5lV2FzRW1wdHkgPSBjdHgubGluZUlzRW1wdHkoKTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKCcpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChleHByLCBleHByLm5hbWUgKyBcIiA9IFwiKTtcbiAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVLZXlFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaW5lV2FzRW1wdHkgPSBjdHgubGluZUlzRW1wdHkoKTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKCcpO1xuICAgICAgICB9XG4gICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChleHByLCBcIltcIik7XG4gICAgICAgIGV4cHIuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChleHByLCBcIl0gPSBcIik7XG4gICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgJyknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyaXRlUHJvcEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpbmVXYXNFbXB0eSA9IGN0eC5saW5lSXNFbXB0eSgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcoJyk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiLlwiICsgZXhwci5uYW1lICsgXCIgPSBcIik7XG4gICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgJyknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBleHByLm5hbWU7XG4gICAgICAgIGlmIChleHByLmJ1aWx0aW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMuZ2V0QnVpbHRpbk1ldGhvZE5hbWUoZXhwci5idWlsdGluKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBzb21lIGJ1aWx0aW5zIGp1c3QgbWVhbiB0byBza2lwIHRoZSBjYWxsLlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChleHByLCBcIi5cIiArIG5hbWUgKyBcIihcIik7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCwgXCIsXCIpO1xuICAgICAgICBjdHgucHJpbnQoZXhwciwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gbWV0aG9kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5nZXRCdWlsdGluTWV0aG9kTmFtZSA9IGZ1bmN0aW9uIChtZXRob2QpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIGV4cHIuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChleHByLCBcIihcIik7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCwgJywnKTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhck5hbWUgPSAoKGFzdC5uYW1lKSk7XG4gICAgICAgIGlmIChhc3QuYnVpbHRpbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGFzdC5idWlsdGluKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVmFyLlN1cGVyOlxuICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gJ3N1cGVyJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVmFyLlRoaXM6XG4gICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSAndGhpcyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaEVycm9yOlxuICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gKChDQVRDSF9FUlJPUl9WQVIkMS5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaFN0YWNrOlxuICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gKChDQVRDSF9TVEFDS19WQVIkMS5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiB2YXJpYWJsZSBcIiArIGFzdC5idWlsdGluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoYXN0LCB2YXJOYW1lKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEluc3RhbnRpYXRlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIm5ldyBcIik7XG4gICAgICAgIGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKFwiKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjdHgsICcsJyk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gYXN0LnZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgZXNjYXBlSWRlbnRpZmllcih2YWx1ZSwgdGhpcy5fZXNjYXBlRG9sbGFySW5TdHJpbmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIihcIik7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICc/ICcpO1xuICAgICAgICBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICc6ICcpOyAvKiogQHR5cGUgez99ICovXG4gICAgICAgICgoYXN0LmZhbHNlQ2FzZSkpLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIilcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXROb3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsICchJyk7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3BTdHI7XG4gICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkVxdWFsczpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc9PSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbDpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc9PT0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnIT0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWw6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnIT09JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQW5kOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJyYmJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuT3I6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnfHwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5QbHVzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJysnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NaW51czpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICctJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRGl2aWRlOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJy8nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NdWx0aXBseTpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICcqJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTW9kdWxvOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJyUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlcjpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc8JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnPD0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5CaWdnZXI6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnPic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFsczpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc+PSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3IgXCIgKyBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKFwiKTtcbiAgICAgICAgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIgXCIgKyBvcFN0ciArIFwiIFwiKTtcbiAgICAgICAgYXN0LnJocy52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFByb3BFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIuXCIpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBhc3QubmFtZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkS2V5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiW1wiKTtcbiAgICAgICAgYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIl1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVzZU5ld0xpbmUgPSBhc3QuZW50cmllcy5sZW5ndGggPiAxO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIltcIiwgdXNlTmV3TGluZSk7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjdHgsICcsJywgdXNlTmV3TGluZSk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCJdXCIsIHVzZU5ld0xpbmUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXNlTmV3TGluZSA9IGFzdC5lbnRyaWVzLmxlbmd0aCA+IDE7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwie1wiLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIGVzY2FwZUlkZW50aWZpZXIoZW50cnkua2V5LCBfdGhpcy5fZXNjYXBlRG9sbGFySW5TdHJpbmdzLCBlbnRyeS5xdW90ZWQpICsgXCI6IFwiKTtcbiAgICAgICAgICAgIGVudHJ5LnZhbHVlLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY3R4KTtcbiAgICAgICAgfSwgYXN0LmVudHJpZXMsIGN0eCwgJywnLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIn1cIiwgdXNlTmV3TGluZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tYUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJygnKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5wYXJ0cywgY3R4LCAnLCcpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCAnKScpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvbnNcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEBwYXJhbSB7P30gc2VwYXJhdG9yXG4gICAgICogQHBhcmFtIHs/PX0gbmV3TGluZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IsIG5ld0xpbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG5ld0xpbmUgPT09IHZvaWQgMCkgeyBuZXdMaW5lID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9LCBleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IsIG5ld0xpbmUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25zXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcGFyYW0gez99IHNlcGFyYXRvclxuICAgICAqIEBwYXJhbSB7Pz19IG5ld0xpbmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxsT2JqZWN0cyA9IGZ1bmN0aW9uIChoYW5kbGVyLCBleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IsIG5ld0xpbmUpIHtcbiAgICAgICAgaWYgKG5ld0xpbmUgPT09IHZvaWQgMCkgeyBuZXdMaW5lID0gZmFsc2U7IH1cbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgc2VwYXJhdG9yLCBuZXdMaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZXIoZXhwcmVzc2lvbnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdMaW5lKSB7XG4gICAgICAgICAgICBjdHgucHJpbnRsbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHN0YXRlbWVudHMsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzdGF0ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIHN0bXQudmlzaXRTdGF0ZW1lbnQoX3RoaXMsIGN0eCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0RW1pdHRlclZpc2l0b3I7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcGFyYW0gez99IGVzY2FwZURvbGxhclxuICogQHBhcmFtIHs/PX0gYWx3YXlzUXVvdGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUlkZW50aWZpZXIoaW5wdXQsIGVzY2FwZURvbGxhciwgYWx3YXlzUXVvdGUpIHtcbiAgICBpZiAoYWx3YXlzUXVvdGUgPT09IHZvaWQgMCkgeyBhbHdheXNRdW90ZSA9IHRydWU7IH1cbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm9keSA9IGlucHV0LnJlcGxhY2UoX1NJTkdMRV9RVU9URV9FU0NBUEVfU1RSSU5HX1JFLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbWF0Y2hbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hbMF0gPT0gJyQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlRG9sbGFyID8gJ1xcXFwkJyA6ICckJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXRjaFswXSA9PSAnXFxuJykge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWF0Y2hbMF0gPT0gJ1xccicpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHInO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXFwiICsgbWF0Y2hbMF07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXF1aXJlc1F1b3RlcyA9IGFsd2F5c1F1b3RlIHx8ICFfTEVHQUxfSURFTlRJRklFUl9SRS50ZXN0KGJvZHkpO1xuICAgIHJldHVybiByZXF1aXJlc1F1b3RlcyA/IFwiJ1wiICsgYm9keSArIFwiJ1wiIDogYm9keTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb3VudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZUluZGVudChjb3VudCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcyA9ICcnO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHJlcyArPSBfSU5ERU5UX1dJVEg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX2RlYnVnRmlsZVBhdGggPSAnL2RlYnVnL2xpYic7XG4vKipcbiAqIEBwYXJhbSB7P30gYXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkZWJ1Z091dHB1dEFzdEFzVHlwZVNjcmlwdChhc3QpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb252ZXJ0ZXIgPSBuZXcgX1RzRW1pdHRlclZpc2l0b3IoX2RlYnVnRmlsZVBhdGgsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZmlsZVBhdGhcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250YWluaW5nRmlsZVBhdGhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZpbGVOYW1lVG9Nb2R1bGVOYW1lOiBmdW5jdGlvbiAoZmlsZVBhdGgsIGNvbnRhaW5pbmdGaWxlUGF0aCkgeyByZXR1cm4gZmlsZVBhdGg7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHN5bWJvbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SW1wb3J0QXM6IGZ1bmN0aW9uIChzeW1ib2wpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIGdldFR5cGVBcml0eTogZnVuY3Rpb24gKHN5bWJvbCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIH0pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0eCA9IEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290KFtdKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3RzID0gQXJyYXkuaXNBcnJheShhc3QpID8gYXN0IDogW2FzdF07XG4gICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgaWYgKGFzdCBpbnN0YW5jZW9mIFN0YXRlbWVudCkge1xuICAgICAgICAgICAgYXN0LnZpc2l0U3RhdGVtZW50KGNvbnZlcnRlciwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3QgaW5zdGFuY2VvZiBFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBhc3QudmlzaXRFeHByZXNzaW9uKGNvbnZlcnRlciwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3QgaW5zdGFuY2VvZiBUeXBlJDEpIHtcbiAgICAgICAgICAgIGFzdC52aXNpdFR5cGUoY29udmVydGVyLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG9uJ3Qga25vdyBob3cgdG8gcHJpbnQgZGVidWcgaW5mbyBmb3IgXCIgKyBhc3QpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGN0eC50b1NvdXJjZSgpO1xufVxudmFyIFR5cGVTY3JpcHRFbWl0dGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9pbXBvcnRSZXNvbHZlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFR5cGVTY3JpcHRFbWl0dGVyKF9pbXBvcnRSZXNvbHZlcikge1xuICAgICAgICB0aGlzLl9pbXBvcnRSZXNvbHZlciA9IF9pbXBvcnRSZXNvbHZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcmNGaWxlUGF0aFxuICAgICAqIEBwYXJhbSB7P30gZ2VuRmlsZVBhdGhcbiAgICAgKiBAcGFyYW0gez99IHN0bXRzXG4gICAgICogQHBhcmFtIHs/fSBleHBvcnRlZFZhcnNcbiAgICAgKiBAcGFyYW0gez89fSBwcmVhbWJsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHlwZVNjcmlwdEVtaXR0ZXIucHJvdG90eXBlLmVtaXRTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHNyY0ZpbGVQYXRoLCBnZW5GaWxlUGF0aCwgc3RtdHMsIGV4cG9ydGVkVmFycywgcHJlYW1ibGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHByZWFtYmxlID09PSB2b2lkIDApIHsgcHJlYW1ibGUgPSAnJzsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb252ZXJ0ZXIgPSBuZXcgX1RzRW1pdHRlclZpc2l0b3IoZ2VuRmlsZVBhdGgsIHRoaXMuX2ltcG9ydFJlc29sdmVyKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R4ID0gRW1pdHRlclZpc2l0b3JDb250ZXh0LmNyZWF0ZVJvb3QoZXhwb3J0ZWRWYXJzKTtcbiAgICAgICAgY29udmVydGVyLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10cywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlYW1ibGVMaW5lcyA9IHByZWFtYmxlID8gcHJlYW1ibGUuc3BsaXQoJ1xcbicpIDogW107XG4gICAgICAgIGNvbnZlcnRlci5yZWV4cG9ydHMuZm9yRWFjaChmdW5jdGlvbiAocmVleHBvcnRzLCBleHBvcnRlZEZpbGVQYXRoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWV4cG9ydHNDb2RlID0gcmVleHBvcnRzLm1hcChmdW5jdGlvbiAocmVleHBvcnQpIHsgcmV0dXJuIHJlZXhwb3J0Lm5hbWUgKyBcIiBhcyBcIiArIHJlZXhwb3J0LmFzOyB9KS5qb2luKCcsJyk7XG4gICAgICAgICAgICBwcmVhbWJsZUxpbmVzLnB1c2goXCJleHBvcnQge1wiICsgcmVleHBvcnRzQ29kZSArIFwifSBmcm9tICdcIiArIF90aGlzLl9pbXBvcnRSZXNvbHZlci5maWxlTmFtZVRvTW9kdWxlTmFtZShleHBvcnRlZEZpbGVQYXRoLCBnZW5GaWxlUGF0aCkgKyBcIic7XCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29udmVydGVyLmltcG9ydHNXaXRoUHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4LCBpbXBvcnRlZEZpbGVQYXRoKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBjYW4ndCB3cml0ZSB0aGUgcmVhbCB3b3JkIGZvciBpbXBvcnQgYXMgaXQgc2NyZXdzIHVwIHN5c3RlbS5qcyBhdXRvIGRldGVjdGlvbi4uLlxuICAgICAgICAgICAgcHJlYW1ibGVMaW5lcy5wdXNoKFwiaW1wXCIgK1xuICAgICAgICAgICAgICAgIChcIm9ydCAqIGFzIFwiICsgcHJlZml4ICsgXCIgZnJvbSAnXCIgKyBfdGhpcy5faW1wb3J0UmVzb2x2ZXIuZmlsZU5hbWVUb01vZHVsZU5hbWUoaW1wb3J0ZWRGaWxlUGF0aCwgZ2VuRmlsZVBhdGgpICsgXCInO1wiKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzbSA9IGN0eC50b1NvdXJjZU1hcEdlbmVyYXRvcihzcmNGaWxlUGF0aCwgZ2VuRmlsZVBhdGgsIHByZWFtYmxlTGluZXMubGVuZ3RoKS50b0pzQ29tbWVudCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaW5lcyA9IHByZWFtYmxlTGluZXMuY29uY2F0KFtjdHgudG9Tb3VyY2UoKSwgc21dKTtcbiAgICAgICAgaWYgKHNtKSB7XG4gICAgICAgICAgICAvLyBhbHdheXMgYWRkIGEgbmV3bGluZSBhdCB0aGUgZW5kLCBhcyBzb21lIHRvb2xzIGhhdmUgYnVncyB3aXRob3V0IGl0LlxuICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgIH07XG4gICAgcmV0dXJuIFR5cGVTY3JpcHRFbWl0dGVyO1xufSgpKTtcbnZhciBfVHNFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9Uc0VtaXR0ZXJWaXNpdG9yLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2dlbkZpbGVQYXRoXG4gICAgICogQHBhcmFtIHs/fSBfaW1wb3J0UmVzb2x2ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfVHNFbWl0dGVyVmlzaXRvcihfZ2VuRmlsZVBhdGgsIF9pbXBvcnRSZXNvbHZlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBmYWxzZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2dlbkZpbGVQYXRoID0gX2dlbkZpbGVQYXRoO1xuICAgICAgICBfdGhpcy5faW1wb3J0UmVzb2x2ZXIgPSBfaW1wb3J0UmVzb2x2ZXI7XG4gICAgICAgIF90aGlzLnR5cGVFeHByZXNzaW9uID0gMDtcbiAgICAgICAgX3RoaXMuaW1wb3J0c1dpdGhQcmVmaXhlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgX3RoaXMucmVleHBvcnRzID0gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHBhcmFtIHs/PX0gZGVmYXVsdFR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodCwgY3R4LCBkZWZhdWx0VHlwZSkge1xuICAgICAgICBpZiAoZGVmYXVsdFR5cGUgPT09IHZvaWQgMCkgeyBkZWZhdWx0VHlwZSA9ICdhbnknOyB9XG4gICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICB0aGlzLnR5cGVFeHByZXNzaW9uKys7XG4gICAgICAgICAgICB0LnZpc2l0VHlwZSh0aGlzLCBjdHgpO1xuICAgICAgICAgICAgdGhpcy50eXBlRXhwcmVzc2lvbi0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnByaW50KG51bGwsIGRlZmF1bHRUeXBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBhc3QudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIGFzdC50eXBlICE9IElORkVSUkVEX1RZUEUpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIFwiKFwiICsgdmFsdWUgKyBcIiBhcyBhbnkpXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwci5jYWxsKHRoaXMsIGFzdCwgY3R4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgaWYgKGFzdC5lbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgJygnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwci5jYWxsKHRoaXMsIGFzdCwgY3R4KTtcbiAgICAgICAgaWYgKGFzdC5lbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgJyBhcyBhbnlbXSknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHRoaXMuX3Zpc2l0SWRlbnRpZmllcihhc3QudmFsdWUsIGFzdC50eXBlUGFyYW1zLCBjdHgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlVmFyU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgaWYgKGN0eC5pc0V4cG9ydGVkVmFyKHN0bXQubmFtZSkgJiYgc3RtdC52YWx1ZSBpbnN0YW5jZW9mIEV4dGVybmFsRXhwciAmJiAhc3RtdC50eXBlKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgYSByZWV4cG9ydFxuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5fcmVzb2x2ZVN0YXRpY1N5bWJvbChzdG10LnZhbHVlLnZhbHVlKSwgbmFtZSA9IF9hLm5hbWUsIGZpbGVQYXRoID0gX2EuZmlsZVBhdGgsIG1lbWJlcnMgPSBfYS5tZW1iZXJzO1xuICAgICAgICAgICAgaWYgKCgobWVtYmVycykpLmxlbmd0aCA9PT0gMCAmJiBmaWxlUGF0aCAhPT0gdGhpcy5fZ2VuRmlsZVBhdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWV4cG9ydHMgPSB0aGlzLnJlZXhwb3J0cy5nZXQoZmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICghcmVleHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZXhwb3J0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZXhwb3J0cy5zZXQoZmlsZVBhdGgsIHJlZXhwb3J0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlZXhwb3J0cy5wdXNoKHsgbmFtZTogbmFtZSwgYXM6IHN0bXQubmFtZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmlzRXhwb3J0ZWRWYXIoc3RtdC5uYW1lKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiZXhwb3J0IFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuRmluYWwpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJjb25zdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCBcInZhclwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCIgXCIgKyBzdG10Lm5hbWUpO1xuICAgICAgICB0aGlzLl9wcmludENvbG9uVHlwZShzdG10LnR5cGUsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcIiA9IFwiKTtcbiAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCI7XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKDxcIik7IC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgKChhc3QudHlwZSkpLnZpc2l0VHlwZSh0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIj5cIik7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEluc3RhbnRpYXRlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIm5ldyBcIik7XG4gICAgICAgIHRoaXMudHlwZUV4cHJlc3Npb24rKztcbiAgICAgICAgYXN0LmNsYXNzRXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdGhpcy50eXBlRXhwcmVzc2lvbi0tO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIihcIik7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY3R4LCAnLCcpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIilcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGN0eC5wdXNoQ2xhc3Moc3RtdCk7XG4gICAgICAgIGlmIChjdHguaXNFeHBvcnRlZFZhcihzdG10Lm5hbWUpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJleHBvcnQgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcImNsYXNzIFwiICsgc3RtdC5uYW1lKTtcbiAgICAgICAgaWYgKHN0bXQucGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCBcIiBleHRlbmRzIFwiKTtcbiAgICAgICAgICAgIHRoaXMudHlwZUV4cHJlc3Npb24rKztcbiAgICAgICAgICAgIHN0bXQucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgdGhpcy50eXBlRXhwcmVzc2lvbi0tO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgc3RtdC5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHsgcmV0dXJuIF90aGlzLl92aXNpdENsYXNzRmllbGQoZmllbGQsIGN0eCk7IH0pO1xuICAgICAgICBpZiAoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl92aXNpdENsYXNzQ29uc3RydWN0b3Ioc3RtdCwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBzdG10LmdldHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZ2V0dGVyKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc0dldHRlcihnZXR0ZXIsIGN0eCk7IH0pO1xuICAgICAgICBzdG10Lm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc01ldGhvZChtZXRob2QsIGN0eCk7IH0pO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifVwiKTtcbiAgICAgICAgY3R4LnBvcENsYXNzKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmaWVsZFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NGaWVsZCA9IGZ1bmN0aW9uIChmaWVsZCwgY3R4KSB7XG4gICAgICAgIGlmIChmaWVsZC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuUHJpdmF0ZSkpIHtcbiAgICAgICAgICAgIC8vIGNvbW1lbnQgb3V0IGFzIGEgd29ya2Fyb3VuZCBmb3IgIzEwOTY3XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgXCIvKnByaXZhdGUqLyBcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KG51bGwsIGZpZWxkLm5hbWUpO1xuICAgICAgICB0aGlzLl9wcmludENvbG9uVHlwZShmaWVsZC50eXBlLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihudWxsLCBcIjtcIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGdldHRlclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NHZXR0ZXIgPSBmdW5jdGlvbiAoZ2V0dGVyLCBjdHgpIHtcbiAgICAgICAgaWYgKGdldHRlci5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuUHJpdmF0ZSkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBcInByaXZhdGUgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChudWxsLCBcImdldCBcIiArIGdldHRlci5uYW1lICsgXCIoKVwiKTtcbiAgICAgICAgdGhpcy5fcHJpbnRDb2xvblR5cGUoZ2V0dGVyLnR5cGUsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKG51bGwsIFwiIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoZ2V0dGVyLmJvZHksIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4obnVsbCwgXCJ9XCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJjb25zdHJ1Y3RvcihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRob2RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZCwgY3R4KSB7XG4gICAgICAgIGlmIChtZXRob2QuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLlByaXZhdGUpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgXCJwcml2YXRlIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQobnVsbCwgbWV0aG9kLm5hbWUgKyBcIihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKG1ldGhvZC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChudWxsLCBcIilcIik7XG4gICAgICAgIHRoaXMuX3ByaW50Q29sb25UeXBlKG1ldGhvZC50eXBlLCBjdHgsICd2b2lkJyk7XG4gICAgICAgIGN0eC5wcmludGxuKG51bGwsIFwiIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4obnVsbCwgXCJ9XCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKFwiKTtcbiAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoYXN0LnBhcmFtcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICB0aGlzLl9wcmludENvbG9uVHlwZShhc3QudHlwZSwgY3R4LCAndm9pZCcpO1xuICAgICAgICBjdHgucHJpbnRsbihhc3QsIFwiID0+IHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoYXN0LnN0YXRlbWVudHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoY3R4LmlzRXhwb3J0ZWRWYXIoc3RtdC5uYW1lKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiZXhwb3J0IFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJmdW5jdGlvbiBcIiArIHN0bXQubmFtZSArIFwiKFwiKTtcbiAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoc3RtdC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcIilcIik7XG4gICAgICAgIHRoaXMuX3ByaW50Q29sb25UeXBlKHN0bXQudHlwZSwgY3R4LCAndm9pZCcpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIiB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ0cnkge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn0gY2F0Y2ggKFwiICsgQ0FUQ0hfRVJST1JfVkFSJDEubmFtZSArIFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhdGNoU3RtdHMgPSBbLyoqIEB0eXBlIHs/fSAqLyAoQ0FUQ0hfU1RBQ0tfVkFSJDEuc2V0KENBVENIX0VSUk9SX1ZBUiQxLnByb3AoJ3N0YWNrJywgbnVsbCkpLnRvRGVjbFN0bXQobnVsbCwgW1xuICAgICAgICAgICAgICAgIFN0bXRNb2RpZmllci5GaW5hbFxuICAgICAgICAgICAgXSkpXS5jb25jYXQoc3RtdC5jYXRjaFN0bXRzKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoY2F0Y2hTdG10cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJ1aWx0aW50VHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHlwZVN0cjtcbiAgICAgICAgc3dpdGNoICh0eXBlLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLkJvb2w6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdib29sZWFuJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLkR5bmFtaWM6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdhbnknO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuRnVuY3Rpb246XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdGdW5jdGlvbic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5UeXBlTmFtZS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdudW1iZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuSW50OlxuICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnbnVtYmVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLlN0cmluZzpcbiAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGJ1aWx0aW4gdHlwZSBcIiArIHR5cGUubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KG51bGwsIHR5cGVTdHIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb25UeXBlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXJyYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGN0eCkge1xuICAgICAgICB0aGlzLnZpc2l0VHlwZSh0eXBlLm9mLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQobnVsbCwgXCJbXVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TWFwVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KG51bGwsIFwie1trZXk6IHN0cmluZ106XCIpO1xuICAgICAgICB0aGlzLnZpc2l0VHlwZSh0eXBlLnZhbHVlVHlwZSwgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KG51bGwsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1ldGhvZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLmdldEJ1aWx0aW5NZXRob2ROYW1lID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lO1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLkNvbmNhdEFycmF5OlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnY29uY2F0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5TdWJzY3JpYmVPYnNlcnZhYmxlOlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnc3Vic2NyaWJlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5CaW5kOlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnYmluZCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiBtZXRob2Q6IFwiICsgbWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1zXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgcGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBfdGhpcy5fcHJpbnRDb2xvblR5cGUocGFyYW0udHlwZSwgY3R4KTtcbiAgICAgICAgfSwgcGFyYW1zLCBjdHgsICcsJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Jlc29sdmVTdGF0aWNTeW1ib2wgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVmZXJlbmNlID0gdmFsdWUucmVmZXJlbmNlO1xuICAgICAgICBpZiAoIShyZWZlcmVuY2UgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvcjogdW5rbm93biBpZGVudGlmaWVyIFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcml0eSA9IHRoaXMuX2ltcG9ydFJlc29sdmVyLmdldFR5cGVBcml0eShyZWZlcmVuY2UpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW1wb3J0UmVmZXJlbmNlID0gdGhpcy5faW1wb3J0UmVzb2x2ZXIuZ2V0SW1wb3J0QXMocmVmZXJlbmNlKSB8fCByZWZlcmVuY2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBpbXBvcnRSZWZlcmVuY2UubmFtZSxcbiAgICAgICAgICAgIGZpbGVQYXRoOiBpbXBvcnRSZWZlcmVuY2UuZmlsZVBhdGgsXG4gICAgICAgICAgICBtZW1iZXJzOiBpbXBvcnRSZWZlcmVuY2UubWVtYmVycywgYXJpdHk6IGFyaXR5XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSB0eXBlUGFyYW1zXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRJZGVudGlmaWVyID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlUGFyYW1zLCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fcmVzb2x2ZVN0YXRpY1N5bWJvbCh2YWx1ZSksIG5hbWUgPSBfYS5uYW1lLCBmaWxlUGF0aCA9IF9hLmZpbGVQYXRoLCBtZW1iZXJzID0gX2EubWVtYmVycywgYXJpdHkgPSBfYS5hcml0eTtcbiAgICAgICAgaWYgKGZpbGVQYXRoICE9IHRoaXMuX2dlbkZpbGVQYXRoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVmaXggPSB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMuZ2V0KGZpbGVQYXRoKTtcbiAgICAgICAgICAgIGlmIChwcmVmaXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiaW1wb3J0XCIgKyB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMuc2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMuc2V0KGZpbGVQYXRoLCBwcmVmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnByaW50KG51bGwsIHByZWZpeCArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKChtZW1iZXJzKSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgbmFtZSk7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgJy4nKTtcbiAgICAgICAgICAgIGN0eC5wcmludChudWxsLCAvKiogQHR5cGUgez99ICovICgobWVtYmVycykpLmpvaW4oJy4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHlwZUV4cHJlc3Npb24gPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgaW4gYSB0eXBlIGV4cHJlc3Npb24gdGhhdCByZWZlcnMgdG8gYSBnZW5lcmljIHR5cGUgdGhlbiBzdXBwbHlcbiAgICAgICAgICAgIC8vIHRoZSByZXF1aXJlZCB0eXBlIHBhcmFtZXRlcnMuIElmIHRoZXJlIHdlcmUgbm90IGVub3VnaCB0eXBlIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIC8vIHN1cHBsaWVkLCBzdXBwbHkgYW55IGFzIHRoZSB0eXBlLiBPdXRzaWRlIGEgdHlwZSBleHByZXNzaW9uIHRoZSByZWZlcmVuY2VcbiAgICAgICAgICAgIC8vIHNob3VsZCBub3Qgc3VwcGx5IHR5cGUgcGFyYW1ldGVycyBhbmQgYmUgdHJlYXRlZCBhcyBhIHNpbXBsZSB2YWx1ZSByZWZlcmVuY2VcbiAgICAgICAgICAgIC8vIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBpdHNlbGYuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdXBwbGllZFBhcmFtZXRlcnMgPSAodHlwZVBhcmFtcyAmJiB0eXBlUGFyYW1zLmxlbmd0aCkgfHwgMDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFkZGl0aW9uYWxQYXJhbWV0ZXJzID0gKGFyaXR5IHx8IDApIC0gc3VwcGxpZWRQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgaWYgKHN1cHBsaWVkUGFyYW1ldGVycyA+IDAgfHwgYWRkaXRpb25hbFBhcmFtZXRlcnMgPiAwKSB7XG4gICAgICAgICAgICAgICAgY3R4LnByaW50KG51bGwsIFwiPFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc3VwcGxpZWRQYXJhbWV0ZXJzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZS52aXNpdFR5cGUoX3RoaXMsIGN0eCk7IH0sIC8qKiBAdHlwZSB7P30gKi8gKCh0eXBlUGFyYW1zKSksIGN0eCwgJywnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxQYXJhbWV0ZXJzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgYWRkaXRpb25hbFBhcmFtZXRlcnM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwIHx8IHN1cHBsaWVkUGFyYW1ldGVycyA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnByaW50KG51bGwsICcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgJ2FueScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBcIj5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHBhcmFtIHs/PX0gZGVmYXVsdFR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fcHJpbnRDb2xvblR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY3R4LCBkZWZhdWx0VHlwZSkge1xuICAgICAgICBpZiAodHlwZSAhPT0gSU5GRVJSRURfVFlQRSkge1xuICAgICAgICAgICAgY3R4LnByaW50KG51bGwsICc6Jyk7XG4gICAgICAgICAgICB0aGlzLnZpc2l0VHlwZSh0eXBlLCBjdHgsIGRlZmF1bHRUeXBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIF9Uc0VtaXR0ZXJWaXNpdG9yO1xufShBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PSBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgID09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gICAgICAgIERPIE5PVCBFRElUIFRISVMgTElTVCBPRiBTRUNVUklUWSBTRU5TSVRJVkUgUFJPUEVSVElFUyBXSVRIT1VUIEEgU0VDVVJJVFkgUkVWSUVXIVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY2ggb3V0IHRvIG1wcm9ic3QgZm9yIGRldGFpbHMuXG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLyoqIE1hcCBmcm9tIHRhZ05hbWV8cHJvcGVydHlOYW1lIFNlY3VyaXR5Q29udGV4dC4gUHJvcGVydGllcyBhcHBseWluZyB0byBhbGwgdGFncyB1c2UgJyonLiAqL1xudmFyIFNFQ1VSSVRZX1NDSEVNQSA9IHt9O1xuLyoqXG4gKiBAcGFyYW0gez99IGN0eFxuICogQHBhcmFtIHs/fSBzcGVjc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJDb250ZXh0KGN0eCwgc3BlY3MpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHNwZWNzXzEgPSBzcGVjczsgX2kgPCBzcGVjc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc3BlYyA9IHNwZWNzXzFbX2ldO1xuICAgICAgICBTRUNVUklUWV9TQ0hFTUFbc3BlYy50b0xvd2VyQ2FzZSgpXSA9IGN0eDtcbiAgICB9XG59XG4vLyBDYXNlIGlzIGluc2lnbmlmaWNhbnQgYmVsb3csIGFsbCBlbGVtZW50IGFuZCBhdHRyaWJ1dGUgbmFtZXMgYXJlIGxvd2VyLWNhc2VkIGZvciBsb29rdXAuXG5yZWdpc3RlckNvbnRleHQoU2VjdXJpdHlDb250ZXh0LkhUTUwsIFtcbiAgICAnaWZyYW1lfHNyY2RvYycsXG4gICAgJyp8aW5uZXJIVE1MJyxcbiAgICAnKnxvdXRlckhUTUwnLFxuXSk7XG5yZWdpc3RlckNvbnRleHQoU2VjdXJpdHlDb250ZXh0LlNUWUxFLCBbJyp8c3R5bGUnXSk7XG4vLyBOQjogbm8gU0NSSVBUIGNvbnRleHRzIGhlcmUsIHRoZXkgYXJlIG5ldmVyIGFsbG93ZWQgZHVlIHRvIHRoZSBwYXJzZXIgc3RyaXBwaW5nIHRoZW0uXG5yZWdpc3RlckNvbnRleHQoU2VjdXJpdHlDb250ZXh0LlVSTCwgW1xuICAgICcqfGZvcm1BY3Rpb24nLCAnYXJlYXxocmVmJywgJ2FyZWF8cGluZycsICdhdWRpb3xzcmMnLCAnYXxocmVmJyxcbiAgICAnYXxwaW5nJywgJ2Jsb2NrcXVvdGV8Y2l0ZScsICdib2R5fGJhY2tncm91bmQnLCAnZGVsfGNpdGUnLCAnZm9ybXxhY3Rpb24nLFxuICAgICdpbWd8c3JjJywgJ2ltZ3xzcmNzZXQnLCAnaW5wdXR8c3JjJywgJ2luc3xjaXRlJywgJ3F8Y2l0ZScsXG4gICAgJ3NvdXJjZXxzcmMnLCAnc291cmNlfHNyY3NldCcsICd0cmFja3xzcmMnLCAndmlkZW98cG9zdGVyJywgJ3ZpZGVvfHNyYycsXG5dKTtcbnJlZ2lzdGVyQ29udGV4dChTZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMLCBbXG4gICAgJ2FwcGxldHxjb2RlJyxcbiAgICAnYXBwbGV0fGNvZGViYXNlJyxcbiAgICAnYmFzZXxocmVmJyxcbiAgICAnZW1iZWR8c3JjJyxcbiAgICAnZnJhbWV8c3JjJyxcbiAgICAnaGVhZHxwcm9maWxlJyxcbiAgICAnaHRtbHxtYW5pZmVzdCcsXG4gICAgJ2lmcmFtZXxzcmMnLFxuICAgICdsaW5rfGhyZWYnLFxuICAgICdtZWRpYXxzcmMnLFxuICAgICdvYmplY3R8Y29kZWJhc2UnLFxuICAgICdvYmplY3R8ZGF0YScsXG4gICAgJ3NjcmlwdHxzcmMnLFxuXSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQk9PTEVBTiA9ICdib29sZWFuJztcbnZhciBOVU1CRVIgPSAnbnVtYmVyJztcbnZhciBTVFJJTkcgPSAnc3RyaW5nJztcbnZhciBPQkpFQ1QgPSAnb2JqZWN0Jztcbi8qKlxuICogVGhpcyBhcnJheSByZXByZXNlbnRzIHRoZSBET00gc2NoZW1hLiBJdCBlbmNvZGVzIGluaGVyaXRhbmNlLCBwcm9wZXJ0aWVzLCBhbmQgZXZlbnRzLlxuICpcbiAqICMjIE92ZXJ2aWV3XG4gKlxuICogRWFjaCBsaW5lIHJlcHJlc2VudHMgb25lIGtpbmQgb2YgZWxlbWVudC4gVGhlIGBlbGVtZW50X2luaGVyaXRhbmNlYCBhbmQgcHJvcGVydGllcyBhcmUgam9pbmVkXG4gKiB1c2luZyBgZWxlbWVudF9pbmhlcml0YW5jZXxwcm9wZXJ0aWVzYCBzeW50YXguXG4gKlxuICogIyMgRWxlbWVudCBJbmhlcml0YW5jZVxuICpcbiAqIFRoZSBgZWxlbWVudF9pbmhlcml0YW5jZWAgY2FuIGJlIGZ1cnRoZXIgc3ViZGl2aWRlZCBhcyBgZWxlbWVudDEsZWxlbWVudDIsLi4uXnBhcmVudEVsZW1lbnRgLlxuICogSGVyZSB0aGUgaW5kaXZpZHVhbCBlbGVtZW50cyBhcmUgc2VwYXJhdGVkIGJ5IGAsYCAoY29tbWFzKS4gRXZlcnkgZWxlbWVudCBpbiB0aGUgbGlzdFxuICogaGFzIGlkZW50aWNhbCBwcm9wZXJ0aWVzLlxuICpcbiAqIEFuIGBlbGVtZW50YCBtYXkgaW5oZXJpdCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgZnJvbSBgcGFyZW50RWxlbWVudGAgSWYgbm8gYF5wYXJlbnRFbGVtZW50YCBpc1xuICogc3BlY2lmaWVkIHRoZW4gYFwiXCJgIChibGFuaykgZWxlbWVudCBpcyBhc3N1bWVkLlxuICpcbiAqIE5PVEU6IFRoZSBibGFuayBlbGVtZW50IGluaGVyaXRzIGZyb20gcm9vdCBgW0VsZW1lbnRdYCBlbGVtZW50LCB0aGUgc3VwZXIgZWxlbWVudCBvZiBhbGxcbiAqIGVsZW1lbnRzLlxuICpcbiAqIE5PVEUgYW4gZWxlbWVudCBwcmVmaXggc3VjaCBhcyBgOnN2ZzpgIGhhcyBubyBzcGVjaWFsIG1lYW5pbmcgdG8gdGhlIHNjaGVtYS5cbiAqXG4gKiAjIyBQcm9wZXJ0aWVzXG4gKlxuICogRWFjaCBlbGVtZW50IGhhcyBhIHNldCBvZiBwcm9wZXJ0aWVzIHNlcGFyYXRlZCBieSBgLGAgKGNvbW1hcykuIEVhY2ggcHJvcGVydHkgY2FuIGJlIHByZWZpeGVkXG4gKiBieSBhIHNwZWNpYWwgY2hhcmFjdGVyIGRlc2lnbmF0aW5nIGl0cyB0eXBlOlxuICpcbiAqIC0gKG5vIHByZWZpeCk6IHByb3BlcnR5IGlzIGEgc3RyaW5nLlxuICogLSBgKmA6IHByb3BlcnR5IHJlcHJlc2VudHMgYW4gZXZlbnQuXG4gKiAtIGAhYDogcHJvcGVydHkgaXMgYSBib29sZWFuLlxuICogLSBgI2A6IHByb3BlcnR5IGlzIGEgbnVtYmVyLlxuICogLSBgJWA6IHByb3BlcnR5IGlzIGFuIG9iamVjdC5cbiAqXG4gKiAjIyBRdWVyeVxuICpcbiAqIFRoZSBjbGFzcyBjcmVhdGVzIGFuIGludGVybmFsIHNxdWFzIHJlcHJlc2VudGF0aW9uIHdoaWNoIGFsbG93cyB0byBlYXNpbHkgYW5zd2VyIHRoZSBxdWVyeSBvZlxuICogaWYgYSBnaXZlbiBwcm9wZXJ0eSBleGlzdCBvbiBhIGdpdmVuIGVsZW1lbnQuXG4gKlxuICogTk9URTogV2UgZG9uJ3QgeWV0IHN1cHBvcnQgcXVlcnlpbmcgZm9yIHR5cGVzIG9yIGV2ZW50cy5cbiAqIE5PVEU6IFRoaXMgc2NoZW1hIGlzIGF1dG8gZXh0cmFjdGVkIGZyb20gYHNjaGVtYV9leHRyYWN0b3IudHNgIGxvY2F0ZWQgaW4gdGhlIHRlc3QgZm9sZGVyLFxuICogICAgICAgc2VlIGRvbV9lbGVtZW50X3NjaGVtYV9yZWdpc3RyeV9zcGVjLnRzXG4gKi9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09IFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgPT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyAgICAgICAgICAgICAgICAgICAgICAgRE8gTk9UIEVESVQgVEhJUyBET00gU0NIRU1BIFdJVEhPVVQgQSBTRUNVUklUWSBSRVZJRVchXG4vL1xuLy8gTmV3bHkgYWRkZWQgcHJvcGVydGllcyBtdXN0IGJlIHNlY3VyaXR5IHJldmlld2VkIGFuZCBhc3NpZ25lZCBhbiBhcHByb3ByaWF0ZSBTZWN1cml0eUNvbnRleHQgaW5cbi8vIGRvbV9zZWN1cml0eV9zY2hlbWEudHMuIFJlYWNoIG91dCB0byBtcHJvYnN0ICYgcmphbWV0IGZvciBkZXRhaWxzLlxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbnZhciBTQ0hFTUEgPSBbXG4gICAgJ1tFbGVtZW50XXx0ZXh0Q29udGVudCwlY2xhc3NMaXN0LGNsYXNzTmFtZSxpZCxpbm5lckhUTUwsKmJlZm9yZWNvcHksKmJlZm9yZWN1dCwqYmVmb3JlcGFzdGUsKmNvcHksKmN1dCwqcGFzdGUsKnNlYXJjaCwqc2VsZWN0c3RhcnQsKndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UsKndlYmtpdGZ1bGxzY3JlZW5lcnJvciwqd2hlZWwsb3V0ZXJIVE1MLCNzY3JvbGxMZWZ0LCNzY3JvbGxUb3AnLFxuICAgICdbSFRNTEVsZW1lbnRdXltFbGVtZW50XXxhY2Nlc3NLZXksY29udGVudEVkaXRhYmxlLGRpciwhZHJhZ2dhYmxlLCFoaWRkZW4saW5uZXJUZXh0LGxhbmcsKmFib3J0LCpiZWZvcmVjb3B5LCpiZWZvcmVjdXQsKmJlZm9yZXBhc3RlLCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmNvcHksKmN1ZWNoYW5nZSwqY3V0LCpkYmxjbGljaywqZHJhZywqZHJhZ2VuZCwqZHJhZ2VudGVyLCpkcmFnbGVhdmUsKmRyYWdvdmVyLCpkcmFnc3RhcnQsKmRyb3AsKmR1cmF0aW9uY2hhbmdlLCplbXB0aWVkLCplbmRlZCwqZXJyb3IsKmZvY3VzLCppbnB1dCwqaW52YWxpZCwqa2V5ZG93biwqa2V5cHJlc3MsKmtleXVwLCpsb2FkLCpsb2FkZWRkYXRhLCpsb2FkZWRtZXRhZGF0YSwqbG9hZHN0YXJ0LCptZXNzYWdlLCptb3VzZWRvd24sKm1vdXNlZW50ZXIsKm1vdXNlbGVhdmUsKm1vdXNlbW92ZSwqbW91c2VvdXQsKm1vdXNlb3ZlciwqbW91c2V1cCwqbW91c2V3aGVlbCwqbW96ZnVsbHNjcmVlbmNoYW5nZSwqbW96ZnVsbHNjcmVlbmVycm9yLCptb3pwb2ludGVybG9ja2NoYW5nZSwqbW96cG9pbnRlcmxvY2tlcnJvciwqcGFzdGUsKnBhdXNlLCpwbGF5LCpwbGF5aW5nLCpwcm9ncmVzcywqcmF0ZWNoYW5nZSwqcmVzZXQsKnJlc2l6ZSwqc2Nyb2xsLCpzZWFyY2gsKnNlZWtlZCwqc2Vla2luZywqc2VsZWN0LCpzZWxlY3RzdGFydCwqc2hvdywqc3RhbGxlZCwqc3VibWl0LCpzdXNwZW5kLCp0aW1ldXBkYXRlLCp0b2dnbGUsKnZvbHVtZWNoYW5nZSwqd2FpdGluZywqd2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvciwqd2ViZ2xjb250ZXh0bG9zdCwqd2ViZ2xjb250ZXh0cmVzdG9yZWQsKndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UsKndlYmtpdGZ1bGxzY3JlZW5lcnJvciwqd2hlZWwsb3V0ZXJUZXh0LCFzcGVsbGNoZWNrLCVzdHlsZSwjdGFiSW5kZXgsdGl0bGUsIXRyYW5zbGF0ZScsXG4gICAgJ2FiYnIsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGIsYmRpLGJkbyxjaXRlLGNvZGUsZGQsZGZuLGR0LGVtLGZpZ2NhcHRpb24sZmlndXJlLGZvb3RlcixoZWFkZXIsaSxrYmQsbWFpbixtYXJrLG5hdixub3NjcmlwdCxyYixycCxydCxydGMscnVieSxzLHNhbXAsc2VjdGlvbixzbWFsbCxzdHJvbmcsc3ViLHN1cCx1LHZhcix3YnJeW0hUTUxFbGVtZW50XXxhY2Nlc3NLZXksY29udGVudEVkaXRhYmxlLGRpciwhZHJhZ2dhYmxlLCFoaWRkZW4saW5uZXJUZXh0LGxhbmcsKmFib3J0LCpiZWZvcmVjb3B5LCpiZWZvcmVjdXQsKmJlZm9yZXBhc3RlLCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmNvcHksKmN1ZWNoYW5nZSwqY3V0LCpkYmxjbGljaywqZHJhZywqZHJhZ2VuZCwqZHJhZ2VudGVyLCpkcmFnbGVhdmUsKmRyYWdvdmVyLCpkcmFnc3RhcnQsKmRyb3AsKmR1cmF0aW9uY2hhbmdlLCplbXB0aWVkLCplbmRlZCwqZXJyb3IsKmZvY3VzLCppbnB1dCwqaW52YWxpZCwqa2V5ZG93biwqa2V5cHJlc3MsKmtleXVwLCpsb2FkLCpsb2FkZWRkYXRhLCpsb2FkZWRtZXRhZGF0YSwqbG9hZHN0YXJ0LCptZXNzYWdlLCptb3VzZWRvd24sKm1vdXNlZW50ZXIsKm1vdXNlbGVhdmUsKm1vdXNlbW92ZSwqbW91c2VvdXQsKm1vdXNlb3ZlciwqbW91c2V1cCwqbW91c2V3aGVlbCwqbW96ZnVsbHNjcmVlbmNoYW5nZSwqbW96ZnVsbHNjcmVlbmVycm9yLCptb3pwb2ludGVybG9ja2NoYW5nZSwqbW96cG9pbnRlcmxvY2tlcnJvciwqcGFzdGUsKnBhdXNlLCpwbGF5LCpwbGF5aW5nLCpwcm9ncmVzcywqcmF0ZWNoYW5nZSwqcmVzZXQsKnJlc2l6ZSwqc2Nyb2xsLCpzZWFyY2gsKnNlZWtlZCwqc2Vla2luZywqc2VsZWN0LCpzZWxlY3RzdGFydCwqc2hvdywqc3RhbGxlZCwqc3VibWl0LCpzdXNwZW5kLCp0aW1ldXBkYXRlLCp0b2dnbGUsKnZvbHVtZWNoYW5nZSwqd2FpdGluZywqd2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvciwqd2ViZ2xjb250ZXh0bG9zdCwqd2ViZ2xjb250ZXh0cmVzdG9yZWQsKndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UsKndlYmtpdGZ1bGxzY3JlZW5lcnJvciwqd2hlZWwsb3V0ZXJUZXh0LCFzcGVsbGNoZWNrLCVzdHlsZSwjdGFiSW5kZXgsdGl0bGUsIXRyYW5zbGF0ZScsXG4gICAgJ21lZGlhXltIVE1MRWxlbWVudF18IWF1dG9wbGF5LCFjb250cm9scywlY3Jvc3NPcmlnaW4sI2N1cnJlbnRUaW1lLCFkZWZhdWx0TXV0ZWQsI2RlZmF1bHRQbGF5YmFja1JhdGUsIWRpc2FibGVSZW1vdGVQbGF5YmFjaywhbG9vcCwhbXV0ZWQsKmVuY3J5cHRlZCwjcGxheWJhY2tSYXRlLHByZWxvYWQsc3JjLCVzcmNPYmplY3QsI3ZvbHVtZScsXG4gICAgJzpzdmc6XltIVE1MRWxlbWVudF18KmFib3J0LCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmN1ZWNoYW5nZSwqZGJsY2xpY2ssKmRyYWcsKmRyYWdlbmQsKmRyYWdlbnRlciwqZHJhZ2xlYXZlLCpkcmFnb3ZlciwqZHJhZ3N0YXJ0LCpkcm9wLCpkdXJhdGlvbmNoYW5nZSwqZW1wdGllZCwqZW5kZWQsKmVycm9yLCpmb2N1cywqaW5wdXQsKmludmFsaWQsKmtleWRvd24sKmtleXByZXNzLCprZXl1cCwqbG9hZCwqbG9hZGVkZGF0YSwqbG9hZGVkbWV0YWRhdGEsKmxvYWRzdGFydCwqbW91c2Vkb3duLCptb3VzZWVudGVyLCptb3VzZWxlYXZlLCptb3VzZW1vdmUsKm1vdXNlb3V0LCptb3VzZW92ZXIsKm1vdXNldXAsKm1vdXNld2hlZWwsKnBhdXNlLCpwbGF5LCpwbGF5aW5nLCpwcm9ncmVzcywqcmF0ZWNoYW5nZSwqcmVzZXQsKnJlc2l6ZSwqc2Nyb2xsLCpzZWVrZWQsKnNlZWtpbmcsKnNlbGVjdCwqc2hvdywqc3RhbGxlZCwqc3VibWl0LCpzdXNwZW5kLCp0aW1ldXBkYXRlLCp0b2dnbGUsKnZvbHVtZWNoYW5nZSwqd2FpdGluZywlc3R5bGUsI3RhYkluZGV4JyxcbiAgICAnOnN2ZzpncmFwaGljc146c3ZnOnwnLFxuICAgICc6c3ZnOmFuaW1hdGlvbl46c3ZnOnwqYmVnaW4sKmVuZCwqcmVwZWF0JyxcbiAgICAnOnN2ZzpnZW9tZXRyeV46c3ZnOnwnLFxuICAgICc6c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb25eOnN2Zzp8JyxcbiAgICAnOnN2ZzpncmFkaWVudF46c3ZnOnwnLFxuICAgICc6c3ZnOnRleHRDb250ZW50Xjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAnOnN2Zzp0ZXh0UG9zaXRpb25pbmdeOnN2Zzp0ZXh0Q29udGVudHwnLFxuICAgICdhXltIVE1MRWxlbWVudF18Y2hhcnNldCxjb29yZHMsZG93bmxvYWQsaGFzaCxob3N0LGhvc3RuYW1lLGhyZWYsaHJlZmxhbmcsbmFtZSxwYXNzd29yZCxwYXRobmFtZSxwaW5nLHBvcnQscHJvdG9jb2wscmVmZXJyZXJQb2xpY3kscmVsLHJldixzZWFyY2gsc2hhcGUsdGFyZ2V0LHRleHQsdHlwZSx1c2VybmFtZScsXG4gICAgJ2FyZWFeW0hUTUxFbGVtZW50XXxhbHQsY29vcmRzLGhhc2gsaG9zdCxob3N0bmFtZSxocmVmLCFub0hyZWYscGFzc3dvcmQscGF0aG5hbWUscGluZyxwb3J0LHByb3RvY29sLHJlZmVycmVyUG9saWN5LHNlYXJjaCxzaGFwZSx0YXJnZXQsdXNlcm5hbWUnLFxuICAgICdhdWRpb15tZWRpYXwnLFxuICAgICdicl5bSFRNTEVsZW1lbnRdfGNsZWFyJyxcbiAgICAnYmFzZV5bSFRNTEVsZW1lbnRdfGhyZWYsdGFyZ2V0JyxcbiAgICAnYm9keV5bSFRNTEVsZW1lbnRdfGFMaW5rLGJhY2tncm91bmQsYmdDb2xvcixsaW5rLCpiZWZvcmV1bmxvYWQsKmJsdXIsKmVycm9yLCpmb2N1cywqaGFzaGNoYW5nZSwqbGFuZ3VhZ2VjaGFuZ2UsKmxvYWQsKm1lc3NhZ2UsKm9mZmxpbmUsKm9ubGluZSwqcGFnZWhpZGUsKnBhZ2VzaG93LCpwb3BzdGF0ZSwqcmVqZWN0aW9uaGFuZGxlZCwqcmVzaXplLCpzY3JvbGwsKnN0b3JhZ2UsKnVuaGFuZGxlZHJlamVjdGlvbiwqdW5sb2FkLHRleHQsdkxpbmsnLFxuICAgICdidXR0b25eW0hUTUxFbGVtZW50XXwhYXV0b2ZvY3VzLCFkaXNhYmxlZCxmb3JtQWN0aW9uLGZvcm1FbmN0eXBlLGZvcm1NZXRob2QsIWZvcm1Ob1ZhbGlkYXRlLGZvcm1UYXJnZXQsbmFtZSx0eXBlLHZhbHVlJyxcbiAgICAnY2FudmFzXltIVE1MRWxlbWVudF18I2hlaWdodCwjd2lkdGgnLFxuICAgICdjb250ZW50XltIVE1MRWxlbWVudF18c2VsZWN0JyxcbiAgICAnZGxeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgJ2RhdGFsaXN0XltIVE1MRWxlbWVudF18JyxcbiAgICAnZGV0YWlsc15bSFRNTEVsZW1lbnRdfCFvcGVuJyxcbiAgICAnZGlhbG9nXltIVE1MRWxlbWVudF18IW9wZW4scmV0dXJuVmFsdWUnLFxuICAgICdkaXJeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgJ2Rpdl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAnZW1iZWReW0hUTUxFbGVtZW50XXxhbGlnbixoZWlnaHQsbmFtZSxzcmMsdHlwZSx3aWR0aCcsXG4gICAgJ2ZpZWxkc2V0XltIVE1MRWxlbWVudF18IWRpc2FibGVkLG5hbWUnLFxuICAgICdmb250XltIVE1MRWxlbWVudF18Y29sb3IsZmFjZSxzaXplJyxcbiAgICAnZm9ybV5bSFRNTEVsZW1lbnRdfGFjY2VwdENoYXJzZXQsYWN0aW9uLGF1dG9jb21wbGV0ZSxlbmNvZGluZyxlbmN0eXBlLG1ldGhvZCxuYW1lLCFub1ZhbGlkYXRlLHRhcmdldCcsXG4gICAgJ2ZyYW1lXltIVE1MRWxlbWVudF18ZnJhbWVCb3JkZXIsbG9uZ0Rlc2MsbWFyZ2luSGVpZ2h0LG1hcmdpbldpZHRoLG5hbWUsIW5vUmVzaXplLHNjcm9sbGluZyxzcmMnLFxuICAgICdmcmFtZXNldF5bSFRNTEVsZW1lbnRdfGNvbHMsKmJlZm9yZXVubG9hZCwqYmx1ciwqZXJyb3IsKmZvY3VzLCpoYXNoY2hhbmdlLCpsYW5ndWFnZWNoYW5nZSwqbG9hZCwqbWVzc2FnZSwqb2ZmbGluZSwqb25saW5lLCpwYWdlaGlkZSwqcGFnZXNob3csKnBvcHN0YXRlLCpyZWplY3Rpb25oYW5kbGVkLCpyZXNpemUsKnNjcm9sbCwqc3RvcmFnZSwqdW5oYW5kbGVkcmVqZWN0aW9uLCp1bmxvYWQscm93cycsXG4gICAgJ2hyXltIVE1MRWxlbWVudF18YWxpZ24sY29sb3IsIW5vU2hhZGUsc2l6ZSx3aWR0aCcsXG4gICAgJ2hlYWReW0hUTUxFbGVtZW50XXwnLFxuICAgICdoMSxoMixoMyxoNCxoNSxoNl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAnaHRtbF5bSFRNTEVsZW1lbnRdfHZlcnNpb24nLFxuICAgICdpZnJhbWVeW0hUTUxFbGVtZW50XXxhbGlnbiwhYWxsb3dGdWxsc2NyZWVuLGZyYW1lQm9yZGVyLGhlaWdodCxsb25nRGVzYyxtYXJnaW5IZWlnaHQsbWFyZ2luV2lkdGgsbmFtZSxyZWZlcnJlclBvbGljeSwlc2FuZGJveCxzY3JvbGxpbmcsc3JjLHNyY2RvYyx3aWR0aCcsXG4gICAgJ2ltZ15bSFRNTEVsZW1lbnRdfGFsaWduLGFsdCxib3JkZXIsJWNyb3NzT3JpZ2luLCNoZWlnaHQsI2hzcGFjZSwhaXNNYXAsbG9uZ0Rlc2MsbG93c3JjLG5hbWUscmVmZXJyZXJQb2xpY3ksc2l6ZXMsc3JjLHNyY3NldCx1c2VNYXAsI3ZzcGFjZSwjd2lkdGgnLFxuICAgICdpbnB1dF5bSFRNTEVsZW1lbnRdfGFjY2VwdCxhbGlnbixhbHQsYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLCFhdXRvZm9jdXMsIWNoZWNrZWQsIWRlZmF1bHRDaGVja2VkLGRlZmF1bHRWYWx1ZSxkaXJOYW1lLCFkaXNhYmxlZCwlZmlsZXMsZm9ybUFjdGlvbixmb3JtRW5jdHlwZSxmb3JtTWV0aG9kLCFmb3JtTm9WYWxpZGF0ZSxmb3JtVGFyZ2V0LCNoZWlnaHQsIWluY3JlbWVudGFsLCFpbmRldGVybWluYXRlLG1heCwjbWF4TGVuZ3RoLG1pbiwjbWluTGVuZ3RoLCFtdWx0aXBsZSxuYW1lLHBhdHRlcm4scGxhY2Vob2xkZXIsIXJlYWRPbmx5LCFyZXF1aXJlZCxzZWxlY3Rpb25EaXJlY3Rpb24sI3NlbGVjdGlvbkVuZCwjc2VsZWN0aW9uU3RhcnQsI3NpemUsc3JjLHN0ZXAsdHlwZSx1c2VNYXAsdmFsdWUsJXZhbHVlQXNEYXRlLCN2YWx1ZUFzTnVtYmVyLCN3aWR0aCcsXG4gICAgJ2tleWdlbl5bSFRNTEVsZW1lbnRdfCFhdXRvZm9jdXMsY2hhbGxlbmdlLCFkaXNhYmxlZCxrZXl0eXBlLG5hbWUnLFxuICAgICdsaV5bSFRNTEVsZW1lbnRdfHR5cGUsI3ZhbHVlJyxcbiAgICAnbGFiZWxeW0hUTUxFbGVtZW50XXxodG1sRm9yJyxcbiAgICAnbGVnZW5kXltIVE1MRWxlbWVudF18YWxpZ24nLFxuICAgICdsaW5rXltIVE1MRWxlbWVudF18YXMsY2hhcnNldCwlY3Jvc3NPcmlnaW4sIWRpc2FibGVkLGhyZWYsaHJlZmxhbmcsaW50ZWdyaXR5LG1lZGlhLHJlbCwlcmVsTGlzdCxyZXYsJXNpemVzLHRhcmdldCx0eXBlJyxcbiAgICAnbWFwXltIVE1MRWxlbWVudF18bmFtZScsXG4gICAgJ21hcnF1ZWVeW0hUTUxFbGVtZW50XXxiZWhhdmlvcixiZ0NvbG9yLGRpcmVjdGlvbixoZWlnaHQsI2hzcGFjZSwjbG9vcCwjc2Nyb2xsQW1vdW50LCNzY3JvbGxEZWxheSwhdHJ1ZVNwZWVkLCN2c3BhY2Usd2lkdGgnLFxuICAgICdtZW51XltIVE1MRWxlbWVudF18IWNvbXBhY3QnLFxuICAgICdtZXRhXltIVE1MRWxlbWVudF18Y29udGVudCxodHRwRXF1aXYsbmFtZSxzY2hlbWUnLFxuICAgICdtZXRlcl5bSFRNTEVsZW1lbnRdfCNoaWdoLCNsb3csI21heCwjbWluLCNvcHRpbXVtLCN2YWx1ZScsXG4gICAgJ2lucyxkZWxeW0hUTUxFbGVtZW50XXxjaXRlLGRhdGVUaW1lJyxcbiAgICAnb2xeW0hUTUxFbGVtZW50XXwhY29tcGFjdCwhcmV2ZXJzZWQsI3N0YXJ0LHR5cGUnLFxuICAgICdvYmplY3ReW0hUTUxFbGVtZW50XXxhbGlnbixhcmNoaXZlLGJvcmRlcixjb2RlLGNvZGVCYXNlLGNvZGVUeXBlLGRhdGEsIWRlY2xhcmUsaGVpZ2h0LCNoc3BhY2UsbmFtZSxzdGFuZGJ5LHR5cGUsdXNlTWFwLCN2c3BhY2Usd2lkdGgnLFxuICAgICdvcHRncm91cF5bSFRNTEVsZW1lbnRdfCFkaXNhYmxlZCxsYWJlbCcsXG4gICAgJ29wdGlvbl5bSFRNTEVsZW1lbnRdfCFkZWZhdWx0U2VsZWN0ZWQsIWRpc2FibGVkLGxhYmVsLCFzZWxlY3RlZCx0ZXh0LHZhbHVlJyxcbiAgICAnb3V0cHV0XltIVE1MRWxlbWVudF18ZGVmYXVsdFZhbHVlLCVodG1sRm9yLG5hbWUsdmFsdWUnLFxuICAgICdwXltIVE1MRWxlbWVudF18YWxpZ24nLFxuICAgICdwYXJhbV5bSFRNTEVsZW1lbnRdfG5hbWUsdHlwZSx2YWx1ZSx2YWx1ZVR5cGUnLFxuICAgICdwaWN0dXJlXltIVE1MRWxlbWVudF18JyxcbiAgICAncHJlXltIVE1MRWxlbWVudF18I3dpZHRoJyxcbiAgICAncHJvZ3Jlc3NeW0hUTUxFbGVtZW50XXwjbWF4LCN2YWx1ZScsXG4gICAgJ3EsYmxvY2txdW90ZSxjaXRlXltIVE1MRWxlbWVudF18JyxcbiAgICAnc2NyaXB0XltIVE1MRWxlbWVudF18IWFzeW5jLGNoYXJzZXQsJWNyb3NzT3JpZ2luLCFkZWZlcixldmVudCxodG1sRm9yLGludGVncml0eSxzcmMsdGV4dCx0eXBlJyxcbiAgICAnc2VsZWN0XltIVE1MRWxlbWVudF18IWF1dG9mb2N1cywhZGlzYWJsZWQsI2xlbmd0aCwhbXVsdGlwbGUsbmFtZSwhcmVxdWlyZWQsI3NlbGVjdGVkSW5kZXgsI3NpemUsdmFsdWUnLFxuICAgICdzaGFkb3deW0hUTUxFbGVtZW50XXwnLFxuICAgICdzb3VyY2VeW0hUTUxFbGVtZW50XXxtZWRpYSxzaXplcyxzcmMsc3Jjc2V0LHR5cGUnLFxuICAgICdzcGFuXltIVE1MRWxlbWVudF18JyxcbiAgICAnc3R5bGVeW0hUTUxFbGVtZW50XXwhZGlzYWJsZWQsbWVkaWEsdHlwZScsXG4gICAgJ2NhcHRpb25eW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgJ3RoLHRkXltIVE1MRWxlbWVudF18YWJicixhbGlnbixheGlzLGJnQ29sb3IsY2gsY2hPZmYsI2NvbFNwYW4saGVhZGVycyxoZWlnaHQsIW5vV3JhcCwjcm93U3BhbixzY29wZSx2QWxpZ24sd2lkdGgnLFxuICAgICdjb2wsY29sZ3JvdXBeW0hUTUxFbGVtZW50XXxhbGlnbixjaCxjaE9mZiwjc3Bhbix2QWxpZ24sd2lkdGgnLFxuICAgICd0YWJsZV5bSFRNTEVsZW1lbnRdfGFsaWduLGJnQ29sb3IsYm9yZGVyLCVjYXB0aW9uLGNlbGxQYWRkaW5nLGNlbGxTcGFjaW5nLGZyYW1lLHJ1bGVzLHN1bW1hcnksJXRGb290LCV0SGVhZCx3aWR0aCcsXG4gICAgJ3RyXltIVE1MRWxlbWVudF18YWxpZ24sYmdDb2xvcixjaCxjaE9mZix2QWxpZ24nLFxuICAgICd0Zm9vdCx0aGVhZCx0Ym9keV5bSFRNTEVsZW1lbnRdfGFsaWduLGNoLGNoT2ZmLHZBbGlnbicsXG4gICAgJ3RlbXBsYXRlXltIVE1MRWxlbWVudF18JyxcbiAgICAndGV4dGFyZWFeW0hUTUxFbGVtZW50XXxhdXRvY2FwaXRhbGl6ZSwhYXV0b2ZvY3VzLCNjb2xzLGRlZmF1bHRWYWx1ZSxkaXJOYW1lLCFkaXNhYmxlZCwjbWF4TGVuZ3RoLCNtaW5MZW5ndGgsbmFtZSxwbGFjZWhvbGRlciwhcmVhZE9ubHksIXJlcXVpcmVkLCNyb3dzLHNlbGVjdGlvbkRpcmVjdGlvbiwjc2VsZWN0aW9uRW5kLCNzZWxlY3Rpb25TdGFydCx2YWx1ZSx3cmFwJyxcbiAgICAndGl0bGVeW0hUTUxFbGVtZW50XXx0ZXh0JyxcbiAgICAndHJhY2teW0hUTUxFbGVtZW50XXwhZGVmYXVsdCxraW5kLGxhYmVsLHNyYyxzcmNsYW5nJyxcbiAgICAndWxeW0hUTUxFbGVtZW50XXwhY29tcGFjdCx0eXBlJyxcbiAgICAndW5rbm93bl5bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ3ZpZGVvXm1lZGlhfCNoZWlnaHQscG9zdGVyLCN3aWR0aCcsXG4gICAgJzpzdmc6YV46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6YW5pbWF0ZV46c3ZnOmFuaW1hdGlvbnwnLFxuICAgICc6c3ZnOmFuaW1hdGVNb3Rpb25eOnN2ZzphbmltYXRpb258JyxcbiAgICAnOnN2ZzphbmltYXRlVHJhbnNmb3JtXjpzdmc6YW5pbWF0aW9ufCcsXG4gICAgJzpzdmc6Y2lyY2xlXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2ZzpjbGlwUGF0aF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6Y3Vyc29yXjpzdmc6fCcsXG4gICAgJzpzdmc6ZGVmc146c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6ZGVzY146c3ZnOnwnLFxuICAgICc6c3ZnOmRpc2NhcmReOnN2Zzp8JyxcbiAgICAnOnN2ZzplbGxpcHNlXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2ZzpmZUJsZW5kXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVDb2xvck1hdHJpeF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlQ29tcG9uZW50VHJhbnNmZXJeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUNvbXBvc2l0ZV46c3ZnOnwnLFxuICAgICc6c3ZnOmZlQ29udm9sdmVNYXRyaXheOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZURpZmZ1c2VMaWdodGluZ146c3ZnOnwnLFxuICAgICc6c3ZnOmZlRGlzcGxhY2VtZW50TWFwXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVEaXN0YW50TGlnaHReOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZURyb3BTaGFkb3deOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUZsb29kXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVGdW5jQV46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAnOnN2ZzpmZUZ1bmNCXjpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbnwnLFxuICAgICc6c3ZnOmZlRnVuY0deOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9ufCcsXG4gICAgJzpzdmc6ZmVGdW5jUl46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAnOnN2ZzpmZUdhdXNzaWFuQmx1cl46c3ZnOnwnLFxuICAgICc6c3ZnOmZlSW1hZ2VeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZU1lcmdlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVNZXJnZU5vZGVeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZU1vcnBob2xvZ3leOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZU9mZnNldF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlUG9pbnRMaWdodF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlU3BlY3VsYXJMaWdodGluZ146c3ZnOnwnLFxuICAgICc6c3ZnOmZlU3BvdExpZ2h0Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVUaWxlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVUdXJidWxlbmNlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmlsdGVyXjpzdmc6fCcsXG4gICAgJzpzdmc6Zm9yZWlnbk9iamVjdF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6Z146c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6aW1hZ2VeOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmxpbmVeOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOmxpbmVhckdyYWRpZW50Xjpzdmc6Z3JhZGllbnR8JyxcbiAgICAnOnN2ZzptcGF0aF46c3ZnOnwnLFxuICAgICc6c3ZnOm1hcmtlcl46c3ZnOnwnLFxuICAgICc6c3ZnOm1hc2teOnN2Zzp8JyxcbiAgICAnOnN2ZzptZXRhZGF0YV46c3ZnOnwnLFxuICAgICc6c3ZnOnBhdGheOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOnBhdHRlcm5eOnN2Zzp8JyxcbiAgICAnOnN2Zzpwb2x5Z29uXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2Zzpwb2x5bGluZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgJzpzdmc6cmFkaWFsR3JhZGllbnReOnN2ZzpncmFkaWVudHwnLFxuICAgICc6c3ZnOnJlY3ReOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOnN2Z146c3ZnOmdyYXBoaWNzfCNjdXJyZW50U2NhbGUsI3pvb21BbmRQYW4nLFxuICAgICc6c3ZnOnNjcmlwdF46c3ZnOnx0eXBlJyxcbiAgICAnOnN2ZzpzZXReOnN2ZzphbmltYXRpb258JyxcbiAgICAnOnN2ZzpzdG9wXjpzdmc6fCcsXG4gICAgJzpzdmc6c3R5bGVeOnN2Zzp8IWRpc2FibGVkLG1lZGlhLHRpdGxlLHR5cGUnLFxuICAgICc6c3ZnOnN3aXRjaF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6c3ltYm9sXjpzdmc6fCcsXG4gICAgJzpzdmc6dHNwYW5eOnN2Zzp0ZXh0UG9zaXRpb25pbmd8JyxcbiAgICAnOnN2Zzp0ZXh0Xjpzdmc6dGV4dFBvc2l0aW9uaW5nfCcsXG4gICAgJzpzdmc6dGV4dFBhdGheOnN2Zzp0ZXh0Q29udGVudHwnLFxuICAgICc6c3ZnOnRpdGxlXjpzdmc6fCcsXG4gICAgJzpzdmc6dXNlXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAnOnN2Zzp2aWV3Xjpzdmc6fCN6b29tQW5kUGFuJyxcbiAgICAnZGF0YV5bSFRNTEVsZW1lbnRdfHZhbHVlJyxcbiAgICAnbWVudWl0ZW1eW0hUTUxFbGVtZW50XXx0eXBlLGxhYmVsLGljb24sIWRpc2FibGVkLCFjaGVja2VkLHJhZGlvZ3JvdXAsIWRlZmF1bHQnLFxuICAgICdzdW1tYXJ5XltIVE1MRWxlbWVudF18JyxcbiAgICAndGltZV5bSFRNTEVsZW1lbnRdfGRhdGVUaW1lJyxcbl07XG52YXIgX0FUVFJfVE9fUFJPUCA9IHtcbiAgICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcbiAgICAnZm9yJzogJ2h0bWxGb3InLFxuICAgICdmb3JtYWN0aW9uJzogJ2Zvcm1BY3Rpb24nLFxuICAgICdpbm5lckh0bWwnOiAnaW5uZXJIVE1MJyxcbiAgICAncmVhZG9ubHknOiAncmVhZE9ubHknLFxuICAgICd0YWJpbmRleCc6ICd0YWJJbmRleCcsXG59O1xudmFyIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9zY2hlbWEgPSB7fTtcbiAgICAgICAgU0NIRU1BLmZvckVhY2goZnVuY3Rpb24gKGVuY29kZWRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHt9O1xuICAgICAgICAgICAgdmFyIF9hID0gZW5jb2RlZFR5cGUuc3BsaXQoJ3wnKSwgc3RyVHlwZSA9IF9hWzBdLCBzdHJQcm9wZXJ0aWVzID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHN0clByb3BlcnRpZXMuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHZhciBfYiA9IHN0clR5cGUuc3BsaXQoJ14nKSwgdHlwZU5hbWVzID0gX2JbMF0sIHN1cGVyTmFtZSA9IF9iWzFdO1xuICAgICAgICAgICAgdHlwZU5hbWVzLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7IHJldHVybiBfdGhpcy5fc2NoZW1hW3RhZy50b0xvd2VyQ2FzZSgpXSA9IHR5cGU7IH0pO1xuICAgICAgICAgICAgdmFyIHN1cGVyVHlwZSA9IHN1cGVyTmFtZSAmJiBfdGhpcy5fc2NoZW1hW3N1cGVyTmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgIGlmIChzdXBlclR5cGUpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzdXBlclR5cGUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgdHlwZVtwcm9wXSA9IHN1cGVyVHlwZVtwcm9wXTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wZXJ0eVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgeWV0IHN1cHBvcnQgZXZlbnRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGV2ZXIgYWxsb3dpbmcgdG8gYmluZCB0byBldmVudHMsIEdPIFRIUk9VR0ggQSBTRUNVUklUWSBSRVZJRVcsIGFsbG93aW5nIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbG1vc3QgY2VydGFpbmx5IGludHJvZHVjZSBiYWQgWFNTIHZ1bG5lcmFiaWxpdGllcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0eXBlW3Byb3BlcnR5LnN1YnN0cmluZygxKV0gPSBFVkVOVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVbcHJvcGVydHkuc3Vic3RyaW5nKDEpXSA9IEJPT0xFQU47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5LnN1YnN0cmluZygxKV0gPSBOVU1CRVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5LnN1YnN0cmluZygxKV0gPSBPQkpFQ1Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVbcHJvcGVydHldID0gU1RSSU5HO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnTmFtZVxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcGFyYW0gez99IHNjaGVtYU1ldGFzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmhhc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BOYW1lLCBzY2hlbWFNZXRhcykge1xuICAgICAgICBpZiAoc2NoZW1hTWV0YXMuc29tZShmdW5jdGlvbiAoc2NoZW1hKSB7IHJldHVybiBzY2hlbWEubmFtZSA9PT0gTk9fRVJST1JTX1NDSEVNQS5uYW1lOyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChpc05nQ29udGFpbmVyKHRhZ05hbWUpIHx8IGlzTmdDb250ZW50KHRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hLm5hbWUgPT09IENVU1RPTV9FTEVNRU5UU19TQ0hFTUEubmFtZTsgfSkpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW4ndCB0ZWxsIG5vdyBhcyB3ZSBkb24ndCBrbm93IHdoaWNoIHByb3BlcnRpZXMgYSBjdXN0b20gZWxlbWVudCB3aWxsIGdldFxuICAgICAgICAgICAgICAgIC8vIG9uY2UgaXQgaXMgaW5zdGFudGlhdGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudFByb3BlcnRpZXMgPSB0aGlzLl9zY2hlbWFbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCB0aGlzLl9zY2hlbWFbJ3Vua25vd24nXTtcbiAgICAgICAgcmV0dXJuICEhZWxlbWVudFByb3BlcnRpZXNbcHJvcE5hbWVdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YWdOYW1lXG4gICAgICogQHBhcmFtIHs/fSBzY2hlbWFNZXRhc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5oYXNFbGVtZW50ID0gZnVuY3Rpb24gKHRhZ05hbWUsIHNjaGVtYU1ldGFzKSB7XG4gICAgICAgIGlmIChzY2hlbWFNZXRhcy5zb21lKGZ1bmN0aW9uIChzY2hlbWEpIHsgcmV0dXJuIHNjaGVtYS5uYW1lID09PSBOT19FUlJPUlNfU0NIRU1BLm5hbWU7IH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgaWYgKGlzTmdDb250YWluZXIodGFnTmFtZSkgfHwgaXNOZ0NvbnRlbnQodGFnTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWFNZXRhcy5zb21lKGZ1bmN0aW9uIChzY2hlbWEpIHsgcmV0dXJuIHNjaGVtYS5uYW1lID09PSBDVVNUT01fRUxFTUVOVFNfU0NIRU1BLm5hbWU7IH0pKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgYW55IGN1c3RvbSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIXRoaXMuX3NjaGVtYVt0YWdOYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc2VjdXJpdHlDb250ZXh0IHJldHVybnMgdGhlIHNlY3VyaXR5IGNvbnRleHQgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSBvbiB0aGUgZ2l2ZW4gRE9NIHRhZy5cbiAgICAgKlxuICAgICAqIFRhZyBhbmQgcHJvcGVydHkgbmFtZSBhcmUgc3RhdGljYWxseSBrbm93biBhbmQgY2Fubm90IGNoYW5nZSBhdCBydW50aW1lLCBpLmUuIGl0IGlzIG5vdFxuICAgICAqIHBvc3NpYmxlIHRvIGJpbmQgYSB2YWx1ZSBpbnRvIGEgY2hhbmdpbmcgYXR0cmlidXRlIG9yIHRhZyBuYW1lLlxuICAgICAqXG4gICAgICogVGhlIGZpbHRlcmluZyBpcyB3aGl0ZSBsaXN0IGJhc2VkLiBBbGwgYXR0cmlidXRlcyBpbiB0aGUgc2NoZW1hIGFib3ZlIGFyZSBhc3N1bWVkIHRvIGhhdmUgdGhlXG4gICAgICogJ05PTkUnIHNlY3VyaXR5IGNvbnRleHQsIGkuZS4gdGhhdCB0aGV5IGFyZSBzYWZlIGluZXJ0IHN0cmluZyB2YWx1ZXMuIE9ubHkgc3BlY2lmaWMgd2VsbCBrbm93blxuICAgICAqIGF0dGFjayB2ZWN0b3JzIGFyZSBhc3NpZ25lZCB0aGVpciBhcHByb3ByaWF0ZSBjb250ZXh0LlxuICAgICAqIEBwYXJhbSB7P30gdGFnTmFtZVxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGlzQXR0cmlidXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLnNlY3VyaXR5Q29udGV4dCA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKGlzQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAvLyBOQjogRm9yIHNlY3VyaXR5IHB1cnBvc2VzLCB1c2UgdGhlIG1hcHBlZCBwcm9wZXJ0eSBuYW1lLCBub3QgdGhlIGF0dHJpYnV0ZSBuYW1lLlxuICAgICAgICAgICAgcHJvcE5hbWUgPSB0aGlzLmdldE1hcHBlZFByb3BOYW1lKHByb3BOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgY29tcGFyaXNvbnMgYXJlIGNhc2UgaW5zZW5zaXRpdmUsIHNvIHRoYXQgY2FzZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGF0dHJpYnV0ZSBhbmRcbiAgICAgICAgLy8gcHJvcGVydHkgbmFtZXMgZG8gbm90IGhhdmUgYSBzZWN1cml0eSBpbXBhY3QuXG4gICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHByb3BOYW1lID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R4ID0gU0VDVVJJVFlfU0NIRU1BW3RhZ05hbWUgKyAnfCcgKyBwcm9wTmFtZV07XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgIH1cbiAgICAgICAgY3R4ID0gU0VDVVJJVFlfU0NIRU1BWycqfCcgKyBwcm9wTmFtZV07XG4gICAgICAgIHJldHVybiBjdHggPyBjdHggOiBTZWN1cml0eUNvbnRleHQuTk9ORTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuZ2V0TWFwcGVkUHJvcE5hbWUgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHsgcmV0dXJuIF9BVFRSX1RPX1BST1BbcHJvcE5hbWVdIHx8IHByb3BOYW1lOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXREZWZhdWx0Q29tcG9uZW50RWxlbWVudE5hbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnbmctY29tcG9uZW50JzsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUudmFsaWRhdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnb24nKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbXNnID0gXCJCaW5kaW5nIHRvIGV2ZW50IHByb3BlcnR5ICdcIiArIG5hbWUgKyBcIicgaXMgZGlzYWxsb3dlZCBmb3Igc2VjdXJpdHkgcmVhc29ucywgXCIgK1xuICAgICAgICAgICAgICAgIChcInBsZWFzZSB1c2UgKFwiICsgbmFtZS5zbGljZSgyKSArIFwiKT0uLi5cIikgK1xuICAgICAgICAgICAgICAgIChcIlxcbklmICdcIiArIG5hbWUgKyBcIicgaXMgYSBkaXJlY3RpdmUgaW5wdXQsIG1ha2Ugc3VyZSB0aGUgZGlyZWN0aXZlIGlzIGltcG9ydGVkIGJ5IHRoZVwiKSArXG4gICAgICAgICAgICAgICAgXCIgY3VycmVudCBtb2R1bGUuXCI7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgbXNnOiBtc2cgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUudmFsaWRhdGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ29uJykpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1zZyA9IFwiQmluZGluZyB0byBldmVudCBhdHRyaWJ1dGUgJ1wiICsgbmFtZSArIFwiJyBpcyBkaXNhbGxvd2VkIGZvciBzZWN1cml0eSByZWFzb25zLCBcIiArXG4gICAgICAgICAgICAgICAgKFwicGxlYXNlIHVzZSAoXCIgKyBuYW1lLnNsaWNlKDIpICsgXCIpPS4uLlwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiB0cnVlLCBtc2c6IG1zZyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5hbGxLbm93bkVsZW1lbnROYW1lcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3NjaGVtYSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm9wTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5ub3JtYWxpemVBbmltYXRpb25TdHlsZVByb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgIHJldHVybiBkYXNoQ2FzZVRvQ2FtZWxDYXNlKHByb3BOYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2FtZWxDYXNlUHJvcFxuICAgICAqIEBwYXJhbSB7P30gdXNlclByb3ZpZGVkUHJvcFxuICAgICAqIEBwYXJhbSB7P30gdmFsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLm5vcm1hbGl6ZUFuaW1hdGlvblN0eWxlVmFsdWUgPSBmdW5jdGlvbiAoY2FtZWxDYXNlUHJvcCwgdXNlclByb3ZpZGVkUHJvcCwgdmFsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVuaXQgPSAnJztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyVmFsID0gdmFsLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvck1zZyA9ICgobnVsbCkpO1xuICAgICAgICBpZiAoX2lzUGl4ZWxEaW1lbnNpb25TdHlsZShjYW1lbENhc2VQcm9wKSAmJiB2YWwgIT09IDAgJiYgdmFsICE9PSAnMCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHVuaXQgPSAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsQW5kU3VmZml4TWF0Y2ggPSB2YWwubWF0Y2goL15bKy1dP1tcXGRcXC5dKyhbYS16XSopJC8pO1xuICAgICAgICAgICAgICAgIGlmICh2YWxBbmRTdWZmaXhNYXRjaCAmJiB2YWxBbmRTdWZmaXhNYXRjaFsxXS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1zZyA9IFwiUGxlYXNlIHByb3ZpZGUgYSBDU1MgdW5pdCB2YWx1ZSBmb3IgXCIgKyB1c2VyUHJvdmlkZWRQcm9wICsgXCI6XCIgKyB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGVycm9yOiBlcnJvck1zZywgdmFsdWU6IHN0clZhbCArIHVuaXQgfTtcbiAgICB9O1xuICAgIHJldHVybiBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnk7XG59KEVsZW1lbnRTY2hlbWFSZWdpc3RyeSkpO1xuRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkRvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBAcGFyYW0gez99IHByb3BcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9pc1BpeGVsRGltZW5zaW9uU3R5bGUocHJvcCkge1xuICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICAgIGNhc2UgJ21pbldpZHRoJzpcbiAgICAgICAgY2FzZSAnbWluSGVpZ2h0JzpcbiAgICAgICAgY2FzZSAnbWF4V2lkdGgnOlxuICAgICAgICBjYXNlICdtYXhIZWlnaHQnOlxuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBjYXNlICdmb250U2l6ZSc6XG4gICAgICAgIGNhc2UgJ291dGxpbmVXaWR0aCc6XG4gICAgICAgIGNhc2UgJ291dGxpbmVPZmZzZXQnOlxuICAgICAgICBjYXNlICdwYWRkaW5nVG9wJzpcbiAgICAgICAgY2FzZSAncGFkZGluZ0xlZnQnOlxuICAgICAgICBjYXNlICdwYWRkaW5nQm90dG9tJzpcbiAgICAgICAgY2FzZSAncGFkZGluZ1JpZ2h0JzpcbiAgICAgICAgY2FzZSAnbWFyZ2luVG9wJzpcbiAgICAgICAgY2FzZSAnbWFyZ2luTGVmdCc6XG4gICAgICAgIGNhc2UgJ21hcmdpbkJvdHRvbSc6XG4gICAgICAgIGNhc2UgJ21hcmdpblJpZ2h0JzpcbiAgICAgICAgY2FzZSAnYm9yZGVyUmFkaXVzJzpcbiAgICAgICAgY2FzZSAnYm9yZGVyV2lkdGgnOlxuICAgICAgICBjYXNlICdib3JkZXJUb3BXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2JvcmRlckxlZnRXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2JvcmRlclJpZ2h0V2lkdGgnOlxuICAgICAgICBjYXNlICdib3JkZXJCb3R0b21XaWR0aCc6XG4gICAgICAgIGNhc2UgJ3RleHRJbmRlbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxudmFyIFNoYWRvd0NzcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2hhZG93Q3NzKCkge1xuICAgICAgICB0aGlzLnN0cmljdFN0eWxpbmcgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNzc1RleHRcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/PX0gaG9zdFNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLnNoaW1Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKGhvc3RTZWxlY3RvciA9PT0gdm9pZCAwKSB7IGhvc3RTZWxlY3RvciA9ICcnOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZU1hcHBpbmdVcmwgPSBleHRyYWN0U291cmNlTWFwcGluZ1VybChjc3NUZXh0KTtcbiAgICAgICAgY3NzVGV4dCA9IHN0cmlwQ29tbWVudHMoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnREaXJlY3RpdmVzKGNzc1RleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGVDc3NUZXh0KGNzc1RleHQsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpICsgc291cmNlTWFwcGluZ1VybDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5faW5zZXJ0RGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnRQb2x5ZmlsbERpcmVjdGl2ZXNJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnRQb2x5ZmlsbFJ1bGVzSW5Dc3NUZXh0KGNzc1RleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc3NUZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnRQb2x5ZmlsbERpcmVjdGl2ZXNJbkNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICAvLyBEaWZmZXJlbmNlIHdpdGggd2ViY29tcG9uZW50cy5qczogZG9lcyBub3QgaGFuZGxlIGNvbW1lbnRzXG4gICAgICAgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoX2Nzc0NvbnRlbnROZXh0U2VsZWN0b3JSZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1bMl0gKyAneyc7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc3NUZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnRQb2x5ZmlsbFJ1bGVzSW5Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgLy8gRGlmZmVyZW5jZSB3aXRoIHdlYmNvbXBvbmVudHMuanM6IGRvZXMgbm90IGhhbmRsZSBjb21tZW50c1xuICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKF9jc3NDb250ZW50UnVsZVJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBtW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBydWxlID0gbVswXS5yZXBsYWNlKG1bMV0sICcnKS5yZXBsYWNlKG1bMl0sICcnKTtcbiAgICAgICAgICAgIHJldHVybiBtWzRdICsgcnVsZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNzc1RleHRcbiAgICAgKiBAcGFyYW0gez99IHNjb3BlU2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGhvc3RTZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fc2NvcGVDc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1bnNjb3BlZFJ1bGVzID0gdGhpcy5fZXh0cmFjdFVuc2NvcGVkUnVsZXNGcm9tQ3NzVGV4dChjc3NUZXh0KTtcbiAgICAgICAgLy8gcmVwbGFjZSA6aG9zdCBhbmQgOmhvc3QtY29udGV4dCAtc2hhZG93Y3NzaG9zdCBhbmQgLXNoYWRvd2Nzc2hvc3QgcmVzcGVjdGl2ZWx5XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnRQb2x5ZmlsbEhvc3RJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0Q29sb25Ib3N0KGNzc1RleHQpO1xuICAgICAgICBjc3NUZXh0ID0gdGhpcy5fY29udmVydENvbG9uSG9zdENvbnRleHQoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzKGNzc1RleHQpO1xuICAgICAgICBpZiAoc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgY3NzVGV4dCA9IHRoaXMuX3Njb3BlU2VsZWN0b3JzKGNzc1RleHQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgY3NzVGV4dCA9IGNzc1RleHQgKyAnXFxuJyArIHVuc2NvcGVkUnVsZXM7XG4gICAgICAgIHJldHVybiBjc3NUZXh0LnRyaW0oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fZXh0cmFjdFVuc2NvcGVkUnVsZXNGcm9tQ3NzVGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB3ZWJjb21wb25lbnRzLmpzOiBkb2VzIG5vdCBoYW5kbGUgY29tbWVudHNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gciA9ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtO1xuICAgICAgICBfY3NzQ29udGVudFVuc2NvcGVkUnVsZVJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlICgobSA9IF9jc3NDb250ZW50VW5zY29wZWRSdWxlUmUuZXhlYyhjc3NUZXh0KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJ1bGUgPSBtWzBdLnJlcGxhY2UobVsyXSwgJycpLnJlcGxhY2UobVsxXSwgbVs0XSk7XG4gICAgICAgICAgICByICs9IHJ1bGUgKyAnXFxuXFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29udmVydENvbG9uSG9zdCA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0Q29sb25SdWxlKGNzc1RleHQsIF9jc3NDb2xvbkhvc3RSZSwgdGhpcy5fY29sb25Ib3N0UGFydFJlcGxhY2VyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29udmVydENvbG9uSG9zdENvbnRleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydENvbG9uUnVsZShjc3NUZXh0LCBfY3NzQ29sb25Ib3N0Q29udGV4dFJlLCB0aGlzLl9jb2xvbkhvc3RDb250ZXh0UGFydFJlcGxhY2VyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICAgICAqIEBwYXJhbSB7P30gcmVnRXhwXG4gICAgICogQHBhcmFtIHs/fSBwYXJ0UmVwbGFjZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbnZlcnRDb2xvblJ1bGUgPSBmdW5jdGlvbiAoY3NzVGV4dCwgcmVnRXhwLCBwYXJ0UmVwbGFjZXIpIHtcbiAgICAgICAgLy8gbVsxXSA9IDpob3N0KC1jb250ZXh0KSwgbVsyXSA9IGNvbnRlbnRzIG9mICgpLCBtWzNdIHJlc3Qgb2YgcnVsZVxuICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKHJlZ0V4cCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1bMl0pIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IG1bMl0uc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHAgPSBwYXJ0c1tpXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICByLnB1c2gocGFydFJlcGxhY2VyKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IsIHAsIG1bM10pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIuam9pbignLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IgKyBtWzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaG9zdFxuICAgICAqIEBwYXJhbSB7P30gcGFydFxuICAgICAqIEBwYXJhbSB7P30gc3VmZml4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb2xvbkhvc3RDb250ZXh0UGFydFJlcGxhY2VyID0gZnVuY3Rpb24gKGhvc3QsIHBhcnQsIHN1ZmZpeCkge1xuICAgICAgICBpZiAocGFydC5pbmRleE9mKF9wb2x5ZmlsbEhvc3QpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvbkhvc3RQYXJ0UmVwbGFjZXIoaG9zdCwgcGFydCwgc3VmZml4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBob3N0ICsgcGFydCArIHN1ZmZpeCArICcsICcgKyBwYXJ0ICsgJyAnICsgaG9zdCArIHN1ZmZpeDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBob3N0XG4gICAgICogQHBhcmFtIHs/fSBwYXJ0XG4gICAgICogQHBhcmFtIHs/fSBzdWZmaXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbG9uSG9zdFBhcnRSZXBsYWNlciA9IGZ1bmN0aW9uIChob3N0LCBwYXJ0LCBzdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIGhvc3QgKyBwYXJ0LnJlcGxhY2UoX3BvbHlmaWxsSG9zdCwgJycpICsgc3VmZml4O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc3NUZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgcmV0dXJuIF9zaGFkb3dET01TZWxlY3RvcnNSZS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgcGF0dGVybikgeyByZXR1cm4gcmVzdWx0LnJlcGxhY2UocGF0dGVybiwgJyAnKTsgfSwgY3NzVGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNzc1RleHRcbiAgICAgKiBAcGFyYW0gez99IHNjb3BlU2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGhvc3RTZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fc2NvcGVTZWxlY3RvcnMgPSBmdW5jdGlvbiAoY3NzVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBwcm9jZXNzUnVsZXMoY3NzVGV4dCwgZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdG9yID0gcnVsZS5zZWxlY3RvcjtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRlbnQgPSBydWxlLmNvbnRlbnQ7XG4gICAgICAgICAgICBpZiAocnVsZS5zZWxlY3RvclswXSAhPSAnQCcpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zY29wZVNlbGVjdG9yKHJ1bGUuc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3RvciwgX3RoaXMuc3RyaWN0U3R5bGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BtZWRpYScpIHx8IHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQHN1cHBvcnRzJykgfHxcbiAgICAgICAgICAgICAgICBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BwYWdlJykgfHwgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAZG9jdW1lbnQnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBfdGhpcy5fc2NvcGVTZWxlY3RvcnMocnVsZS5jb250ZW50LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDc3NSdWxlKHNlbGVjdG9yLCBjb250ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBzY29wZVNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBob3N0U2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IHN0cmljdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fc2NvcGVTZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnNwbGl0KCcsJylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHBhcnQpIHsgcmV0dXJuIHBhcnQudHJpbSgpLnNwbGl0KF9zaGFkb3dEZWVwU2VsZWN0b3JzKTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRlZXBQYXJ0cykge1xuICAgICAgICAgICAgdmFyIHNoYWxsb3dQYXJ0ID0gZGVlcFBhcnRzWzBdLCBvdGhlclBhcnRzID0gZGVlcFBhcnRzLnNsaWNlKDEpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXBwbHlTY29wZSA9IGZ1bmN0aW9uIChzaGFsbG93UGFydCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc2VsZWN0b3JOZWVkc1Njb3Bpbmcoc2hhbGxvd1BhcnQsIHNjb3BlU2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpY3QgP1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FwcGx5U3RyaWN0U2VsZWN0b3JTY29wZShzaGFsbG93UGFydCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXBwbHlTZWxlY3RvclNjb3BlKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3dQYXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gW2FwcGx5U2NvcGUoc2hhbGxvd1BhcnQpXS5jb25jYXQob3RoZXJQYXJ0cykuam9pbignICcpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBzY29wZVNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9zZWxlY3Rvck5lZWRzU2NvcGluZyA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZSA9IHRoaXMuX21ha2VTY29wZU1hdGNoZXIoc2NvcGVTZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiAhcmUudGVzdChzZWxlY3Rvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNjb3BlU2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX21ha2VTY29wZU1hdGNoZXIgPSBmdW5jdGlvbiAoc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBscmUgPSAvXFxbL2c7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJyZSA9IC9cXF0vZztcbiAgICAgICAgc2NvcGVTZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IucmVwbGFjZShscmUsICdcXFxcWycpLnJlcGxhY2UocnJlLCAnXFxcXF0nKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14oJyArIHNjb3BlU2VsZWN0b3IgKyAnKScgKyBfc2VsZWN0b3JSZVN1ZmZpeCwgJ20nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IHNjb3BlU2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGhvc3RTZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fYXBwbHlTZWxlY3RvclNjb3BlID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgLy8gRGlmZmVyZW5jZSBmcm9tIHdlYmNvbXBvbmVudHMuanM6IHNjb3BlU2VsZWN0b3IgY291bGQgbm90IGJlIGFuIGFycmF5XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBzY29wZVNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBob3N0U2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2FwcGx5U2ltcGxlU2VsZWN0b3JTY29wZSA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgIC8vIEluIEFuZHJvaWQgYnJvd3NlciwgdGhlIGxhc3RJbmRleCBpcyBub3QgcmVzZXQgd2hlbiB0aGUgcmVnZXggaXMgdXNlZCBpbiBTdHJpbmcucmVwbGFjZSgpXG4gICAgICAgIF9wb2x5ZmlsbEhvc3RSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICBpZiAoX3BvbHlmaWxsSG9zdFJlLnRlc3Qoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXBsYWNlQnlfMSA9IHRoaXMuc3RyaWN0U3R5bGluZyA/IFwiW1wiICsgaG9zdFNlbGVjdG9yICsgXCJdXCIgOiBzY29wZVNlbGVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvclJlLCBmdW5jdGlvbiAoaG5jLCBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKC8oW146XSopKDoqKSguKikvLCBmdW5jdGlvbiAoXywgYmVmb3JlLCBjb2xvbiwgYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlZm9yZSArIHJlcGxhY2VCeV8xICsgY29sb24gKyBhZnRlcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoX3BvbHlmaWxsSG9zdFJlLCByZXBsYWNlQnlfMSArICcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3BlU2VsZWN0b3IgKyAnICcgKyBzZWxlY3RvcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IHNjb3BlU2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGhvc3RTZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fYXBwbHlTdHJpY3RTZWxlY3RvclNjb3BlID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNSZSA9IC9cXFtpcz0oW15cXF1dKilcXF0vZztcbiAgICAgICAgc2NvcGVTZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IucmVwbGFjZShpc1JlLCBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHBhcnRzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnRzWzBdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0ck5hbWUgPSAnWycgKyBzY29wZVNlbGVjdG9yICsgJ10nO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBfc2NvcGVTZWxlY3RvclBhcnQgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2NvcGVkUCA9IHAudHJpbSgpO1xuICAgICAgICAgICAgaWYgKCFzY29wZWRQKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAuaW5kZXhPZihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVkUCA9IF90aGlzLl9hcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUocCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSA6aG9zdCBzaW5jZSBpdCBzaG91bGQgYmUgdW5uZWNlc3NhcnlcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ID0gcC5yZXBsYWNlKF9wb2x5ZmlsbEhvc3RSZSwgJycpO1xuICAgICAgICAgICAgICAgIGlmICh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlcyA9IHQubWF0Y2goLyhbXjpdKikoOiopKC4qKS8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVkUCA9IG1hdGNoZXNbMV0gKyBhdHRyTmFtZSArIG1hdGNoZXNbMl0gKyBtYXRjaGVzWzNdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNjb3BlZFA7XG4gICAgICAgIH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNhZmVDb250ZW50ID0gbmV3IFNhZmVTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIHNlbGVjdG9yID0gc2FmZUNvbnRlbnQuY29udGVudCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY29wZWRTZWxlY3RvciA9ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZXAgPSAvKCB8PnxcXCt8fig/IT0pKVxccyovZztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2NvcGVBZnRlciA9IHNlbGVjdG9yLmluZGV4T2YoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcik7XG4gICAgICAgIHdoaWxlICgocmVzID0gc2VwLmV4ZWMoc2VsZWN0b3IpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VwYXJhdG9yID0gcmVzWzFdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydCA9IHNlbGVjdG9yLnNsaWNlKHN0YXJ0SW5kZXgsIHJlcy5pbmRleCkudHJpbSgpO1xuICAgICAgICAgICAgLy8gaWYgYSBzZWxlY3RvciBhcHBlYXJzIGJlZm9yZSA6aG9zdC1jb250ZXh0IGl0IHNob3VsZCBub3QgYmUgc2hpbW1lZCBhcyBpdFxuICAgICAgICAgICAgLy8gbWF0Y2hlcyBvbiBhbmNlc3RvciBlbGVtZW50cyBhbmQgbm90IG9uIGVsZW1lbnRzIGluIHRoZSBob3N0J3Mgc2hhZG93XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY29wZWRQYXJ0ID0gc3RhcnRJbmRleCA+PSBzY29wZUFmdGVyID8gX3Njb3BlU2VsZWN0b3JQYXJ0KHBhcnQpIDogcGFydDtcbiAgICAgICAgICAgIHNjb3BlZFNlbGVjdG9yICs9IHNjb3BlZFBhcnQgKyBcIiBcIiArIHNlcGFyYXRvciArIFwiIFwiO1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IHNlcC5sYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgc2NvcGVkU2VsZWN0b3IgKz0gX3Njb3BlU2VsZWN0b3JQYXJ0KHNlbGVjdG9yLnN1YnN0cmluZyhzdGFydEluZGV4KSk7XG4gICAgICAgIC8vIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVycyB3aXRoIHRoZWlyIG9yaWdpbmFsIHZhbHVlc1xuICAgICAgICByZXR1cm4gc2FmZUNvbnRlbnQucmVzdG9yZShzY29wZWRTZWxlY3Rvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnRQb2x5ZmlsbEhvc3RJbkNzc1RleHQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoX2NvbG9uSG9zdENvbnRleHRSZSwgX3BvbHlmaWxsSG9zdENvbnRleHQpXG4gICAgICAgICAgICAucmVwbGFjZShfY29sb25Ib3N0UmUsIF9wb2x5ZmlsbEhvc3QpO1xuICAgIH07XG4gICAgcmV0dXJuIFNoYWRvd0Nzcztcbn0oKSk7XG52YXIgU2FmZVNlbGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2FmZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJzID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAvLyBSZXBsYWNlcyBhdHRyaWJ1dGUgc2VsZWN0b3JzIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAgICAvLyBUaGUgV1MgaW4gW2F0dHI9XCJ2YSBsdWVcIl0gd291bGQgb3RoZXJ3aXNlIGJlIGludGVycHJldGVkIGFzIGEgc2VsZWN0b3Igc2VwYXJhdG9yLlxuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoLyhcXFtbXlxcXV0qXFxdKS9nLCBmdW5jdGlvbiAoXywga2VlcCkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VCeSA9IFwiX19waC1cIiArIF90aGlzLmluZGV4ICsgXCJfX1wiO1xuICAgICAgICAgICAgX3RoaXMucGxhY2Vob2xkZXJzLnB1c2goa2VlcCk7XG4gICAgICAgICAgICBfdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VCeTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlcGxhY2VzIHRoZSBleHByZXNzaW9uIGluIGA6bnRoLWNoaWxkKDJuICsgMSlgIHdpdGggYSBwbGFjZWhvbGRlci5cbiAgICAgICAgLy8gV1MgYW5kIFwiK1wiIHdvdWxkIG90aGVyd2lzZSBiZSBpbnRlcnByZXRlZCBhcyBzZWxlY3RvciBzZXBhcmF0b3JzLlxuICAgICAgICB0aGlzLl9jb250ZW50ID0gc2VsZWN0b3IucmVwbGFjZSgvKDpudGgtWy1cXHddKykoXFwoW14pXStcXCkpL2csIGZ1bmN0aW9uIChfLCBwc2V1ZG8sIGV4cCkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VCeSA9IFwiX19waC1cIiArIF90aGlzLmluZGV4ICsgXCJfX1wiO1xuICAgICAgICAgICAgX3RoaXMucGxhY2Vob2xkZXJzLnB1c2goZXhwKTtcbiAgICAgICAgICAgIF90aGlzLmluZGV4Kys7XG4gICAgICAgICAgICByZXR1cm4gcHNldWRvICsgcmVwbGFjZUJ5O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2FmZVNlbGVjdG9yLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvX19waC0oXFxkKylfXy9nLCBmdW5jdGlvbiAocGgsIGluZGV4KSB7IHJldHVybiBfdGhpcy5wbGFjZWhvbGRlcnNbK2luZGV4XTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNhZmVTZWxlY3Rvci5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7IH07XG4gICAgcmV0dXJuIFNhZmVTZWxlY3Rvcjtcbn0oKSk7XG52YXIgX2Nzc0NvbnRlbnROZXh0U2VsZWN0b3JSZSA9IC9wb2x5ZmlsbC1uZXh0LXNlbGVjdG9yW159XSpjb250ZW50OltcXHNdKj8oWydcIl0pKC4qPylcXDFbO1xcc10qfShbXntdKj8pey9naW07XG52YXIgX2Nzc0NvbnRlbnRSdWxlUmUgPSAvKHBvbHlmaWxsLXJ1bGUpW159XSooY29udGVudDpbXFxzXSooWydcIl0pKC4qPylcXDMpWztcXHNdKltefV0qfS9naW07XG52YXIgX2Nzc0NvbnRlbnRVbnNjb3BlZFJ1bGVSZSA9IC8ocG9seWZpbGwtdW5zY29wZWQtcnVsZSlbXn1dKihjb250ZW50OltcXHNdKihbJ1wiXSkoLio/KVxcMylbO1xcc10qW159XSp9L2dpbTtcbnZhciBfcG9seWZpbGxIb3N0ID0gJy1zaGFkb3djc3Nob3N0Jztcbi8vIG5vdGU6IDpob3N0LWNvbnRleHQgcHJlLXByb2Nlc3NlZCB0byAtc2hhZG93Y3NzaG9zdGNvbnRleHQuXG52YXIgX3BvbHlmaWxsSG9zdENvbnRleHQgPSAnLXNoYWRvd2Nzc2NvbnRleHQnO1xudmFyIF9wYXJlblN1ZmZpeCA9ICcpKD86XFxcXCgoJyArXG4gICAgJyg/OlxcXFwoW14pKF0qXFxcXCl8W14pKF0qKSs/JyArXG4gICAgJylcXFxcKSk/KFteLHtdKiknO1xudmFyIF9jc3NDb2xvbkhvc3RSZSA9IG5ldyBSZWdFeHAoJygnICsgX3BvbHlmaWxsSG9zdCArIF9wYXJlblN1ZmZpeCwgJ2dpbScpO1xudmFyIF9jc3NDb2xvbkhvc3RDb250ZXh0UmUgPSBuZXcgUmVnRXhwKCcoJyArIF9wb2x5ZmlsbEhvc3RDb250ZXh0ICsgX3BhcmVuU3VmZml4LCAnZ2ltJyk7XG52YXIgX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciA9IF9wb2x5ZmlsbEhvc3QgKyAnLW5vLWNvbWJpbmF0b3InO1xudmFyIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3JSZSA9IC8tc2hhZG93Y3NzaG9zdC1uby1jb21iaW5hdG9yKFteXFxzXSopLztcbnZhciBfc2hhZG93RE9NU2VsZWN0b3JzUmUgPSBbXG4gICAgLzo6c2hhZG93L2csXG4gICAgLzo6Y29udGVudC9nLFxuICAgIC8vIERlcHJlY2F0ZWQgc2VsZWN0b3JzXG4gICAgL1xcL3NoYWRvdy1kZWVwXFwvL2csXG4gICAgL1xcL3NoYWRvd1xcLy9nLFxuXTtcbnZhciBfc2hhZG93RGVlcFNlbGVjdG9ycyA9IC8oPzo+Pj4pfCg/OlxcL2RlZXBcXC8pL2c7XG52YXIgX3NlbGVjdG9yUmVTdWZmaXggPSAnKFs+XFxcXHN+K1xcWy4sezpdW1xcXFxzXFxcXFNdKik/JCc7XG52YXIgX3BvbHlmaWxsSG9zdFJlID0gLy1zaGFkb3djc3Nob3N0L2dpbTtcbnZhciBfY29sb25Ib3N0UmUgPSAvOmhvc3QvZ2ltO1xudmFyIF9jb2xvbkhvc3RDb250ZXh0UmUgPSAvOmhvc3QtY29udGV4dC9naW07XG52YXIgX2NvbW1lbnRSZSA9IC9cXC9cXCpcXHMqW1xcc1xcU10qP1xcKlxcLy9nO1xuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzdHJpcENvbW1lbnRzKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoX2NvbW1lbnRSZSwgJycpO1xufVxuLy8gYWxsIGNvbW1lbnRzIGV4Y2VwdCBpbmxpbmUgc291cmNlIG1hcHBpbmdcbnZhciBfc291cmNlTWFwcGluZ1VybFJlID0gL1xcL1xcKlxccyojXFxzKnNvdXJjZU1hcHBpbmdVUkw9W1xcc1xcU10rP1xcKlxcLy87XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RTb3VyY2VNYXBwaW5nVXJsKGlucHV0KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlciA9IGlucHV0Lm1hdGNoKF9zb3VyY2VNYXBwaW5nVXJsUmUpO1xuICAgIHJldHVybiBtYXRjaGVyID8gbWF0Y2hlclswXSA6ICcnO1xufVxudmFyIF9ydWxlUmUgPSAvKFxccyopKFteO1xce1xcfV0rPykoXFxzKikoKD86eyVCTE9DSyV9P1xccyo7Pyl8KD86XFxzKjspKS9nO1xudmFyIF9jdXJseVJlID0gLyhbe31dKS9nO1xudmFyIE9QRU5fQ1VSTFkgPSAneyc7XG52YXIgQ0xPU0VfQ1VSTFkgPSAnfSc7XG52YXIgQkxPQ0tfUExBQ0VIT0xERVIgPSAnJUJMT0NLJSc7XG52YXIgQ3NzUnVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENzc1J1bGUoc2VsZWN0b3IsIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIH1cbiAgICByZXR1cm4gQ3NzUnVsZTtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEBwYXJhbSB7P30gcnVsZUNhbGxiYWNrXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwcm9jZXNzUnVsZXMoaW5wdXQsIHJ1bGVDYWxsYmFjaykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGlucHV0V2l0aEVzY2FwZWRCbG9ja3MgPSBlc2NhcGVCbG9ja3MoaW5wdXQpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5leHRCbG9ja0luZGV4ID0gMDtcbiAgICByZXR1cm4gaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5lc2NhcGVkU3RyaW5nLnJlcGxhY2UoX3J1bGVSZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdG9yID0gbVsyXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGVudCA9ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdWZmaXggPSBtWzRdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZW50UHJlZml4ID0gJyc7XG4gICAgICAgIGlmIChzdWZmaXggJiYgc3VmZml4LnN0YXJ0c1dpdGgoJ3snICsgQkxPQ0tfUExBQ0VIT0xERVIpKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5ibG9ja3NbbmV4dEJsb2NrSW5kZXgrK107XG4gICAgICAgICAgICBzdWZmaXggPSBzdWZmaXguc3Vic3RyaW5nKEJMT0NLX1BMQUNFSE9MREVSLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgY29udGVudFByZWZpeCA9ICd7JztcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBydWxlID0gcnVsZUNhbGxiYWNrKG5ldyBDc3NSdWxlKHNlbGVjdG9yLCBjb250ZW50KSk7XG4gICAgICAgIHJldHVybiBcIlwiICsgbVsxXSArIHJ1bGUuc2VsZWN0b3IgKyBtWzNdICsgY29udGVudFByZWZpeCArIHJ1bGUuY29udGVudCArIHN1ZmZpeDtcbiAgICB9KTtcbn1cbnZhciBTdHJpbmdXaXRoRXNjYXBlZEJsb2NrcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlc2NhcGVkU3RyaW5nXG4gICAgICogQHBhcmFtIHs/fSBibG9ja3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdHJpbmdXaXRoRXNjYXBlZEJsb2Nrcyhlc2NhcGVkU3RyaW5nLCBibG9ja3MpIHtcbiAgICAgICAgdGhpcy5lc2NhcGVkU3RyaW5nID0gZXNjYXBlZFN0cmluZztcbiAgICAgICAgdGhpcy5ibG9ja3MgPSBibG9ja3M7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmdXaXRoRXNjYXBlZEJsb2Nrcztcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUJsb2NrcyhpbnB1dCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGlucHV0UGFydHMgPSBpbnB1dC5zcGxpdChfY3VybHlSZSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0UGFydHMgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlc2NhcGVkQmxvY2tzID0gW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYnJhY2tldENvdW50ID0gMDtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50QmxvY2tQYXJ0cyA9IFtdO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydEluZGV4ID0gMDsgcGFydEluZGV4IDwgaW5wdXRQYXJ0cy5sZW5ndGg7IHBhcnRJbmRleCsrKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnQgPSBpbnB1dFBhcnRzW3BhcnRJbmRleF07XG4gICAgICAgIGlmIChwYXJ0ID09IENMT1NFX0NVUkxZKSB7XG4gICAgICAgICAgICBicmFja2V0Q291bnQtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJhY2tldENvdW50ID4gMCkge1xuICAgICAgICAgICAgY3VycmVudEJsb2NrUGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50QmxvY2tQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZEJsb2Nrcy5wdXNoKGN1cnJlbnRCbG9ja1BhcnRzLmpvaW4oJycpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKEJMT0NLX1BMQUNFSE9MREVSKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxvY2tQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0UGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydCA9PSBPUEVOX0NVUkxZKSB7XG4gICAgICAgICAgICBicmFja2V0Q291bnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VycmVudEJsb2NrUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICBlc2NhcGVkQmxvY2tzLnB1c2goY3VycmVudEJsb2NrUGFydHMuam9pbignJykpO1xuICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKEJMT0NLX1BMQUNFSE9MREVSKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdXaXRoRXNjYXBlZEJsb2NrcyhyZXN1bHRQYXJ0cy5qb2luKCcnKSwgZXNjYXBlZEJsb2Nrcyk7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQ09NUE9ORU5UX1ZBUklBQkxFID0gJyVDT01QJSc7XG52YXIgSE9TVF9BVFRSID0gXCJfbmdob3N0LVwiICsgQ09NUE9ORU5UX1ZBUklBQkxFO1xudmFyIENPTlRFTlRfQVRUUiA9IFwiX25nY29udGVudC1cIiArIENPTVBPTkVOVF9WQVJJQUJMRTtcbnZhciBTdHlsZXNDb21waWxlRGVwZW5kZW5jeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVVcmxcbiAgICAgKiBAcGFyYW0gez99IGlzU2hpbW1lZFxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVQbGFjZWhvbGRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5KG5hbWUsIG1vZHVsZVVybCwgaXNTaGltbWVkLCB2YWx1ZVBsYWNlaG9sZGVyKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMubW9kdWxlVXJsID0gbW9kdWxlVXJsO1xuICAgICAgICB0aGlzLmlzU2hpbW1lZCA9IGlzU2hpbW1lZDtcbiAgICAgICAgdGhpcy52YWx1ZVBsYWNlaG9sZGVyID0gdmFsdWVQbGFjZWhvbGRlcjtcbiAgICB9XG4gICAgcmV0dXJuIFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5O1xufSgpKTtcbnZhciBTdHlsZXNDb21waWxlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFN0eWxlc2hlZXRcbiAgICAgKiBAcGFyYW0gez99IGV4dGVybmFsU3R5bGVzaGVldHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdHlsZXNDb21waWxlUmVzdWx0KGNvbXBvbmVudFN0eWxlc2hlZXQsIGV4dGVybmFsU3R5bGVzaGVldHMpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRTdHlsZXNoZWV0ID0gY29tcG9uZW50U3R5bGVzaGVldDtcbiAgICAgICAgdGhpcy5leHRlcm5hbFN0eWxlc2hlZXRzID0gZXh0ZXJuYWxTdHlsZXNoZWV0cztcbiAgICB9XG4gICAgcmV0dXJuIFN0eWxlc0NvbXBpbGVSZXN1bHQ7XG59KCkpO1xudmFyIENvbXBpbGVkU3R5bGVzaGVldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZW1lbnRzXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZXNWYXJcbiAgICAgKiBAcGFyYW0gez99IGRlcGVuZGVuY2llc1xuICAgICAqIEBwYXJhbSB7P30gaXNTaGltbWVkXG4gICAgICogQHBhcmFtIHs/fSBtZXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZWRTdHlsZXNoZWV0KHN0YXRlbWVudHMsIHN0eWxlc1ZhciwgZGVwZW5kZW5jaWVzLCBpc1NoaW1tZWQsIG1ldGEpIHtcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgdGhpcy5zdHlsZXNWYXIgPSBzdHlsZXNWYXI7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICB0aGlzLmlzU2hpbW1lZCA9IGlzU2hpbW1lZDtcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVkU3R5bGVzaGVldDtcbn0oKSk7XG52YXIgU3R5bGVDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfdXJsUmVzb2x2ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdHlsZUNvbXBpbGVyKF91cmxSZXNvbHZlcikge1xuICAgICAgICB0aGlzLl91cmxSZXNvbHZlciA9IF91cmxSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fc2hhZG93Q3NzID0gbmV3IFNoYWRvd0NzcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZSA9ICgoY29tcC50ZW1wbGF0ZSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHRlcm5hbFN0eWxlc2hlZXRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudFN0eWxlc2hlZXQgPSB0aGlzLl9jb21waWxlU3R5bGVzKGNvbXAsIG5ldyBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhKHtcbiAgICAgICAgICAgIHN0eWxlczogdGVtcGxhdGUuc3R5bGVzLFxuICAgICAgICAgICAgc3R5bGVVcmxzOiB0ZW1wbGF0ZS5zdHlsZVVybHMsXG4gICAgICAgICAgICBtb2R1bGVVcmw6IGlkZW50aWZpZXJNb2R1bGVVcmwoY29tcC50eXBlKVxuICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgICAgIHRlbXBsYXRlLmV4dGVybmFsU3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVzaGVldE1ldGEpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBpbGVkU3R5bGVzaGVldCA9IF90aGlzLl9jb21waWxlU3R5bGVzKGNvbXAsIHN0eWxlc2hlZXRNZXRhLCBmYWxzZSk7XG4gICAgICAgICAgICBleHRlcm5hbFN0eWxlc2hlZXRzLnB1c2goY29tcGlsZWRTdHlsZXNoZWV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgU3R5bGVzQ29tcGlsZVJlc3VsdChjb21wb25lbnRTdHlsZXNoZWV0LCBleHRlcm5hbFN0eWxlc2hlZXRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVzaGVldFxuICAgICAqIEBwYXJhbSB7P30gaXNDb21wb25lbnRTdHlsZXNoZWV0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdHlsZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZVN0eWxlcyA9IGZ1bmN0aW9uIChjb21wLCBzdHlsZXNoZWV0LCBpc0NvbXBvbmVudFN0eWxlc2hlZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2hpbSA9ICgoY29tcC50ZW1wbGF0ZSkpLmVuY2Fwc3VsYXRpb24gPT09IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZUV4cHJlc3Npb25zID0gc3R5bGVzaGVldC5zdHlsZXMubWFwKGZ1bmN0aW9uIChwbGFpblN0eWxlKSB7IHJldHVybiBsaXRlcmFsKF90aGlzLl9zaGltSWZOZWVkZWQocGxhaW5TdHlsZSwgc2hpbSkpOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwZW5kZW5jaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBzdHlsZXNoZWV0LnN0eWxlVXJscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWRlbnRpZmllciA9IHsgcmVmZXJlbmNlOiBudWxsIH07XG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChuZXcgU3R5bGVzQ29tcGlsZURlcGVuZGVuY3koZ2V0U3R5bGVzVmFyTmFtZShudWxsKSwgc3R5bGVzaGVldC5zdHlsZVVybHNbaV0sIHNoaW0sIGlkZW50aWZpZXIpKTtcbiAgICAgICAgICAgIHN0eWxlRXhwcmVzc2lvbnMucHVzaChuZXcgRXh0ZXJuYWxFeHByKGlkZW50aWZpZXIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdHlsZXMgdmFyaWFibGUgY29udGFpbnMgcGxhaW4gc3RyaW5ncyBhbmQgYXJyYXlzIG9mIG90aGVyIHN0eWxlcyBhcnJheXMgKHJlY3Vyc2l2ZSksXG4gICAgICAgIC8vIHNvIHdlIHNldCBpdHMgdHlwZSB0byBkeW5hbWljLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXNWYXIgPSBnZXRTdHlsZXNWYXJOYW1lKGlzQ29tcG9uZW50U3R5bGVzaGVldCA/IGNvbXAgOiBudWxsKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RtdCA9IHZhcmlhYmxlKHN0eWxlc1ZhcilcbiAgICAgICAgICAgIC5zZXQobGl0ZXJhbEFycihzdHlsZUV4cHJlc3Npb25zLCBuZXcgQXJyYXlUeXBlKERZTkFNSUNfVFlQRSwgW1R5cGVNb2RpZmllci5Db25zdF0pKSlcbiAgICAgICAgICAgIC50b0RlY2xTdG10KG51bGwsIFtTdG10TW9kaWZpZXIuRmluYWxdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlZFN0eWxlc2hlZXQoW3N0bXRdLCBzdHlsZXNWYXIsIGRlcGVuZGVuY2llcywgc2hpbSwgc3R5bGVzaGVldCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlXG4gICAgICogQHBhcmFtIHs/fSBzaGltXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdHlsZUNvbXBpbGVyLnByb3RvdHlwZS5fc2hpbUlmTmVlZGVkID0gZnVuY3Rpb24gKHN0eWxlJCQxLCBzaGltKSB7XG4gICAgICAgIHJldHVybiBzaGltID8gdGhpcy5fc2hhZG93Q3NzLnNoaW1Dc3NUZXh0KHN0eWxlJCQxLCBDT05URU5UX0FUVFIsIEhPU1RfQVRUUikgOiBzdHlsZSQkMTtcbiAgICB9O1xuICAgIHJldHVybiBTdHlsZUNvbXBpbGVyO1xufSgpKTtcblN0eWxlQ29tcGlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBpbGVySW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuU3R5bGVDb21waWxlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IFVybFJlc29sdmVyLCB9LFxuXTsgfTtcbi8qKlxuICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlc1Zhck5hbWUoY29tcG9uZW50KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gXCJzdHlsZXNcIjtcbiAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgIHJlc3VsdCArPSBcIl9cIiArIGlkZW50aWZpZXJOYW1lKGNvbXBvbmVudC50eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBFdmVudEhhbmRsZXJWYXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudEhhbmRsZXJWYXJzKCkge1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRIYW5kbGVyVmFycztcbn0oKSk7XG5FdmVudEhhbmRsZXJWYXJzLmV2ZW50ID0gdmFyaWFibGUoJyRldmVudCcpO1xudmFyIENvbnZlcnRBY3Rpb25CaW5kaW5nUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRzXG4gICAgICogQHBhcmFtIHs/fSBhbGxvd0RlZmF1bHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb252ZXJ0QWN0aW9uQmluZGluZ1Jlc3VsdChzdG10cywgYWxsb3dEZWZhdWx0KSB7XG4gICAgICAgIHRoaXMuc3RtdHMgPSBzdG10cztcbiAgICAgICAgdGhpcy5hbGxvd0RlZmF1bHQgPSBhbGxvd0RlZmF1bHQ7XG4gICAgfVxuICAgIHJldHVybiBDb252ZXJ0QWN0aW9uQmluZGluZ1Jlc3VsdDtcbn0oKSk7XG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBleHByZXNzaW9uIEFTVCBpbnRvIGFuIGV4ZWN1dGFibGUgb3V0cHV0IEFTVCwgYXNzdW1pbmcgdGhlIGV4cHJlc3Npb24gaXNcbiAqIHVzZWQgaW4gYW4gYWN0aW9uIGJpbmRpbmcgKGUuZy4gYW4gZXZlbnQgaGFuZGxlcikuXG4gKiBAcGFyYW0gez99IGxvY2FsUmVzb2x2ZXJcbiAqIEBwYXJhbSB7P30gaW1wbGljaXRSZWNlaXZlclxuICogQHBhcmFtIHs/fSBhY3Rpb25cbiAqIEBwYXJhbSB7P30gYmluZGluZ0lkXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0QWN0aW9uQmluZGluZyhsb2NhbFJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBhY3Rpb24sIGJpbmRpbmdJZCkge1xuICAgIGlmICghbG9jYWxSZXNvbHZlcikge1xuICAgICAgICBsb2NhbFJlc29sdmVyID0gbmV3IERlZmF1bHRMb2NhbFJlc29sdmVyKCk7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGFjdGlvbldpdGhvdXRCdWlsdGlucyA9IGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmdCdWlsdGlucyh7XG4gICAgICAgIGNyZWF0ZUxpdGVyYWxBcnJheUNvbnZlcnRlcjogZnVuY3Rpb24gKGFyZ0NvdW50KSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBubyBjYWNoaW5nIGZvciBsaXRlcmFsIGFycmF5cyBpbiBhY3Rpb25zLlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcmdzKSB7IHJldHVybiBsaXRlcmFsQXJyKGFyZ3MpOyB9O1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVMaXRlcmFsTWFwQ29udmVydGVyOiBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICAgICAgLy8gTm90ZTogbm8gY2FjaGluZyBmb3IgbGl0ZXJhbCBtYXBzIGluIGFjdGlvbnMuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHsgcmV0dXJuIGxpdGVyYWxNYXAoLyoqIEB0eXBlIHs/fSAqLyAoa2V5cy5tYXAoZnVuY3Rpb24gKGtleSwgaSkgeyByZXR1cm4gW2tleSwgYXJnc1tpXV07IH0pKSk7IH07XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZVBpcGVDb252ZXJ0ZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIFN0YXRlOiBBY3Rpb25zIGFyZSBub3QgYWxsb3dlZCB0byBjb250YWluIHBpcGVzLiBQaXBlOiBcIiArIG5hbWUpO1xuICAgICAgICB9XG4gICAgfSwgYWN0aW9uKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdG9yID0gbmV3IF9Bc3RUb0lyVmlzaXRvcihsb2NhbFJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBiaW5kaW5nSWQpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGFjdGlvblN0bXRzID0gW107XG4gICAgZmxhdHRlblN0YXRlbWVudHMoYWN0aW9uV2l0aG91dEJ1aWx0aW5zLnZpc2l0KHZpc2l0b3IsIF9Nb2RlLlN0YXRlbWVudCksIGFjdGlvblN0bXRzKTtcbiAgICBwcmVwZW5kVGVtcG9yYXJ5RGVjbHModmlzaXRvci50ZW1wb3JhcnlDb3VudCwgYmluZGluZ0lkLCBhY3Rpb25TdG10cyk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGFzdEluZGV4ID0gYWN0aW9uU3RtdHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2ZW50RGVmYXVsdFZhciA9ICgobnVsbCkpO1xuICAgIGlmIChsYXN0SW5kZXggPj0gMCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYXN0U3RhdGVtZW50ID0gYWN0aW9uU3RtdHNbbGFzdEluZGV4XTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmV0dXJuRXhwciA9IGNvbnZlcnRTdG10SW50b0V4cHJlc3Npb24obGFzdFN0YXRlbWVudCk7XG4gICAgICAgIGlmIChyZXR1cm5FeHByKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBXZSBuZWVkIHRvIGNhc3QgdGhlIHJlc3VsdCBvZiB0aGUgbWV0aG9kIGNhbGwgdG8gZHluYW1pYyxcbiAgICAgICAgICAgIC8vIGFzIGl0IG1pZ2h0IGJlIGEgdm9pZCBtZXRob2QhXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdFZhciA9IGNyZWF0ZVByZXZlbnREZWZhdWx0VmFyKGJpbmRpbmdJZCk7XG4gICAgICAgICAgICBhY3Rpb25TdG10c1tsYXN0SW5kZXhdID1cbiAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdFZhci5zZXQocmV0dXJuRXhwci5jYXN0KERZTkFNSUNfVFlQRSkubm90SWRlbnRpY2FsKGxpdGVyYWwoZmFsc2UpKSlcbiAgICAgICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29udmVydEFjdGlvbkJpbmRpbmdSZXN1bHQoYWN0aW9uU3RtdHMsIHByZXZlbnREZWZhdWx0VmFyKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb252ZXJ0ZXJGYWN0b3J5XG4gKiBAcGFyYW0gez99IGFzdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29udmVydFByb3BlcnR5QmluZGluZ0J1aWx0aW5zKGNvbnZlcnRlckZhY3RvcnksIGFzdCkge1xuICAgIHJldHVybiBjb252ZXJ0QnVpbHRpbnMoY29udmVydGVyRmFjdG9yeSwgYXN0KTtcbn1cbnZhciBDb252ZXJ0UHJvcGVydHlCaW5kaW5nUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRzXG4gICAgICogQHBhcmFtIHs/fSBjdXJyVmFsRXhwclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbnZlcnRQcm9wZXJ0eUJpbmRpbmdSZXN1bHQoc3RtdHMsIGN1cnJWYWxFeHByKSB7XG4gICAgICAgIHRoaXMuc3RtdHMgPSBzdG10cztcbiAgICAgICAgdGhpcy5jdXJyVmFsRXhwciA9IGN1cnJWYWxFeHByO1xuICAgIH1cbiAgICByZXR1cm4gQ29udmVydFByb3BlcnR5QmluZGluZ1Jlc3VsdDtcbn0oKSk7XG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBleHByZXNzaW9uIEFTVCBpbnRvIGFuIGV4ZWN1dGFibGUgb3V0cHV0IEFTVCwgYXNzdW1pbmcgdGhlIGV4cHJlc3Npb25cbiAqIGlzIHVzZWQgaW4gcHJvcGVydHkgYmluZGluZy4gVGhlIGV4cHJlc3Npb24gaGFzIHRvIGJlIHByZXByb2Nlc3NlZCB2aWFcbiAqIGBjb252ZXJ0UHJvcGVydHlCaW5kaW5nQnVpbHRpbnNgLlxuICogQHBhcmFtIHs/fSBsb2NhbFJlc29sdmVyXG4gKiBAcGFyYW0gez99IGltcGxpY2l0UmVjZWl2ZXJcbiAqIEBwYXJhbSB7P30gZXhwcmVzc2lvbldpdGhvdXRCdWlsdGluc1xuICogQHBhcmFtIHs/fSBiaW5kaW5nSWRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcobG9jYWxSZXNvbHZlciwgaW1wbGljaXRSZWNlaXZlciwgZXhwcmVzc2lvbldpdGhvdXRCdWlsdGlucywgYmluZGluZ0lkKSB7XG4gICAgaWYgKCFsb2NhbFJlc29sdmVyKSB7XG4gICAgICAgIGxvY2FsUmVzb2x2ZXIgPSBuZXcgRGVmYXVsdExvY2FsUmVzb2x2ZXIoKTtcbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VyclZhbEV4cHIgPSBjcmVhdGVDdXJyVmFsdWVFeHByKGJpbmRpbmdJZCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RtdHMgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdG9yID0gbmV3IF9Bc3RUb0lyVmlzaXRvcihsb2NhbFJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBiaW5kaW5nSWQpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dHB1dEV4cHIgPSBleHByZXNzaW9uV2l0aG91dEJ1aWx0aW5zLnZpc2l0KHZpc2l0b3IsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgIGlmICh2aXNpdG9yLnRlbXBvcmFyeUNvdW50KSB7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB2aXNpdG9yLnRlbXBvcmFyeUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHN0bXRzLnB1c2godGVtcG9yYXJ5RGVjbGFyYXRpb24oYmluZGluZ0lkLCBpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RtdHMucHVzaChjdXJyVmFsRXhwci5zZXQob3V0cHV0RXhwcikudG9EZWNsU3RtdChudWxsLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSkpO1xuICAgIHJldHVybiBuZXcgQ29udmVydFByb3BlcnR5QmluZGluZ1Jlc3VsdChzdG10cywgY3VyclZhbEV4cHIpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvbnZlcnRlckZhY3RvcnlcbiAqIEBwYXJhbSB7P30gYXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0QnVpbHRpbnMoY29udmVydGVyRmFjdG9yeSwgYXN0KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBfQnVpbHRpbkFzdENvbnZlcnRlcihjb252ZXJ0ZXJGYWN0b3J5KTtcbiAgICByZXR1cm4gYXN0LnZpc2l0KHZpc2l0b3IpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGJpbmRpbmdJZFxuICogQHBhcmFtIHs/fSB0ZW1wb3JhcnlOdW1iZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRlbXBvcmFyeU5hbWUoYmluZGluZ0lkLCB0ZW1wb3JhcnlOdW1iZXIpIHtcbiAgICByZXR1cm4gXCJ0bXBfXCIgKyBiaW5kaW5nSWQgKyBcIl9cIiArIHRlbXBvcmFyeU51bWJlcjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBiaW5kaW5nSWRcbiAqIEBwYXJhbSB7P30gdGVtcG9yYXJ5TnVtYmVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0ZW1wb3JhcnlEZWNsYXJhdGlvbihiaW5kaW5nSWQsIHRlbXBvcmFyeU51bWJlcikge1xuICAgIHJldHVybiBuZXcgRGVjbGFyZVZhclN0bXQodGVtcG9yYXJ5TmFtZShiaW5kaW5nSWQsIHRlbXBvcmFyeU51bWJlciksIE5VTExfRVhQUik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdGVtcG9yYXJ5Q291bnRcbiAqIEBwYXJhbSB7P30gYmluZGluZ0lkXG4gKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHByZXBlbmRUZW1wb3JhcnlEZWNscyh0ZW1wb3JhcnlDb3VudCwgYmluZGluZ0lkLCBzdGF0ZW1lbnRzKSB7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gdGVtcG9yYXJ5Q291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBzdGF0ZW1lbnRzLnVuc2hpZnQodGVtcG9yYXJ5RGVjbGFyYXRpb24oYmluZGluZ0lkLCBpKSk7XG4gICAgfVxufVxudmFyIF9Nb2RlID0ge307XG5fTW9kZS5TdGF0ZW1lbnQgPSAwO1xuX01vZGUuRXhwcmVzc2lvbiA9IDE7XG5fTW9kZVtfTW9kZS5TdGF0ZW1lbnRdID0gXCJTdGF0ZW1lbnRcIjtcbl9Nb2RlW19Nb2RlLkV4cHJlc3Npb25dID0gXCJFeHByZXNzaW9uXCI7XG4vKipcbiAqIEBwYXJhbSB7P30gbW9kZVxuICogQHBhcmFtIHs/fSBhc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGVuc3VyZVN0YXRlbWVudE1vZGUobW9kZSwgYXN0KSB7XG4gICAgaWYgKG1vZGUgIT09IF9Nb2RlLlN0YXRlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhIHN0YXRlbWVudCwgYnV0IHNhdyBcIiArIGFzdCk7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IG1vZGVcbiAqIEBwYXJhbSB7P30gYXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBlbnN1cmVFeHByZXNzaW9uTW9kZShtb2RlLCBhc3QpIHtcbiAgICBpZiAobW9kZSAhPT0gX01vZGUuRXhwcmVzc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhbiBleHByZXNzaW9uLCBidXQgc2F3IFwiICsgYXN0KTtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbW9kZVxuICogQHBhcmFtIHs/fSBleHByXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBleHByKSB7XG4gICAgaWYgKG1vZGUgPT09IF9Nb2RlLlN0YXRlbWVudCkge1xuICAgICAgICByZXR1cm4gZXhwci50b1N0bXQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbn1cbnZhciBfQnVpbHRpbkFzdENvbnZlcnRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9CdWlsdGluQXN0Q29udmVydGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2NvbnZlcnRlckZhY3RvcnlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfQnVpbHRpbkFzdENvbnZlcnRlcihfY29udmVydGVyRmFjdG9yeSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fY29udmVydGVyRmFjdG9yeSA9IF9jb252ZXJ0ZXJGYWN0b3J5O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQnVpbHRpbkFzdENvbnZlcnRlci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gW2FzdC5leHBdLmNvbmNhdChhc3QuYXJncykubWFwKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGFzdC52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJ1aWx0aW5GdW5jdGlvbkNhbGwoYXN0LnNwYW4sIGFyZ3MsIHRoaXMuX2NvbnZlcnRlckZhY3RvcnkuY3JlYXRlUGlwZUNvbnZlcnRlcihhc3QubmFtZSwgYXJncy5sZW5ndGgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQnVpbHRpbkFzdENvbnZlcnRlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSBhc3QuZXhwcmVzc2lvbnMubWFwKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGFzdC52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJ1aWx0aW5GdW5jdGlvbkNhbGwoYXN0LnNwYW4sIGFyZ3MsIHRoaXMuX2NvbnZlcnRlckZhY3RvcnkuY3JlYXRlTGl0ZXJhbEFycmF5Q29udmVydGVyKGFzdC5leHByZXNzaW9ucy5sZW5ndGgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQnVpbHRpbkFzdENvbnZlcnRlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gYXN0LnZhbHVlcy5tYXAoZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVpbHRpbkZ1bmN0aW9uQ2FsbChhc3Quc3BhbiwgYXJncywgdGhpcy5fY29udmVydGVyRmFjdG9yeS5jcmVhdGVMaXRlcmFsTWFwQ29udmVydGVyKGFzdC5rZXlzKSk7XG4gICAgfTtcbiAgICByZXR1cm4gX0J1aWx0aW5Bc3RDb252ZXJ0ZXI7XG59KEFzdFRyYW5zZm9ybWVyKSk7XG52YXIgX0FzdFRvSXJWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9sb2NhbFJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBfaW1wbGljaXRSZWNlaXZlclxuICAgICAqIEBwYXJhbSB7P30gYmluZGluZ0lkXG4gICAgICovXG4gICAgZnVuY3Rpb24gX0FzdFRvSXJWaXNpdG9yKF9sb2NhbFJlc29sdmVyLCBfaW1wbGljaXRSZWNlaXZlciwgYmluZGluZ0lkKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsUmVzb2x2ZXIgPSBfbG9jYWxSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5faW1wbGljaXRSZWNlaXZlciA9IF9pbXBsaWNpdFJlY2VpdmVyO1xuICAgICAgICB0aGlzLmJpbmRpbmdJZCA9IGJpbmRpbmdJZDtcbiAgICAgICAgdGhpcy5fbm9kZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcmVzdWx0TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5ID0gMDtcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlDb3VudCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QmluYXJ5ID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcDtcbiAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLlBsdXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk1pbnVzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5NdWx0aXBseTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuRGl2aWRlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Nb2R1bG87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcmJic6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5BbmQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5PcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkVxdWFscztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk5vdEVxdWFscztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5JZGVudGljYWw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICchPT0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTm90SWRlbnRpY2FsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Mb3dlcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuQmlnZ2VyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIG9wZXJhdGlvbiBcIiArIGFzdC5vcGVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKG9wLCB0aGlzLnZpc2l0KGFzdC5sZWZ0LCBfTW9kZS5FeHByZXNzaW9uKSwgdGhpcy52aXNpdChhc3QucmlnaHQsIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICBlbnN1cmVTdGF0ZW1lbnRNb2RlKG1vZGUsIGFzdCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgbW9kZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IHRoaXMudmlzaXQoYXN0LmNvbmRpdGlvbiwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCB2YWx1ZS5jb25kaXRpb25hbCh0aGlzLnZpc2l0KGFzdC50cnVlRXhwLCBfTW9kZS5FeHByZXNzaW9uKSwgdGhpcy52aXNpdChhc3QuZmFsc2VFeHAsIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IFBpcGVzIHNob3VsZCBoYXZlIGJlZW4gY29udmVydGVkIGludG8gZnVuY3Rpb25zLiBQaXBlOiBcIiArIGFzdC5uYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb252ZXJ0ZWRBcmdzID0gdGhpcy52aXNpdEFsbChhc3QuYXJncywgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZuUmVzdWx0O1xuICAgICAgICBpZiAoYXN0IGluc3RhbmNlb2YgQnVpbHRpbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgICAgZm5SZXN1bHQgPSBhc3QuY29udmVydGVyKGNvbnZlcnRlZEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm5SZXN1bHQgPSB0aGlzLnZpc2l0KC8qKiBAdHlwZSB7P30gKi8gKChhc3QudGFyZ2V0KSksIF9Nb2RlLkV4cHJlc3Npb24pLmNhbGxGbihjb252ZXJ0ZWRBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgZm5SZXN1bHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbXBsaWNpdFJlY2VpdmVyID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICBlbnN1cmVFeHByZXNzaW9uTW9kZShtb2RlLCBhc3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5faW1wbGljaXRSZWNlaXZlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgZW5zdXJlRXhwcmVzc2lvbk1vZGUobW9kZSwgYXN0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IFtsaXRlcmFsKGFzdC5leHByZXNzaW9ucy5sZW5ndGgpXTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGFzdC5zdHJpbmdzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgYXJncy5wdXNoKGxpdGVyYWwoYXN0LnN0cmluZ3NbaV0pKTtcbiAgICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLnZpc2l0KGFzdC5leHByZXNzaW9uc1tpXSwgX01vZGUuRXhwcmVzc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MucHVzaChsaXRlcmFsKGFzdC5zdHJpbmdzW2FzdC5zdHJpbmdzLmxlbmd0aCAtIDFdKSk7XG4gICAgICAgIHJldHVybiBhc3QuZXhwcmVzc2lvbnMubGVuZ3RoIDw9IDkgP1xuICAgICAgICAgICAgaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLmlubGluZUludGVycG9sYXRlKSkuY2FsbEZuKGFyZ3MpIDpcbiAgICAgICAgICAgIGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5pbnRlcnBvbGF0ZSkpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgYXJnc1swXSwgbGl0ZXJhbEFycihhcmdzLnNsaWNlKDEpKVxuICAgICAgICAgICAgXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWVkUmVhZCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVmdE1vc3RTYWZlID0gdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCk7XG4gICAgICAgIGlmIChsZWZ0TW9zdFNhZmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgbGVmdE1vc3RTYWZlLCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCB0aGlzLnZpc2l0KGFzdC5vYmosIF9Nb2RlLkV4cHJlc3Npb24pLmtleSh0aGlzLnZpc2l0KGFzdC5rZXksIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2JqID0gdGhpcy52aXNpdChhc3Qub2JqLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ID0gdGhpcy52aXNpdChhc3Qua2V5LCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0aGlzLnZpc2l0KGFzdC52YWx1ZSwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBvYmoua2V5KGtleSkuc2V0KHZhbHVlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBTdGF0ZTogbGl0ZXJhbCBhcnJheXMgc2hvdWxkIGhhdmUgYmVlbiBjb252ZXJ0ZWQgaW50byBmdW5jdGlvbnNcIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgU3RhdGU6IGxpdGVyYWwgbWFwcyBzaG91bGQgaGF2ZSBiZWVuIGNvbnZlcnRlZCBpbnRvIGZ1bmN0aW9uc1wiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIGxpdGVyYWwoYXN0LnZhbHVlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUuX2dldExvY2FsID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHRoaXMuX2xvY2FsUmVzb2x2ZXIuZ2V0TG9jYWwobmFtZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZWZ0TW9zdFNhZmUgPSB0aGlzLmxlZnRNb3N0U2FmZU5vZGUoYXN0KTtcbiAgICAgICAgaWYgKGxlZnRNb3N0U2FmZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNhZmVBY2Nlc3MoYXN0LCBsZWZ0TW9zdFNhZmUsIG1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY2VpdmVyID0gdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09PSB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFyRXhwciA9IHRoaXMuX2dldExvY2FsKGFzdC5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodmFyRXhwcikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB2YXJFeHByLmNhbGxGbihhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlci5jYWxsTWV0aG9kKGFzdC5uYW1lLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByZWZpeE5vdCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIG5vdCh0aGlzLnZpc2l0KGFzdC5leHByZXNzaW9uLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlZnRNb3N0U2FmZSA9IHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpO1xuICAgICAgICBpZiAobGVmdE1vc3RTYWZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjZWl2ZXIgPSB0aGlzLnZpc2l0KGFzdC5yZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZXIgPT09IHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXRMb2NhbChhc3QubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlci5wcm9wKGFzdC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByb3BlcnR5V3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY2VpdmVyID0gdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICBpZiAocmVjZWl2ZXIgPT09IHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhckV4cHIgPSB0aGlzLl9nZXRMb2NhbChhc3QubmFtZSk7XG4gICAgICAgICAgICBpZiAodmFyRXhwcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFzc2lnbiB0byBhIHJlZmVyZW5jZSBvciB2YXJpYWJsZSEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgcmVjZWl2ZXIucHJvcChhc3QubmFtZSkuc2V0KHRoaXMudmlzaXQoYXN0LnZhbHVlLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpLCBtb2RlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2FmZU1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCksIG1vZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RzXG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKGFzdHMsIG1vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGFzdHMubWFwKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIF90aGlzLnZpc2l0KGFzdCwgbW9kZSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVvdGVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBldmFsdWF0aW9uIVxcbiAgICAgICAgU3RhdGVtZW50OiBcIiArIGFzdC51bmludGVycHJldGVkRXhwcmVzc2lvbiArIFwiIGxvY2F0ZWQgYXQgXCIgKyBhc3QubG9jYXRpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMuX3Jlc3VsdE1hcC5nZXQoYXN0KTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHJldHVybiAodGhpcy5fbm9kZU1hcC5nZXQoYXN0KSB8fCBhc3QpLnZpc2l0KHRoaXMsIG1vZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGxlZnRNb3N0U2FmZVxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5jb252ZXJ0U2FmZUFjY2VzcyA9IGZ1bmN0aW9uIChhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSkge1xuICAgICAgICAvLyBJZiB0aGUgZXhwcmVzc2lvbiBjb250YWlucyBhIHNhZmUgYWNjZXNzIG5vZGUgb24gdGhlIGxlZnQgaXQgbmVlZHMgdG8gYmUgY29udmVydGVkIHRvXG4gICAgICAgIC8vIGFuIGV4cHJlc3Npb24gdGhhdCBndWFyZHMgdGhlIGFjY2VzcyB0byB0aGUgbWVtYmVyIGJ5IGNoZWNraW5nIHRoZSByZWNlaXZlciBmb3IgYmxhbmsuIEFzXG4gICAgICAgIC8vIGV4ZWN1dGlvbiBwcm9jZWVkcyBmcm9tIGxlZnQgdG8gcmlnaHQsIHRoZSBsZWZ0IG1vc3QgcGFydCBvZiB0aGUgZXhwcmVzc2lvbiBtdXN0IGJlIGd1YXJkZWRcbiAgICAgICAgLy8gZmlyc3QgYnV0LCBiZWNhdXNlIG1lbWJlciBhY2Nlc3MgaXMgbGVmdCBhc3NvY2lhdGl2ZSwgdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGV4cHJlc3Npb24gaXMgYXRcbiAgICAgICAgLy8gdGhlIHRvcCBvZiB0aGUgQVNULiBUaGUgZGVzaXJlZCByZXN1bHQgcmVxdWlyZXMgbGlmdGluZyBhIGNvcHkgb2YgdGhlIHRoZSBsZWZ0IHBhcnQgb2YgdGhlXG4gICAgICAgIC8vIGV4cHJlc3Npb24gdXAgdG8gdGVzdCBpdCBmb3IgYmxhbmsgYmVmb3JlIGdlbmVyYXRpbmcgdGhlIHVuZ3VhcmRlZCB2ZXJzaW9uLlxuICAgICAgICAvLyBDb25zaWRlciwgZm9yIGV4YW1wbGUgdGhlIGZvbGxvd2luZyBleHByZXNzaW9uOiBhPy5iLmM/LmQuZVxuICAgICAgICAvLyBUaGlzIHJlc3VsdHMgaW4gdGhlIGFzdDpcbiAgICAgICAgLy8gICAgICAgICAuXG4gICAgICAgIC8vICAgICAgICAvIFxcXG4gICAgICAgIC8vICAgICAgID8uICAgZVxuICAgICAgICAvLyAgICAgIC8gIFxcXG4gICAgICAgIC8vICAgICAuICAgIGRcbiAgICAgICAgLy8gICAgLyBcXFxuICAgICAgICAvLyAgID8uICBjXG4gICAgICAgIC8vICAvICBcXFxuICAgICAgICAvLyBhICAgIGJcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyB0cmVlIHNob3VsZCBiZSBnZW5lcmF0ZWQ6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgICAvLS0tLSA/IC0tLS1cXFxuICAgICAgICAvLyAgICAgICAvICAgICAgfCAgICAgIFxcXG4gICAgICAgIC8vICAgICBhICAgLy0tLSA/IC0tLVxcICBudWxsXG4gICAgICAgIC8vICAgICAgICAvICAgICB8ICAgICBcXFxuICAgICAgICAvLyAgICAgICAuICAgICAgLiAgICAgbnVsbFxuICAgICAgICAvLyAgICAgIC8gXFwgICAgLyBcXFxuICAgICAgICAvLyAgICAgLiAgYyAgIC4gICBlXG4gICAgICAgIC8vICAgIC8gXFwgICAgLyBcXFxuICAgICAgICAvLyAgIGEgICBiICAsICAgZFxuICAgICAgICAvLyAgICAgICAgIC8gXFxcbiAgICAgICAgLy8gICAgICAgIC4gICBjXG4gICAgICAgIC8vICAgICAgIC8gXFxcbiAgICAgICAgLy8gICAgICBhICAgYlxuICAgICAgICAvL1xuICAgICAgICAvLyBOb3RpY2UgdGhhdCB0aGUgZmlyc3QgZ3VhcmQgY29uZGl0aW9uIGlzIHRoZSBsZWZ0IGhhbmQgb2YgdGhlIGxlZnQgbW9zdCBzYWZlIGFjY2VzcyBub2RlXG4gICAgICAgIC8vIHdoaWNoIGNvbWVzIGluIGFzIGxlZnRNb3N0U2FmZSB0byB0aGlzIHJvdXRpbmUuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGd1YXJkZWRFeHByZXNzaW9uID0gdGhpcy52aXNpdChsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wb3JhcnkgPSAoKHVuZGVmaW5lZCkpO1xuICAgICAgICBpZiAodGhpcy5uZWVkc1RlbXBvcmFyeShsZWZ0TW9zdFNhZmUucmVjZWl2ZXIpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZXhwcmVzc2lvbiBoYXMgbWV0aG9kIGNhbGxzIG9yIHBpcGVzIHRoZW4gd2UgbmVlZCB0byBzYXZlIHRoZSByZXN1bHQgaW50byBhXG4gICAgICAgICAgICAvLyB0ZW1wb3JhcnkgdmFyaWFibGUgdG8gYXZvaWQgY2FsbGluZyBzdGF0ZWZ1bCBvciBpbXB1cmUgY29kZSBtb3JlIHRoYW4gb25jZS5cbiAgICAgICAgICAgIHRlbXBvcmFyeSA9IHRoaXMuYWxsb2NhdGVUZW1wb3JhcnkoKTtcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIHRoZSByZXN1bHQgaW4gdGhlIHRlbXBvcmFyeSB2YXJpYWJsZVxuICAgICAgICAgICAgZ3VhcmRlZEV4cHJlc3Npb24gPSB0ZW1wb3Jhcnkuc2V0KGd1YXJkZWRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBhbGwgZnVydGhlciByZWZlcmVuY2VzIHRvIHRoZSBndWFyZGVkIGV4cHJlc3Npb24gcmVmZXIgdG8gdGhlIHRlbXBvcmFyeSBpbnN0ZWFkLlxuICAgICAgICAgICAgdGhpcy5fcmVzdWx0TWFwLnNldChsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIHRlbXBvcmFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uZGl0aW9uID0gZ3VhcmRlZEV4cHJlc3Npb24uaXNCbGFuaygpO1xuICAgICAgICAvLyBDb252ZXJ0IHRoZSBhc3QgdG8gYW4gdW5ndWFyZGVkIGFjY2VzcyB0byB0aGUgcmVjZWl2ZXIncyBtZW1iZXIuIFRoZSBtYXAgd2lsbCBzdWJzdGl0dXRlXG4gICAgICAgIC8vIGxlZnRNb3N0Tm9kZSB3aXRoIGl0cyB1bmd1YXJkZWQgdmVyc2lvbiBpbiB0aGUgY2FsbCB0byBgdGhpcy52aXNpdCgpYC5cbiAgICAgICAgaWYgKGxlZnRNb3N0U2FmZSBpbnN0YW5jZW9mIFNhZmVNZXRob2RDYWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2RlTWFwLnNldChsZWZ0TW9zdFNhZmUsIG5ldyBNZXRob2RDYWxsKGxlZnRNb3N0U2FmZS5zcGFuLCBsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIGxlZnRNb3N0U2FmZS5uYW1lLCBsZWZ0TW9zdFNhZmUuYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbm9kZU1hcC5zZXQobGVmdE1vc3RTYWZlLCBuZXcgUHJvcGVydHlSZWFkKGxlZnRNb3N0U2FmZS5zcGFuLCBsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIGxlZnRNb3N0U2FmZS5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB0aGUgbm9kZSBub3cgd2l0aG91dCB0aGUgZ3VhcmRlZCBtZW1iZXIgYWNjZXNzLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhY2Nlc3MgPSB0aGlzLnZpc2l0KGFzdCwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbWFwcGluZy4gVGhpcyBpcyBub3Qgc3RyaWN0bHkgcmVxdWlyZWQgYXMgdGhlIGNvbnZlcnRlciBvbmx5IHRyYXZlcnNlcyBlYWNoIG5vZGVcbiAgICAgICAgLy8gb25jZSBidXQgaXMgc2FmZXIgaWYgdGhlIGNvbnZlcnNpb24gaXMgY2hhbmdlZCB0byB0cmF2ZXJzZSB0aGUgbm9kZXMgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAgIHRoaXMuX25vZGVNYXAuZGVsZXRlKGxlZnRNb3N0U2FmZSk7XG4gICAgICAgIC8vIElmIHdlIGFsbG9jYXRlZCBhIHRlbXBvcmFyeSwgcmVsZWFzZSBpdC5cbiAgICAgICAgaWYgKHRlbXBvcmFyeSkge1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlVGVtcG9yYXJ5KHRlbXBvcmFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJvZHVjZSB0aGUgY29uZGl0aW9uYWxcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIGNvbmRpdGlvbi5jb25kaXRpb25hbChsaXRlcmFsKG51bGwpLCBhY2Nlc3MpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLmxlZnRNb3N0U2FmZU5vZGUgPSBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGFzdCkge1xuICAgICAgICAgICAgcmV0dXJuIChfdGhpcy5fbm9kZU1hcC5nZXQoYXN0KSB8fCBhc3QpLnZpc2l0KHZpc2l0b3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXN0LnZpc2l0KHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0QmluYXJ5OiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRDaGFpbjogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0Q29uZGl0aW9uYWw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdEZ1bmN0aW9uQ2FsbDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0SW1wbGljaXRSZWNlaXZlcjogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0SW50ZXJwb2xhdGlvbjogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0S2V5ZWRSZWFkOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh0aGlzLCBhc3Qub2JqKTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0S2V5ZWRXcml0ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0TGl0ZXJhbEFycmF5OiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRMaXRlcmFsTWFwOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRMaXRlcmFsUHJpbWl0aXZlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRNZXRob2RDYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRQaXBlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRQcmVmaXhOb3Q6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdFByb3BlcnR5UmVhZDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodGhpcywgYXN0LnJlY2VpdmVyKTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0UHJvcGVydHlXcml0ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0UXVvdGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdFNhZmVNZXRob2RDYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpIHx8IGFzdDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0U2FmZVByb3BlcnR5UmVhZDogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpIHx8IGFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5uZWVkc1RlbXBvcmFyeSA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgYXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gYXN0ICYmIChfdGhpcy5fbm9kZU1hcC5nZXQoYXN0KSB8fCBhc3QpLnZpc2l0KHZpc2l0b3IpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdFNvbWUgPSBmdW5jdGlvbiAodmlzaXRvciwgYXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gYXN0LnNvbWUoZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodmlzaXRvciwgYXN0KTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhc3QudmlzaXQoe1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRCaW5hcnk6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5sZWZ0KSB8fCB2aXNpdCh0aGlzLCBhc3QucmlnaHQpOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRDaGFpbjogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdENvbmRpdGlvbmFsOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5jb25kaXRpb24pIHx8IHZpc2l0KHRoaXMsIGFzdC50cnVlRXhwKSB8fFxuICAgICAgICAgICAgICAgICAgICB2aXNpdCh0aGlzLCBhc3QuZmFsc2VFeHApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0RnVuY3Rpb25DYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRJbXBsaWNpdFJlY2VpdmVyOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0SW50ZXJwb2xhdGlvbjogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXRTb21lKHRoaXMsIGFzdC5leHByZXNzaW9ucyk7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdEtleWVkUmVhZDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdEtleWVkV3JpdGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRMaXRlcmFsQXJyYXk6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxNYXA6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxQcmltaXRpdmU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRNZXRob2RDYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRQaXBlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRQcmVmaXhOb3Q6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5leHByZXNzaW9uKTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0UHJvcGVydHlSZWFkOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0UHJvcGVydHlXcml0ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdFF1b3RlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0U2FmZU1ldGhvZENhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdFNhZmVQcm9wZXJ0eVJlYWQ6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLmFsbG9jYXRlVGVtcG9yYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wTnVtYmVyID0gdGhpcy5fY3VycmVudFRlbXBvcmFyeSsrO1xuICAgICAgICB0aGlzLnRlbXBvcmFyeUNvdW50ID0gTWF0aC5tYXgodGhpcy5fY3VycmVudFRlbXBvcmFyeSwgdGhpcy50ZW1wb3JhcnlDb3VudCk7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZFZhckV4cHIodGVtcG9yYXJ5TmFtZSh0aGlzLmJpbmRpbmdJZCwgdGVtcE51bWJlcikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZW1wb3JhcnlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUucmVsZWFzZVRlbXBvcmFyeSA9IGZ1bmN0aW9uICh0ZW1wb3JhcnkpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudFRlbXBvcmFyeS0tO1xuICAgICAgICBpZiAodGVtcG9yYXJ5Lm5hbWUgIT0gdGVtcG9yYXJ5TmFtZSh0aGlzLmJpbmRpbmdJZCwgdGhpcy5fY3VycmVudFRlbXBvcmFyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbXBvcmFyeSBcIiArIHRlbXBvcmFyeS5uYW1lICsgXCIgcmVsZWFzZWQgb3V0IG9mIG9yZGVyXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX0FzdFRvSXJWaXNpdG9yO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBhcmdcbiAqIEBwYXJhbSB7P30gb3V0cHV0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBmbGF0dGVuU3RhdGVtZW50cyhhcmcsIG91dHB1dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgKChhcmcpKS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZmxhdHRlblN0YXRlbWVudHMoZW50cnksIG91dHB1dCk7IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2goYXJnKTtcbiAgICB9XG59XG52YXIgRGVmYXVsdExvY2FsUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlZmF1bHRMb2NhbFJlc29sdmVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlZmF1bHRMb2NhbFJlc29sdmVyLnByb3RvdHlwZS5nZXRMb2NhbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09PSBFdmVudEhhbmRsZXJWYXJzLmV2ZW50Lm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBFdmVudEhhbmRsZXJWYXJzLmV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmF1bHRMb2NhbFJlc29sdmVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBiaW5kaW5nSWRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUN1cnJWYWx1ZUV4cHIoYmluZGluZ0lkKSB7XG4gICAgcmV0dXJuIHZhcmlhYmxlKFwiY3VyclZhbF9cIiArIGJpbmRpbmdJZCk7IC8vIGZpeCBzeW50YXggaGlnaGxpZ2h0aW5nOiBgXG59XG4vKipcbiAqIEBwYXJhbSB7P30gYmluZGluZ0lkXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVQcmV2ZW50RGVmYXVsdFZhcihiaW5kaW5nSWQpIHtcbiAgICByZXR1cm4gdmFyaWFibGUoXCJwZF9cIiArIGJpbmRpbmdJZCk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gc3RtdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29udmVydFN0bXRJbnRvRXhwcmVzc2lvbihzdG10KSB7XG4gICAgaWYgKHN0bXQgaW5zdGFuY2VvZiBFeHByZXNzaW9uU3RhdGVtZW50KSB7XG4gICAgICAgIHJldHVybiBzdG10LmV4cHI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0bXQgaW5zdGFuY2VvZiBSZXR1cm5TdGF0ZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxudmFyIEJ1aWx0aW5GdW5jdGlvbkNhbGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdWlsdGluRnVuY3Rpb25DYWxsLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gYXJnc1xuICAgICAqIEBwYXJhbSB7P30gY29udmVydGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQnVpbHRpbkZ1bmN0aW9uQ2FsbChzcGFuLCBhcmdzLCBjb252ZXJ0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgbnVsbCwgYXJncykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIF90aGlzLmNvbnZlcnRlciA9IGNvbnZlcnRlcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQnVpbHRpbkZ1bmN0aW9uQ2FsbDtcbn0oRnVuY3Rpb25DYWxsKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQ0xBU1NfQVRUUiQxID0gJ2NsYXNzJztcbnZhciBTVFlMRV9BVFRSID0gJ3N0eWxlJztcbnZhciBJTVBMSUNJVF9URU1QTEFURV9WQVIgPSAnXFwkaW1wbGljaXQnO1xudmFyIFZpZXdDb21waWxlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAgICAgKiBAcGFyYW0gez99IHZpZXdDbGFzc1ZhclxuICAgICAqIEBwYXJhbSB7P30gcmVuZGVyZXJUeXBlVmFyXG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlld0NvbXBpbGVSZXN1bHQoc3RhdGVtZW50cywgdmlld0NsYXNzVmFyLCByZW5kZXJlclR5cGVWYXIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgdGhpcy52aWV3Q2xhc3NWYXIgPSB2aWV3Q2xhc3NWYXI7XG4gICAgICAgIHRoaXMucmVuZGVyZXJUeXBlVmFyID0gcmVuZGVyZXJUeXBlVmFyO1xuICAgIH1cbiAgICByZXR1cm4gVmlld0NvbXBpbGVSZXN1bHQ7XG59KCkpO1xudmFyIFZpZXdDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZ2VuQ29uZmlnTmV4dFxuICAgICAqIEBwYXJhbSB7P30gX3NjaGVtYVJlZ2lzdHJ5XG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlld0NvbXBpbGVyKF9nZW5Db25maWdOZXh0LCBfc2NoZW1hUmVnaXN0cnkpIHtcbiAgICAgICAgdGhpcy5fZ2VuQ29uZmlnTmV4dCA9IF9nZW5Db25maWdOZXh0O1xuICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeSA9IF9zY2hlbWFSZWdpc3RyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZXNcbiAgICAgKiBAcGFyYW0gez99IHVzZWRQaXBlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0NvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgdGVtcGxhdGUsIHN0eWxlcywgdXNlZFBpcGVzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVtYmVkZGVkVmlld0NvdW50ID0gMDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljUXVlcnlJZHMgPSBmaW5kU3RhdGljUXVlcnlJZHModGVtcGxhdGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0ZW1lbnRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlbmRlckNvbXBvbmVudFZhck5hbWUgPSAoKHVuZGVmaW5lZCkpO1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5pc0hvc3QpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlXzEgPSAoKGNvbXBvbmVudC50ZW1wbGF0ZSkpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VzdG9tUmVuZGVyRGF0YSA9IFtdO1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlXzEuYW5pbWF0aW9ucyAmJiB0ZW1wbGF0ZV8xLmFuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tUmVuZGVyRGF0YS5wdXNoKG5ldyBMaXRlcmFsTWFwRW50cnkoJ2FuaW1hdGlvbicsIGNvbnZlcnRWYWx1ZVRvT3V0cHV0QXN0KHRlbXBsYXRlXzEuYW5pbWF0aW9ucyksIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlbmRlckNvbXBvbmVudFZhciA9IHZhcmlhYmxlKHJlbmRlcmVyVHlwZU5hbWUoY29tcG9uZW50LnR5cGUucmVmZXJlbmNlKSk7XG4gICAgICAgICAgICByZW5kZXJDb21wb25lbnRWYXJOYW1lID0gKChyZW5kZXJDb21wb25lbnRWYXIubmFtZSkpO1xuICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHJlbmRlckNvbXBvbmVudFZhclxuICAgICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLmNyZWF0ZVJlbmRlcmVyVHlwZTIpKVxuICAgICAgICAgICAgICAgIC5jYWxsRm4oW25ldyBMaXRlcmFsTWFwRXhwcihbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBMaXRlcmFsTWFwRW50cnkoJ2VuY2Fwc3VsYXRpb24nLCBsaXRlcmFsKHRlbXBsYXRlXzEuZW5jYXBzdWxhdGlvbikpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgTGl0ZXJhbE1hcEVudHJ5KCdzdHlsZXMnLCBzdHlsZXMpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgTGl0ZXJhbE1hcEVudHJ5KCdkYXRhJywgbmV3IExpdGVyYWxNYXBFeHByKGN1c3RvbVJlbmRlckRhdGEpKVxuICAgICAgICAgICAgICAgIF0pXSkpXG4gICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQoaW1wb3J0VHlwZShjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLlJlbmRlcmVyVHlwZTIpKSwgW1N0bXRNb2RpZmllci5GaW5hbF0pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3QnVpbGRlckZhY3RvcnkgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbWJlZGRlZFZpZXdJbmRleCA9IGVtYmVkZGVkVmlld0NvdW50Kys7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZpZXdCdWlsZGVyKHBhcmVudCwgY29tcG9uZW50LCBlbWJlZGRlZFZpZXdJbmRleCwgdXNlZFBpcGVzLCBzdGF0aWNRdWVyeUlkcywgdmlld0J1aWxkZXJGYWN0b3J5KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IHZpZXdCdWlsZGVyRmFjdG9yeShudWxsKTtcbiAgICAgICAgdmlzaXRvci52aXNpdEFsbChbXSwgdGVtcGxhdGUpO1xuICAgICAgICBzdGF0ZW1lbnRzLnB1c2guYXBwbHkoc3RhdGVtZW50cywgdmlzaXRvci5idWlsZCgpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3Q29tcGlsZVJlc3VsdChzdGF0ZW1lbnRzLCB2aXNpdG9yLnZpZXdOYW1lLCByZW5kZXJDb21wb25lbnRWYXJOYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBWaWV3Q29tcGlsZXI7XG59KCkpO1xuVmlld0NvbXBpbGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblZpZXdDb21waWxlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IENvbXBpbGVyQ29uZmlnLCB9LFxuICAgIHsgdHlwZTogRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCB9LFxuXTsgfTtcbnZhciBMT0dfVkFSID0gdmFyaWFibGUoJ2wnKTtcbnZhciBWSUVXX1ZBUiA9IHZhcmlhYmxlKCd2Jyk7XG52YXIgQ0hFQ0tfVkFSID0gdmFyaWFibGUoJ2NrJyk7XG52YXIgQ09NUF9WQVIgPSB2YXJpYWJsZSgnY28nKTtcbnZhciBFVkVOVF9OQU1FX1ZBUiA9IHZhcmlhYmxlKCdlbicpO1xudmFyIEFMTE9XX0RFRkFVTFRfVkFSID0gdmFyaWFibGUoXCJhZFwiKTtcbnZhciBWaWV3QnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7P30gZW1iZWRkZWRWaWV3SW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHVzZWRQaXBlc1xuICAgICAqIEBwYXJhbSB7P30gc3RhdGljUXVlcnlJZHNcbiAgICAgKiBAcGFyYW0gez99IHZpZXdCdWlsZGVyRmFjdG9yeVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFZpZXdCdWlsZGVyKHBhcmVudCwgY29tcG9uZW50LCBlbWJlZGRlZFZpZXdJbmRleCwgdXNlZFBpcGVzLCBzdGF0aWNRdWVyeUlkcywgdmlld0J1aWxkZXJGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5lbWJlZGRlZFZpZXdJbmRleCA9IGVtYmVkZGVkVmlld0luZGV4O1xuICAgICAgICB0aGlzLnVzZWRQaXBlcyA9IHVzZWRQaXBlcztcbiAgICAgICAgdGhpcy5zdGF0aWNRdWVyeUlkcyA9IHN0YXRpY1F1ZXJ5SWRzO1xuICAgICAgICB0aGlzLnZpZXdCdWlsZGVyRmFjdG9yeSA9IHZpZXdCdWlsZGVyRmFjdG9yeTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLnB1cmVQaXBlTm9kZUluZGljZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnJlZk5vZGVJbmRpY2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAvLyBUT0RPKHRib3NjaCk6IFRoZSBvbGQgdmlldyBjb21waWxlciB1c2VkIHRvIHVzZSBhbiBgYW55YCB0eXBlXG4gICAgICAgIC8vIGZvciB0aGUgY29udGV4dCBpbiBhbnkgZW1iZWRkZWQgdmlldy4gV2Uga2VlcCB0aGlzIGJlaGFpdm9yIGZvciBub3dcbiAgICAgICAgLy8gdG8gYmUgYWJsZSB0byBpbnRyb2R1Y2UgdGhlIG5ldyB2aWV3IGNvbXBpbGVyIHdpdGhvdXQgdG9vIG1hbnkgZXJyb3JzLlxuICAgICAgICB0aGlzLmNvbXBUeXBlID1cbiAgICAgICAgICAgIHRoaXMuZW1iZWRkZWRWaWV3SW5kZXggPiAwID8gRFlOQU1JQ19UWVBFIDogaW1wb3J0VHlwZSh0aGlzLmNvbXBvbmVudC50eXBlKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdCdWlsZGVyLnByb3RvdHlwZSwgXCJ2aWV3TmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld0NsYXNzTmFtZSh0aGlzLmNvbXBvbmVudC50eXBlLnJlZmVyZW5jZSwgdGhpcy5lbWJlZGRlZFZpZXdJbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFyaWFibGVzXG4gICAgICogQHBhcmFtIHs/fSBhc3ROb2Rlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKHZhcmlhYmxlcywgYXN0Tm9kZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgcGlwZXMgZm9yIHRoZSBwdXJlIHBpcGVzIGltbWVkaWF0ZWx5LCBzbyB0aGF0IHdlIGtub3cgdGhlaXIgaW5kaWNlcy5cbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy51c2VkUGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChwaXBlLnB1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHVyZVBpcGVOb2RlSW5kaWNlc1twaXBlLm5hbWVdID0gX3RoaXMuX2NyZWF0ZVBpcGUobnVsbCwgcGlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcnlJZHNfMSA9IHN0YXRpY1ZpZXdRdWVyeUlkcyh0aGlzLnN0YXRpY1F1ZXJ5SWRzKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnZpZXdRdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5LCBxdWVyeUluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogcXVlcmllcyBzdGFydCB3aXRoIGlkIDEgc28gd2UgY2FuIHVzZSB0aGUgbnVtYmVyIGluIGEgQmxvb20gZmlsdGVyIVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJ5SWQgPSBxdWVyeUluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5nVHlwZSA9IHF1ZXJ5LmZpcnN0ID8gMCAvKiBGaXJzdCAqLyA6IDE7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmxhZ3MgPSA2NzEwODg2NCAvKiBUeXBlVmlld1F1ZXJ5ICovIHwgY2FsY1N0YXRpY0R5bmFtaWNRdWVyeUZsYWdzKHF1ZXJ5SWRzXzEsIHF1ZXJ5SWQsIHF1ZXJ5LmZpcnN0KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVGbGFnczogZmxhZ3MsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5xdWVyeURlZikpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXRlcmFsKGZsYWdzKSwgbGl0ZXJhbChxdWVyeUlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBMaXRlcmFsTWFwRXhwcihbbmV3IExpdGVyYWxNYXBFbnRyeShxdWVyeS5wcm9wZXJ0eU5hbWUsIGxpdGVyYWwoYmluZGluZ1R5cGUpKV0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGVWaXNpdEFsbCh0aGlzLCBhc3ROb2Rlcyk7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiAoYXN0Tm9kZXMubGVuZ3RoID09PSAwIHx8IG5lZWRzQWRkaXRpb25hbFJvb3ROb2RlKGFzdE5vZGVzKSkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSB2aWV3IGlzIGFuIGVtYmVkZGVkIHZpZXcsIHRoZW4gd2UgbmVlZCB0byBhZGQgYW4gYWRkaXRpb25hbCByb290IG5vZGUgaW4gc29tZSBjYXNlc1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgc291cmNlU3BhbjogbnVsbCxcbiAgICAgICAgICAgICAgICBub2RlRmxhZ3M6IDEgLyogVHlwZUVsZW1lbnQgKi8sXG4gICAgICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLmFuY2hvckRlZikpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWwoMCAvKiBOb25lICovKSwgTlVMTF9FWFBSLCBOVUxMX0VYUFIsIGxpdGVyYWwoMClcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSB0YXJnZXRTdGF0ZW1lbnRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAodGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgICBpZiAodGFyZ2V0U3RhdGVtZW50cyA9PT0gdm9pZCAwKSB7IHRhcmdldFN0YXRlbWVudHMgPSBbXTsgfVxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5idWlsZCh0YXJnZXRTdGF0ZW1lbnRzKTsgfSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX2NyZWF0ZU5vZGVFeHByZXNzaW9ucygpLCB1cGRhdGVSZW5kZXJlclN0bXRzID0gX2EudXBkYXRlUmVuZGVyZXJTdG10cywgdXBkYXRlRGlyZWN0aXZlc1N0bXRzID0gX2EudXBkYXRlRGlyZWN0aXZlc1N0bXRzLCBub2RlRGVmRXhwcnMgPSBfYS5ub2RlRGVmRXhwcnM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZVJlbmRlcmVyRm4gPSB0aGlzLl9jcmVhdGVVcGRhdGVGbih1cGRhdGVSZW5kZXJlclN0bXRzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBkYXRlRGlyZWN0aXZlc0ZuID0gdGhpcy5fY3JlYXRlVXBkYXRlRm4odXBkYXRlRGlyZWN0aXZlc1N0bXRzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld0ZsYWdzID0gMDtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCAmJiB0aGlzLmNvbXBvbmVudC5jaGFuZ2VEZXRlY3Rpb24gPT09IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCkge1xuICAgICAgICAgICAgdmlld0ZsYWdzIHw9IDIgLyogT25QdXNoICovO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdGYWN0b3J5ID0gbmV3IERlY2xhcmVGdW5jdGlvblN0bXQodGhpcy52aWV3TmFtZSwgW25ldyBGblBhcmFtKC8qKiBAdHlwZSB7P30gKi8gKChMT0dfVkFSLm5hbWUpKSldLCBbbmV3IFJldHVyblN0YXRlbWVudChpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMudmlld0RlZikpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbCh2aWV3RmxhZ3MpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWxBcnIobm9kZURlZkV4cHJzKSxcbiAgICAgICAgICAgICAgICB1cGRhdGVEaXJlY3RpdmVzRm4sXG4gICAgICAgICAgICAgICAgdXBkYXRlUmVuZGVyZXJGbixcbiAgICAgICAgICAgIF0pKV0sIGltcG9ydFR5cGUoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5WaWV3RGVmaW5pdGlvbikpKTtcbiAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoKHZpZXdGYWN0b3J5KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFN0YXRlbWVudHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVwZGF0ZVN0bXRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZVVwZGF0ZUZuID0gZnVuY3Rpb24gKHVwZGF0ZVN0bXRzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZUZuO1xuICAgICAgICBpZiAodXBkYXRlU3RtdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlU3RtdHMgPSBbXTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb21wb25lbnQuaXNIb3N0ICYmIGZpbmRSZWFkVmFyTmFtZXModXBkYXRlU3RtdHMpLmhhcygvKiogQHR5cGUgez99ICovICgoQ09NUF9WQVIubmFtZSkpKSkge1xuICAgICAgICAgICAgICAgIHByZVN0bXRzLnB1c2goQ09NUF9WQVIuc2V0KFZJRVdfVkFSLnByb3AoJ2NvbXBvbmVudCcpKS50b0RlY2xTdG10KHRoaXMuY29tcFR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZUZuID0gZm4oW1xuICAgICAgICAgICAgICAgIG5ldyBGblBhcmFtKC8qKiBAdHlwZSB7P30gKi8gKChDSEVDS19WQVIubmFtZSkpLCBJTkZFUlJFRF9UWVBFKSxcbiAgICAgICAgICAgICAgICBuZXcgRm5QYXJhbSgvKiogQHR5cGUgez99ICovICgoVklFV19WQVIubmFtZSkpLCBJTkZFUlJFRF9UWVBFKVxuICAgICAgICAgICAgXSwgcHJlU3RtdHMuY29uY2F0KHVwZGF0ZVN0bXRzKSwgSU5GRVJSRURfVFlQRSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVGbiA9IE5VTExfRVhQUjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBkYXRlRm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0TmdDb250ZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAvLyBuZ0NvbnRlbnREZWYobmdDb250ZW50SW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcik6IE5vZGVEZWY7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3BhbjogYXN0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDQgLyogVHlwZU5nQ29udGVudCAqLyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5uZ0NvbnRlbnREZWYpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoYXN0Lm5nQ29udGVudEluZGV4KSwgbGl0ZXJhbChhc3QuaW5kZXgpXG4gICAgICAgICAgICBdKVxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gdGV4dERlZihuZ0NvbnRlbnRJbmRleDogbnVtYmVyLCBjb25zdGFudHM6IHN0cmluZ1tdKTogTm9kZURlZjtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBhc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogMiAvKiBUeXBlVGV4dCAqLyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy50ZXh0RGVmKSkuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGFzdC5uZ0NvbnRlbnRJbmRleCksIGxpdGVyYWxBcnIoW2xpdGVyYWwoYXN0LnZhbHVlKV0pXG4gICAgICAgICAgICBdKVxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0Qm91bmRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlSW5kZXggPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgLy8gcmVzZXJ2ZSB0aGUgc3BhY2UgaW4gdGhlIG5vZGVEZWZzIGFycmF5XG4gICAgICAgIHRoaXMubm9kZXMucHVzaCgvKiogQHR5cGUgez99ICovICgobnVsbCkpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0V2l0aFNvdXJjZSA9IChhc3QudmFsdWUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnRlciA9IChhc3RXaXRoU291cmNlLmFzdCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZVJlbmRlcmVyRXhwcmVzc2lvbnMgPSBpbnRlci5leHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKGV4cHIsIGJpbmRpbmdJbmRleCkgeyByZXR1cm4gX3RoaXMuX3ByZXByb2Nlc3NVcGRhdGVFeHByZXNzaW9uKHsgbm9kZUluZGV4OiBub2RlSW5kZXgsIGJpbmRpbmdJbmRleDogYmluZGluZ0luZGV4LCBzb3VyY2VTcGFuOiBhc3Quc291cmNlU3BhbiwgY29udGV4dDogQ09NUF9WQVIsIHZhbHVlOiBleHByIH0pOyB9KTtcbiAgICAgICAgLy8gdGV4dERlZihuZ0NvbnRlbnRJbmRleDogbnVtYmVyLCBjb25zdGFudHM6IHN0cmluZ1tdKTogTm9kZURlZjtcbiAgICAgICAgdGhpcy5ub2Rlc1tub2RlSW5kZXhdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IGFzdC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgbm9kZUZsYWdzOiAyIC8qIFR5cGVUZXh0ICovLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLnRleHREZWYpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoYXN0Lm5nQ29udGVudEluZGV4KSwgbGl0ZXJhbEFycihpbnRlci5zdHJpbmdzLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gbGl0ZXJhbChzKTsgfSkpXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIHVwZGF0ZVJlbmRlcmVyOiB1cGRhdGVSZW5kZXJlckV4cHJlc3Npb25zXG4gICAgICAgIH0pOyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEVtYmVkZGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICAvLyByZXNlcnZlIHRoZSBzcGFjZSBpbiB0aGUgbm9kZURlZnMgYXJyYXlcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKChudWxsKSkpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl92aXNpdEVsZW1lbnRPclRlbXBsYXRlKG5vZGVJbmRleCwgYXN0KSwgZmxhZ3MgPSBfYS5mbGFncywgcXVlcnlNYXRjaGVzRXhwciA9IF9hLnF1ZXJ5TWF0Y2hlc0V4cHIsIGhvc3RFdmVudHMgPSBfYS5ob3N0RXZlbnRzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZFZpc2l0b3IgPSB0aGlzLnZpZXdCdWlsZGVyRmFjdG9yeSh0aGlzKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkVmlzaXRvcik7XG4gICAgICAgIGNoaWxkVmlzaXRvci52aXNpdEFsbChhc3QudmFyaWFibGVzLCBhc3QuY2hpbGRyZW4pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZENvdW50ID0gdGhpcy5ub2Rlcy5sZW5ndGggLSBub2RlSW5kZXggLSAxO1xuICAgICAgICAvLyBhbmNob3JEZWYoXG4gICAgICAgIC8vICAgZmxhZ3M6IE5vZGVGbGFncywgbWF0Y2hlZFF1ZXJpZXM6IFtzdHJpbmcsIFF1ZXJ5VmFsdWVUeXBlXVtdLCBuZ0NvbnRlbnRJbmRleDogbnVtYmVyLFxuICAgICAgICAvLyAgIGNoaWxkQ291bnQ6IG51bWJlciwgaGFuZGxlRXZlbnRGbj86IEVsZW1lbnRIYW5kbGVFdmVudEZuLCB0ZW1wbGF0ZUZhY3Rvcnk/OlxuICAgICAgICAvLyAgIFZpZXdEZWZpbml0aW9uRmFjdG9yeSk6IE5vZGVEZWY7XG4gICAgICAgIHRoaXMubm9kZXNbbm9kZUluZGV4XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBhc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogMSAvKiBUeXBlRWxlbWVudCAqLyB8IGZsYWdzLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLmFuY2hvckRlZikpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChmbGFncyksXG4gICAgICAgICAgICAgICAgcXVlcnlNYXRjaGVzRXhwcixcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGFzdC5uZ0NvbnRlbnRJbmRleCksXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChjaGlsZENvdW50KSxcbiAgICAgICAgICAgICAgICBfdGhpcy5fY3JlYXRlRWxlbWVudEhhbmRsZUV2ZW50Rm4obm9kZUluZGV4LCBob3N0RXZlbnRzKSxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZShjaGlsZFZpc2l0b3Iudmlld05hbWUpLFxuICAgICAgICAgICAgXSlcbiAgICAgICAgfSk7IH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZUluZGV4ID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgIC8vIHJlc2VydmUgdGhlIHNwYWNlIGluIHRoZSBub2RlRGVmcyBhcnJheSBzbyB3ZSBjYW4gYWRkIGNoaWxkcmVuXG4gICAgICAgIHRoaXMubm9kZXMucHVzaCgvKiogQHR5cGUgez99ICovICgobnVsbCkpKTtcbiAgICAgICAgLy8gVXNpbmcgYSBudWxsIGVsZW1lbnQgbmFtZSBjcmVhdGVzIGFuIGFuY2hvci5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxOYW1lID0gaXNOZ0NvbnRhaW5lcihhc3QubmFtZSkgPyBudWxsIDogYXN0Lm5hbWU7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX3Zpc2l0RWxlbWVudE9yVGVtcGxhdGUobm9kZUluZGV4LCBhc3QpLCBmbGFncyA9IF9hLmZsYWdzLCB1c2VkRXZlbnRzID0gX2EudXNlZEV2ZW50cywgcXVlcnlNYXRjaGVzRXhwciA9IF9hLnF1ZXJ5TWF0Y2hlc0V4cHIsIGRpckhvc3RCaW5kaW5ncyA9IF9hLmhvc3RCaW5kaW5ncywgaG9zdEV2ZW50cyA9IF9hLmhvc3RFdmVudHM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlucHV0RGVmcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cGRhdGVSZW5kZXJlckV4cHJlc3Npb25zID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dHB1dERlZnMgPSBbXTtcbiAgICAgICAgaWYgKGVsTmFtZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdEJpbmRpbmdzID0gYXN0LmlucHV0c1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGlucHV0QXN0KSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IC8qKiBAdHlwZSB7P30gKi8gKENPTVBfVkFSKSxcbiAgICAgICAgICAgICAgICBpbnB1dEFzdDogaW5wdXRBc3QsXG4gICAgICAgICAgICAgICAgZGlyQXN0OiAvKiogQHR5cGUgez99ICovIChudWxsKSxcbiAgICAgICAgICAgIH0pOyB9KVxuICAgICAgICAgICAgICAgIC5jb25jYXQoZGlySG9zdEJpbmRpbmdzKTtcbiAgICAgICAgICAgIGlmIChob3N0QmluZGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlUmVuZGVyZXJFeHByZXNzaW9ucyA9XG4gICAgICAgICAgICAgICAgICAgIGhvc3RCaW5kaW5ncy5tYXAoZnVuY3Rpb24gKGhvc3RCaW5kaW5nLCBiaW5kaW5nSW5kZXgpIHsgcmV0dXJuIF90aGlzLl9wcmVwcm9jZXNzVXBkYXRlRXhwcmVzc2lvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBob3N0QmluZGluZy5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUluZGV4OiBub2RlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nSW5kZXg6IGJpbmRpbmdJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGhvc3RCaW5kaW5nLmlucHV0QXN0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaG9zdEJpbmRpbmcuaW5wdXRBc3QudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgICAgIGlucHV0RGVmcyA9IGhvc3RCaW5kaW5ncy5tYXAoZnVuY3Rpb24gKGhvc3RCaW5kaW5nKSB7IHJldHVybiBlbGVtZW50QmluZGluZ0RlZihob3N0QmluZGluZy5pbnB1dEFzdCwgaG9zdEJpbmRpbmcuZGlyQXN0KTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXREZWZzID0gdXNlZEV2ZW50cy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IF9hWzBdLCBldmVudE5hbWUgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGl0ZXJhbEFycihbbGl0ZXJhbCh0YXJnZXQpLCBsaXRlcmFsKGV2ZW50TmFtZSldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlVmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRDb3VudCA9IHRoaXMubm9kZXMubGVuZ3RoIC0gbm9kZUluZGV4IC0gMTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcEFzdCA9IGFzdC5kaXJlY3RpdmVzLmZpbmQoZnVuY3Rpb24gKGRpckFzdCkgeyByZXR1cm4gZGlyQXN0LmRpcmVjdGl2ZS5pc0NvbXBvbmVudDsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBSZW5kZXJlclR5cGUgPSBOVUxMX0VYUFI7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBWaWV3ID0gTlVMTF9FWFBSO1xuICAgICAgICBpZiAoY29tcEFzdCkge1xuICAgICAgICAgICAgY29tcFZpZXcgPSBpbXBvcnRFeHByKHsgcmVmZXJlbmNlOiBjb21wQXN0LmRpcmVjdGl2ZS5jb21wb25lbnRWaWV3VHlwZSB9KTtcbiAgICAgICAgICAgIGNvbXBSZW5kZXJlclR5cGUgPSBpbXBvcnRFeHByKHsgcmVmZXJlbmNlOiBjb21wQXN0LmRpcmVjdGl2ZS5yZW5kZXJlclR5cGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxlbWVudERlZihcbiAgICAgICAgLy8gICBmbGFnczogTm9kZUZsYWdzLCBtYXRjaGVkUXVlcmllc0RzbDogW3N0cmluZyB8IG51bWJlciwgUXVlcnlWYWx1ZVR5cGVdW10sXG4gICAgICAgIC8vICAgbmdDb250ZW50SW5kZXg6IG51bWJlciwgY2hpbGRDb3VudDogbnVtYmVyLCBuYW1lc3BhY2VBbmROYW1lOiBzdHJpbmcsXG4gICAgICAgIC8vICAgZml4ZWRBdHRyczogW3N0cmluZywgc3RyaW5nXVtdID0gW10sXG4gICAgICAgIC8vICAgYmluZGluZ3M/OiBbQmluZGluZ0ZsYWdzLCBzdHJpbmcsIHN0cmluZyB8IFNlY3VyaXR5Q29udGV4dF1bXSxcbiAgICAgICAgLy8gICBvdXRwdXRzPzogKFtPdXRwdXRUeXBlLkVsZW1lbnRPdXRwdXQgfCBPdXRwdXRUeXBlLkRpcmVjdGl2ZUhvc3RPdXRwdXQsIHN0cmluZywgc3RyaW5nXSlbXSxcbiAgICAgICAgLy8gICBoYW5kbGVFdmVudD86IEVsZW1lbnRIYW5kbGVFdmVudEZuLFxuICAgICAgICAvLyAgIGNvbXBvbmVudFZpZXc/OiAoKSA9PiBWaWV3RGVmaW5pdGlvbiwgY29tcG9uZW50UmVuZGVyZXJUeXBlPzogUmVuZGVyZXJUeXBlMik6IE5vZGVEZWY7XG4gICAgICAgIHRoaXMubm9kZXNbbm9kZUluZGV4XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBhc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogMSAvKiBUeXBlRWxlbWVudCAqLyB8IGZsYWdzLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLmVsZW1lbnREZWYpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoZmxhZ3MpLFxuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hlc0V4cHIsXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChhc3QubmdDb250ZW50SW5kZXgpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoY2hpbGRDb3VudCksXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChlbE5hbWUpLFxuICAgICAgICAgICAgICAgIGVsTmFtZSA/IGZpeGVkQXR0cnNEZWYoYXN0KSA6IE5VTExfRVhQUixcbiAgICAgICAgICAgICAgICBpbnB1dERlZnMubGVuZ3RoID8gbGl0ZXJhbEFycihpbnB1dERlZnMpIDogTlVMTF9FWFBSLFxuICAgICAgICAgICAgICAgIG91dHB1dERlZnMubGVuZ3RoID8gbGl0ZXJhbEFycihvdXRwdXREZWZzKSA6IE5VTExfRVhQUixcbiAgICAgICAgICAgICAgICBfdGhpcy5fY3JlYXRlRWxlbWVudEhhbmRsZUV2ZW50Rm4obm9kZUluZGV4LCBob3N0RXZlbnRzKSxcbiAgICAgICAgICAgICAgICBjb21wVmlldyxcbiAgICAgICAgICAgICAgICBjb21wUmVuZGVyZXJUeXBlLFxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICB1cGRhdGVSZW5kZXJlcjogdXBkYXRlUmVuZGVyZXJFeHByZXNzaW9uc1xuICAgICAgICB9KTsgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZUluZGV4XG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fdmlzaXRFbGVtZW50T3JUZW1wbGF0ZSA9IGZ1bmN0aW9uIChub2RlSW5kZXgsIGFzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbGFncyA9IDA7XG4gICAgICAgIGlmIChhc3QuaGFzVmlld0NvbnRhaW5lcikge1xuICAgICAgICAgICAgZmxhZ3MgfD0gODM4ODYwOCAvKiBFbWJlZGRlZFZpZXdzICovO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVzZWRFdmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGFzdC5vdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBlbGVtZW50RXZlbnROYW1lQW5kVGFyZ2V0KGV2ZW50LCBudWxsKSwgbmFtZSA9IF9hLm5hbWUsIHRhcmdldCA9IF9hLnRhcmdldDtcbiAgICAgICAgICAgIHVzZWRFdmVudHMuc2V0KMm1ZWxlbWVudEV2ZW50RnVsbE5hbWUodGFyZ2V0LCBuYW1lKSwgW3RhcmdldCwgbmFtZV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYXN0LmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyQXN0KSB7XG4gICAgICAgICAgICBkaXJBc3QuaG9zdEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGVsZW1lbnRFdmVudE5hbWVBbmRUYXJnZXQoZXZlbnQsIGRpckFzdCksIG5hbWUgPSBfYS5uYW1lLCB0YXJnZXQgPSBfYS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdXNlZEV2ZW50cy5zZXQoybVlbGVtZW50RXZlbnRGdWxsTmFtZSh0YXJnZXQsIG5hbWUpLCBbdGFyZ2V0LCBuYW1lXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RCaW5kaW5ncyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0RXZlbnRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlclByb3ZpZGVyID0gY3JlYXRlQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKGFzdC5kaXJlY3RpdmVzKTtcbiAgICAgICAgaWYgKGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlclByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aGlzLl92aXNpdFByb3ZpZGVyKGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlclByb3ZpZGVyLCBhc3QucXVlcnlNYXRjaGVzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3QucHJvdmlkZXJzLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyQXN0LCBwcm92aWRlckluZGV4KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJBc3QgPSAoKHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlySW5kZXggPSAoKHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgYXN0LmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAobG9jYWxEaXJBc3QsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxEaXJBc3QuZGlyZWN0aXZlLnR5cGUucmVmZXJlbmNlID09PSB0b2tlblJlZmVyZW5jZShwcm92aWRlckFzdC50b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyQXN0ID0gbG9jYWxEaXJBc3Q7XG4gICAgICAgICAgICAgICAgICAgIGRpckluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChkaXJBc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5fdmlzaXREaXJlY3RpdmUocHJvdmlkZXJBc3QsIGRpckFzdCwgZGlySW5kZXgsIG5vZGVJbmRleCwgYXN0LnJlZmVyZW5jZXMsIGFzdC5xdWVyeU1hdGNoZXMsIHVzZWRFdmVudHMsIC8qKiBAdHlwZSB7P30gKi8gKChfdGhpcy5zdGF0aWNRdWVyeUlkcy5nZXQoLyoqIEB0eXBlIHs/fSAqLyAoYXN0KSkpKSksIGRpckhvc3RCaW5kaW5ncyA9IF9hLmhvc3RCaW5kaW5ncywgZGlySG9zdEV2ZW50cyA9IF9hLmhvc3RFdmVudHM7XG4gICAgICAgICAgICAgICAgaG9zdEJpbmRpbmdzLnB1c2guYXBwbHkoaG9zdEJpbmRpbmdzLCBkaXJIb3N0QmluZGluZ3MpO1xuICAgICAgICAgICAgICAgIGhvc3RFdmVudHMucHVzaC5hcHBseShob3N0RXZlbnRzLCBkaXJIb3N0RXZlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLl92aXNpdFByb3ZpZGVyKHByb3ZpZGVyQXN0LCBhc3QucXVlcnlNYXRjaGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJ5TWF0Y2hFeHBycyA9IFtdO1xuICAgICAgICBhc3QucXVlcnlNYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZVR5cGUgPSAoKHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgaWYgKHRva2VuUmVmZXJlbmNlKG1hdGNoLnZhbHVlKSA9PT0gcmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuRWxlbWVudFJlZikpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSAwIC8qIEVsZW1lbnRSZWYgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlblJlZmVyZW5jZShtYXRjaC52YWx1ZSkgPT09IHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlZpZXdDb250YWluZXJSZWYpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gMyAvKiBWaWV3Q29udGFpbmVyUmVmICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW5SZWZlcmVuY2UobWF0Y2gudmFsdWUpID09PSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5UZW1wbGF0ZVJlZikpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSAyIC8qIFRlbXBsYXRlUmVmICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlNYXRjaEV4cHJzLnB1c2gobGl0ZXJhbEFycihbbGl0ZXJhbChtYXRjaC5xdWVyeUlkKSwgbGl0ZXJhbCh2YWx1ZVR5cGUpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXN0LnJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZVR5cGUgPSAoKHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgaWYgKCFyZWYudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSAxIC8qIFJlbmRlckVsZW1lbnQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlblJlZmVyZW5jZShyZWYudmFsdWUpID09PSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5UZW1wbGF0ZVJlZikpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSAyIC8qIFRlbXBsYXRlUmVmICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVmTm9kZUluZGljZXNbcmVmLm5hbWVdID0gbm9kZUluZGV4O1xuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hFeHBycy5wdXNoKGxpdGVyYWxBcnIoW2xpdGVyYWwocmVmLm5hbWUpLCBsaXRlcmFsKHZhbHVlVHlwZSldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhc3Qub3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChvdXRwdXRBc3QpIHtcbiAgICAgICAgICAgIGhvc3RFdmVudHMucHVzaCh7IGNvbnRleHQ6IENPTVBfVkFSLCBldmVudEFzdDogb3V0cHV0QXN0LCBkaXJBc3Q6IC8qKiBAdHlwZSB7P30gKi8gKChudWxsKSkgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLFxuICAgICAgICAgICAgdXNlZEV2ZW50czogQXJyYXkuZnJvbSh1c2VkRXZlbnRzLnZhbHVlcygpKSxcbiAgICAgICAgICAgIHF1ZXJ5TWF0Y2hlc0V4cHI6IHF1ZXJ5TWF0Y2hFeHBycy5sZW5ndGggPyBsaXRlcmFsQXJyKHF1ZXJ5TWF0Y2hFeHBycykgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICBob3N0QmluZGluZ3M6IGhvc3RCaW5kaW5ncyxcbiAgICAgICAgICAgIGhvc3RFdmVudHM6IGhvc3RFdmVudHNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJBc3RcbiAgICAgKiBAcGFyYW0gez99IGRpckFzdFxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlSW5kZXhcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnROb2RlSW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHJlZnNcbiAgICAgKiBAcGFyYW0gez99IHF1ZXJ5TWF0Y2hlc1xuICAgICAqIEBwYXJhbSB7P30gdXNlZEV2ZW50c1xuICAgICAqIEBwYXJhbSB7P30gcXVlcnlJZHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fdmlzaXREaXJlY3RpdmUgPSBmdW5jdGlvbiAocHJvdmlkZXJBc3QsIGRpckFzdCwgZGlyZWN0aXZlSW5kZXgsIGVsZW1lbnROb2RlSW5kZXgsIHJlZnMsIHF1ZXJ5TWF0Y2hlcywgdXNlZEV2ZW50cywgcXVlcnlJZHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZUluZGV4ID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgIC8vIHJlc2VydmUgdGhlIHNwYWNlIGluIHRoZSBub2RlRGVmcyBhcnJheSBzbyB3ZSBjYW4gYWRkIGNoaWxkcmVuXG4gICAgICAgIHRoaXMubm9kZXMucHVzaCgvKiogQHR5cGUgez99ICovICgobnVsbCkpKTtcbiAgICAgICAgZGlyQXN0LmRpcmVjdGl2ZS5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5LCBxdWVyeUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyeUlkID0gZGlyQXN0LmNvbnRlbnRRdWVyeVN0YXJ0SWQgKyBxdWVyeUluZGV4O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmxhZ3MgPSAzMzU1NDQzMiAvKiBUeXBlQ29udGVudFF1ZXJ5ICovIHwgY2FsY1N0YXRpY0R5bmFtaWNRdWVyeUZsYWdzKHF1ZXJ5SWRzLCBxdWVyeUlkLCBxdWVyeS5maXJzdCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5nVHlwZSA9IHF1ZXJ5LmZpcnN0ID8gMCAvKiBGaXJzdCAqLyA6IDE7XG4gICAgICAgICAgICBfdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgc291cmNlU3BhbjogZGlyQXN0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgbm9kZUZsYWdzOiBmbGFncyxcbiAgICAgICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMucXVlcnlEZWYpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgICAgICBsaXRlcmFsKGZsYWdzKSwgbGl0ZXJhbChxdWVyeUlkKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IExpdGVyYWxNYXBFeHByKFtuZXcgTGl0ZXJhbE1hcEVudHJ5KHF1ZXJ5LnByb3BlcnR5TmFtZSwgbGl0ZXJhbChiaW5kaW5nVHlwZSkpXSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5vdGU6IHRoZSBvcGVyYXRpb24gYmVsb3cgbWlnaHQgYWxzbyBjcmVhdGUgbmV3IG5vZGVEZWZzLFxuICAgICAgICAvLyBidXQgd2UgZG9uJ3Qgd2FudCB0aGVtIHRvIGJlIGEgY2hpbGQgb2YgYSBkaXJlY3RpdmUsXG4gICAgICAgIC8vIGFzIHRoZXkgbWlnaHQgYmUgYSBwcm92aWRlci9waXBlIG9uIHRoZWlyIG93bi5cbiAgICAgICAgLy8gSS5lLiB3ZSBvbmx5IGFsbG93IHF1ZXJpZXMgYXMgY2hpbGRyZW4gb2YgZGlyZWN0aXZlcyBub2Rlcy5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRDb3VudCA9IHRoaXMubm9kZXMubGVuZ3RoIC0gbm9kZUluZGV4IC0gMTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fdmlzaXRQcm92aWRlck9yRGlyZWN0aXZlKHByb3ZpZGVyQXN0LCBxdWVyeU1hdGNoZXMpLCBmbGFncyA9IF9hLmZsYWdzLCBxdWVyeU1hdGNoRXhwcnMgPSBfYS5xdWVyeU1hdGNoRXhwcnMsIHByb3ZpZGVyRXhwciA9IF9hLnByb3ZpZGVyRXhwciwgZGVwc0V4cHIgPSBfYS5kZXBzRXhwcjtcbiAgICAgICAgcmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIGlmIChyZWYudmFsdWUgJiYgdG9rZW5SZWZlcmVuY2UocmVmLnZhbHVlKSA9PT0gdG9rZW5SZWZlcmVuY2UocHJvdmlkZXJBc3QudG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVmTm9kZUluZGljZXNbcmVmLm5hbWVdID0gbm9kZUluZGV4O1xuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hFeHBycy5wdXNoKGxpdGVyYWxBcnIoW2xpdGVyYWwocmVmLm5hbWUpLCBsaXRlcmFsKDQgLyogUHJvdmlkZXIgKi8pXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRpckFzdC5kaXJlY3RpdmUuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGZsYWdzIHw9IDE2Mzg0IC8qIENvbXBvbmVudCAqLztcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnB1dERlZnMgPSBkaXJBc3QuaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXRBc3QsIGlucHV0SW5kZXgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcFZhbHVlID0gbGl0ZXJhbEFycihbbGl0ZXJhbChpbnB1dEluZGV4KSwgbGl0ZXJhbChpbnB1dEFzdC5kaXJlY3RpdmVOYW1lKV0pO1xuICAgICAgICAgICAgLy8gTm90ZTogaXQncyBpbXBvcnRhbnQgdG8gbm90IHF1b3RlIHRoZSBrZXkgc28gdGhhdCB3ZSBjYW4gY2FwdHVyZSByZW5hbWVzIGJ5IG1pbmlmaWVycyFcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcEVudHJ5KGlucHV0QXN0LmRpcmVjdGl2ZU5hbWUsIG1hcFZhbHVlLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXRwdXREZWZzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpck1ldGEgPSBkaXJBc3QuZGlyZWN0aXZlO1xuICAgICAgICBPYmplY3Qua2V5cyhkaXJNZXRhLm91dHB1dHMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudE5hbWUgPSBkaXJNZXRhLm91dHB1dHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgaWYgKHVzZWRFdmVudHMuaGFzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBpdCdzIGltcG9ydGFudCB0byBub3QgcXVvdGUgdGhlIGtleSBzbyB0aGF0IHdlIGNhbiBjYXB0dXJlIHJlbmFtZXMgYnkgbWluaWZpZXJzIVxuICAgICAgICAgICAgICAgIG91dHB1dERlZnMucHVzaChuZXcgTGl0ZXJhbE1hcEVudHJ5KHByb3BOYW1lLCBsaXRlcmFsKGV2ZW50TmFtZSksIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cGRhdGVEaXJlY3RpdmVFeHByZXNzaW9ucyA9IFtdO1xuICAgICAgICBpZiAoZGlyQXN0LmlucHV0cy5sZW5ndGggfHwgKGZsYWdzICYgKDEzMTA3MiAvKiBEb0NoZWNrICovIHwgMzI3NjggLyogT25Jbml0ICovKSkgPiAwKSB7XG4gICAgICAgICAgICB1cGRhdGVEaXJlY3RpdmVFeHByZXNzaW9ucyA9XG4gICAgICAgICAgICAgICAgZGlyQXN0LmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0LCBiaW5kaW5nSW5kZXgpIHsgcmV0dXJuIF90aGlzLl9wcmVwcm9jZXNzVXBkYXRlRXhwcmVzc2lvbih7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleDogbm9kZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nSW5kZXg6IGJpbmRpbmdJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlU3BhbjogaW5wdXQuc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogQ09NUF9WQVIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dC52YWx1ZVxuICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJDb250ZXh0RXhwciA9IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5ub2RlVmFsdWUpKS5jYWxsRm4oW1xuICAgICAgICAgICAgVklFV19WQVIsIGxpdGVyYWwobm9kZUluZGV4KVxuICAgICAgICBdKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdEJpbmRpbmdzID0gZGlyQXN0Lmhvc3RQcm9wZXJ0aWVzLm1hcChmdW5jdGlvbiAoaW5wdXRBc3QpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBjb250ZXh0OiBkaXJDb250ZXh0RXhwcixcbiAgICAgICAgICAgIGRpckFzdDogZGlyQXN0LFxuICAgICAgICAgICAgaW5wdXRBc3Q6IGlucHV0QXN0LFxuICAgICAgICB9KTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RFdmVudHMgPSBkaXJBc3QuaG9zdEV2ZW50cy5tYXAoZnVuY3Rpb24gKGhvc3RFdmVudEFzdCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGRpckNvbnRleHRFeHByLFxuICAgICAgICAgICAgZXZlbnRBc3Q6IGhvc3RFdmVudEFzdCwgZGlyQXN0OiBkaXJBc3QsXG4gICAgICAgIH0pOyB9KTtcbiAgICAgICAgLy8gZGlyZWN0aXZlRGVmKFxuICAgICAgICAvLyAgIGZsYWdzOiBOb2RlRmxhZ3MsIG1hdGNoZWRRdWVyaWVzOiBbc3RyaW5nLCBRdWVyeVZhbHVlVHlwZV1bXSwgY2hpbGRDb3VudDogbnVtYmVyLCBjdG9yOlxuICAgICAgICAvLyAgIGFueSxcbiAgICAgICAgLy8gICBkZXBzOiAoW0RlcEZsYWdzLCBhbnldIHwgYW55KVtdLCBwcm9wcz86IHtbbmFtZTogc3RyaW5nXTogW251bWJlciwgc3RyaW5nXX0sXG4gICAgICAgIC8vICAgb3V0cHV0cz86IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfSwgY29tcG9uZW50PzogKCkgPT4gVmlld0RlZmluaXRpb24pOiBOb2RlRGVmO1xuICAgICAgICB0aGlzLm5vZGVzW25vZGVJbmRleF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3BhbjogZGlyQXN0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDgxOTIgLyogVHlwZURpcmVjdGl2ZSAqLyB8IGZsYWdzLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLmRpcmVjdGl2ZURlZikpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChmbGFncyksIHF1ZXJ5TWF0Y2hFeHBycy5sZW5ndGggPyBsaXRlcmFsQXJyKHF1ZXJ5TWF0Y2hFeHBycykgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChjaGlsZENvdW50KSwgcHJvdmlkZXJFeHByLCBkZXBzRXhwcixcbiAgICAgICAgICAgICAgICBpbnB1dERlZnMubGVuZ3RoID8gbmV3IExpdGVyYWxNYXBFeHByKGlucHV0RGVmcykgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICAgICAgb3V0cHV0RGVmcy5sZW5ndGggPyBuZXcgTGl0ZXJhbE1hcEV4cHIob3V0cHV0RGVmcykgOiBOVUxMX0VYUFJcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgdXBkYXRlRGlyZWN0aXZlczogdXBkYXRlRGlyZWN0aXZlRXhwcmVzc2lvbnMsXG4gICAgICAgICAgICBkaXJlY3RpdmU6IGRpckFzdC5kaXJlY3RpdmUudHlwZSxcbiAgICAgICAgfSk7IH07XG4gICAgICAgIHJldHVybiB7IGhvc3RCaW5kaW5nczogaG9zdEJpbmRpbmdzLCBob3N0RXZlbnRzOiBob3N0RXZlbnRzIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyQXN0XG4gICAgICogQHBhcmFtIHs/fSBxdWVyeU1hdGNoZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fdmlzaXRQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlckFzdCwgcXVlcnlNYXRjaGVzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICAvLyByZXNlcnZlIHRoZSBzcGFjZSBpbiB0aGUgbm9kZURlZnMgYXJyYXkgc28gd2UgY2FuIGFkZCBjaGlsZHJlblxuICAgICAgICB0aGlzLm5vZGVzLnB1c2goLyoqIEB0eXBlIHs/fSAqLyAoKG51bGwpKSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX3Zpc2l0UHJvdmlkZXJPckRpcmVjdGl2ZShwcm92aWRlckFzdCwgcXVlcnlNYXRjaGVzKSwgZmxhZ3MgPSBfYS5mbGFncywgcXVlcnlNYXRjaEV4cHJzID0gX2EucXVlcnlNYXRjaEV4cHJzLCBwcm92aWRlckV4cHIgPSBfYS5wcm92aWRlckV4cHIsIGRlcHNFeHByID0gX2EuZGVwc0V4cHI7XG4gICAgICAgIC8vIHByb3ZpZGVyRGVmKFxuICAgICAgICAvLyAgIGZsYWdzOiBOb2RlRmxhZ3MsIG1hdGNoZWRRdWVyaWVzOiBbc3RyaW5nLCBRdWVyeVZhbHVlVHlwZV1bXSwgdG9rZW46YW55LFxuICAgICAgICAvLyAgIHZhbHVlOiBhbnksIGRlcHM6IChbRGVwRmxhZ3MsIGFueV0gfCBhbnkpW10pOiBOb2RlRGVmO1xuICAgICAgICB0aGlzLm5vZGVzW25vZGVJbmRleF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3BhbjogcHJvdmlkZXJBc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogZmxhZ3MsXG4gICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMucHJvdmlkZXJEZWYpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoZmxhZ3MpLCBxdWVyeU1hdGNoRXhwcnMubGVuZ3RoID8gbGl0ZXJhbEFycihxdWVyeU1hdGNoRXhwcnMpIDogTlVMTF9FWFBSLFxuICAgICAgICAgICAgICAgIHRva2VuRXhwcihwcm92aWRlckFzdC50b2tlbiksIHByb3ZpZGVyRXhwciwgZGVwc0V4cHJcbiAgICAgICAgICAgIF0pXG4gICAgICAgIH0pOyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlckFzdFxuICAgICAqIEBwYXJhbSB7P30gcXVlcnlNYXRjaGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX3Zpc2l0UHJvdmlkZXJPckRpcmVjdGl2ZSA9IGZ1bmN0aW9uIChwcm92aWRlckFzdCwgcXVlcnlNYXRjaGVzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZsYWdzID0gMDtcbiAgICAgICAgaWYgKCFwcm92aWRlckFzdC5lYWdlcikge1xuICAgICAgICAgICAgZmxhZ3MgfD0gMjA0OCAvKiBMYXp5UHJvdmlkZXIgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVyQXN0LnByb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLlByaXZhdGVTZXJ2aWNlKSB7XG4gICAgICAgICAgICBmbGFncyB8PSA0MDk2IC8qIFByaXZhdGVQcm92aWRlciAqLztcbiAgICAgICAgfVxuICAgICAgICBwcm92aWRlckFzdC5saWZlY3ljbGVIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaWZlY3ljbGVIb29rKSB7XG4gICAgICAgICAgICAvLyBmb3IgcmVndWxhciBwcm92aWRlcnMsIHdlIG9ubHkgc3VwcG9ydCBuZ09uRGVzdHJveVxuICAgICAgICAgICAgaWYgKGxpZmVjeWNsZUhvb2sgPT09IMm1TGlmZWN5Y2xlSG9va3MuT25EZXN0cm95IHx8XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJBc3QucHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJBc3QucHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gbGlmZWN5Y2xlSG9va1RvTm9kZUZsYWcobGlmZWN5Y2xlSG9vayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyeU1hdGNoRXhwcnMgPSBbXTtcbiAgICAgICAgcXVlcnlNYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICBpZiAodG9rZW5SZWZlcmVuY2UobWF0Y2gudmFsdWUpID09PSB0b2tlblJlZmVyZW5jZShwcm92aWRlckFzdC50b2tlbikpIHtcbiAgICAgICAgICAgICAgICBxdWVyeU1hdGNoRXhwcnMucHVzaChsaXRlcmFsQXJyKFtsaXRlcmFsKG1hdGNoLnF1ZXJ5SWQpLCBsaXRlcmFsKDQgLyogUHJvdmlkZXIgKi8pXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9hID0gcHJvdmlkZXJEZWYocHJvdmlkZXJBc3QpLCBwcm92aWRlckV4cHIgPSBfYS5wcm92aWRlckV4cHIsIGRlcHNFeHByID0gX2EuZGVwc0V4cHIsIHByb3ZpZGVyVHlwZSA9IF9hLmZsYWdzO1xuICAgICAgICByZXR1cm4geyBmbGFnczogZmxhZ3MgfCBwcm92aWRlclR5cGUsIHF1ZXJ5TWF0Y2hFeHByczogcXVlcnlNYXRjaEV4cHJzLCBwcm92aWRlckV4cHI6IHByb3ZpZGVyRXhwciwgZGVwc0V4cHI6IGRlcHNFeHByIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5nZXRMb2NhbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09IEV2ZW50SGFuZGxlclZhcnMuZXZlbnQubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIEV2ZW50SGFuZGxlclZhcnMuZXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VyclZpZXdFeHByID0gVklFV19WQVI7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gY3VyckJ1aWxkZXIgPSB0aGlzOyBjdXJyQnVpbGRlcjsgY3VyckJ1aWxkZXIgPSBjdXJyQnVpbGRlci5wYXJlbnQsXG4gICAgICAgICAgICBjdXJyVmlld0V4cHIgPSBjdXJyVmlld0V4cHIucHJvcCgncGFyZW50JykuY2FzdChEWU5BTUlDX1RZUEUpKSB7XG4gICAgICAgICAgICAvLyBjaGVjayByZWZlcmVuY2VzXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWZOb2RlSW5kZXggPSBjdXJyQnVpbGRlci5yZWZOb2RlSW5kaWNlc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChyZWZOb2RlSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMubm9kZVZhbHVlKSkuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICAgICAgY3VyclZpZXdFeHByLCBsaXRlcmFsKHJlZk5vZGVJbmRleClcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIHZhcmlhYmxlc1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFyQXN0ID0gY3VyckJ1aWxkZXIudmFyaWFibGVzLmZpbmQoZnVuY3Rpb24gKHZhckFzdCkgeyByZXR1cm4gdmFyQXN0Lm5hbWUgPT09IG5hbWU7IH0pO1xuICAgICAgICAgICAgaWYgKHZhckFzdCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhclZhbHVlID0gdmFyQXN0LnZhbHVlIHx8IElNUExJQ0lUX1RFTVBMQVRFX1ZBUjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyclZpZXdFeHByLnByb3AoJ2NvbnRleHQnKS5wcm9wKHZhclZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gYXJnQ291bnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVMaXRlcmFsQXJyYXlDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoc291cmNlU3BhbiwgYXJnQ291bnQpIHtcbiAgICAgICAgaWYgKGFyZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZUV4cHJfMSA9IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5FTVBUWV9BUlJBWSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlRXhwcl8xOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICAvLyBwdXJlQXJyYXlEZWYoYXJnQ291bnQ6IG51bWJlcik6IE5vZGVEZWY7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3Bhbjogc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogMTYgLyogVHlwZVB1cmVBcnJheSAqLyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5wdXJlQXJyYXlEZWYpKS5jYWxsRm4oW2xpdGVyYWwoYXJnQ291bnQpXSlcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHsgcmV0dXJuIGNhbGxDaGVja1N0bXQobm9kZUluZGV4LCBhcmdzKTsgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30ga2V5c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLmNyZWF0ZUxpdGVyYWxNYXBDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoc291cmNlU3Bhbiwga2V5cykge1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlRXhwcl8yID0gaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLkVNUFRZX01BUCkpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlRXhwcl8yOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICAvLyBmdW5jdGlvbiBwdXJlT2JqZWN0RGVmKHByb3BlcnR5TmFtZXM6IHN0cmluZ1tdKTogTm9kZURlZlxuICAgICAgICB0aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IHNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDMyIC8qIFR5cGVQdXJlT2JqZWN0ICovLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLnB1cmVPYmplY3REZWYpKVxuICAgICAgICAgICAgICAgIC5jYWxsRm4oW2xpdGVyYWxBcnIoa2V5cy5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gbGl0ZXJhbChrZXkpOyB9KSldKVxuICAgICAgICB9KTsgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJncykgeyByZXR1cm4gY2FsbENoZWNrU3RtdChub2RlSW5kZXgsIGFyZ3MpOyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBhcmdDb3VudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLmNyZWF0ZVBpcGVDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgbmFtZSwgYXJnQ291bnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGlwZSA9ICgodGhpcy51c2VkUGlwZXMuZmluZChmdW5jdGlvbiAocGlwZVN1bW1hcnkpIHsgcmV0dXJuIHBpcGVTdW1tYXJ5Lm5hbWUgPT09IG5hbWU7IH0pKSk7XG4gICAgICAgIGlmIChwaXBlLnB1cmUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVJbmRleF8xID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICAvLyBmdW5jdGlvbiBwdXJlUGlwZURlZihhcmdDb3VudDogbnVtYmVyKTogTm9kZURlZjtcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGV4cHJlc3Npb24uc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICBub2RlRmxhZ3M6IDY0IC8qIFR5cGVQdXJlUGlwZSAqLyxcbiAgICAgICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMucHVyZVBpcGVEZWYpKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbEZuKFtsaXRlcmFsKGFyZ0NvdW50KV0pXG4gICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICAvLyBmaW5kIHVuZGVybHlpbmcgcGlwZSBpbiB0aGUgY29tcG9uZW50IHZpZXdcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBWaWV3RXhwciA9IFZJRVdfVkFSO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcEJ1aWxkZXIgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBCdWlsZGVyLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNvbXBCdWlsZGVyID0gY29tcEJ1aWxkZXIucGFyZW50O1xuICAgICAgICAgICAgICAgIGNvbXBWaWV3RXhwciA9IGNvbXBWaWV3RXhwci5wcm9wKCdwYXJlbnQnKS5jYXN0KERZTkFNSUNfVFlQRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaXBlTm9kZUluZGV4ID0gY29tcEJ1aWxkZXIucHVyZVBpcGVOb2RlSW5kaWNlc1tuYW1lXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGVWYWx1ZUV4cHJfMSA9IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5ub2RlVmFsdWUpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGNvbXBWaWV3RXhwciwgbGl0ZXJhbChwaXBlTm9kZUluZGV4KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHsgcmV0dXJuIGNhbGxVbndyYXBWYWx1ZShleHByZXNzaW9uLm5vZGVJbmRleCwgZXhwcmVzc2lvbi5iaW5kaW5nSW5kZXgsIGNhbGxDaGVja1N0bXQobm9kZUluZGV4XzEsIFtwaXBlVmFsdWVFeHByXzFdLmNvbmNhdChhcmdzKSkpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZUluZGV4ID0gdGhpcy5fY3JlYXRlUGlwZShleHByZXNzaW9uLnNvdXJjZVNwYW4sIHBpcGUpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZVZhbHVlRXhwcl8xID0gaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLm5vZGVWYWx1ZSkpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgVklFV19WQVIsIGxpdGVyYWwobm9kZUluZGV4KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHsgcmV0dXJuIGNhbGxVbndyYXBWYWx1ZShleHByZXNzaW9uLm5vZGVJbmRleCwgZXhwcmVzc2lvbi5iaW5kaW5nSW5kZXgsIG5vZGVWYWx1ZUV4cHJfMS5jYWxsTWV0aG9kKCd0cmFuc2Zvcm0nLCBhcmdzKSk7IH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gcGlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl9jcmVhdGVQaXBlID0gZnVuY3Rpb24gKHNvdXJjZVNwYW4sIHBpcGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZUluZGV4ID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZsYWdzID0gMDtcbiAgICAgICAgcGlwZS50eXBlLmxpZmVjeWNsZUhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGxpZmVjeWNsZUhvb2spIHtcbiAgICAgICAgICAgIC8vIGZvciBwaXBlcywgd2Ugb25seSBzdXBwb3J0IG5nT25EZXN0cm95XG4gICAgICAgICAgICBpZiAobGlmZWN5Y2xlSG9vayA9PT0gybVMaWZlY3ljbGVIb29rcy5PbkRlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBmbGFncyB8PSBsaWZlY3ljbGVIb29rVG9Ob2RlRmxhZyhsaWZlY3ljbGVIb29rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcEV4cHJzID0gcGlwZS50eXBlLmRpRGVwcy5tYXAoZGVwRGVmKTtcbiAgICAgICAgLy8gZnVuY3Rpb24gcGlwZURlZihcbiAgICAgICAgLy8gICBmbGFnczogTm9kZUZsYWdzLCBjdG9yOiBhbnksIGRlcHM6IChbRGVwRmxhZ3MsIGFueV0gfCBhbnkpW10pOiBOb2RlRGVmXG4gICAgICAgIHRoaXMubm9kZXMucHVzaChmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3Bhbjogc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogOCAvKiBUeXBlUGlwZSAqLyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5waXBlRGVmKSkuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGZsYWdzKSwgaW1wb3J0RXhwcihwaXBlLnR5cGUpLCBsaXRlcmFsQXJyKGRlcEV4cHJzKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICByZXR1cm4gbm9kZUluZGV4O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX3ByZXByb2Nlc3NVcGRhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGVJbmRleDogZXhwcmVzc2lvbi5ub2RlSW5kZXgsXG4gICAgICAgICAgICBiaW5kaW5nSW5kZXg6IGV4cHJlc3Npb24uYmluZGluZ0luZGV4LFxuICAgICAgICAgICAgc291cmNlU3BhbjogZXhwcmVzc2lvbi5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgY29udGV4dDogZXhwcmVzc2lvbi5jb250ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmdCdWlsdGlucyh7XG4gICAgICAgICAgICAgICAgY3JlYXRlTGl0ZXJhbEFycmF5Q29udmVydGVyOiBmdW5jdGlvbiAoYXJnQ291bnQpIHsgcmV0dXJuIF90aGlzLmNyZWF0ZUxpdGVyYWxBcnJheUNvbnZlcnRlcihleHByZXNzaW9uLnNvdXJjZVNwYW4sIGFyZ0NvdW50KTsgfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVMaXRlcmFsTWFwQ29udmVydGVyOiBmdW5jdGlvbiAoa2V5cykgeyByZXR1cm4gX3RoaXMuY3JlYXRlTGl0ZXJhbE1hcENvbnZlcnRlcihleHByZXNzaW9uLnNvdXJjZVNwYW4sIGtleXMpOyB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZVBpcGVDb252ZXJ0ZXI6IGZ1bmN0aW9uIChuYW1lLCBhcmdDb3VudCkgeyByZXR1cm4gX3RoaXMuY3JlYXRlUGlwZUNvbnZlcnRlcihleHByZXNzaW9uLCBuYW1lLCBhcmdDb3VudCk7IH1cbiAgICAgICAgICAgIH0sIGV4cHJlc3Npb24udmFsdWUpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fY3JlYXRlTm9kZUV4cHJlc3Npb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBkYXRlQmluZGluZ0NvdW50ID0gMDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBkYXRlUmVuZGVyZXJTdG10cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cGRhdGVEaXJlY3RpdmVzU3RtdHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZURlZkV4cHJzID0gdGhpcy5ub2Rlcy5tYXAoZnVuY3Rpb24gKGZhY3RvcnksIG5vZGVJbmRleCkge1xuICAgICAgICAgICAgdmFyIF9hID0gZmFjdG9yeSgpLCBub2RlRGVmID0gX2Eubm9kZURlZiwgbm9kZUZsYWdzID0gX2Eubm9kZUZsYWdzLCB1cGRhdGVEaXJlY3RpdmVzID0gX2EudXBkYXRlRGlyZWN0aXZlcywgdXBkYXRlUmVuZGVyZXIgPSBfYS51cGRhdGVSZW5kZXJlciwgc291cmNlU3BhbiA9IF9hLnNvdXJjZVNwYW47XG4gICAgICAgICAgICBpZiAodXBkYXRlUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVSZW5kZXJlclN0bXRzLnB1c2guYXBwbHkodXBkYXRlUmVuZGVyZXJTdG10cywgY3JlYXRlVXBkYXRlU3RhdGVtZW50cyhub2RlSW5kZXgsIHNvdXJjZVNwYW4sIHVwZGF0ZVJlbmRlcmVyLCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZURpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVEaXJlY3RpdmVzU3RtdHMucHVzaC5hcHBseSh1cGRhdGVEaXJlY3RpdmVzU3RtdHMsIGNyZWF0ZVVwZGF0ZVN0YXRlbWVudHMobm9kZUluZGV4LCBzb3VyY2VTcGFuLCB1cGRhdGVEaXJlY3RpdmVzLCAobm9kZUZsYWdzICYgKDEzMTA3MiAvKiBEb0NoZWNrICovIHwgMzI3NjggLyogT25Jbml0ICovKSkgPiAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSB1c2UgYSBjb21tYSBleHByZXNzaW9uIHRvIGNhbGwgdGhlIGxvZyBmdW5jdGlvbiBiZWZvcmVcbiAgICAgICAgICAgIC8vIHRoZSBub2RlRGVmIGZ1bmN0aW9uLCBidXQgc3RpbGwgdXNlIHRoZSByZXN1bHQgb2YgdGhlIG5vZGVEZWYgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIGFzIHRoZSB2YWx1ZS5cbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIG9ubHkgYWRkIHRoZSBsb2dnZXIgdG8gZWxlbWVudHMgLyB0ZXh0IG5vZGVzLFxuICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgZ2VuZXJhdGUgdG9vIG11Y2ggY29kZS5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvZ1dpdGhOb2RlRGVmID0gbm9kZUZsYWdzICYgMyAvKiBDYXRSZW5kZXJOb2RlICovID9cbiAgICAgICAgICAgICAgICBuZXcgQ29tbWFFeHByKFtMT0dfVkFSLmNhbGxGbihbXSkuY2FsbEZuKFtdKSwgbm9kZURlZl0pIDpcbiAgICAgICAgICAgICAgICBub2RlRGVmO1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5U291cmNlU3BhblRvRXhwcmVzc2lvbklmTmVlZGVkKGxvZ1dpdGhOb2RlRGVmLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IHVwZGF0ZVJlbmRlcmVyU3RtdHM6IHVwZGF0ZVJlbmRlcmVyU3RtdHMsIHVwZGF0ZURpcmVjdGl2ZXNTdG10czogdXBkYXRlRGlyZWN0aXZlc1N0bXRzLCBub2RlRGVmRXhwcnM6IG5vZGVEZWZFeHBycyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBub2RlSW5kZXhcbiAgICAgICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvbnNcbiAgICAgICAgICogQHBhcmFtIHs/fSBhbGxvd0VtcHR5RXhwcnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVVwZGF0ZVN0YXRlbWVudHMobm9kZUluZGV4LCBzb3VyY2VTcGFuLCBleHByZXNzaW9ucywgYWxsb3dFbXB0eUV4cHJzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cGRhdGVTdG10cyA9IFtdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwcnMgPSBleHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZVNwYW4gPSBfYS5zb3VyY2VTcGFuLCBjb250ZXh0ID0gX2EuY29udGV4dCwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5nSWQgPSBcIlwiICsgdXBkYXRlQmluZGluZ0NvdW50Kys7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZVJlc29sdmVyID0gY29udGV4dCA9PT0gQ09NUF9WQVIgPyBzZWxmIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBjb252ZXJ0UHJvcGVydHlCaW5kaW5nKG5hbWVSZXNvbHZlciwgY29udGV4dCwgdmFsdWUsIGJpbmRpbmdJZCksIHN0bXRzID0gX2Iuc3RtdHMsIGN1cnJWYWxFeHByID0gX2IuY3VyclZhbEV4cHI7XG4gICAgICAgICAgICAgICAgdXBkYXRlU3RtdHMucHVzaC5hcHBseSh1cGRhdGVTdG10cywgc3RtdHMubWFwKGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBhcHBseVNvdXJjZVNwYW5Ub1N0YXRlbWVudElmTmVlZGVkKHN0bXQsIHNvdXJjZVNwYW4pOyB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5U291cmNlU3BhblRvRXhwcmVzc2lvbklmTmVlZGVkKGN1cnJWYWxFeHByLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCB8fCBhbGxvd0VtcHR5RXhwcnMpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoKGFwcGx5U291cmNlU3BhblRvU3RhdGVtZW50SWZOZWVkZWQoY2FsbENoZWNrU3RtdChub2RlSW5kZXgsIGV4cHJzKS50b1N0bXQoKSwgc291cmNlU3BhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN0bXRzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVJbmRleFxuICAgICAqIEBwYXJhbSB7P30gaGFuZGxlcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fY3JlYXRlRWxlbWVudEhhbmRsZUV2ZW50Rm4gPSBmdW5jdGlvbiAobm9kZUluZGV4LCBoYW5kbGVycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoYW5kbGVFdmVudFN0bXRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhbmRsZUV2ZW50QmluZGluZ0NvdW50ID0gMDtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gX2EuY29udGV4dCwgZXZlbnRBc3QgPSBfYS5ldmVudEFzdCwgZGlyQXN0ID0gX2EuZGlyQXN0O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmluZGluZ0lkID0gXCJcIiArIGhhbmRsZUV2ZW50QmluZGluZ0NvdW50Kys7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lUmVzb2x2ZXIgPSBjb250ZXh0ID09PSBDT01QX1ZBUiA/IF90aGlzIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBfYiA9IGNvbnZlcnRBY3Rpb25CaW5kaW5nKG5hbWVSZXNvbHZlciwgY29udGV4dCwgZXZlbnRBc3QuaGFuZGxlciwgYmluZGluZ0lkKSwgc3RtdHMgPSBfYi5zdG10cywgYWxsb3dEZWZhdWx0ID0gX2IuYWxsb3dEZWZhdWx0O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJ1ZVN0bXRzID0gc3RtdHM7XG4gICAgICAgICAgICBpZiAoYWxsb3dEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgdHJ1ZVN0bXRzLnB1c2goQUxMT1dfREVGQVVMVF9WQVIuc2V0KGFsbG93RGVmYXVsdC5hbmQoQUxMT1dfREVGQVVMVF9WQVIpKS50b1N0bXQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2MgPSBlbGVtZW50RXZlbnROYW1lQW5kVGFyZ2V0KGV2ZW50QXN0LCBkaXJBc3QpLCBldmVudFRhcmdldCA9IF9jLnRhcmdldCwgZXZlbnROYW1lID0gX2MubmFtZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZ1bGxFdmVudE5hbWUgPSDJtWVsZW1lbnRFdmVudEZ1bGxOYW1lKGV2ZW50VGFyZ2V0LCBldmVudE5hbWUpO1xuICAgICAgICAgICAgaGFuZGxlRXZlbnRTdG10cy5wdXNoKGFwcGx5U291cmNlU3BhblRvU3RhdGVtZW50SWZOZWVkZWQobmV3IElmU3RtdChsaXRlcmFsKGZ1bGxFdmVudE5hbWUpLmlkZW50aWNhbChFVkVOVF9OQU1FX1ZBUiksIHRydWVTdG10cyksIGV2ZW50QXN0LnNvdXJjZVNwYW4pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhbmRsZUV2ZW50Rm47XG4gICAgICAgIGlmIChoYW5kbGVFdmVudFN0bXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZVN0bXRzID0gW0FMTE9XX0RFRkFVTFRfVkFSLnNldChsaXRlcmFsKHRydWUpKS50b0RlY2xTdG10KEJPT0xfVFlQRSldO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudC5pc0hvc3QgJiYgZmluZFJlYWRWYXJOYW1lcyhoYW5kbGVFdmVudFN0bXRzKS5oYXMoLyoqIEB0eXBlIHs/fSAqLyAoKENPTVBfVkFSLm5hbWUpKSkpIHtcbiAgICAgICAgICAgICAgICBwcmVTdG10cy5wdXNoKENPTVBfVkFSLnNldChWSUVXX1ZBUi5wcm9wKCdjb21wb25lbnQnKSkudG9EZWNsU3RtdCh0aGlzLmNvbXBUeXBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVFdmVudEZuID0gZm4oW1xuICAgICAgICAgICAgICAgIG5ldyBGblBhcmFtKC8qKiBAdHlwZSB7P30gKi8gKChWSUVXX1ZBUi5uYW1lKSksIElORkVSUkVEX1RZUEUpLFxuICAgICAgICAgICAgICAgIG5ldyBGblBhcmFtKC8qKiBAdHlwZSB7P30gKi8gKChFVkVOVF9OQU1FX1ZBUi5uYW1lKSksIElORkVSUkVEX1RZUEUpLFxuICAgICAgICAgICAgICAgIG5ldyBGblBhcmFtKC8qKiBAdHlwZSB7P30gKi8gKChFdmVudEhhbmRsZXJWYXJzLmV2ZW50Lm5hbWUpKSwgSU5GRVJSRURfVFlQRSlcbiAgICAgICAgICAgIF0sIHByZVN0bXRzLmNvbmNhdChoYW5kbGVFdmVudFN0bXRzLCBbbmV3IFJldHVyblN0YXRlbWVudChBTExPV19ERUZBVUxUX1ZBUildKSwgSU5GRVJSRURfVFlQRSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVFdmVudEZuID0gTlVMTF9FWFBSO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVFdmVudEZuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RGlyZWN0aXZlUHJvcGVydHkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdFJlZmVyZW5jZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0VmFyaWFibGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEV2ZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEF0dHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgcmV0dXJuIFZpZXdCdWlsZGVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBwcm92aWRlckFzdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcHJvdmlkZXJEZWYocHJvdmlkZXJBc3QpIHtcbiAgICByZXR1cm4gcHJvdmlkZXJBc3QubXVsdGlQcm92aWRlciA/XG4gICAgICAgIG11bHRpUHJvdmlkZXJEZWYocHJvdmlkZXJBc3QucHJvdmlkZXJzKSA6XG4gICAgICAgIHNpbmdsZVByb3ZpZGVyRGVmKHByb3ZpZGVyQXN0LnByb3ZpZGVyVHlwZSwgcHJvdmlkZXJBc3QucHJvdmlkZXJzWzBdKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwcm92aWRlcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG11bHRpUHJvdmlkZXJEZWYocHJvdmlkZXJzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsRGVwRGVmcyA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbFBhcmFtcyA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJzID0gcHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIsIHByb3ZpZGVySW5kZXgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwcjtcbiAgICAgICAgaWYgKHByb3ZpZGVyLnVzZUNsYXNzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBFeHBycyA9IGNvbnZlcnREZXBzKHByb3ZpZGVySW5kZXgsIHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlQ2xhc3MuZGlEZXBzKTtcbiAgICAgICAgICAgIGV4cHIgPSBpbXBvcnRFeHByKHByb3ZpZGVyLnVzZUNsYXNzKS5pbnN0YW50aWF0ZShkZXBFeHBycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwRXhwcnMgPSBjb252ZXJ0RGVwcyhwcm92aWRlckluZGV4LCBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUZhY3RvcnkuZGlEZXBzKTtcbiAgICAgICAgICAgIGV4cHIgPSBpbXBvcnRFeHByKHByb3ZpZGVyLnVzZUZhY3RvcnkpLmNhbGxGbihkZXBFeHBycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRXhpc3RpbmcpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcEV4cHJzID0gY29udmVydERlcHMocHJvdmlkZXJJbmRleCwgW3sgdG9rZW46IHByb3ZpZGVyLnVzZUV4aXN0aW5nIH1dKTtcbiAgICAgICAgICAgIGV4cHIgPSBkZXBFeHByc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4cHIgPSBjb252ZXJ0VmFsdWVUb091dHB1dEFzdChwcm92aWRlci51c2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvdmlkZXJFeHByID0gZm4oYWxsUGFyYW1zLCBbbmV3IFJldHVyblN0YXRlbWVudChsaXRlcmFsQXJyKGV4cHJzKSldLCBJTkZFUlJFRF9UWVBFKTtcbiAgICByZXR1cm4geyBwcm92aWRlckV4cHI6IHByb3ZpZGVyRXhwciwgZmxhZ3M6IDUxMiAvKiBUeXBlRmFjdG9yeVByb3ZpZGVyICovLCBkZXBzRXhwcjogbGl0ZXJhbEFycihhbGxEZXBEZWZzKSB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJJbmRleFxuICAgICAqIEBwYXJhbSB7P30gZGVwc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udmVydERlcHMocHJvdmlkZXJJbmRleCwgZGVwcykge1xuICAgICAgICByZXR1cm4gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCwgZGVwSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtTmFtZSA9IFwicFwiICsgcHJvdmlkZXJJbmRleCArIFwiX1wiICsgZGVwSW5kZXg7XG4gICAgICAgICAgICBhbGxQYXJhbXMucHVzaChuZXcgRm5QYXJhbShwYXJhbU5hbWUsIERZTkFNSUNfVFlQRSkpO1xuICAgICAgICAgICAgYWxsRGVwRGVmcy5wdXNoKGRlcERlZihkZXApKTtcbiAgICAgICAgICAgIHJldHVybiB2YXJpYWJsZShwYXJhbU5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcHJvdmlkZXJUeXBlXG4gKiBAcGFyYW0gez99IHByb3ZpZGVyTWV0YVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc2luZ2xlUHJvdmlkZXJEZWYocHJvdmlkZXJUeXBlLCBwcm92aWRlck1ldGEpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlckV4cHI7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmxhZ3M7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwcztcbiAgICBpZiAocHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8IHByb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLkNvbXBvbmVudCkge1xuICAgICAgICBwcm92aWRlckV4cHIgPSBpbXBvcnRFeHByKC8qKiBAdHlwZSB7P30gKi8gKChwcm92aWRlck1ldGEudXNlQ2xhc3MpKSk7XG4gICAgICAgIGZsYWdzID0gODE5MiAvKiBUeXBlRGlyZWN0aXZlICovO1xuICAgICAgICBkZXBzID0gcHJvdmlkZXJNZXRhLmRlcHMgfHwgKChwcm92aWRlck1ldGEudXNlQ2xhc3MpKS5kaURlcHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAocHJvdmlkZXJNZXRhLnVzZUNsYXNzKSB7XG4gICAgICAgICAgICBwcm92aWRlckV4cHIgPSBpbXBvcnRFeHByKHByb3ZpZGVyTWV0YS51c2VDbGFzcyk7XG4gICAgICAgICAgICBmbGFncyA9IDI1NiAvKiBUeXBlQ2xhc3NQcm92aWRlciAqLztcbiAgICAgICAgICAgIGRlcHMgPSBwcm92aWRlck1ldGEuZGVwcyB8fCBwcm92aWRlck1ldGEudXNlQ2xhc3MuZGlEZXBzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyTWV0YS51c2VGYWN0b3J5KSB7XG4gICAgICAgICAgICBwcm92aWRlckV4cHIgPSBpbXBvcnRFeHByKHByb3ZpZGVyTWV0YS51c2VGYWN0b3J5KTtcbiAgICAgICAgICAgIGZsYWdzID0gNTEyIC8qIFR5cGVGYWN0b3J5UHJvdmlkZXIgKi87XG4gICAgICAgICAgICBkZXBzID0gcHJvdmlkZXJNZXRhLmRlcHMgfHwgcHJvdmlkZXJNZXRhLnVzZUZhY3RvcnkuZGlEZXBzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyTWV0YS51c2VFeGlzdGluZykge1xuICAgICAgICAgICAgcHJvdmlkZXJFeHByID0gTlVMTF9FWFBSO1xuICAgICAgICAgICAgZmxhZ3MgPSAxMDI0IC8qIFR5cGVVc2VFeGlzdGluZ1Byb3ZpZGVyICovO1xuICAgICAgICAgICAgZGVwcyA9IFt7IHRva2VuOiBwcm92aWRlck1ldGEudXNlRXhpc3RpbmcgfV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm92aWRlckV4cHIgPSBjb252ZXJ0VmFsdWVUb091dHB1dEFzdChwcm92aWRlck1ldGEudXNlVmFsdWUpO1xuICAgICAgICAgICAgZmxhZ3MgPSAxMjggLyogVHlwZVZhbHVlUHJvdmlkZXIgKi87XG4gICAgICAgICAgICBkZXBzID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwc0V4cHIgPSBsaXRlcmFsQXJyKGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIGRlcERlZihkZXApOyB9KSk7XG4gICAgcmV0dXJuIHsgcHJvdmlkZXJFeHByOiBwcm92aWRlckV4cHIsIGZsYWdzOiBmbGFncywgZGVwc0V4cHI6IGRlcHNFeHByIH07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdG9rZW5NZXRhXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0b2tlbkV4cHIodG9rZW5NZXRhKSB7XG4gICAgcmV0dXJuIHRva2VuTWV0YS5pZGVudGlmaWVyID8gaW1wb3J0RXhwcih0b2tlbk1ldGEuaWRlbnRpZmllcikgOiBsaXRlcmFsKHRva2VuTWV0YS52YWx1ZSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZGVwXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkZXBEZWYoZGVwKSB7XG4gICAgLy8gTm90ZTogdGhlIGZvbGxvd2luZyBmaWVsZHMgaGF2ZSBhbHJlYWR5IGJlZW4gbm9ybWFsaXplZCBvdXQgYnkgcHJvdmlkZXJfYW5hbHl6ZXI6XG4gICAgLy8gLSBpc0F0dHJpYnV0ZSwgaXNTZWxmLCBpc0hvc3RcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByID0gZGVwLmlzVmFsdWUgPyBjb252ZXJ0VmFsdWVUb091dHB1dEFzdChkZXAudmFsdWUpIDogdG9rZW5FeHByKC8qKiBAdHlwZSB7P30gKi8gKChkZXAudG9rZW4pKSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmxhZ3MgPSAwO1xuICAgIGlmIChkZXAuaXNTa2lwU2VsZikge1xuICAgICAgICBmbGFncyB8PSAxIC8qIFNraXBTZWxmICovO1xuICAgIH1cbiAgICBpZiAoZGVwLmlzT3B0aW9uYWwpIHtcbiAgICAgICAgZmxhZ3MgfD0gMiAvKiBPcHRpb25hbCAqLztcbiAgICB9XG4gICAgaWYgKGRlcC5pc1ZhbHVlKSB7XG4gICAgICAgIGZsYWdzIHw9IDggLyogVmFsdWUgKi87XG4gICAgfVxuICAgIHJldHVybiBmbGFncyA9PT0gMCAvKiBOb25lICovID8gZXhwciA6IGxpdGVyYWxBcnIoW2xpdGVyYWwoZmxhZ3MpLCBleHByXSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gYXN0Tm9kZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5lZWRzQWRkaXRpb25hbFJvb3ROb2RlKGFzdE5vZGVzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGFzdEFzdE5vZGUgPSBhc3ROb2Rlc1thc3ROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdEFzdE5vZGUgaW5zdGFuY2VvZiBFbWJlZGRlZFRlbXBsYXRlQXN0KSB7XG4gICAgICAgIHJldHVybiBsYXN0QXN0Tm9kZS5oYXNWaWV3Q29udGFpbmVyO1xuICAgIH1cbiAgICBpZiAobGFzdEFzdE5vZGUgaW5zdGFuY2VvZiBFbGVtZW50QXN0KSB7XG4gICAgICAgIGlmIChpc05nQ29udGFpbmVyKGxhc3RBc3ROb2RlLm5hbWUpICYmIGxhc3RBc3ROb2RlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5lZWRzQWRkaXRpb25hbFJvb3ROb2RlKGxhc3RBc3ROb2RlLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFzdEFzdE5vZGUuaGFzVmlld0NvbnRhaW5lcjtcbiAgICB9XG4gICAgcmV0dXJuIGxhc3RBc3ROb2RlIGluc3RhbmNlb2YgTmdDb250ZW50QXN0O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGxpZmVjeWNsZUhvb2tcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGxpZmVjeWNsZUhvb2tUb05vZGVGbGFnKGxpZmVjeWNsZUhvb2spIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlRmxhZyA9IDA7XG4gICAgc3dpdGNoIChsaWZlY3ljbGVIb29rKSB7XG4gICAgICAgIGNhc2UgybVMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkOlxuICAgICAgICAgICAgbm9kZUZsYWcgPSAxMDQ4NTc2IC8qIEFmdGVyQ29udGVudENoZWNrZWQgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSDJtUxpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudEluaXQ6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDUyNDI4OCAvKiBBZnRlckNvbnRlbnRJbml0ICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgybVMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdDaGVja2VkOlxuICAgICAgICAgICAgbm9kZUZsYWcgPSA0MTk0MzA0IC8qIEFmdGVyVmlld0NoZWNrZWQgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSDJtUxpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0luaXQ6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDIwOTcxNTIgLyogQWZ0ZXJWaWV3SW5pdCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIMm1TGlmZWN5Y2xlSG9va3MuRG9DaGVjazpcbiAgICAgICAgICAgIG5vZGVGbGFnID0gMTMxMDcyIC8qIERvQ2hlY2sgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSDJtUxpZmVjeWNsZUhvb2tzLk9uQ2hhbmdlczpcbiAgICAgICAgICAgIG5vZGVGbGFnID0gMjYyMTQ0IC8qIE9uQ2hhbmdlcyAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIMm1TGlmZWN5Y2xlSG9va3MuT25EZXN0cm95OlxuICAgICAgICAgICAgbm9kZUZsYWcgPSA2NTUzNiAvKiBPbkRlc3Ryb3kgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSDJtUxpZmVjeWNsZUhvb2tzLk9uSW5pdDpcbiAgICAgICAgICAgIG5vZGVGbGFnID0gMzI3NjggLyogT25Jbml0ICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBub2RlRmxhZztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpbnB1dEFzdFxuICogQHBhcmFtIHs/fSBkaXJBc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRCaW5kaW5nRGVmKGlucHV0QXN0LCBkaXJBc3QpIHtcbiAgICBzd2l0Y2ggKGlucHV0QXN0LnR5cGUpIHtcbiAgICAgICAgY2FzZSBQcm9wZXJ0eUJpbmRpbmdUeXBlLkF0dHJpYnV0ZTpcbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsQXJyKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKDEgLyogVHlwZUVsZW1lbnRBdHRyaWJ1dGUgKi8pLCBsaXRlcmFsKGlucHV0QXN0Lm5hbWUpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoaW5wdXRBc3Quc2VjdXJpdHlDb250ZXh0KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIGNhc2UgUHJvcGVydHlCaW5kaW5nVHlwZS5Qcm9wZXJ0eTpcbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsQXJyKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKDggLyogVHlwZVByb3BlcnR5ICovKSwgbGl0ZXJhbChpbnB1dEFzdC5uYW1lKSxcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGlucHV0QXN0LnNlY3VyaXR5Q29udGV4dClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICBjYXNlIFByb3BlcnR5QmluZGluZ1R5cGUuQW5pbWF0aW9uOlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmluZGluZ1R5cGUgPSA4IC8qIFR5cGVQcm9wZXJ0eSAqLyB8XG4gICAgICAgICAgICAgICAgKGRpckFzdCAmJiBkaXJBc3QuZGlyZWN0aXZlLmlzQ29tcG9uZW50ID8gMzIgLyogU3ludGhldGljSG9zdFByb3BlcnR5ICovIDpcbiAgICAgICAgICAgICAgICAgICAgMTYgLyogU3ludGhldGljUHJvcGVydHkgKi8pO1xuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoYmluZGluZ1R5cGUpLCBsaXRlcmFsKCdAJyArIGlucHV0QXN0Lm5hbWUpLCBsaXRlcmFsKGlucHV0QXN0LnNlY3VyaXR5Q29udGV4dClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICBjYXNlIFByb3BlcnR5QmluZGluZ1R5cGUuQ2xhc3M6XG4gICAgICAgICAgICByZXR1cm4gbGl0ZXJhbEFycihbbGl0ZXJhbCgyIC8qIFR5cGVFbGVtZW50Q2xhc3MgKi8pLCBsaXRlcmFsKGlucHV0QXN0Lm5hbWUpLCBOVUxMX0VYUFJdKTtcbiAgICAgICAgY2FzZSBQcm9wZXJ0eUJpbmRpbmdUeXBlLlN0eWxlOlxuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoNCAvKiBUeXBlRWxlbWVudFN0eWxlICovKSwgbGl0ZXJhbChpbnB1dEFzdC5uYW1lKSwgbGl0ZXJhbChpbnB1dEFzdC51bml0KVxuICAgICAgICAgICAgXSk7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IGVsZW1lbnRBc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGZpeGVkQXR0cnNEZWYoZWxlbWVudEFzdCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcFJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZWxlbWVudEFzdC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyQXN0KSB7IG1hcFJlc3VsdFthdHRyQXN0Lm5hbWVdID0gYXR0ckFzdC52YWx1ZTsgfSk7XG4gICAgZWxlbWVudEFzdC5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpckFzdCkge1xuICAgICAgICBPYmplY3Qua2V5cyhkaXJBc3QuZGlyZWN0aXZlLmhvc3RBdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGRpckFzdC5kaXJlY3RpdmUuaG9zdEF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2VmFsdWUgPSBtYXBSZXN1bHRbbmFtZV07XG4gICAgICAgICAgICBtYXBSZXN1bHRbbmFtZV0gPSBwcmV2VmFsdWUgIT0gbnVsbCA/IG1lcmdlQXR0cmlidXRlVmFsdWUobmFtZSwgcHJldlZhbHVlLCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gTm90ZTogV2UgbmVlZCB0byBzb3J0IHRvIGdldCBhIGRlZmluZWQgb3V0cHV0IG9yZGVyXG4gICAgLy8gZm9yIHRlc3RzIGFuZCBmb3IgY2FjaGluZyBnZW5lcmF0ZWQgYXJ0aWZhY3RzLi4uXG4gICAgcmV0dXJuIGxpdGVyYWxBcnIoT2JqZWN0LmtleXMobWFwUmVzdWx0KS5zb3J0KCkubWFwKGZ1bmN0aW9uIChhdHRyTmFtZSkgeyByZXR1cm4gbGl0ZXJhbEFycihbbGl0ZXJhbChhdHRyTmFtZSksIGxpdGVyYWwobWFwUmVzdWx0W2F0dHJOYW1lXSldKTsgfSkpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGF0dHJOYW1lXG4gKiBAcGFyYW0gez99IGF0dHJWYWx1ZTFcbiAqIEBwYXJhbSB7P30gYXR0clZhbHVlMlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBdHRyaWJ1dGVWYWx1ZShhdHRyTmFtZSwgYXR0clZhbHVlMSwgYXR0clZhbHVlMikge1xuICAgIGlmIChhdHRyTmFtZSA9PSBDTEFTU19BVFRSJDEgfHwgYXR0ck5hbWUgPT0gU1RZTEVfQVRUUikge1xuICAgICAgICByZXR1cm4gYXR0clZhbHVlMSArIFwiIFwiICsgYXR0clZhbHVlMjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhdHRyVmFsdWUyO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBub2RlSW5kZXhcbiAqIEBwYXJhbSB7P30gZXhwcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNhbGxDaGVja1N0bXQobm9kZUluZGV4LCBleHBycykge1xuICAgIGlmIChleHBycy5sZW5ndGggPiAxMCkge1xuICAgICAgICByZXR1cm4gQ0hFQ0tfVkFSLmNhbGxGbihbVklFV19WQVIsIGxpdGVyYWwobm9kZUluZGV4KSwgbGl0ZXJhbCgxIC8qIER5bmFtaWMgKi8pLCBsaXRlcmFsQXJyKGV4cHJzKV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIENIRUNLX1ZBUi5jYWxsRm4oW1ZJRVdfVkFSLCBsaXRlcmFsKG5vZGVJbmRleCksIGxpdGVyYWwoMCAvKiBJbmxpbmUgKi8pXS5jb25jYXQoZXhwcnMpKTtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbm9kZUluZGV4XG4gKiBAcGFyYW0gez99IGJpbmRpbmdJZHhcbiAqIEBwYXJhbSB7P30gZXhwclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY2FsbFVud3JhcFZhbHVlKG5vZGVJbmRleCwgYmluZGluZ0lkeCwgZXhwcikge1xuICAgIHJldHVybiBpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMudW53cmFwVmFsdWUpKS5jYWxsRm4oW1xuICAgICAgICBWSUVXX1ZBUiwgbGl0ZXJhbChub2RlSW5kZXgpLCBsaXRlcmFsKGJpbmRpbmdJZHgpLCBleHByXG4gICAgXSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbm9kZXNcbiAqIEBwYXJhbSB7Pz19IHJlc3VsdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZmluZFN0YXRpY1F1ZXJ5SWRzKG5vZGVzLCByZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsgcmVzdWx0ID0gbmV3IE1hcCgpOyB9XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0aWNRdWVyeUlkcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHluYW1pY1F1ZXJ5SWRzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyeU1hdGNoZXMgPSAoKHVuZGVmaW5lZCkpO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnRBc3QpIHtcbiAgICAgICAgICAgIGZpbmRTdGF0aWNRdWVyeUlkcyhub2RlLmNoaWxkcmVuLCByZXN1bHQpO1xuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoaWxkRGF0YSA9ICgocmVzdWx0LmdldChjaGlsZCkpKTtcbiAgICAgICAgICAgICAgICBjaGlsZERhdGEuc3RhdGljUXVlcnlJZHMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlJZCkgeyByZXR1cm4gc3RhdGljUXVlcnlJZHMuYWRkKHF1ZXJ5SWQpOyB9KTtcbiAgICAgICAgICAgICAgICBjaGlsZERhdGEuZHluYW1pY1F1ZXJ5SWRzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5SWQpIHsgcmV0dXJuIGR5bmFtaWNRdWVyeUlkcy5hZGQocXVlcnlJZCk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBxdWVyeU1hdGNoZXMgPSBub2RlLnF1ZXJ5TWF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgRW1iZWRkZWRUZW1wbGF0ZUFzdCkge1xuICAgICAgICAgICAgZmluZFN0YXRpY1F1ZXJ5SWRzKG5vZGUuY2hpbGRyZW4sIHJlc3VsdCk7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGREYXRhID0gKChyZXN1bHQuZ2V0KGNoaWxkKSkpO1xuICAgICAgICAgICAgICAgIGNoaWxkRGF0YS5zdGF0aWNRdWVyeUlkcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeUlkKSB7IHJldHVybiBkeW5hbWljUXVlcnlJZHMuYWRkKHF1ZXJ5SWQpOyB9KTtcbiAgICAgICAgICAgICAgICBjaGlsZERhdGEuZHluYW1pY1F1ZXJ5SWRzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5SWQpIHsgcmV0dXJuIGR5bmFtaWNRdWVyeUlkcy5hZGQocXVlcnlJZCk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBxdWVyeU1hdGNoZXMgPSBub2RlLnF1ZXJ5TWF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnlNYXRjaGVzKSB7XG4gICAgICAgICAgICBxdWVyeU1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIHN0YXRpY1F1ZXJ5SWRzLmFkZChtYXRjaC5xdWVyeUlkKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZHluYW1pY1F1ZXJ5SWRzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5SWQpIHsgcmV0dXJuIHN0YXRpY1F1ZXJ5SWRzLmRlbGV0ZShxdWVyeUlkKTsgfSk7XG4gICAgICAgIHJlc3VsdC5zZXQobm9kZSwgeyBzdGF0aWNRdWVyeUlkczogc3RhdGljUXVlcnlJZHMsIGR5bmFtaWNRdWVyeUlkczogZHluYW1pY1F1ZXJ5SWRzIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbm9kZVN0YXRpY1F1ZXJ5SWRzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzdGF0aWNWaWV3UXVlcnlJZHMobm9kZVN0YXRpY1F1ZXJ5SWRzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljUXVlcnlJZHMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHluYW1pY1F1ZXJ5SWRzID0gbmV3IFNldCgpO1xuICAgIEFycmF5LmZyb20obm9kZVN0YXRpY1F1ZXJ5SWRzLnZhbHVlcygpKS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBlbnRyeS5zdGF0aWNRdWVyeUlkcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeUlkKSB7IHJldHVybiBzdGF0aWNRdWVyeUlkcy5hZGQocXVlcnlJZCk7IH0pO1xuICAgICAgICBlbnRyeS5keW5hbWljUXVlcnlJZHMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlJZCkgeyByZXR1cm4gZHluYW1pY1F1ZXJ5SWRzLmFkZChxdWVyeUlkKTsgfSk7XG4gICAgfSk7XG4gICAgZHluYW1pY1F1ZXJ5SWRzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5SWQpIHsgcmV0dXJuIHN0YXRpY1F1ZXJ5SWRzLmRlbGV0ZShxdWVyeUlkKTsgfSk7XG4gICAgcmV0dXJuIHsgc3RhdGljUXVlcnlJZHM6IHN0YXRpY1F1ZXJ5SWRzLCBkeW5hbWljUXVlcnlJZHM6IGR5bmFtaWNRdWVyeUlkcyB9O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcihkaXJlY3RpdmVzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcG9uZW50RGlyTWV0YSA9IGRpcmVjdGl2ZXMuZmluZChmdW5jdGlvbiAoZGlyQXN0KSB7IHJldHVybiBkaXJBc3QuZGlyZWN0aXZlLmlzQ29tcG9uZW50OyB9KTtcbiAgICBpZiAoY29tcG9uZW50RGlyTWV0YSAmJiBjb21wb25lbnREaXJNZXRhLmRpcmVjdGl2ZS5lbnRyeUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJ5Q29tcG9uZW50RmFjdG9yaWVzID0gY29tcG9uZW50RGlyTWV0YS5kaXJlY3RpdmUuZW50cnlDb21wb25lbnRzLm1hcChmdW5jdGlvbiAoZW50cnlDb21wb25lbnQpIHsgcmV0dXJuIGltcG9ydEV4cHIoeyByZWZlcmVuY2U6IGVudHJ5Q29tcG9uZW50LmNvbXBvbmVudEZhY3RvcnkgfSk7IH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbiA9IGNyZWF0ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc01ldGEgPSB7XG4gICAgICAgICAgICBkaURlcHM6IFtcbiAgICAgICAgICAgICAgICB7IGlzVmFsdWU6IHRydWUsIHZhbHVlOiBsaXRlcmFsQXJyKGVudHJ5Q29tcG9uZW50RmFjdG9yaWVzKSB9LFxuICAgICAgICAgICAgICAgIHsgdG9rZW46IHRva2VuLCBpc1NraXBTZWxmOiB0cnVlLCBpc09wdGlvbmFsOiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgeyB0b2tlbjogY3JlYXRlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLk5nTW9kdWxlUmVmKSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGxpZmVjeWNsZUhvb2tzOiBbXSxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogcmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcilcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm92aWRlckFzdCh0b2tlbiwgZmFsc2UsIHRydWUsIFt7IHRva2VuOiB0b2tlbiwgbXVsdGk6IGZhbHNlLCB1c2VDbGFzczogY2xhc3NNZXRhIH1dLCBQcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UsIFtdLCBjb21wb25lbnREaXJNZXRhLnNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBldmVudEFzdFxuICogQHBhcmFtIHs/fSBkaXJBc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRFdmVudE5hbWVBbmRUYXJnZXQoZXZlbnRBc3QsIGRpckFzdCkge1xuICAgIGlmIChldmVudEFzdC5pc0FuaW1hdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogXCJAXCIgKyBldmVudEFzdC5uYW1lICsgXCIuXCIgKyBldmVudEFzdC5waGFzZSxcbiAgICAgICAgICAgIHRhcmdldDogZGlyQXN0ICYmIGRpckFzdC5kaXJlY3RpdmUuaXNDb21wb25lbnQgPyAnY29tcG9uZW50JyA6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBldmVudEFzdDtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcXVlcnlJZHNcbiAqIEBwYXJhbSB7P30gcXVlcnlJZFxuICogQHBhcmFtIHs/fSBpc0ZpcnN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjYWxjU3RhdGljRHluYW1pY1F1ZXJ5RmxhZ3MocXVlcnlJZHMsIHF1ZXJ5SWQsIGlzRmlyc3QpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbGFncyA9IDA7XG4gICAgLy8gTm90ZTogV2Ugb25seSBtYWtlIHF1ZXJpZXMgc3RhdGljIHRoYXQgcXVlcnkgZm9yIGEgc2luZ2xlIGl0ZW0uXG4gICAgLy8gVGhpcyBpcyBiZWNhdXNlIG9mIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggdGhlIG9sZCB2aWV3IGNvbXBpbGVyLi4uXG4gICAgaWYgKGlzRmlyc3QgJiYgKHF1ZXJ5SWRzLnN0YXRpY1F1ZXJ5SWRzLmhhcyhxdWVyeUlkKSB8fCAhcXVlcnlJZHMuZHluYW1pY1F1ZXJ5SWRzLmhhcyhxdWVyeUlkKSkpIHtcbiAgICAgICAgZmxhZ3MgfD0gMTM0MjE3NzI4IC8qIFN0YXRpY1F1ZXJ5ICovO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmxhZ3MgfD0gMjY4NDM1NDU2IC8qIER5bmFtaWNRdWVyeSAqLztcbiAgICB9XG4gICAgcmV0dXJuIGZsYWdzO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEdlbmVyYXRlZEZpbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3JjRmlsZVVybFxuICAgICAqIEBwYXJhbSB7P30gZ2VuRmlsZVVybFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gR2VuZXJhdGVkRmlsZShzcmNGaWxlVXJsLCBnZW5GaWxlVXJsLCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zcmNGaWxlVXJsID0gc3JjRmlsZVVybDtcbiAgICAgICAgdGhpcy5nZW5GaWxlVXJsID0gZ2VuRmlsZVVybDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIHJldHVybiBHZW5lcmF0ZWRGaWxlO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQHBhcmFtIHs/fSBzdW1tYXJ5UmVzb2x2ZXJcbiAqIEBwYXJhbSB7P30gc3ltYm9sUmVzb2x2ZXJcbiAqIEBwYXJhbSB7P30gc3ltYm9sc1xuICogQHBhcmFtIHs/fSB0eXBlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplU3VtbWFyaWVzKHN1bW1hcnlSZXNvbHZlciwgc3ltYm9sUmVzb2x2ZXIsIHN5bWJvbHMsIHR5cGVzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VyaWFsaXplciA9IG5ldyBTZXJpYWxpemVyJDEoc3ltYm9sUmVzb2x2ZXIsIHN1bW1hcnlSZXNvbHZlcik7XG4gICAgLy8gZm9yIHN5bWJvbHMsIHdlIHVzZSBldmVyeXRoaW5nIGV4Y2VwdCBmb3IgdGhlIGNsYXNzIG1ldGFkYXRhIGl0c2VsZlxuICAgIC8vICh3ZSBrZWVwIHRoZSBzdGF0aWNzIHRob3VnaCksIGFzIHRoZSBjbGFzcyBtZXRhZGF0YSBpcyBjb250YWluZWQgaW4gdGhlXG4gICAgLy8gQ29tcGlsZVR5cGVTdW1tYXJ5LlxuICAgIHN5bWJvbHMuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2ZWRTeW1ib2wpIHsgcmV0dXJuIHNlcmlhbGl6ZXIuYWRkT3JNZXJnZVN1bW1hcnkoeyBzeW1ib2w6IHJlc29sdmVkU3ltYm9sLnN5bWJvbCwgbWV0YWRhdGE6IHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhIH0pOyB9KTtcbiAgICAvLyBBZGQgc3VtbWFyaWVzIHRoYXQgYXJlIHJlZmVyZW5jZWQgYnkgdGhlIGdpdmVuIHN5bWJvbHMgKHRyYW5zaXRpdmVseSlcbiAgICAvLyBOb3RlOiB0aGUgc2VyaWFsaXplci5zeW1ib2xzIGFycmF5IG1pZ2h0IGJlIGdyb3dpbmcgd2hpbGVcbiAgICAvLyB3ZSBleGVjdXRlIHRoZSBsb29wIVxuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvY2Vzc2VkSW5kZXggPSAwOyBwcm9jZXNzZWRJbmRleCA8IHNlcmlhbGl6ZXIuc3ltYm9scy5sZW5ndGg7IHByb2Nlc3NlZEluZGV4KyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sID0gc2VyaWFsaXplci5zeW1ib2xzW3Byb2Nlc3NlZEluZGV4XTtcbiAgICAgICAgaWYgKHN1bW1hcnlSZXNvbHZlci5pc0xpYnJhcnlGaWxlKHN5bWJvbC5maWxlUGF0aCkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1bW1hcnkgPSBzdW1tYXJ5UmVzb2x2ZXIucmVzb2x2ZVN1bW1hcnkoc3ltYm9sKTtcbiAgICAgICAgICAgIGlmICghc3VtbWFyeSkge1xuICAgICAgICAgICAgICAgIC8vIHNvbWUgc3ltYm9scyBtaWdodCBvcmlnaW5hdGUgZnJvbSBhIHBsYWluIHR5cGVzY3JpcHQgbGlicmFyeVxuICAgICAgICAgICAgICAgIC8vIHRoYXQganVzdCBleHBvcnRlZCAuZC50cyBhbmQgLm1ldGFkYXRhLmpzb24gZmlsZXMsIGkuZS4gd2hlcmUgbm8gc3VtbWFyeVxuICAgICAgICAgICAgICAgIC8vIGZpbGVzIHdlcmUgY3JlYXRlZC5cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFN5bWJvbCA9IHN5bWJvbFJlc29sdmVyLnJlc29sdmVTeW1ib2woc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtbWFyeSA9IHsgc3ltYm9sOiByZXNvbHZlZFN5bWJvbC5zeW1ib2wsIG1ldGFkYXRhOiByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdW1tYXJ5KSB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplci5hZGRPck1lcmdlU3VtbWFyeShzdW1tYXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGQgdHlwZSBzdW1tYXJpZXMuXG4gICAgLy8gTm90ZTogV2UgZG9uJ3QgYWRkIHRoZSBzdW1tYXJpZXMgb2YgYWxsIHJlZmVyZW5jZWQgc3ltYm9scyBhcyBmb3IgdGhlIFJlc29sdmVkU3ltYm9scyxcbiAgICAvLyBhcyB0aGUgdHlwZSBzdW1tYXJpZXMgYWxyZWFkeSBjb250YWluIHRoZSB0cmFuc2l0aXZlIGRhdGEgdGhhdCB0aGV5IHJlcXVpcmVcbiAgICAvLyAoaW4gYSBtaW5pbWFsIHdheSkuXG4gICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZVN1bW1hcnkpIHtcbiAgICAgICAgc2VyaWFsaXplci5hZGRPck1lcmdlU3VtbWFyeSh7IHN5bWJvbDogdHlwZVN1bW1hcnkudHlwZS5yZWZlcmVuY2UsIG1ldGFkYXRhOiBudWxsLCB0eXBlOiB0eXBlU3VtbWFyeSB9KTtcbiAgICAgICAgaWYgKHR5cGVTdW1tYXJ5LnN1bW1hcnlLaW5kID09PSBDb21waWxlU3VtbWFyeUtpbmQuTmdNb2R1bGUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlU3VtbWFyeSA9ICh0eXBlU3VtbWFyeSk7XG4gICAgICAgICAgICBuZ01vZHVsZVN1bW1hcnkuZXhwb3J0ZWREaXJlY3RpdmVzLmNvbmNhdChuZ01vZHVsZVN1bW1hcnkuZXhwb3J0ZWRQaXBlcykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2wgPSBpZC5yZWZlcmVuY2U7XG4gICAgICAgICAgICAgICAgaWYgKHN1bW1hcnlSZXNvbHZlci5pc0xpYnJhcnlGaWxlKHN5bWJvbC5maWxlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VtbWFyeSA9IHN1bW1hcnlSZXNvbHZlci5yZXNvbHZlU3VtbWFyeShzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VtbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplci5hZGRPck1lcmdlU3VtbWFyeShzdW1tYXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZXIuc2VyaWFsaXplKCk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gc3ltYm9sQ2FjaGVcbiAqIEBwYXJhbSB7P30ganNvblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZGVzZXJpYWxpemVTdW1tYXJpZXMoc3ltYm9sQ2FjaGUsIGpzb24pIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXNlcmlhbGl6ZXIgPSBuZXcgRGVzZXJpYWxpemVyKHN5bWJvbENhY2hlKTtcbiAgICByZXR1cm4gZGVzZXJpYWxpemVyLmRlc2VyaWFsaXplKGpzb24pO1xufVxudmFyIFNlcmlhbGl6ZXIkMSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcmlhbGl6ZXIkMSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN5bWJvbFJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBzdW1tYXJ5UmVzb2x2ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXJpYWxpemVyJDEoc3ltYm9sUmVzb2x2ZXIsIHN1bW1hcnlSZXNvbHZlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zeW1ib2xSZXNvbHZlciA9IHN5bWJvbFJlc29sdmVyO1xuICAgICAgICBfdGhpcy5zdW1tYXJ5UmVzb2x2ZXIgPSBzdW1tYXJ5UmVzb2x2ZXI7XG4gICAgICAgIC8vIE5vdGU6IFRoaXMgb25seSBjb250YWlucyBzeW1ib2xzIHdpdGhvdXQgbWVtYmVycy5cbiAgICAgICAgX3RoaXMuc3ltYm9scyA9IFtdO1xuICAgICAgICBfdGhpcy5pbmRleEJ5U3ltYm9sID0gbmV3IE1hcCgpO1xuICAgICAgICBfdGhpcy5wcm9jZXNzZWRTdW1tYXJ5QnlTeW1ib2wgPSBuZXcgTWFwKCk7XG4gICAgICAgIF90aGlzLnByb2Nlc3NlZFN1bW1hcmllcyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3VtbWFyeVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VyaWFsaXplciQxLnByb3RvdHlwZS5hZGRPck1lcmdlU3VtbWFyeSA9IGZ1bmN0aW9uIChzdW1tYXJ5KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbE1ldGEgPSBzdW1tYXJ5Lm1ldGFkYXRhO1xuICAgICAgICBpZiAoc3ltYm9sTWV0YSAmJiBzeW1ib2xNZXRhLl9fc3ltYm9saWMgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgIC8vIEZvciBjbGFzc2VzLCB3ZSBrZWVwIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZWlyIGNsYXNzIGRlY29yYXRvcnMuXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGtlZXAgZS5nLiB0aGUgY3RvciBhcmdzLCBtZXRob2QgbmFtZXMsIG1ldGhvZCBkZWNvcmF0b3JzXG4gICAgICAgICAgICAvLyBzbyB0aGF0IHRoZSBjbGFzcyBjYW4gYmUgZXh0ZW5kZWQgaW4gYW5vdGhlciBjb21waWxhdGlvbiB1bml0LlxuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qga2VlcCB0aGUgY2xhc3MgZGVjb3JhdG9ycyBhc1xuICAgICAgICAgICAgLy8gMSkgdGhleSByZWZlciB0byBkYXRhXG4gICAgICAgICAgICAvLyAgIHRoYXQgc2hvdWxkIG5vdCBjYXVzZSBhIHJlYnVpbGQgb2YgZG93bnN0cmVhbSBjb21waWxhdGlvbiB1bml0c1xuICAgICAgICAgICAgLy8gICAoZS5nLiBpbmxpbmUgdGVtcGxhdGVzIG9mIEBDb21wb25lbnQsIG9yIEBOZ01vZHVsZS5kZWNsYXJhdGlvbnMpXG4gICAgICAgICAgICAvLyAyKSB0aGVpciBkYXRhIGlzIGFscmVhZHkgY2FwdHVyZWQgaW4gVHlwZVN1bW1hcmllcywgZS5nLiBEaXJlY3RpdmVTdW1tYXJ5LlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xvbmVfMSA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3ltYm9sTWV0YSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcE5hbWUgIT09ICdkZWNvcmF0b3JzJykge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZV8xW3Byb3BOYW1lXSA9IHN5bWJvbE1ldGFbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3ltYm9sTWV0YSA9IGNsb25lXzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvY2Vzc2VkU3VtbWFyeSA9IHRoaXMucHJvY2Vzc2VkU3VtbWFyeUJ5U3ltYm9sLmdldChzdW1tYXJ5LnN5bWJvbCk7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkU3VtbWFyeSkge1xuICAgICAgICAgICAgcHJvY2Vzc2VkU3VtbWFyeSA9IHRoaXMucHJvY2Vzc1ZhbHVlKHsgc3ltYm9sOiBzdW1tYXJ5LnN5bWJvbCB9KTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkU3VtbWFyaWVzLnB1c2gocHJvY2Vzc2VkU3VtbWFyeSk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NlZFN1bW1hcnlCeVN5bWJvbC5zZXQoc3VtbWFyeS5zeW1ib2wsIHByb2Nlc3NlZFN1bW1hcnkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6ID09IG9uIHB1cnBvc2UgdG8gY29tcGFyZSB3aXRoIHVuZGVmaW5lZCFcbiAgICAgICAgaWYgKHByb2Nlc3NlZFN1bW1hcnkubWV0YWRhdGEgPT0gbnVsbCAmJiBzeW1ib2xNZXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHByb2Nlc3NlZFN1bW1hcnkubWV0YWRhdGEgPSB0aGlzLnByb2Nlc3NWYWx1ZShzeW1ib2xNZXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiA9PSBvbiBwdXJwb3NlIHRvIGNvbXBhcmUgd2l0aCB1bmRlZmluZWQhXG4gICAgICAgIGlmIChwcm9jZXNzZWRTdW1tYXJ5LnR5cGUgPT0gbnVsbCAmJiBzdW1tYXJ5LnR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvY2Vzc2VkU3VtbWFyeS50eXBlID0gdGhpcy5wcm9jZXNzVmFsdWUoc3VtbWFyeS50eXBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJpYWxpemVyJDEucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwb3J0QXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ganNvbiA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHN1bW1hcmllczogdGhpcy5wcm9jZXNzZWRTdW1tYXJpZXMsXG4gICAgICAgICAgICBzeW1ib2xzOiB0aGlzLnN5bWJvbHMubWFwKGZ1bmN0aW9uIChzeW1ib2wsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sLmFzc2VydE5vTWVtYmVycygpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGltcG9ydEFzID0gKCh1bmRlZmluZWQpKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUoc3ltYm9sLmZpbGVQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRBcyA9IHN5bWJvbC5uYW1lICsgXCJfXCIgKyBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXMucHVzaCh7IHN5bWJvbDogc3ltYm9sLCBleHBvcnRBczogaW1wb3J0QXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIF9fc3ltYm9sOiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogc3ltYm9sLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNvbnZlcnQgdGhlIHNvdXJjZSBmaWxlbmFtZXMgdGludG8gb3V0cHV0IGZpbGVuYW1lcyxcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGhlIGdlbmVyYXRlZCBzdW1tYXJ5IGZpbGUgd2lsbCBiZSB1c2VkIHdoZW4gdGVoIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcGlsYXRpb24gdW5pdCBpcyB1c2VkIGFzIGEgbGlicmFyeVxuICAgICAgICAgICAgICAgICAgICBmaWxlUGF0aDogX3RoaXMuc3VtbWFyeVJlc29sdmVyLmdldExpYnJhcnlGaWxlTmFtZShzeW1ib2wuZmlsZVBhdGgpLFxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRBczogaW1wb3J0QXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGpzb246IGpzb24sIGV4cG9ydEFzOiBleHBvcnRBcyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VyaWFsaXplciQxLnByb3RvdHlwZS5wcm9jZXNzVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZpc2l0VmFsdWUodmFsdWUsIHRoaXMsIG51bGwpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcmlhbGl6ZXIkMS5wcm90b3R5cGUudmlzaXRPdGhlciA9IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VTeW1ib2wgPSB0aGlzLnN5bWJvbFJlc29sdmVyLmdldFN0YXRpY1N5bWJvbCh2YWx1ZS5maWxlUGF0aCwgdmFsdWUubmFtZSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IHRoaXMuaW5kZXhCeVN5bWJvbC5nZXQoYmFzZVN5bWJvbCk7XG4gICAgICAgICAgICAvLyBOb3RlOiA9PSBvbiBwdXJwb3NlIHRvIGNvbXBhcmUgd2l0aCB1bmRlZmluZWQhXG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5pbmRleEJ5U3ltYm9sLnNpemU7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleEJ5U3ltYm9sLnNldChiYXNlU3ltYm9sLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zeW1ib2xzLnB1c2goYmFzZVN5bWJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBfX3N5bWJvbDogaW5kZXgsIG1lbWJlcnM6IHZhbHVlLm1lbWJlcnMgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNlcmlhbGl6ZXIkMTtcbn0oVmFsdWVUcmFuc2Zvcm1lcikpO1xudmFyIERlc2VyaWFsaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlc2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN5bWJvbENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVzZXJpYWxpemVyKHN5bWJvbENhY2hlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN5bWJvbENhY2hlID0gc3ltYm9sQ2FjaGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBqc29uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZXNlcmlhbGl6ZXIucHJvdG90eXBlLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGltcG9ydEFzID0gW107XG4gICAgICAgIHRoaXMuc3ltYm9scyA9IFtdO1xuICAgICAgICBkYXRhLnN5bWJvbHMuZm9yRWFjaChmdW5jdGlvbiAoc2VyaWFsaXplZFN5bWJvbCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sID0gX3RoaXMuc3ltYm9sQ2FjaGUuZ2V0KHNlcmlhbGl6ZWRTeW1ib2wuZmlsZVBhdGgsIHNlcmlhbGl6ZWRTeW1ib2wubmFtZSk7XG4gICAgICAgICAgICBfdGhpcy5zeW1ib2xzLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgIGlmIChzZXJpYWxpemVkU3ltYm9sLmltcG9ydEFzKSB7XG4gICAgICAgICAgICAgICAgaW1wb3J0QXMucHVzaCh7IHN5bWJvbDogc3ltYm9sLCBpbXBvcnRBczogc2VyaWFsaXplZFN5bWJvbC5pbXBvcnRBcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1bW1hcmllcyA9IHZpc2l0VmFsdWUoZGF0YS5zdW1tYXJpZXMsIHRoaXMsIG51bGwpO1xuICAgICAgICByZXR1cm4geyBzdW1tYXJpZXM6IHN1bW1hcmllcywgaW1wb3J0QXM6IGltcG9ydEFzIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1hcFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVzZXJpYWxpemVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcCA9IGZ1bmN0aW9uIChtYXAsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCdfX3N5bWJvbCcgaW4gbWFwKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYXNlU3ltYm9sID0gdGhpcy5zeW1ib2xzW21hcFsnX19zeW1ib2wnXV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZW1iZXJzID0gbWFwWydtZW1iZXJzJ107XG4gICAgICAgICAgICByZXR1cm4gbWVtYmVycy5sZW5ndGggPyB0aGlzLnN5bWJvbENhY2hlLmdldChiYXNlU3ltYm9sLmZpbGVQYXRoLCBiYXNlU3ltYm9sLm5hbWUsIG1lbWJlcnMpIDpcbiAgICAgICAgICAgICAgICBiYXNlU3ltYm9sO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudmlzaXRTdHJpbmdNYXAuY2FsbCh0aGlzLCBtYXAsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGVzZXJpYWxpemVyO1xufShWYWx1ZVRyYW5zZm9ybWVyKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQW90Q29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2NvbmZpZ1xuICAgICAqIEBwYXJhbSB7P30gX2hvc3RcbiAgICAgKiBAcGFyYW0gez99IF9tZXRhZGF0YVJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBfdGVtcGxhdGVQYXJzZXJcbiAgICAgKiBAcGFyYW0gez99IF9zdHlsZUNvbXBpbGVyXG4gICAgICogQHBhcmFtIHs/fSBfdmlld0NvbXBpbGVyXG4gICAgICogQHBhcmFtIHs/fSBfbmdNb2R1bGVDb21waWxlclxuICAgICAqIEBwYXJhbSB7P30gX291dHB1dEVtaXR0ZXJcbiAgICAgKiBAcGFyYW0gez99IF9zdW1tYXJ5UmVzb2x2ZXJcbiAgICAgKiBAcGFyYW0gez99IF9sb2NhbGVJZFxuICAgICAqIEBwYXJhbSB7P30gX3RyYW5zbGF0aW9uRm9ybWF0XG4gICAgICogQHBhcmFtIHs/fSBfZ2VuRmlsZVByZWFtYmxlXG4gICAgICogQHBhcmFtIHs/fSBfc3ltYm9sUmVzb2x2ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBb3RDb21waWxlcihfY29uZmlnLCBfaG9zdCwgX21ldGFkYXRhUmVzb2x2ZXIsIF90ZW1wbGF0ZVBhcnNlciwgX3N0eWxlQ29tcGlsZXIsIF92aWV3Q29tcGlsZXIsIF9uZ01vZHVsZUNvbXBpbGVyLCBfb3V0cHV0RW1pdHRlciwgX3N1bW1hcnlSZXNvbHZlciwgX2xvY2FsZUlkLCBfdHJhbnNsYXRpb25Gb3JtYXQsIF9nZW5GaWxlUHJlYW1ibGUsIF9zeW1ib2xSZXNvbHZlcikge1xuICAgICAgICB0aGlzLl9jb25maWcgPSBfY29uZmlnO1xuICAgICAgICB0aGlzLl9ob3N0ID0gX2hvc3Q7XG4gICAgICAgIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIgPSBfbWV0YWRhdGFSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVQYXJzZXIgPSBfdGVtcGxhdGVQYXJzZXI7XG4gICAgICAgIHRoaXMuX3N0eWxlQ29tcGlsZXIgPSBfc3R5bGVDb21waWxlcjtcbiAgICAgICAgdGhpcy5fdmlld0NvbXBpbGVyID0gX3ZpZXdDb21waWxlcjtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVDb21waWxlciA9IF9uZ01vZHVsZUNvbXBpbGVyO1xuICAgICAgICB0aGlzLl9vdXRwdXRFbWl0dGVyID0gX291dHB1dEVtaXR0ZXI7XG4gICAgICAgIHRoaXMuX3N1bW1hcnlSZXNvbHZlciA9IF9zdW1tYXJ5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX2xvY2FsZUlkID0gX2xvY2FsZUlkO1xuICAgICAgICB0aGlzLl90cmFuc2xhdGlvbkZvcm1hdCA9IF90cmFuc2xhdGlvbkZvcm1hdDtcbiAgICAgICAgdGhpcy5fZ2VuRmlsZVByZWFtYmxlID0gX2dlbkZpbGVQcmVhbWJsZTtcbiAgICAgICAgdGhpcy5fc3ltYm9sUmVzb2x2ZXIgPSBfc3ltYm9sUmVzb2x2ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuY2xlYXJDYWNoZSgpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcm9vdEZpbGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuY29tcGlsZUFsbCA9IGZ1bmN0aW9uIChyb290RmlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvZ3JhbVN5bWJvbHMgPSBleHRyYWN0UHJvZ3JhbVN5bWJvbHModGhpcy5fc3ltYm9sUmVzb2x2ZXIsIHJvb3RGaWxlcywgdGhpcy5faG9zdCk7XG4gICAgICAgIHZhciBfYSA9IGFuYWx5emVBbmRWYWxpZGF0ZU5nTW9kdWxlcyhwcm9ncmFtU3ltYm9scywgdGhpcy5faG9zdCwgdGhpcy5fbWV0YWRhdGFSZXNvbHZlciksIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUgPSBfYS5uZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLCBmaWxlcyA9IF9hLmZpbGVzLCBuZ01vZHVsZXMgPSBfYS5uZ01vZHVsZXM7XG4gICAgICAgIHJldHVybiBQcm9taXNlXG4gICAgICAgICAgICAuYWxsKG5nTW9kdWxlcy5tYXAoZnVuY3Rpb24gKG5nTW9kdWxlKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5sb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGEobmdNb2R1bGUudHlwZS5yZWZlcmVuY2UsIGZhbHNlKTsgfSkpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VNb2R1bGVzID0gZmlsZXMubWFwKGZ1bmN0aW9uIChmaWxlKSB7IHJldHVybiBfdGhpcy5fY29tcGlsZVNyY0ZpbGUoZmlsZS5zcmNVcmwsIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUsIGZpbGUuZGlyZWN0aXZlcywgZmlsZS5waXBlcywgZmlsZS5uZ01vZHVsZXMsIGZpbGUuaW5qZWN0YWJsZXMpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuKHNvdXJjZU1vZHVsZXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3JjRmlsZVVybFxuICAgICAqIEBwYXJhbSB7P30gbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZVxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEBwYXJhbSB7P30gcGlwZXNcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlc1xuICAgICAqIEBwYXJhbSB7P30gaW5qZWN0YWJsZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZVNyY0ZpbGUgPSBmdW5jdGlvbiAoc3JjRmlsZVVybCwgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZSwgZGlyZWN0aXZlcywgcGlwZXMsIG5nTW9kdWxlcywgaW5qZWN0YWJsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlsZVN1ZmZpeCA9IHNwbGl0VHlwZXNjcmlwdFN1ZmZpeChzcmNGaWxlVXJsKVsxXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGVtZW50cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBvcnRlZFZhcnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZ2VuZXJhdGVkRmlsZXMgPSBbXTtcbiAgICAgICAgZ2VuZXJhdGVkRmlsZXMucHVzaCh0aGlzLl9jcmVhdGVTdW1tYXJ5KHNyY0ZpbGVVcmwsIGRpcmVjdGl2ZXMsIHBpcGVzLCBuZ01vZHVsZXMsIGluamVjdGFibGVzLCBzdGF0ZW1lbnRzLCBleHBvcnRlZFZhcnMpKTtcbiAgICAgICAgLy8gY29tcGlsZSBhbGwgbmcgbW9kdWxlc1xuICAgICAgICBleHBvcnRlZFZhcnMucHVzaC5hcHBseShleHBvcnRlZFZhcnMsIG5nTW9kdWxlcy5tYXAoZnVuY3Rpb24gKG5nTW9kdWxlVHlwZSkgeyByZXR1cm4gX3RoaXMuX2NvbXBpbGVNb2R1bGUobmdNb2R1bGVUeXBlLCBzdGF0ZW1lbnRzKTsgfSkpO1xuICAgICAgICAvLyBjb21waWxlIGNvbXBvbmVudHNcbiAgICAgICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJUeXBlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wTWV0YSA9IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKC8qKiBAdHlwZSB7P30gKi8gKGRpclR5cGUpKTtcbiAgICAgICAgICAgIGlmICghY29tcE1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGUgPSBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLmdldChkaXJUeXBlKTtcbiAgICAgICAgICAgIGlmICghbmdNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBFcnJvcjogY2Fubm90IGRldGVybWluZSB0aGUgbW9kdWxlIGZvciBjb21wb25lbnQgXCIgKyBpZGVudGlmaWVyTmFtZShjb21wTWV0YS50eXBlKSArIFwiIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9hc3NlcnRDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICAgICAgLy8gY29tcGlsZSBzdHlsZXNcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlc0NvbXBpbGVSZXN1bHRzID0gX3RoaXMuX3N0eWxlQ29tcGlsZXIuY29tcGlsZUNvbXBvbmVudChjb21wTWV0YSk7XG4gICAgICAgICAgICBzdHlsZXNDb21waWxlUmVzdWx0cy5leHRlcm5hbFN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBpbGVkU3R5bGVTaGVldCkge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlZEZpbGVzLnB1c2goX3RoaXMuX2NvZGdlblN0eWxlcyhzcmNGaWxlVXJsLCBjb21waWxlZFN0eWxlU2hlZXQsIGZpbGVTdWZmaXgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gY29tcGlsZSBjb21wb25lbnRzXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wVmlld1ZhcnMgPSBfdGhpcy5fY29tcGlsZUNvbXBvbmVudChjb21wTWV0YSwgbmdNb2R1bGUsIG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUuZGlyZWN0aXZlcywgc3R5bGVzQ29tcGlsZVJlc3VsdHMuY29tcG9uZW50U3R5bGVzaGVldCwgZmlsZVN1ZmZpeCwgc3RhdGVtZW50cyk7XG4gICAgICAgICAgICBleHBvcnRlZFZhcnMucHVzaChfdGhpcy5fY29tcGlsZUNvbXBvbmVudEZhY3RvcnkoY29tcE1ldGEsIG5nTW9kdWxlLCBmaWxlU3VmZml4LCBzdGF0ZW1lbnRzKSwgY29tcFZpZXdWYXJzLnZpZXdDbGFzc1ZhciwgY29tcFZpZXdWYXJzLmNvbXBSZW5kZXJUeXBlVmFyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdGF0ZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNyY01vZHVsZSA9IHRoaXMuX2NvZGVnZW5Tb3VyY2VNb2R1bGUoc3JjRmlsZVVybCwgbmdmYWN0b3J5RmlsZVBhdGgoc3JjRmlsZVVybCksIHN0YXRlbWVudHMsIGV4cG9ydGVkVmFycyk7XG4gICAgICAgICAgICBnZW5lcmF0ZWRGaWxlcy51bnNoaWZ0KHNyY01vZHVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlZEZpbGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcmNGaWxlVXJsXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVzXG4gICAgICogQHBhcmFtIHs/fSBwaXBlc1xuICAgICAqIEBwYXJhbSB7P30gbmdNb2R1bGVzXG4gICAgICogQHBhcmFtIHs/fSBpbmplY3RhYmxlc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0U3RhdGVtZW50c1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0RXhwb3J0ZWRWYXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2NyZWF0ZVN1bW1hcnkgPSBmdW5jdGlvbiAoc3JjRmlsZVVybCwgZGlyZWN0aXZlcywgcGlwZXMsIG5nTW9kdWxlcywgaW5qZWN0YWJsZXMsIHRhcmdldFN0YXRlbWVudHMsIHRhcmdldEV4cG9ydGVkVmFycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2xTdW1tYXJpZXMgPSB0aGlzLl9zeW1ib2xSZXNvbHZlci5nZXRTeW1ib2xzT2Yoc3JjRmlsZVVybClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHN5bWJvbCkgeyByZXR1cm4gX3RoaXMuX3N5bWJvbFJlc29sdmVyLnJlc29sdmVTeW1ib2woc3ltYm9sKTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGVTdW1tYXJpZXMgPSBuZ01vZHVsZXMubWFwKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuICgoX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVTdW1tYXJ5KHJlZikpKTsgfSkuY29uY2F0KGRpcmVjdGl2ZXMubWFwKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuICgoX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlU3VtbWFyeShyZWYpKSk7IH0pLCBwaXBlcy5tYXAoZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gKChfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRQaXBlU3VtbWFyeShyZWYpKSk7IH0pLCBpbmplY3RhYmxlcy5tYXAoZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gKChfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRJbmplY3RhYmxlU3VtbWFyeShyZWYpKSk7IH0pKTtcbiAgICAgICAgdmFyIF9hID0gc2VyaWFsaXplU3VtbWFyaWVzKHRoaXMuX3N1bW1hcnlSZXNvbHZlciwgdGhpcy5fc3ltYm9sUmVzb2x2ZXIsIHN5bWJvbFN1bW1hcmllcywgdHlwZVN1bW1hcmllcyksIGpzb24gPSBfYS5qc29uLCBleHBvcnRBcyA9IF9hLmV4cG9ydEFzO1xuICAgICAgICBleHBvcnRBcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoKHZhcmlhYmxlKGVudHJ5LmV4cG9ydEFzKS5zZXQoaW1wb3J0RXhwcih7IHJlZmVyZW5jZTogZW50cnkuc3ltYm9sIH0pKS50b0RlY2xTdG10KCkpO1xuICAgICAgICAgICAgdGFyZ2V0RXhwb3J0ZWRWYXJzLnB1c2goZW50cnkuZXhwb3J0QXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmF0ZWRGaWxlKHNyY0ZpbGVVcmwsIHN1bW1hcnlGaWxlTmFtZShzcmNGaWxlVXJsKSwganNvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlVHlwZVxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0U3RhdGVtZW50c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlTW9kdWxlID0gZnVuY3Rpb24gKG5nTW9kdWxlVHlwZSwgdGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ01vZHVsZSA9ICgodGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKG5nTW9kdWxlVHlwZSkpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvdmlkZXJzID0gW107XG4gICAgICAgIGlmICh0aGlzLl9sb2NhbGVJZCkge1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRva2VuOiBjcmVhdGVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuTE9DQUxFX0lEKSxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogdGhpcy5fbG9jYWxlSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdHJhbnNsYXRpb25Gb3JtYXQpIHtcbiAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0b2tlbjogY3JlYXRlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLlRSQU5TTEFUSU9OU19GT1JNQVQpLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiB0aGlzLl90cmFuc2xhdGlvbkZvcm1hdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXBwQ29tcGlsZVJlc3VsdCA9IHRoaXMuX25nTW9kdWxlQ29tcGlsZXIuY29tcGlsZShuZ01vZHVsZSwgcHJvdmlkZXJzKTtcbiAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoLmFwcGx5KHRhcmdldFN0YXRlbWVudHMsIGFwcENvbXBpbGVSZXN1bHQuc3RhdGVtZW50cyk7XG4gICAgICAgIHJldHVybiBhcHBDb21waWxlUmVzdWx0Lm5nTW9kdWxlRmFjdG9yeVZhcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcE1ldGFcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlXG4gICAgICogQHBhcmFtIHs/fSBmaWxlU3VmZml4XG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRTdGF0ZW1lbnRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVDb21wb25lbnRGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbXBNZXRhLCBuZ01vZHVsZSwgZmlsZVN1ZmZpeCwgdGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0VHlwZSA9IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0SG9zdENvbXBvbmVudFR5cGUoY29tcE1ldGEudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0TWV0YSA9IGNyZWF0ZUhvc3RDb21wb25lbnRNZXRhKGhvc3RUeXBlLCBjb21wTWV0YSwgdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRIb3N0Q29tcG9uZW50Vmlld0NsYXNzKGhvc3RUeXBlKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RWaWV3RmFjdG9yeVZhciA9IHRoaXMuX2NvbXBpbGVDb21wb25lbnQoaG9zdE1ldGEsIG5nTW9kdWxlLCBbY29tcE1ldGEudHlwZV0sIG51bGwsIGZpbGVTdWZmaXgsIHRhcmdldFN0YXRlbWVudHMpXG4gICAgICAgICAgICAudmlld0NsYXNzVmFyO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wRmFjdG9yeVZhciA9IGNvbXBvbmVudEZhY3RvcnlOYW1lKGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5wdXRzRXhwcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wTmFtZSBpbiBjb21wTWV0YS5pbnB1dHMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlTmFtZSA9IGNvbXBNZXRhLmlucHV0c1twcm9wTmFtZV07XG4gICAgICAgICAgICAvLyBEb24ndCBxdW90ZSBzbyB0aGF0IHRoZSBrZXkgZ2V0cyBtaW5pZmllZC4uLlxuICAgICAgICAgICAgaW5wdXRzRXhwcnMucHVzaChuZXcgTGl0ZXJhbE1hcEVudHJ5KHByb3BOYW1lLCBsaXRlcmFsKHRlbXBsYXRlTmFtZSksIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3V0cHV0c0V4cHJzID0gW107XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcE5hbWUgaW4gY29tcE1ldGEub3V0cHV0cykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVOYW1lID0gY29tcE1ldGEub3V0cHV0c1twcm9wTmFtZV07XG4gICAgICAgICAgICAvLyBEb24ndCBxdW90ZSBzbyB0aGF0IHRoZSBrZXkgZ2V0cyBtaW5pZmllZC4uLlxuICAgICAgICAgICAgb3V0cHV0c0V4cHJzLnB1c2gobmV3IExpdGVyYWxNYXBFbnRyeShwcm9wTmFtZSwgbGl0ZXJhbCh0ZW1wbGF0ZU5hbWUpLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldFN0YXRlbWVudHMucHVzaCh2YXJpYWJsZShjb21wRmFjdG9yeVZhcilcbiAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLmNyZWF0ZUNvbXBvbmVudEZhY3RvcnkpKS5jYWxsRm4oW1xuICAgICAgICAgICAgbGl0ZXJhbChjb21wTWV0YS5zZWxlY3RvciksIGltcG9ydEV4cHIoY29tcE1ldGEudHlwZSksXG4gICAgICAgICAgICB2YXJpYWJsZShob3N0Vmlld0ZhY3RvcnlWYXIpLCBuZXcgTGl0ZXJhbE1hcEV4cHIoaW5wdXRzRXhwcnMpLFxuICAgICAgICAgICAgbmV3IExpdGVyYWxNYXBFeHByKG91dHB1dHNFeHBycyksXG4gICAgICAgICAgICBsaXRlcmFsQXJyKC8qKiBAdHlwZSB7P30gKi8gKChjb21wTWV0YS50ZW1wbGF0ZSkpLm5nQ29udGVudFNlbGVjdG9ycy5tYXAoZnVuY3Rpb24gKHNlbGVjdG9yKSB7IHJldHVybiBsaXRlcmFsKHNlbGVjdG9yKTsgfSkpXG4gICAgICAgIF0pKVxuICAgICAgICAgICAgLnRvRGVjbFN0bXQoaW1wb3J0VHlwZShjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnkpLCBbLyoqIEB0eXBlIHs/fSAqLyAoKGltcG9ydFR5cGUoY29tcE1ldGEudHlwZSkpKV0sIFtUeXBlTW9kaWZpZXIuQ29uc3RdKSwgW1N0bXRNb2RpZmllci5GaW5hbF0pKTtcbiAgICAgICAgcmV0dXJuIGNvbXBGYWN0b3J5VmFyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wTWV0YVxuICAgICAqIEBwYXJhbSB7P30gbmdNb2R1bGVcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZUlkZW50aWZpZXJzXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRTdHlsZXNcbiAgICAgKiBAcGFyYW0gez99IGZpbGVTdWZmaXhcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFN0YXRlbWVudHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wTWV0YSwgbmdNb2R1bGUsIGRpcmVjdGl2ZUlkZW50aWZpZXJzLCBjb21wb25lbnRTdHlsZXMsIGZpbGVTdWZmaXgsIHRhcmdldFN0YXRlbWVudHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZUlkZW50aWZpZXJzLm1hcChmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVTdW1tYXJ5KGRpci5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGlwZXMgPSBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLnBpcGVzLm1hcChmdW5jdGlvbiAocGlwZSkgeyByZXR1cm4gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0UGlwZVN1bW1hcnkocGlwZS5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fdGVtcGxhdGVQYXJzZXIucGFyc2UoY29tcE1ldGEsIC8qKiBAdHlwZSB7P30gKi8gKCgoKGNvbXBNZXRhLnRlbXBsYXRlKSkudGVtcGxhdGUpKSwgZGlyZWN0aXZlcywgcGlwZXMsIG5nTW9kdWxlLnNjaGVtYXMsIHRlbXBsYXRlU291cmNlVXJsKG5nTW9kdWxlLnR5cGUsIGNvbXBNZXRhLCAvKiogQHR5cGUgez99ICovICgoY29tcE1ldGEudGVtcGxhdGUpKSkpLCBwYXJzZWRUZW1wbGF0ZSA9IF9hLnRlbXBsYXRlLCB1c2VkUGlwZXMgPSBfYS5waXBlcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVzRXhwciA9IGNvbXBvbmVudFN0eWxlcyA/IHZhcmlhYmxlKGNvbXBvbmVudFN0eWxlcy5zdHlsZXNWYXIpIDogbGl0ZXJhbEFycihbXSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdSZXN1bHQgPSB0aGlzLl92aWV3Q29tcGlsZXIuY29tcGlsZUNvbXBvbmVudChjb21wTWV0YSwgcGFyc2VkVGVtcGxhdGUsIHN0eWxlc0V4cHIsIHVzZWRQaXBlcyk7XG4gICAgICAgIGlmIChjb21wb25lbnRTdHlsZXMpIHtcbiAgICAgICAgICAgIHRhcmdldFN0YXRlbWVudHMucHVzaC5hcHBseSh0YXJnZXRTdGF0ZW1lbnRzLCBfcmVzb2x2ZVN0eWxlU3RhdGVtZW50cyh0aGlzLl9zeW1ib2xSZXNvbHZlciwgY29tcG9uZW50U3R5bGVzLCBmaWxlU3VmZml4KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoLmFwcGx5KHRhcmdldFN0YXRlbWVudHMsIHZpZXdSZXN1bHQuc3RhdGVtZW50cyk7XG4gICAgICAgIHJldHVybiB7IHZpZXdDbGFzc1Zhcjogdmlld1Jlc3VsdC52aWV3Q2xhc3NWYXIsIGNvbXBSZW5kZXJUeXBlVmFyOiB2aWV3UmVzdWx0LnJlbmRlcmVyVHlwZVZhciB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmaWxlVXJsXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZXNDb21waWxlUmVzdWx0XG4gICAgICogQHBhcmFtIHs/fSBmaWxlU3VmZml4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2NvZGdlblN0eWxlcyA9IGZ1bmN0aW9uIChmaWxlVXJsLCBzdHlsZXNDb21waWxlUmVzdWx0LCBmaWxlU3VmZml4KSB7XG4gICAgICAgIF9yZXNvbHZlU3R5bGVTdGF0ZW1lbnRzKHRoaXMuX3N5bWJvbFJlc29sdmVyLCBzdHlsZXNDb21waWxlUmVzdWx0LCBmaWxlU3VmZml4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvZGVnZW5Tb3VyY2VNb2R1bGUoZmlsZVVybCwgX3N0eWxlc01vZHVsZVVybCgvKiogQHR5cGUgez99ICovICgoc3R5bGVzQ29tcGlsZVJlc3VsdC5tZXRhLm1vZHVsZVVybCkpLCBzdHlsZXNDb21waWxlUmVzdWx0LmlzU2hpbW1lZCwgZmlsZVN1ZmZpeCksIHN0eWxlc0NvbXBpbGVSZXN1bHQuc3RhdGVtZW50cywgW3N0eWxlc0NvbXBpbGVSZXN1bHQuc3R5bGVzVmFyXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNyY0ZpbGVVcmxcbiAgICAgKiBAcGFyYW0gez99IGdlbkZpbGVVcmxcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAgICAgKiBAcGFyYW0gez99IGV4cG9ydGVkVmFyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jb2RlZ2VuU291cmNlTW9kdWxlID0gZnVuY3Rpb24gKHNyY0ZpbGVVcmwsIGdlbkZpbGVVcmwsIHN0YXRlbWVudHMsIGV4cG9ydGVkVmFycykge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyYXRlZEZpbGUoc3JjRmlsZVVybCwgZ2VuRmlsZVVybCwgdGhpcy5fb3V0cHV0RW1pdHRlci5lbWl0U3RhdGVtZW50cyhzb3VyY2VVcmwoc3JjRmlsZVVybCksIGdlbkZpbGVVcmwsIHN0YXRlbWVudHMsIGV4cG9ydGVkVmFycywgdGhpcy5fZ2VuRmlsZVByZWFtYmxlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQW90Q29tcGlsZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHJlZmxlY3RvclxuICogQHBhcmFtIHs/fSBjb21waWxlUmVzdWx0XG4gKiBAcGFyYW0gez99IGZpbGVTdWZmaXhcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9yZXNvbHZlU3R5bGVTdGF0ZW1lbnRzKHJlZmxlY3RvciwgY29tcGlsZVJlc3VsdCwgZmlsZVN1ZmZpeCkge1xuICAgIGNvbXBpbGVSZXN1bHQuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICBkZXAudmFsdWVQbGFjZWhvbGRlci5yZWZlcmVuY2UgPSByZWZsZWN0b3IuZ2V0U3RhdGljU3ltYm9sKF9zdHlsZXNNb2R1bGVVcmwoZGVwLm1vZHVsZVVybCwgZGVwLmlzU2hpbW1lZCwgZmlsZVN1ZmZpeCksIGRlcC5uYW1lKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29tcGlsZVJlc3VsdC5zdGF0ZW1lbnRzO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHN0eWxlc2hlZXRVcmxcbiAqIEBwYXJhbSB7P30gc2hpbVxuICogQHBhcmFtIHs/fSBzdWZmaXhcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9zdHlsZXNNb2R1bGVVcmwoc3R5bGVzaGVldFVybCwgc2hpbSwgc3VmZml4KSB7XG4gICAgcmV0dXJuIFwiXCIgKyBzdHlsZXNoZWV0VXJsICsgKHNoaW0gPyAnLnNoaW0nIDogJycpICsgXCIubmdzdHlsZVwiICsgc3VmZml4O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG1ldGFcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9hc3NlcnRDb21wb25lbnQobWV0YSkge1xuICAgIGlmICghbWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY29tcGlsZSAnXCIgKyBpZGVudGlmaWVyTmFtZShtZXRhLnR5cGUpICsgXCInIGJlY2F1c2UgaXQgaXMgbm90IGEgY29tcG9uZW50LlwiKTtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcHJvZ3JhbVN0YXRpY1N5bWJvbHNcbiAqIEBwYXJhbSB7P30gaG9zdFxuICogQHBhcmFtIHs/fSBtZXRhZGF0YVJlc29sdmVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBhbmFseXplTmdNb2R1bGVzKHByb2dyYW1TdGF0aWNTeW1ib2xzLCBob3N0LCBtZXRhZGF0YVJlc29sdmVyKSB7XG4gICAgdmFyIF9hID0gX2NyZWF0ZU5nTW9kdWxlcyhwcm9ncmFtU3RhdGljU3ltYm9scywgaG9zdCwgbWV0YWRhdGFSZXNvbHZlciksIG5nTW9kdWxlcyA9IF9hLm5nTW9kdWxlcywgc3ltYm9sc01pc3NpbmdNb2R1bGUgPSBfYS5zeW1ib2xzTWlzc2luZ01vZHVsZTtcbiAgICByZXR1cm4gX2FuYWx5emVOZ01vZHVsZXMocHJvZ3JhbVN0YXRpY1N5bWJvbHMsIG5nTW9kdWxlcywgc3ltYm9sc01pc3NpbmdNb2R1bGUsIG1ldGFkYXRhUmVzb2x2ZXIpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHByb2dyYW1TdGF0aWNTeW1ib2xzXG4gKiBAcGFyYW0gez99IGhvc3RcbiAqIEBwYXJhbSB7P30gbWV0YWRhdGFSZXNvbHZlclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYW5hbHl6ZUFuZFZhbGlkYXRlTmdNb2R1bGVzKHByb2dyYW1TdGF0aWNTeW1ib2xzLCBob3N0LCBtZXRhZGF0YVJlc29sdmVyKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gYW5hbHl6ZU5nTW9kdWxlcyhwcm9ncmFtU3RhdGljU3ltYm9scywgaG9zdCwgbWV0YWRhdGFSZXNvbHZlcik7XG4gICAgaWYgKHJlc3VsdC5zeW1ib2xzTWlzc2luZ01vZHVsZSAmJiByZXN1bHQuc3ltYm9sc01pc3NpbmdNb2R1bGUubGVuZ3RoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lc3NhZ2VzID0gcmVzdWx0LnN5bWJvbHNNaXNzaW5nTW9kdWxlLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gXCJDYW5ub3QgZGV0ZXJtaW5lIHRoZSBtb2R1bGUgZm9yIGNsYXNzIFwiICsgcy5uYW1lICsgXCIgaW4gXCIgKyBzLmZpbGVQYXRoICsgXCIhIEFkZCBcIiArIHMubmFtZSArIFwiIHRvIHRoZSBOZ01vZHVsZSB0byBmaXggaXQuXCI7IH0pO1xuICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihtZXNzYWdlcy5qb2luKCdcXG4nKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcHJvZ3JhbVN5bWJvbHNcbiAqIEBwYXJhbSB7P30gbmdNb2R1bGVNZXRhc1xuICogQHBhcmFtIHs/fSBzeW1ib2xzTWlzc2luZ01vZHVsZVxuICogQHBhcmFtIHs/fSBtZXRhZGF0YVJlc29sdmVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfYW5hbHl6ZU5nTW9kdWxlcyhwcm9ncmFtU3ltYm9scywgbmdNb2R1bGVNZXRhcywgc3ltYm9sc01pc3NpbmdNb2R1bGUsIG1ldGFkYXRhUmVzb2x2ZXIpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVNZXRhc0J5UmVmID0gbmV3IE1hcCgpO1xuICAgIG5nTW9kdWxlTWV0YXMuZm9yRWFjaChmdW5jdGlvbiAobmdNb2R1bGUpIHsgcmV0dXJuIG1vZHVsZU1ldGFzQnlSZWYuc2V0KG5nTW9kdWxlLnR5cGUucmVmZXJlbmNlLCBuZ01vZHVsZSk7IH0pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUgPSBuZXcgTWFwKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGVzQnlGaWxlID0gbmV3IE1hcCgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nRGlyZWN0aXZlc0J5RmlsZSA9IG5ldyBNYXAoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ1BpcGVzQnlGaWxlID0gbmV3IE1hcCgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nSW5qZWN0YWJsZXNCeUZpbGUgPSBuZXcgTWFwKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlsZVBhdGhzID0gbmV3IFNldCgpO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSBwcm9kdWNlIGFuIGFuYWx5emVkIGZpbGUgZm9yIGVhY2ggaW5wdXQgZmlsZVxuICAgIHByb2dyYW1TeW1ib2xzLmZvckVhY2goZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaWxlUGF0aCA9IHN5bWJvbC5maWxlUGF0aDtcbiAgICAgICAgZmlsZVBhdGhzLmFkZChmaWxlUGF0aCk7XG4gICAgICAgIGlmIChtZXRhZGF0YVJlc29sdmVyLmlzSW5qZWN0YWJsZShzeW1ib2wpKSB7XG4gICAgICAgICAgICBuZ0luamVjdGFibGVzQnlGaWxlLnNldChmaWxlUGF0aCwgKG5nSW5qZWN0YWJsZXNCeUZpbGUuZ2V0KGZpbGVQYXRoKSB8fCBbXSkuY29uY2F0KHN5bWJvbCkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gTG9vcGluZyBvdmVyIGFsbCBtb2R1bGVzIHRvIGNvbnN0cnVjdDpcbiAgICAvLyAtIGEgbWFwIGZyb20gZmlsZSB0byBtb2R1bGVzIGBuZ01vZHVsZXNCeUZpbGVgLFxuICAgIC8vIC0gYSBtYXAgZnJvbSBmaWxlIHRvIGRpcmVjdGl2ZXMgYG5nRGlyZWN0aXZlc0J5RmlsZWAsXG4gICAgLy8gLSBhIG1hcCBmcm9tIGZpbGUgdG8gcGlwZXMgYG5nUGlwZXNCeUZpbGVgLFxuICAgIC8vIC0gYSBtYXAgZnJvbSBkaXJlY3RpdmUvcGlwZSB0byBtb2R1bGUgYG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmVgLlxuICAgIG5nTW9kdWxlTWV0YXMuZm9yRWFjaChmdW5jdGlvbiAobmdNb2R1bGVNZXRhKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNyY0ZpbGVVcmwgPSBuZ01vZHVsZU1ldGEudHlwZS5yZWZlcmVuY2UuZmlsZVBhdGg7XG4gICAgICAgIGZpbGVQYXRocy5hZGQoc3JjRmlsZVVybCk7XG4gICAgICAgIG5nTW9kdWxlc0J5RmlsZS5zZXQoc3JjRmlsZVVybCwgKG5nTW9kdWxlc0J5RmlsZS5nZXQoc3JjRmlsZVVybCkgfHwgW10pLmNvbmNhdChuZ01vZHVsZU1ldGEudHlwZS5yZWZlcmVuY2UpKTtcbiAgICAgICAgbmdNb2R1bGVNZXRhLmRlY2xhcmVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaWxlVXJsID0gZGlySWRlbnRpZmllci5yZWZlcmVuY2UuZmlsZVBhdGg7XG4gICAgICAgICAgICBmaWxlUGF0aHMuYWRkKGZpbGVVcmwpO1xuICAgICAgICAgICAgbmdEaXJlY3RpdmVzQnlGaWxlLnNldChmaWxlVXJsLCAobmdEaXJlY3RpdmVzQnlGaWxlLmdldChmaWxlVXJsKSB8fCBbXSkuY29uY2F0KGRpcklkZW50aWZpZXIucmVmZXJlbmNlKSk7XG4gICAgICAgICAgICBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLnNldChkaXJJZGVudGlmaWVyLnJlZmVyZW5jZSwgbmdNb2R1bGVNZXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG5nTW9kdWxlTWV0YS5kZWNsYXJlZFBpcGVzLmZvckVhY2goZnVuY3Rpb24gKHBpcGVJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaWxlVXJsID0gcGlwZUlkZW50aWZpZXIucmVmZXJlbmNlLmZpbGVQYXRoO1xuICAgICAgICAgICAgZmlsZVBhdGhzLmFkZChmaWxlVXJsKTtcbiAgICAgICAgICAgIG5nUGlwZXNCeUZpbGUuc2V0KGZpbGVVcmwsIChuZ1BpcGVzQnlGaWxlLmdldChmaWxlVXJsKSB8fCBbXSkuY29uY2F0KHBpcGVJZGVudGlmaWVyLnJlZmVyZW5jZSkpO1xuICAgICAgICAgICAgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZS5zZXQocGlwZUlkZW50aWZpZXIucmVmZXJlbmNlLCBuZ01vZHVsZU1ldGEpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaWxlcyA9IFtdO1xuICAgIGZpbGVQYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChzcmNVcmwpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyZWN0aXZlcyA9IG5nRGlyZWN0aXZlc0J5RmlsZS5nZXQoc3JjVXJsKSB8fCBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGlwZXMgPSBuZ1BpcGVzQnlGaWxlLmdldChzcmNVcmwpIHx8IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ01vZHVsZXMgPSBuZ01vZHVsZXNCeUZpbGUuZ2V0KHNyY1VybCkgfHwgW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluamVjdGFibGVzID0gbmdJbmplY3RhYmxlc0J5RmlsZS5nZXQoc3JjVXJsKSB8fCBbXTtcbiAgICAgICAgZmlsZXMucHVzaCh7IHNyY1VybDogc3JjVXJsLCBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLCBwaXBlczogcGlwZXMsIG5nTW9kdWxlczogbmdNb2R1bGVzLCBpbmplY3RhYmxlczogaW5qZWN0YWJsZXMgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gbWFwIGRpcmVjdGl2ZS9waXBlIHRvIG1vZHVsZVxuICAgICAgICBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlOiBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLFxuICAgICAgICAvLyBsaXN0IG1vZHVsZXMgYW5kIGRpcmVjdGl2ZXMgZm9yIGV2ZXJ5IHNvdXJjZSBmaWxlXG4gICAgICAgIGZpbGVzOiBmaWxlcyxcbiAgICAgICAgbmdNb2R1bGVzOiBuZ01vZHVsZU1ldGFzLCBzeW1ib2xzTWlzc2luZ01vZHVsZTogc3ltYm9sc01pc3NpbmdNb2R1bGVcbiAgICB9O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbFJlc29sdmVyXG4gKiBAcGFyYW0gez99IGZpbGVzXG4gKiBAcGFyYW0gez99IGhvc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm9ncmFtU3ltYm9scyhzdGF0aWNTeW1ib2xSZXNvbHZlciwgZmlsZXMsIGhvc3QpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0aWNTeW1ib2xzID0gW107XG4gICAgZmlsZXMuZmlsdGVyKGZ1bmN0aW9uIChmaWxlTmFtZSkgeyByZXR1cm4gaG9zdC5pc1NvdXJjZUZpbGUoZmlsZU5hbWUpOyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHN0YXRpY1N5bWJvbFJlc29sdmVyLmdldFN5bWJvbHNPZihzb3VyY2VGaWxlKS5mb3JFYWNoKGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkU3ltYm9sID0gc3RhdGljU3ltYm9sUmVzb2x2ZXIucmVzb2x2ZVN5bWJvbChzeW1ib2wpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sTWV0YSA9IHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhO1xuICAgICAgICAgICAgaWYgKHN5bWJvbE1ldGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sTWV0YS5fX3N5bWJvbGljICE9ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHN5bWJvbHMgdGhhdCBhcmUgb25seSBpbmNsdWRlZCB0byByZWNvcmQgZXJyb3IgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1N5bWJvbHMucHVzaChyZXNvbHZlZFN5bWJvbC5zeW1ib2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0YXRpY1N5bWJvbHM7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcHJvZ3JhbVN0YXRpY1N5bWJvbHNcbiAqIEBwYXJhbSB7P30gaG9zdFxuICogQHBhcmFtIHs/fSBtZXRhZGF0YVJlc29sdmVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfY3JlYXRlTmdNb2R1bGVzKHByb2dyYW1TdGF0aWNTeW1ib2xzLCBob3N0LCBtZXRhZGF0YVJlc29sdmVyKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGVzID0gbmV3IE1hcCgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb2dyYW1QaXBlc0FuZERpcmVjdGl2ZXMgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ01vZHVsZVBpcGVzQW5kRGlyZWN0aXZlID0gbmV3IFNldCgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGFkZE5nTW9kdWxlID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICBpZiAobmdNb2R1bGVzLmhhcyhzdGF0aWNTeW1ib2wpIHx8ICFob3N0LmlzU291cmNlRmlsZShzdGF0aWNTeW1ib2wuZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGUgPSBtZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEoc3RhdGljU3ltYm9sLCBmYWxzZSk7XG4gICAgICAgIGlmIChuZ01vZHVsZSkge1xuICAgICAgICAgICAgbmdNb2R1bGVzLnNldChuZ01vZHVsZS50eXBlLnJlZmVyZW5jZSwgbmdNb2R1bGUpO1xuICAgICAgICAgICAgbmdNb2R1bGUuZGVjbGFyZWREaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gbmdNb2R1bGVQaXBlc0FuZERpcmVjdGl2ZS5hZGQoZGlyLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICAgICAgbmdNb2R1bGUuZGVjbGFyZWRQaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwaXBlKSB7IHJldHVybiBuZ01vZHVsZVBpcGVzQW5kRGlyZWN0aXZlLmFkZChwaXBlLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICAgICAgLy8gRm9yIGV2ZXJ5IGlucHV0IG1vZHVsZSBhZGQgdGhlIGxpc3Qgb2YgdHJhbnNpdGl2ZWx5IGluY2x1ZGVkIG1vZHVsZXNcbiAgICAgICAgICAgIG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RNZXRhKSB7IHJldHVybiBhZGROZ01vZHVsZShtb2RNZXRhLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIW5nTW9kdWxlO1xuICAgIH07XG4gICAgcHJvZ3JhbVN0YXRpY1N5bWJvbHMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGljU3ltYm9sKSB7XG4gICAgICAgIGlmICghYWRkTmdNb2R1bGUoc3RhdGljU3ltYm9sKSAmJlxuICAgICAgICAgICAgKG1ldGFkYXRhUmVzb2x2ZXIuaXNEaXJlY3RpdmUoc3RhdGljU3ltYm9sKSB8fCBtZXRhZGF0YVJlc29sdmVyLmlzUGlwZShzdGF0aWNTeW1ib2wpKSkge1xuICAgICAgICAgICAgcHJvZ3JhbVBpcGVzQW5kRGlyZWN0aXZlcy5wdXNoKHN0YXRpY1N5bWJvbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBUaHJvdyBhbiBlcnJvciBpZiBhbnkgb2YgdGhlIHByb2dyYW0gcGlwZSBvciBkaXJlY3RpdmVzIGlzIG5vdCBkZWNsYXJlZCBieSBhIG1vZHVsZVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbHNNaXNzaW5nTW9kdWxlID0gcHJvZ3JhbVBpcGVzQW5kRGlyZWN0aXZlcy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuICFuZ01vZHVsZVBpcGVzQW5kRGlyZWN0aXZlLmhhcyhzKTsgfSk7XG4gICAgcmV0dXJuIHsgbmdNb2R1bGVzOiBBcnJheS5mcm9tKG5nTW9kdWxlcy52YWx1ZXMoKSksIHN5bWJvbHNNaXNzaW5nTW9kdWxlOiBzeW1ib2xzTWlzc2luZ01vZHVsZSB9O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY0RlbGVnYXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMoc3RhdGljRGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5zdGF0aWNEZWxlZ2F0ZSA9IHN0YXRpY0RlbGVnYXRlO1xuICAgICAgICB0aGlzLmR5bmFtaWNEZWxlZ2F0ZSA9IG5ldyDJtVJlZmxlY3Rpb25DYXBhYmlsaXRpZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0aWNEZWxlZ2F0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMuaW5zdGFsbCA9IGZ1bmN0aW9uIChzdGF0aWNEZWxlZ2F0ZSkge1xuICAgICAgICDJtXJlZmxlY3Rvci51cGRhdGVDYXBhYmlsaXRpZXMobmV3IFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzKHN0YXRpY0RlbGVnYXRlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5pc1JlZmxlY3Rpb25FbmFibGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5mYWN0b3J5ID0gZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHRoaXMuZHluYW1pY0RlbGVnYXRlLmZhY3RvcnkodHlwZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBsY1Byb3BlcnR5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuaGFzTGlmZWN5Y2xlSG9vayA9IGZ1bmN0aW9uICh0eXBlLCBsY1Byb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBpc1N0YXRpY1R5cGUodHlwZSkgPyB0aGlzLnN0YXRpY0RlbGVnYXRlLmhhc0xpZmVjeWNsZUhvb2sodHlwZSwgbGNQcm9wZXJ0eSkgOlxuICAgICAgICAgICAgdGhpcy5keW5hbWljRGVsZWdhdGUuaGFzTGlmZWN5Y2xlSG9vayh0eXBlLCBsY1Byb3BlcnR5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gaXNTdGF0aWNUeXBlKHR5cGUpID8gdGhpcy5zdGF0aWNEZWxlZ2F0ZS5wYXJhbWV0ZXJzKHR5cGUpIDpcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY0RlbGVnYXRlLnBhcmFtZXRlcnModHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5hbm5vdGF0aW9ucyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBpc1N0YXRpY1R5cGUodHlwZSkgPyB0aGlzLnN0YXRpY0RlbGVnYXRlLmFubm90YXRpb25zKHR5cGUpIDpcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY0RlbGVnYXRlLmFubm90YXRpb25zKHR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlT3JGdW5jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUucHJvcE1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RhdGljVHlwZSh0eXBlT3JGdW5jKSA/IHRoaXMuc3RhdGljRGVsZWdhdGUucHJvcE1ldGFkYXRhKHR5cGVPckZ1bmMpIDpcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY0RlbGVnYXRlLnByb3BNZXRhZGF0YSh0eXBlT3JGdW5jKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmdldHRlciA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0aGlzLmR5bmFtaWNEZWxlZ2F0ZS5nZXR0ZXIobmFtZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuc2V0dGVyID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHRoaXMuZHluYW1pY0RlbGVnYXRlLnNldHRlcihuYW1lKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5tZXRob2QgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gdGhpcy5keW5hbWljRGVsZWdhdGUubWV0aG9kKG5hbWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmltcG9ydFVyaSA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiAoKHRoaXMuc3RhdGljRGVsZWdhdGUuaW1wb3J0VXJpKHR5cGUpKSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUucmVzb3VyY2VVcmkgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdGhpcy5zdGF0aWNEZWxlZ2F0ZS5yZXNvdXJjZVVyaSh0eXBlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVVybFxuICAgICAqIEBwYXJhbSB7P30gbWVtYmVyc1xuICAgICAqIEBwYXJhbSB7P30gcnVudGltZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnJlc29sdmVJZGVudGlmaWVyID0gZnVuY3Rpb24gKG5hbWUsIG1vZHVsZVVybCwgbWVtYmVycywgcnVudGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0aWNEZWxlZ2F0ZS5yZXNvbHZlSWRlbnRpZmllcihuYW1lLCBtb2R1bGVVcmwsIG1lbWJlcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbnVtSWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnJlc29sdmVFbnVtID0gZnVuY3Rpb24gKGVudW1JZGVudGlmaWVyLCBuYW1lKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY1R5cGUoZW51bUlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0aWNEZWxlZ2F0ZS5yZXNvbHZlRW51bShlbnVtSWRlbnRpZmllciwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB0eXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1N0YXRpY1R5cGUodHlwZSkge1xuICAgIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZS5uYW1lICYmIHR5cGUuZmlsZVBhdGg7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQU5HVUxBUl9DT1JFID0gJ0Bhbmd1bGFyL2NvcmUnO1xudmFyIEhJRERFTl9LRVkgPSAvXlxcJC4qXFwkJC87XG52YXIgSUdOT1JFID0ge1xuICAgIF9fc3ltYm9saWM6ICdpZ25vcmUnXG59O1xuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzaG91bGRJZ25vcmUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuX19zeW1ib2xpYyA9PSAnaWdub3JlJztcbn1cbi8qKlxuICogQSBzdGF0aWMgcmVmbGVjdG9yIGltcGxlbWVudHMgZW5vdWdoIG9mIHRoZSBSZWZsZWN0b3IgQVBJIHRoYXQgaXMgbmVjZXNzYXJ5IHRvIGNvbXBpbGVcbiAqIHRlbXBsYXRlcyBzdGF0aWNhbGx5LlxuICovXG52YXIgU3RhdGljUmVmbGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN1bW1hcnlSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gc3ltYm9sUmVzb2x2ZXJcbiAgICAgKiBAcGFyYW0gez89fSBrbm93bk1ldGFkYXRhQ2xhc3Nlc1xuICAgICAqIEBwYXJhbSB7Pz19IGtub3duTWV0YWRhdGFGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSBlcnJvclJlY29yZGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhdGljUmVmbGVjdG9yKHN1bW1hcnlSZXNvbHZlciwgc3ltYm9sUmVzb2x2ZXIsIGtub3duTWV0YWRhdGFDbGFzc2VzLCBrbm93bk1ldGFkYXRhRnVuY3Rpb25zLCBlcnJvclJlY29yZGVyKSB7XG4gICAgICAgIGlmIChrbm93bk1ldGFkYXRhQ2xhc3NlcyA9PT0gdm9pZCAwKSB7IGtub3duTWV0YWRhdGFDbGFzc2VzID0gW107IH1cbiAgICAgICAgaWYgKGtub3duTWV0YWRhdGFGdW5jdGlvbnMgPT09IHZvaWQgMCkgeyBrbm93bk1ldGFkYXRhRnVuY3Rpb25zID0gW107IH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdW1tYXJ5UmVzb2x2ZXIgPSBzdW1tYXJ5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuc3ltYm9sUmVzb2x2ZXIgPSBzeW1ib2xSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5lcnJvclJlY29yZGVyID0gZXJyb3JSZWNvcmRlcjtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucHJvcGVydHlDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tZXRob2RDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb252ZXJzaW9uTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25Gb3JQYXJlbnRDbGFzc1dpdGhTdW1tYXJ5S2luZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uTmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUNvbnZlcnNpb25NYXAoKTtcbiAgICAgICAga25vd25NZXRhZGF0YUNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoa2MpIHsgcmV0dXJuIF90aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IoX3RoaXMuZ2V0U3RhdGljU3ltYm9sKGtjLmZpbGVQYXRoLCBrYy5uYW1lKSwga2MuY3Rvcik7IH0pO1xuICAgICAgICBrbm93bk1ldGFkYXRhRnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGtmKSB7IHJldHVybiBfdGhpcy5fcmVnaXN0ZXJGdW5jdGlvbihfdGhpcy5nZXRTdGF0aWNTeW1ib2woa2YuZmlsZVBhdGgsIGtmLm5hbWUpLCBrZi5mbik7IH0pO1xuICAgICAgICB0aGlzLmFubm90YXRpb25Gb3JQYXJlbnRDbGFzc1dpdGhTdW1tYXJ5S2luZC5zZXQoQ29tcGlsZVN1bW1hcnlLaW5kLkRpcmVjdGl2ZSwgW0RpcmVjdGl2ZSwgQ29tcG9uZW50XSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkZvclBhcmVudENsYXNzV2l0aFN1bW1hcnlLaW5kLnNldChDb21waWxlU3VtbWFyeUtpbmQuUGlwZSwgW1BpcGVdKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uRm9yUGFyZW50Q2xhc3NXaXRoU3VtbWFyeUtpbmQuc2V0KENvbXBpbGVTdW1tYXJ5S2luZC5OZ01vZHVsZSwgW05nTW9kdWxlXSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkZvclBhcmVudENsYXNzV2l0aFN1bW1hcnlLaW5kLnNldChDb21waWxlU3VtbWFyeUtpbmQuSW5qZWN0YWJsZSwgW0luamVjdGFibGUsIFBpcGUsIERpcmVjdGl2ZSwgQ29tcG9uZW50LCBOZ01vZHVsZV0pO1xuICAgICAgICB0aGlzLmFubm90YXRpb25OYW1lcy5zZXQoRGlyZWN0aXZlLCAnRGlyZWN0aXZlJyk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbk5hbWVzLnNldChDb21wb25lbnQsICdDb21wb25lbnQnKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uTmFtZXMuc2V0KFBpcGUsICdQaXBlJyk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbk5hbWVzLnNldChOZ01vZHVsZSwgJ05nTW9kdWxlJyk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbk5hbWVzLnNldChJbmplY3RhYmxlLCAnSW5qZWN0YWJsZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVPckZ1bmNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuaW1wb3J0VXJpID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljU3ltYm9sID0gdGhpcy5maW5kU3ltYm9sRGVjbGFyYXRpb24odHlwZU9yRnVuYyk7XG4gICAgICAgIHJldHVybiBzdGF0aWNTeW1ib2wgPyBzdGF0aWNTeW1ib2wuZmlsZVBhdGggOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlT3JGdW5jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnJlc291cmNlVXJpID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljU3ltYm9sID0gdGhpcy5maW5kU3ltYm9sRGVjbGFyYXRpb24odHlwZU9yRnVuYyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bWJvbFJlc29sdmVyLmdldFJlc291cmNlUGF0aChzdGF0aWNTeW1ib2wpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVVcmxcbiAgICAgKiBAcGFyYW0gez99IG1lbWJlcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUucmVzb2x2ZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAobmFtZSwgbW9kdWxlVXJsLCBtZW1iZXJzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGltcG9ydFN5bWJvbCA9IHRoaXMuZ2V0U3RhdGljU3ltYm9sKG1vZHVsZVVybCwgbmFtZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJvb3RTeW1ib2wgPSB0aGlzLmZpbmREZWNsYXJhdGlvbihtb2R1bGVVcmwsIG5hbWUpO1xuICAgICAgICBpZiAoaW1wb3J0U3ltYm9sICE9IHJvb3RTeW1ib2wpIHtcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sUmVzb2x2ZXIucmVjb3JkSW1wb3J0QXMocm9vdFN5bWJvbCwgaW1wb3J0U3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVtYmVycyAmJiBtZW1iZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGljU3ltYm9sKHJvb3RTeW1ib2wuZmlsZVBhdGgsIHJvb3RTeW1ib2wubmFtZSwgbWVtYmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3RTeW1ib2w7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVVybFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRhaW5pbmdGaWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmZpbmREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChtb2R1bGVVcmwsIG5hbWUsIGNvbnRhaW5pbmdGaWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRTeW1ib2xEZWNsYXJhdGlvbih0aGlzLnN5bWJvbFJlc29sdmVyLmdldFN5bWJvbEJ5TW9kdWxlKG1vZHVsZVVybCwgbmFtZSwgY29udGFpbmluZ0ZpbGUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmZpbmRTeW1ib2xEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRTeW1ib2wgPSB0aGlzLnN5bWJvbFJlc29sdmVyLnJlc29sdmVTeW1ib2woc3ltYm9sKTtcbiAgICAgICAgaWYgKHJlc29sdmVkU3ltYm9sICYmIHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kU3ltYm9sRGVjbGFyYXRpb24ocmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbnVtSWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5yZXNvbHZlRW51bSA9IGZ1bmN0aW9uIChlbnVtSWRlbnRpZmllciwgbmFtZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0aWNTeW1ib2wgPSBlbnVtSWRlbnRpZmllcjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVtYmVycyA9IChzdGF0aWNTeW1ib2wubWVtYmVycyB8fCBbXSkuY29uY2F0KG5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0aWNTeW1ib2woc3RhdGljU3ltYm9sLmZpbGVQYXRoLCBzdGF0aWNTeW1ib2wubmFtZSwgbWVtYmVycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuYW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbm5vdGF0aW9ucyA9IHRoaXMuYW5ub3RhdGlvbkNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFhbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgYW5ub3RhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzTWV0YWRhdGEgPSB0aGlzLmdldFR5cGVNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudFR5cGUgPSB0aGlzLmZpbmRQYXJlbnRUeXBlKHR5cGUsIGNsYXNzTWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKHBhcmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRBbm5vdGF0aW9ucyA9IHRoaXMuYW5ub3RhdGlvbnMocGFyZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMucHVzaC5hcHBseShhbm5vdGF0aW9ucywgcGFyZW50QW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3duQW5ub3RhdGlvbnNfMSA9IFtdO1xuICAgICAgICAgICAgaWYgKGNsYXNzTWV0YWRhdGFbJ2RlY29yYXRvcnMnXSkge1xuICAgICAgICAgICAgICAgIG93bkFubm90YXRpb25zXzEgPSB0aGlzLnNpbXBsaWZ5KHR5cGUsIGNsYXNzTWV0YWRhdGFbJ2RlY29yYXRvcnMnXSk7XG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMucHVzaC5hcHBseShhbm5vdGF0aW9ucywgb3duQW5ub3RhdGlvbnNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50VHlwZSAmJiAhdGhpcy5zdW1tYXJ5UmVzb2x2ZXIuaXNMaWJyYXJ5RmlsZSh0eXBlLmZpbGVQYXRoKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUocGFyZW50VHlwZS5maWxlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdW1tYXJ5ID0gdGhpcy5zdW1tYXJ5UmVzb2x2ZXIucmVzb2x2ZVN1bW1hcnkocGFyZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1bW1hcnkgJiYgc3VtbWFyeS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcXVpcmVkQW5ub3RhdGlvblR5cGVzID0gKCh0aGlzLmFubm90YXRpb25Gb3JQYXJlbnRDbGFzc1dpdGhTdW1tYXJ5S2luZC5nZXQoLyoqIEB0eXBlIHs/fSAqLyAoKHN1bW1hcnkudHlwZS5zdW1tYXJ5S2luZCkpKSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlSGFzUmVxdWlyZWRBbm5vdGF0aW9uID0gcmVxdWlyZWRBbm5vdGF0aW9uVHlwZXMuc29tZShmdW5jdGlvbiAocmVxdWlyZWRUeXBlKSB7IHJldHVybiBvd25Bbm5vdGF0aW9uc18xLnNvbWUoZnVuY3Rpb24gKGFubikgeyByZXR1cm4gYW5uIGluc3RhbmNlb2YgcmVxdWlyZWRUeXBlOyB9KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZUhhc1JlcXVpcmVkQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIkNsYXNzIFwiICsgdHlwZS5uYW1lICsgXCIgaW4gXCIgKyB0eXBlLmZpbGVQYXRoICsgXCIgZXh0ZW5kcyBmcm9tIGEgXCIgKyBDb21waWxlU3VtbWFyeUtpbmRbKChzdW1tYXJ5LnR5cGUuc3VtbWFyeUtpbmQpKV0gKyBcIiBpbiBhbm90aGVyIGNvbXBpbGF0aW9uIHVuaXQgd2l0aG91dCBkdXBsaWNhdGluZyB0aGUgZGVjb3JhdG9yLiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiUGxlYXNlIGFkZCBhIFwiICsgcmVxdWlyZWRBbm5vdGF0aW9uVHlwZXMubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBfdGhpcy5hbm5vdGF0aW9uTmFtZXMuZ2V0KHR5cGUpOyB9KS5qb2luKCcgb3IgJykgKyBcIiBkZWNvcmF0b3IgdG8gdGhlIGNsYXNzLlwiKSksIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FjaGUuc2V0KHR5cGUsIGFubm90YXRpb25zLmZpbHRlcihmdW5jdGlvbiAoYW5uKSB7IHJldHVybiAhIWFubjsgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbm5vdGF0aW9ucztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5wcm9wTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wTWV0YWRhdGEgPSB0aGlzLnByb3BlcnR5Q2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoIXByb3BNZXRhZGF0YSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NNZXRhZGF0YSA9IHRoaXMuZ2V0VHlwZU1ldGFkYXRhKHR5cGUpO1xuICAgICAgICAgICAgcHJvcE1ldGFkYXRhID0ge307XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRUeXBlID0gdGhpcy5maW5kUGFyZW50VHlwZSh0eXBlLCBjbGFzc01ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50UHJvcE1ldGFkYXRhXzEgPSB0aGlzLnByb3BNZXRhZGF0YShwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJlbnRQcm9wTWV0YWRhdGFfMSkuZm9yRWFjaChmdW5jdGlvbiAocGFyZW50UHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAoKHByb3BNZXRhZGF0YSkpW3BhcmVudFByb3BdID0gcGFyZW50UHJvcE1ldGFkYXRhXzFbcGFyZW50UHJvcF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZW1iZXJzXzEgPSBjbGFzc01ldGFkYXRhWydtZW1iZXJzJ10gfHwge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhtZW1iZXJzXzEpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcERhdGEgPSBtZW1iZXJzXzFbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3AgPSAoKHByb3BEYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbmQoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbJ19fc3ltYm9saWMnXSA9PSAncHJvcGVydHknIHx8IGFbJ19fc3ltYm9saWMnXSA9PSAnbWV0aG9kJzsgfSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVjb3JhdG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICgoKHByb3BNZXRhZGF0YSkpW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBkZWNvcmF0b3JzLnB1c2guYXBwbHkoZGVjb3JhdG9ycywgKChwcm9wTWV0YWRhdGEpKVtwcm9wTmFtZV0pO1xuICAgICAgICAgICAgICAgIH0gLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgICgocHJvcE1ldGFkYXRhKSlbcHJvcE5hbWVdID0gZGVjb3JhdG9ycztcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAmJiBwcm9wWydkZWNvcmF0b3JzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb3JhdG9ycy5wdXNoLmFwcGx5KGRlY29yYXRvcnMsIF90aGlzLnNpbXBsaWZ5KHR5cGUsIHByb3BbJ2RlY29yYXRvcnMnXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eUNhY2hlLnNldCh0eXBlLCBwcm9wTWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wTWV0YWRhdGE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUucGFyYW1ldGVycyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmICghKHR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKG5ldyBFcnJvcihcInBhcmFtZXRlcnMgcmVjZWl2ZWQgXCIgKyBKU09OLnN0cmluZ2lmeSh0eXBlKSArIFwiIHdoaWNoIGlzIG5vdCBhIFN0YXRpY1N5bWJvbFwiKSwgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtZXRlcnNfMSA9IHRoaXMucGFyYW1ldGVyQ2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICAgICAgaWYgKCFwYXJhbWV0ZXJzXzEpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc01ldGFkYXRhID0gdGhpcy5nZXRUeXBlTWV0YWRhdGEodHlwZSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50VHlwZSA9IHRoaXMuZmluZFBhcmVudFR5cGUodHlwZSwgY2xhc3NNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVtYmVycyA9IGNsYXNzTWV0YWRhdGEgPyBjbGFzc01ldGFkYXRhWydtZW1iZXJzJ10gOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0b3JEYXRhID0gbWVtYmVycyA/IG1lbWJlcnNbJ19fY3Rvcl9fJ10gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChjdG9yRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdG9yID0gKChjdG9yRGF0YSkpLmZpbmQoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbJ19fc3ltYm9saWMnXSA9PSAnY29uc3RydWN0b3InOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1ldGVyVHlwZXMgPSAodGhpcy5zaW1wbGlmeSh0eXBlLCBjdG9yWydwYXJhbWV0ZXJzJ10gfHwgW10pKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1ldGVyRGVjb3JhdG9yc18xID0gKHRoaXMuc2ltcGxpZnkodHlwZSwgY3RvclsncGFyYW1ldGVyRGVjb3JhdG9ycyddIHx8IFtdKSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNfMSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbVR5cGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXN0ZWRSZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRSZXN1bHQucHVzaChwYXJhbVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVjb3JhdG9ycyA9IHBhcmFtZXRlckRlY29yYXRvcnNfMSA/IHBhcmFtZXRlckRlY29yYXRvcnNfMVtpbmRleF0gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlY29yYXRvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRSZXN1bHQucHVzaC5hcHBseShuZXN0ZWRSZXN1bHQsIGRlY29yYXRvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAoKHBhcmFtZXRlcnNfMSkpLnB1c2gobmVzdGVkUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyc18xID0gdGhpcy5wYXJhbWV0ZXJzKHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtZXRlcnNfMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzXzEgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJDYWNoZS5zZXQodHlwZSwgcGFyYW1ldGVyc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJhbWV0ZXJzXzE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgb24gdHlwZSBcIiArIEpTT04uc3RyaW5naWZ5KHR5cGUpICsgXCIgd2l0aCBlcnJvciBcIiArIGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLl9tZXRob2ROYW1lcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1ldGhvZE5hbWVzID0gdGhpcy5tZXRob2RDYWNoZS5nZXQodHlwZSk7XG4gICAgICAgIGlmICghbWV0aG9kTmFtZXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzTWV0YWRhdGEgPSB0aGlzLmdldFR5cGVNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgIG1ldGhvZE5hbWVzID0ge307XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRUeXBlID0gdGhpcy5maW5kUGFyZW50VHlwZSh0eXBlLCBjbGFzc01ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50TWV0aG9kTmFtZXNfMSA9IHRoaXMuX21ldGhvZE5hbWVzKHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmVudE1ldGhvZE5hbWVzXzEpLmZvckVhY2goZnVuY3Rpb24gKHBhcmVudFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgKChtZXRob2ROYW1lcykpW3BhcmVudFByb3BdID0gcGFyZW50TWV0aG9kTmFtZXNfMVtwYXJlbnRQcm9wXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlcnNfMiA9IGNsYXNzTWV0YWRhdGFbJ21lbWJlcnMnXSB8fCB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG1lbWJlcnNfMikuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wRGF0YSA9IG1lbWJlcnNfMltwcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNNZXRob2QgPSAoKHByb3BEYXRhKSkuc29tZShmdW5jdGlvbiAoYSkgeyByZXR1cm4gYVsnX19zeW1ib2xpYyddID09ICdtZXRob2QnOyB9KTsgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgICgobWV0aG9kTmFtZXMpKVtwcm9wTmFtZV0gPSAoKG1ldGhvZE5hbWVzKSlbcHJvcE5hbWVdIHx8IGlzTWV0aG9kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm1ldGhvZENhY2hlLnNldCh0eXBlLCBtZXRob2ROYW1lcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZE5hbWVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBjbGFzc01ldGFkYXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmZpbmRQYXJlbnRUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGNsYXNzTWV0YWRhdGEpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50VHlwZSA9IHRoaXMudHJ5U2ltcGxpZnkodHlwZSwgY2xhc3NNZXRhZGF0YVsnZXh0ZW5kcyddKTtcbiAgICAgICAgaWYgKHBhcmVudFR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRUeXBlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IGxjUHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuaGFzTGlmZWN5Y2xlSG9vayA9IGZ1bmN0aW9uICh0eXBlLCBsY1Byb3BlcnR5KSB7XG4gICAgICAgIGlmICghKHR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKG5ldyBFcnJvcihcImhhc0xpZmVjeWNsZUhvb2sgcmVjZWl2ZWQgXCIgKyBKU09OLnN0cmluZ2lmeSh0eXBlKSArIFwiIHdoaWNoIGlzIG5vdCBhIFN0YXRpY1N5bWJvbFwiKSwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuX21ldGhvZE5hbWVzKHR5cGUpW2xjUHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIG9uIHR5cGUgXCIgKyBKU09OLnN0cmluZ2lmeSh0eXBlKSArIFwiIHdpdGggZXJyb3IgXCIgKyBlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKHR5cGUsIGN0b3IpIHtcbiAgICAgICAgdGhpcy5jb252ZXJzaW9uTWFwLnNldCh0eXBlLCBmdW5jdGlvbiAoY29udGV4dCwgYXJncykgeyByZXR1cm4gbmV3IChjdG9yLmJpbmQuYXBwbHkoY3RvciwgW3ZvaWQgMF0uY29uY2F0KGFyZ3MpKSkoKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLl9yZWdpc3RlckZ1bmN0aW9uID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XG4gICAgICAgIHRoaXMuY29udmVyc2lvbk1hcC5zZXQodHlwZSwgZnVuY3Rpb24gKGNvbnRleHQsIGFyZ3MpIHsgcmV0dXJuIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmluaXRpYWxpemVDb252ZXJzaW9uTWFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmluamVjdGlvblRva2VuID0gdGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnSW5qZWN0aW9uVG9rZW4nKTtcbiAgICAgICAgdGhpcy5vcGFxdWVUb2tlbiA9IHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ09wYXF1ZVRva2VuJyk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdIb3N0JyksIEhvc3QpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnSW5qZWN0YWJsZScpLCBJbmplY3RhYmxlKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ1NlbGYnKSwgU2VsZik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdTa2lwU2VsZicpLCBTa2lwU2VsZik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdJbmplY3QnKSwgSW5qZWN0KTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ09wdGlvbmFsJyksIE9wdGlvbmFsKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0F0dHJpYnV0ZScpLCBBdHRyaWJ1dGUpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnQ29udGVudENoaWxkJyksIENvbnRlbnRDaGlsZCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdDb250ZW50Q2hpbGRyZW4nKSwgQ29udGVudENoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ1ZpZXdDaGlsZCcpLCBWaWV3Q2hpbGQpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnVmlld0NoaWxkcmVuJyksIFZpZXdDaGlsZHJlbik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdJbnB1dCcpLCBJbnB1dCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdPdXRwdXQnKSwgT3V0cHV0KTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ1BpcGUnKSwgUGlwZSk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdIb3N0QmluZGluZycpLCBIb3N0QmluZGluZyk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdIb3N0TGlzdGVuZXInKSwgSG9zdExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0RpcmVjdGl2ZScpLCBEaXJlY3RpdmUpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnQ29tcG9uZW50JyksIENvbXBvbmVudCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdOZ01vZHVsZScpLCBOZ01vZHVsZSk7XG4gICAgICAgIC8vIE5vdGU6IFNvbWUgbWV0YWRhdGEgY2xhc3NlcyBjYW4gYmUgdXNlZCBkaXJlY3RseSB3aXRoIFByb3ZpZGVyLmRlcHMuXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdIb3N0JyksIEhvc3QpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnU2VsZicpLCBTZWxmKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ1NraXBTZWxmJyksIFNraXBTZWxmKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ09wdGlvbmFsJyksIE9wdGlvbmFsKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJGdW5jdGlvbih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICd0cmlnZ2VyJyksIHRyaWdnZXIpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckZ1bmN0aW9uKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ3N0YXRlJyksIHN0YXRlKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJGdW5jdGlvbih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICd0cmFuc2l0aW9uJyksIHRyYW5zaXRpb24pO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckZ1bmN0aW9uKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ3N0eWxlJyksIHN0eWxlKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJGdW5jdGlvbih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdhbmltYXRlJyksIGFuaW1hdGUpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckZ1bmN0aW9uKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ2tleWZyYW1lcycpLCBrZXlmcmFtZXMpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckZ1bmN0aW9uKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ3NlcXVlbmNlJyksIHNlcXVlbmNlKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJGdW5jdGlvbih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdncm91cCcpLCBncm91cCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXRTdGF0aWNTeW1ib2wgcHJvZHVjZXMgYSBUeXBlIHdob3NlIG1ldGFkYXRhIGlzIGtub3duIGJ1dCB3aG9zZSBpbXBsZW1lbnRhdGlvbiBpcyBub3QgbG9hZGVkLlxuICAgICAqIEFsbCB0eXBlcyBwYXNzZWQgdG8gdGhlIFN0YXRpY1Jlc29sdmVyIHNob3VsZCBiZSBwc2V1ZG8tdHlwZXMgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGRlY2xhcmF0aW9uRmlsZSB0aGUgYWJzb2x1dGUgcGF0aCBvZiB0aGUgZmlsZSB3aGVyZSB0aGUgc3ltYm9sIGlzIGRlY2xhcmVkXG4gICAgICogQHBhcmFtIHs/fSBuYW1lIHRoZSBuYW1lIG9mIHRoZSB0eXBlLlxuICAgICAqIEBwYXJhbSB7Pz19IG1lbWJlcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuZ2V0U3RhdGljU3ltYm9sID0gZnVuY3Rpb24gKGRlY2xhcmF0aW9uRmlsZSwgbmFtZSwgbWVtYmVycykge1xuICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2xSZXNvbHZlci5nZXRTdGF0aWNTeW1ib2woZGVjbGFyYXRpb25GaWxlLCBuYW1lLCBtZW1iZXJzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcGFyYW0gez89fSBwYXRoXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnJlcG9ydEVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBjb250ZXh0LCBwYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yUmVjb3JkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JSZWNvcmRlcihlcnJvciwgKGNvbnRleHQgJiYgY29udGV4dC5maWxlUGF0aCkgfHwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2ltcGxpZnkgYnV0IGRpc2NhcmQgYW55IGVycm9yc1xuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUudHJ5U2ltcGxpZnkgPSBmdW5jdGlvbiAoY29udGV4dCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3JpZ2luYWxSZWNvcmRlciA9IHRoaXMuZXJyb3JSZWNvcmRlcjtcbiAgICAgICAgdGhpcy5lcnJvclJlY29yZGVyID0gZnVuY3Rpb24gKGVycm9yLCBmaWxlTmFtZSkgeyB9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLnNpbXBsaWZ5KGNvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5lcnJvclJlY29yZGVyID0gb3JpZ2luYWxSZWNvcmRlcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5zaW1wbGlmeSA9IGZ1bmN0aW9uIChjb250ZXh0LCB2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2NvcGUgPSBCaW5kaW5nU2NvcGUuZW1wdHk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhbGxpbmcgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcGFyYW0gez99IGRlcHRoXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBzaW1wbGlmeUluQ29udGV4dChjb250ZXh0LCB2YWx1ZSwgZGVwdGgpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBzdGF0aWNTeW1ib2xcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVSZWZlcmVuY2VWYWx1ZShzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFN5bWJvbCA9IHNlbGYuc3ltYm9sUmVzb2x2ZXIucmVzb2x2ZVN5bWJvbChzdGF0aWNTeW1ib2wpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZFN5bWJvbCA/IHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBmdW5jdGlvblN5bWJvbFxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSB0YXJnZXRGdW5jdGlvblxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhcmdzXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBzaW1wbGlmeUNhbGwoZnVuY3Rpb25TeW1ib2wsIHRhcmdldEZ1bmN0aW9uLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEZ1bmN0aW9uICYmIHRhcmdldEZ1bmN0aW9uWydfX3N5bWJvbGljJ10gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGluZy5nZXQoZnVuY3Rpb25TeW1ib2wpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY3Vyc2lvbiBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGluZy5zZXQoZnVuY3Rpb25TeW1ib2wsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWVfMSA9IHRhcmdldEZ1bmN0aW9uWyd2YWx1ZSddO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlXzEgJiYgKGRlcHRoICE9IDAgfHwgdmFsdWVfMS5fX3N5bWJvbGljICE9ICdlcnJvcicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1ldGVycyA9IHRhcmdldEZ1bmN0aW9uWydwYXJhbWV0ZXJzJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVmYXVsdHMgPSB0YXJnZXRGdW5jdGlvbi5kZWZhdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gc2ltcGxpZnlJbkNvbnRleHQoY29udGV4dCwgYXJnLCBkZXB0aCArIDEpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHNob3VsZElnbm9yZShhcmcpID8gdW5kZWZpbmVkIDogYXJnOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdHMgJiYgZGVmYXVsdHMubGVuZ3RoID4gYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoLmFwcGx5KGFyZ3MsIGRlZmF1bHRzLnNsaWNlKGFyZ3MubGVuZ3RoKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzaW1wbGlmeSh2YWx1ZSk7IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnVuY3Rpb25TY29wZSA9IEJpbmRpbmdTY29wZS5idWlsZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uU2NvcGUuZGVmaW5lKHBhcmFtZXRlcnNbaV0sIGFyZ3NbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRTY29wZSA9IHNjb3BlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gZnVuY3Rpb25TY29wZS5kb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdF8xID0gc2ltcGxpZnlJbkNvbnRleHQoZnVuY3Rpb25TeW1ib2wsIHZhbHVlXzEsIGRlcHRoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSA9IG9sZFNjb3BlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XzE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsaW5nLmRlbGV0ZShmdW5jdGlvblN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGRlcHRoIGlzIDAgd2UgYXJlIGV2YWx1YXRpbmcgdGhlIHRvcCBsZXZlbCBleHByZXNzaW9uIHRoYXQgaXMgZGVzY3JpYmluZyBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlY29yYXRvci4gSW4gdGhpcyBjYXNlLCBpdCBpcyBhIGRlY29yYXRvciB3ZSBkb24ndCB1bmRlcnN0YW5kLCBzdWNoIGFzIGEgY3VzdG9tXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbi1hbmd1bGFyIGRlY29yYXRvciwgYW5kIHdlIHNob3VsZCBqdXN0IGlnbm9yZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElHTk9SRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5KHsgX19zeW1ib2xpYzogJ2Vycm9yJywgbWVzc2FnZTogJ0Z1bmN0aW9uIGNhbGwgbm90IHN1cHBvcnRlZCcsIGNvbnRleHQ6IGZ1bmN0aW9uU3ltYm9sIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25cbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNpbXBsaWZ5KGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmltaXRpdmUoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0XzIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9ICgoZXhwcmVzc2lvbikpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgYSBzcHJlYWQgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5fX3N5bWJvbGljID09PSAnc3ByZWFkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNwcmVhZEFycmF5ID0gc2ltcGxpZnkoaXRlbS5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzcHJlYWRBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBzcHJlYWRBcnJheV8xID0gc3ByZWFkQXJyYXk7IF9iIDwgc3ByZWFkQXJyYXlfMS5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcHJlYWRJdGVtID0gc3ByZWFkQXJyYXlfMVtfYl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRfMi5wdXNoKHNwcmVhZEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlXzIgPSBzaW1wbGlmeShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRJZ25vcmUodmFsdWVfMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdF8yLnB1c2godmFsdWVfMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdF8yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIHNpbXBsaWZpY2F0aW9uIGF0IGJ1aWx0aW4gc3ltYm9sc1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gc2VsZi5pbmplY3Rpb25Ub2tlbiB8fCBleHByZXNzaW9uID09PSBzZWxmLm9wYXF1ZVRva2VuIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbnZlcnNpb25NYXAuaGFzKGV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRpY1N5bWJvbCA9IGV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWNsYXJhdGlvblZhbHVlID0gcmVzb2x2ZVJlZmVyZW5jZVZhbHVlKHN0YXRpY1N5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVjbGFyYXRpb25WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeUluQ29udGV4dChzdGF0aWNTeW1ib2wsIGRlY2xhcmF0aW9uVmFsdWUsIGRlcHRoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGljU3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uWydfX3N5bWJvbGljJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRpY1N5bWJvbCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwcmVzc2lvblsnX19zeW1ib2xpYyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYmlub3AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZWZ0ID0gc2ltcGxpZnkoZXhwcmVzc2lvblsnbGVmdCddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZShsZWZ0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByaWdodCA9IHNpbXBsaWZ5KGV4cHJlc3Npb25bJ3JpZ2h0J10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlKHJpZ2h0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChleHByZXNzaW9uWydvcGVyYXRvciddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcmJic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgJiYgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgfHwgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCB8IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgXiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ICYgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPT0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICchPSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgIT0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc9PT0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ID09PSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgIT09IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPCByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ID4gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPD0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPj0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc8PCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPDwgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc+Pic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPj4gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgLSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ICogcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAvIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgJSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpZic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbmRpdGlvbiA9IHNpbXBsaWZ5KGV4cHJlc3Npb25bJ2NvbmRpdGlvbiddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IHNpbXBsaWZ5KGV4cHJlc3Npb25bJ3RoZW5FeHByZXNzaW9uJ10pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBsaWZ5KGV4cHJlc3Npb25bJ2Vsc2VFeHByZXNzaW9uJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wZXJhbmQgPSBzaW1wbGlmeShleHByZXNzaW9uWydvcGVyYW5kJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlKG9wZXJhbmQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXhwcmVzc2lvblsnb3BlcmF0b3InXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLW9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIW9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd+JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gfm9wZXJhbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW5kZXgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleFRhcmdldCA9IHNpbXBsaWZ5KGV4cHJlc3Npb25bJ2V4cHJlc3Npb24nXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gc2ltcGxpZnkoZXhwcmVzc2lvblsnaW5kZXgnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleFRhcmdldCAmJiBpc1ByaW1pdGl2ZShpbmRleCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhUYXJnZXRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZW1iZXIgPSBleHByZXNzaW9uWydtZW1iZXInXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0Q29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdFRhcmdldCA9IHNpbXBsaWZ5KGV4cHJlc3Npb25bJ2V4cHJlc3Npb24nXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RUYXJnZXQgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlcnMgPSBzZWxlY3RUYXJnZXQubWVtYmVycy5jb25jYXQobWVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdENvbnRleHQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZ2V0U3RhdGljU3ltYm9sKHNlbGVjdFRhcmdldC5maWxlUGF0aCwgc2VsZWN0VGFyZ2V0Lm5hbWUsIG1lbWJlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVjbGFyYXRpb25WYWx1ZSA9IHJlc29sdmVSZWZlcmVuY2VWYWx1ZShzZWxlY3RDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5SW5Db250ZXh0KHNlbGVjdENvbnRleHQsIGRlY2xhcmF0aW9uVmFsdWUsIGRlcHRoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0Q29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0VGFyZ2V0ICYmIGlzUHJpbWl0aXZlKG1lbWJlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZnlJbkNvbnRleHQoc2VsZWN0Q29udGV4dCwgc2VsZWN0VGFyZ2V0W21lbWJlcl0sIGRlcHRoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlZmVyZW5jZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IFRoaXMgb25seSBoYXMgdG8gZGVhbCB3aXRoIHZhcmlhYmxlIHJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzIHN5bWJvbCByZWZlcmVuY2VzIGhhdmUgYmVlbiBjb252ZXJ0ZWQgaW50byBTdGF0aWNTeW1ib2xzIGFscmVhZHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIFN0YXRpY1N5bWJvbFJlc29sdmVyIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gZXhwcmVzc2lvblsnbmFtZSddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2NhbFZhbHVlID0gc2NvcGUucmVzb2x2ZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsVmFsdWUgIT0gQmluZGluZ1Njb3BlLm1pc3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduZXcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NhbGwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGZ1bmN0aW9uIGlzIGEgYnVpbHQtaW4gY29udmVyc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNTeW1ib2wgPSBzaW1wbGlmeUluQ29udGV4dChjb250ZXh0LCBleHByZXNzaW9uWydleHByZXNzaW9uJ10sIGRlcHRoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0aWNTeW1ib2wgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0aWNTeW1ib2wgPT09IHNlbGYuaW5qZWN0aW9uVG9rZW4gfHwgc3RhdGljU3ltYm9sID09PSBzZWxmLm9wYXF1ZVRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgc29tZWJvZHkgY2FsbHMgbmV3IEluamVjdGlvblRva2VuLCBkb24ndCBjcmVhdGUgYW4gSW5qZWN0aW9uVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHJhdGhlciByZXR1cm4gdGhlIHN5bWJvbCB0byB3aGljaCB0aGUgSW5qZWN0aW9uVG9rZW4gaXMgYXNzaWduZWQgdG8uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdFeHByZXNzaW9ucyA9IGV4cHJlc3Npb25bJ2FyZ3VtZW50cyddIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udmVydGVyID0gc2VsZi5jb252ZXJzaW9uTWFwLmdldChzdGF0aWNTeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnZlcnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSBhcmdFeHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gc2ltcGxpZnlJbkNvbnRleHQoY29udGV4dCwgYXJnLCBkZXB0aCArIDEpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHNob3VsZElnbm9yZShhcmcpID8gdW5kZWZpbmVkIDogYXJnOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydGVyKGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBmdW5jdGlvbiBpcyBvbmUgd2UgY2FuIHNpbXBsaWZ5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhcmdldEZ1bmN0aW9uID0gcmVzb2x2ZVJlZmVyZW5jZVZhbHVlKHN0YXRpY1N5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5Q2FsbChzdGF0aWNTeW1ib2wsIHRhcmdldEZ1bmN0aW9uLCBhcmdFeHByZXNzaW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElHTk9SRTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lc3NhZ2UgPSBwcm9kdWNlRXJyb3JNZXNzYWdlKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvblsnbGluZSddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICsgXCIgKHBvc2l0aW9uIFwiICsgKGV4cHJlc3Npb25bJ2xpbmUnXSArIDEpICsgXCI6XCIgKyAoZXhwcmVzc2lvblsnY2hhcmFjdGVyJ10gKyAxKSArIFwiIGluIHRoZSBvcmlnaW5hbCAudHMgZmlsZSlcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVwb3J0RXJyb3IocG9zaXRpb25hbEVycm9yKG1lc3NhZ2UsIGNvbnRleHQuZmlsZVBhdGgsIGV4cHJlc3Npb25bJ2xpbmUnXSwgZXhwcmVzc2lvblsnY2hhcmFjdGVyJ10pLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVwb3J0RXJyb3IobmV3IEVycm9yKG1lc3NhZ2UpLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSUdOT1JFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lnbm9yZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcFN0cmluZ01hcChleHByZXNzaW9uLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHsgcmV0dXJuIHNpbXBsaWZ5KHZhbHVlKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBJR05PUkU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlcnMgPSBjb250ZXh0Lm1lbWJlcnMubGVuZ3RoID8gXCIuXCIgKyBjb250ZXh0Lm1lbWJlcnMuam9pbignLicpIDogJyc7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVzc2FnZSA9IGUubWVzc2FnZSArIFwiLCByZXNvbHZpbmcgc3ltYm9sIFwiICsgY29udGV4dC5uYW1lICsgbWVtYmVycyArIFwiIGluIFwiICsgY29udGV4dC5maWxlUGF0aDtcbiAgICAgICAgICAgICAgICBpZiAoZS5maWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBwb3NpdGlvbmFsRXJyb3IobWVzc2FnZSwgZS5maWxlTmFtZSwgZS5saW5lLCBlLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY29yZGVkU2ltcGxpZnlJbkNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCwgdmFsdWUsIGRlcHRoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeUluQ29udGV4dChjb250ZXh0LCB2YWx1ZSwgZGVwdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXBvcnRFcnJvcihlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5lcnJvclJlY29yZGVyID8gcmVjb3JkZWRTaW1wbGlmeUluQ29udGV4dChjb250ZXh0LCB2YWx1ZSwgMCkgOlxuICAgICAgICAgICAgc2ltcGxpZnlJbkNvbnRleHQoY29udGV4dCwgdmFsdWUsIDApO1xuICAgICAgICBpZiAoc2hvdWxkSWdub3JlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5nZXRUeXBlTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFN5bWJvbCA9IHRoaXMuc3ltYm9sUmVzb2x2ZXIucmVzb2x2ZVN5bWJvbCh0eXBlKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkU3ltYm9sICYmIHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhID8gcmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEgOlxuICAgICAgICAgICAgeyBfX3N5bWJvbGljOiAnY2xhc3MnIH07XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljUmVmbGVjdG9yO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBlcnJvclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXhwYW5kZWRNZXNzYWdlKGVycm9yKSB7XG4gICAgc3dpdGNoIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgIGNhc2UgJ1JlZmVyZW5jZSB0byBub24tZXhwb3J0ZWQgY2xhc3MnOlxuICAgICAgICAgICAgaWYgKGVycm9yLmNvbnRleHQgJiYgZXJyb3IuY29udGV4dC5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSZWZlcmVuY2UgdG8gYSBub24tZXhwb3J0ZWQgY2xhc3MgXCIgKyBlcnJvci5jb250ZXh0LmNsYXNzTmFtZSArIFwiLiBDb25zaWRlciBleHBvcnRpbmcgdGhlIGNsYXNzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVmFyaWFibGUgbm90IGluaXRpYWxpemVkJzpcbiAgICAgICAgICAgIHJldHVybiAnT25seSBpbml0aWFsaXplZCB2YXJpYWJsZXMgYW5kIGNvbnN0YW50cyBjYW4gYmUgcmVmZXJlbmNlZCBiZWNhdXNlIHRoZSB2YWx1ZSBvZiB0aGlzIHZhcmlhYmxlIGlzIG5lZWRlZCBieSB0aGUgdGVtcGxhdGUgY29tcGlsZXInO1xuICAgICAgICBjYXNlICdEZXN0cnVjdHVyaW5nIG5vdCBzdXBwb3J0ZWQnOlxuICAgICAgICAgICAgcmV0dXJuICdSZWZlcmVuY2luZyBhbiBleHBvcnRlZCBkZXN0cnVjdHVyZWQgdmFyaWFibGUgb3IgY29uc3RhbnQgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgdGVtcGxhdGUgY29tcGlsZXIuIENvbnNpZGVyIHNpbXBsaWZ5aW5nIHRoaXMgdG8gYXZvaWQgZGVzdHJ1Y3R1cmluZyc7XG4gICAgICAgIGNhc2UgJ0NvdWxkIG5vdCByZXNvbHZlIHR5cGUnOlxuICAgICAgICAgICAgaWYgKGVycm9yLmNvbnRleHQgJiYgZXJyb3IuY29udGV4dC50eXBlTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkNvdWxkIG5vdCByZXNvbHZlIHR5cGUgXCIgKyBlcnJvci5jb250ZXh0LnR5cGVOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0Z1bmN0aW9uIGNhbGwgbm90IHN1cHBvcnRlZCc6XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVmaXggPSBlcnJvci5jb250ZXh0ICYmIGVycm9yLmNvbnRleHQubmFtZSA/IFwiQ2FsbGluZyBmdW5jdGlvbiAnXCIgKyBlcnJvci5jb250ZXh0Lm5hbWUgKyBcIicsIGZcIiA6ICdGJztcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXggK1xuICAgICAgICAgICAgICAgICd1bmN0aW9uIGNhbGxzIGFyZSBub3Qgc3VwcG9ydGVkLiBDb25zaWRlciByZXBsYWNpbmcgdGhlIGZ1bmN0aW9uIG9yIGxhbWJkYSB3aXRoIGEgcmVmZXJlbmNlIHRvIGFuIGV4cG9ydGVkIGZ1bmN0aW9uJztcbiAgICAgICAgY2FzZSAnUmVmZXJlbmNlIHRvIGEgbG9jYWwgc3ltYm9sJzpcbiAgICAgICAgICAgIGlmIChlcnJvci5jb250ZXh0ICYmIGVycm9yLmNvbnRleHQubmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlJlZmVyZW5jZSB0byBhIGxvY2FsIChub24tZXhwb3J0ZWQpIHN5bWJvbCAnXCIgKyBlcnJvci5jb250ZXh0Lm5hbWUgKyBcIicuIENvbnNpZGVyIGV4cG9ydGluZyB0aGUgc3ltYm9sXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZXJyb3JcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHByb2R1Y2VFcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgICByZXR1cm4gXCJFcnJvciBlbmNvdW50ZXJlZCByZXNvbHZpbmcgc3ltYm9sIHZhbHVlcyBzdGF0aWNhbGx5LiBcIiArIGV4cGFuZGVkTWVzc2FnZShlcnJvcik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEBwYXJhbSB7P30gdHJhbnNmb3JtXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtYXBTdHJpbmdNYXAoaW5wdXQsIHRyYW5zZm9ybSkge1xuICAgIGlmICghaW5wdXQpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhpbnB1dCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gdHJhbnNmb3JtKGlucHV0W2tleV0sIGtleSk7XG4gICAgICAgIGlmICghc2hvdWxkSWdub3JlKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKEhJRERFTl9LRVkudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCB7IGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG9cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKG8pIHtcbiAgICByZXR1cm4gbyA9PT0gbnVsbCB8fCAodHlwZW9mIG8gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG8gIT09ICdvYmplY3QnKTtcbn1cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBCaW5kaW5nU2NvcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJpbmRpbmdTY29wZSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nU2NvcGUucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAobmFtZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1Njb3BlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVmaW5lOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50LnNpemUgPiAwID8gbmV3IFBvcHVsYXRlZFNjb3BlKGN1cnJlbnQpIDogQmluZGluZ1Njb3BlLmVtcHR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEJpbmRpbmdTY29wZTtcbn0oKSk7XG5CaW5kaW5nU2NvcGUubWlzc2luZyA9IHt9O1xuQmluZGluZ1Njb3BlLmVtcHR5ID0geyByZXNvbHZlOiBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gQmluZGluZ1Njb3BlLm1pc3Npbmc7IH0gfTtcbnZhciBQb3B1bGF0ZWRTY29wZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBvcHVsYXRlZFNjb3BlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYmluZGluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQb3B1bGF0ZWRTY29wZShiaW5kaW5ncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5iaW5kaW5ncyA9IGJpbmRpbmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUG9wdWxhdGVkU2NvcGUucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5ncy5oYXMobmFtZSkgPyB0aGlzLmJpbmRpbmdzLmdldChuYW1lKSA6IEJpbmRpbmdTY29wZS5taXNzaW5nO1xuICAgIH07XG4gICAgcmV0dXJuIFBvcHVsYXRlZFNjb3BlO1xufShCaW5kaW5nU2NvcGUpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gKiBAcGFyYW0gez99IGZpbGVOYW1lXG4gKiBAcGFyYW0gez99IGxpbmVcbiAqIEBwYXJhbSB7P30gY29sdW1uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwb3NpdGlvbmFsRXJyb3IobWVzc2FnZSwgZmlsZU5hbWUsIGxpbmUsIGNvbHVtbikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAoKHJlc3VsdCkpLmZpbGVOYW1lID0gZmlsZU5hbWU7XG4gICAgKChyZXN1bHQpKS5saW5lID0gbGluZTtcbiAgICAoKHJlc3VsdCkpLmNvbHVtbiA9IGNvbHVtbjtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFJlc29sdmVkU3RhdGljU3ltYm9sID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN5bWJvbFxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZXNvbHZlZFN0YXRpY1N5bWJvbChzeW1ib2wsIG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgfVxuICAgIHJldHVybiBSZXNvbHZlZFN0YXRpY1N5bWJvbDtcbn0oKSk7XG52YXIgU1VQUE9SVEVEX1NDSEVNQV9WRVJTSU9OID0gMztcbi8qKlxuICogVGhpcyBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgbG9hZGluZyBtZXRhZGF0YSBwZXIgc3ltYm9sLFxuICogYW5kIG5vcm1hbGl6aW5nIHJlZmVyZW5jZXMgYmV0d2VlbiBzeW1ib2xzLlxuICpcbiAqIEludGVybmFsbHksIGl0IG9ubHkgdXNlcyBzeW1ib2xzIHdpdGhvdXQgbWVtYmVycyxcbiAqIGFuZCBkZWR1Y2VzIHRoZSB2YWx1ZXMgZm9yIHN5bWJvbHMgd2l0aCBtZW1iZXJzIGJhc2VkXG4gKiBvbiB0aGVzZSBzeW1ib2xzLlxuICovXG52YXIgU3RhdGljU3ltYm9sUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaG9zdFxuICAgICAqIEBwYXJhbSB7P30gc3RhdGljU3ltYm9sQ2FjaGVcbiAgICAgKiBAcGFyYW0gez99IHN1bW1hcnlSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7Pz19IGVycm9yUmVjb3JkZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGF0aWNTeW1ib2xSZXNvbHZlcihob3N0LCBzdGF0aWNTeW1ib2xDYWNoZSwgc3VtbWFyeVJlc29sdmVyLCBlcnJvclJlY29yZGVyKSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuc3RhdGljU3ltYm9sQ2FjaGUgPSBzdGF0aWNTeW1ib2xDYWNoZTtcbiAgICAgICAgdGhpcy5zdW1tYXJ5UmVzb2x2ZXIgPSBzdW1tYXJ5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuZXJyb3JSZWNvcmRlciA9IGVycm9yUmVjb3JkZXI7XG4gICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFN5bWJvbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRGaWxlUGF0aHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuaW1wb3J0QXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc3ltYm9sUmVzb3VyY2VQYXRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zeW1ib2xGcm9tRmlsZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0aWNTeW1ib2xcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlU3ltYm9sID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICBpZiAoc3RhdGljU3ltYm9sLm1lbWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuICgodGhpcy5fcmVzb2x2ZVN5bWJvbE1lbWJlcnMoc3RhdGljU3ltYm9sKSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMucmVzb2x2ZWRTeW1ib2xzLmdldChzdGF0aWNTeW1ib2wpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9ICgodGhpcy5fcmVzb2x2ZVN5bWJvbEZyb21TdW1tYXJ5KHN0YXRpY1N5bWJvbCkpKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBTb21lIHVzZXJzIHVzZSBsaWJyYXJpZXMgdGhhdCB3ZXJlIG5vdCBjb21waWxlZCB3aXRoIG5nYywgaS5lLiB0aGV5IGRvbid0XG4gICAgICAgIC8vIGhhdmUgc3VtbWFyaWVzLCBvbmx5IC5kLnRzIGZpbGVzLiBTbyB3ZSBhbHdheXMgbmVlZCB0byBjaGVjayBib3RoLCB0aGUgc3VtbWFyeVxuICAgICAgICAvLyBhbmQgbWV0YWRhdGEuXG4gICAgICAgIHRoaXMuX2NyZWF0ZVN5bWJvbHNPZihzdGF0aWNTeW1ib2wuZmlsZVBhdGgpO1xuICAgICAgICByZXN1bHQgPSAoKHRoaXMucmVzb2x2ZWRTeW1ib2xzLmdldChzdGF0aWNTeW1ib2wpKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXRJbXBvcnRBcyBwcm9kdWNlcyBhIHN5bWJvbCB0aGF0IGNhbiBiZSB1c2VkIHRvIGltcG9ydCB0aGUgZ2l2ZW4gc3ltYm9sLlxuICAgICAqIFRoZSBpbXBvcnQgbWlnaHQgYmUgZGlmZmVyZW50IHRoYW4gdGhlIHN5bWJvbCBpZiB0aGUgc3ltYm9sIGlzIGV4cG9ydGVkIGZyb21cbiAgICAgKiBhIGxpYnJhcnkgd2l0aCBhIHN1bW1hcnk7IGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byBpbXBvcnQgdGhlIHN5bWJvbCBmcm9tIHRoZVxuICAgICAqIG5nZmFjdG9yeSByZS1leHBvcnQgaW5zdGVhZCBvZiBkaXJlY3RseSB0byBhdm9pZCBpbnRyb2R1Y2luZyBhIGRpcmVjdCBkZXBlbmRlbmN5XG4gICAgICogb24gYW4gb3RoZXJ3aXNlIGluZGlyZWN0IGRlcGVuZGVuY3kuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbCB0aGUgc3ltYm9sIGZvciB3aGljaCB0byBnZW5lcmF0ZSBhIGltcG9ydCBzeW1ib2xcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRJbXBvcnRBcyA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgaWYgKHN0YXRpY1N5bWJvbC5tZW1iZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZVN5bWJvbCA9IHRoaXMuZ2V0U3RhdGljU3ltYm9sKHN0YXRpY1N5bWJvbC5maWxlUGF0aCwgc3RhdGljU3ltYm9sLm5hbWUpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZUltcG9ydEFzID0gdGhpcy5nZXRJbXBvcnRBcyhiYXNlU3ltYm9sKTtcbiAgICAgICAgICAgIHJldHVybiBiYXNlSW1wb3J0QXMgP1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0U3RhdGljU3ltYm9sKGJhc2VJbXBvcnRBcy5maWxlUGF0aCwgYmFzZUltcG9ydEFzLm5hbWUsIHN0YXRpY1N5bWJvbC5tZW1iZXJzKSA6XG4gICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLnN1bW1hcnlSZXNvbHZlci5nZXRJbXBvcnRBcyhzdGF0aWNTeW1ib2wpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gKCh0aGlzLmltcG9ydEFzLmdldChzdGF0aWNTeW1ib2wpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldFJlc291cmNlUGF0aCBwcm9kdWNlcyB0aGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgbG9jYXRpb24gb2YgdGhlIHN5bWJvbCBhbmQgc2hvdWxkXG4gICAgICogYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHJlbGF0aXZlIGxvY2F0aW9uIG9mIHJlc291cmNlIHJlZmVyZW5jZXMgcmVjb3JkZWQgaW5cbiAgICAgKiBzeW1ib2wgbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHs/fSBzdGF0aWNTeW1ib2xcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRSZXNvdXJjZVBhdGggPSBmdW5jdGlvbiAoc3RhdGljU3ltYm9sKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bWJvbFJlc291cmNlUGF0aHMuZ2V0KHN0YXRpY1N5bWJvbCkgfHwgc3RhdGljU3ltYm9sLmZpbGVQYXRoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZ2V0VHlwZUFyaXR5IHJldHVybnMgdGhlIG51bWJlciBvZiBnZW5lcmljIHR5cGUgcGFyYW1ldGVycyB0aGUgZ2l2ZW4gc3ltYm9sXG4gICAgICogaGFzLiBJZiB0aGUgc3ltYm9sIGlzIG5vdCBhIHR5cGUgdGhlIHJlc3VsdCBpcyBudWxsLlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGljU3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuZ2V0VHlwZUFyaXR5ID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICAvLyBJZiB0aGUgZmlsZSBpcyBhIGZhY3RvcnkgZmlsZSwgZG9uJ3QgcmVzb2x2ZSB0aGUgc3ltYm9sIGFzIGRvaW5nIHNvIHdvdWxkXG4gICAgICAgIC8vIGNhdXNlIHRoZSBtZXRhZGF0YSBmb3IgYW4gZmFjdG9yeSBmaWxlIHRvIGJlIGxvYWRlZCB3aGljaCBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAvLyBBbGwgcmVmZXJlbmNlcyB0byBnZW5lcmF0ZWQgY2xhc3NlcyBtdXN0IGluY2x1ZGUgdGhlIGNvcnJlY3QgYXJpdHkgd2hlbmV2ZXJcbiAgICAgICAgLy8gZ2VuZXJhdGluZyBjb2RlLlxuICAgICAgICBpZiAoaXNOZ0ZhY3RvcnlGaWxlKHN0YXRpY1N5bWJvbC5maWxlUGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkU3ltYm9sID0gdGhpcy5yZXNvbHZlU3ltYm9sKHN0YXRpY1N5bWJvbCk7XG4gICAgICAgIHdoaWxlIChyZXNvbHZlZFN5bWJvbCAmJiByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgcmVzb2x2ZWRTeW1ib2wgPSB0aGlzLnJlc29sdmVTeW1ib2wocmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAocmVzb2x2ZWRTeW1ib2wgJiYgcmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEgJiYgcmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEuYXJpdHkpIHx8IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVN5bWJvbFxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0U3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUucmVjb3JkSW1wb3J0QXMgPSBmdW5jdGlvbiAoc291cmNlU3ltYm9sLCB0YXJnZXRTeW1ib2wpIHtcbiAgICAgICAgc291cmNlU3ltYm9sLmFzc2VydE5vTWVtYmVycygpO1xuICAgICAgICB0YXJnZXRTeW1ib2wuYXNzZXJ0Tm9NZW1iZXJzKCk7XG4gICAgICAgIHRoaXMuaW1wb3J0QXMuc2V0KHNvdXJjZVN5bWJvbCwgdGFyZ2V0U3ltYm9sKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGUgYWxsIGluZm9ybWF0aW9uIGRlcml2ZWQgZnJvbSB0aGUgZ2l2ZW4gZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZU5hbWUgdGhlIGZpbGUgdG8gaW52YWxpZGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmludmFsaWRhdGVGaWxlID0gZnVuY3Rpb24gKGZpbGVOYW1lKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZS5kZWxldGUoZmlsZU5hbWUpO1xuICAgICAgICB0aGlzLnJlc29sdmVkRmlsZVBhdGhzLmRlbGV0ZShmaWxlTmFtZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbHMgPSB0aGlzLnN5bWJvbEZyb21GaWxlLmdldChmaWxlTmFtZSk7XG4gICAgICAgIGlmIChzeW1ib2xzKSB7XG4gICAgICAgICAgICB0aGlzLnN5bWJvbEZyb21GaWxlLmRlbGV0ZShmaWxlTmFtZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHN5bWJvbHNfMSA9IHN5bWJvbHM7IF9pIDwgc3ltYm9sc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBzeW1ib2wgPSBzeW1ib2xzXzFbX2ldO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRTeW1ib2xzLmRlbGV0ZShzeW1ib2wpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0QXMuZGVsZXRlKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zeW1ib2xSZXNvdXJjZVBhdGhzLmRlbGV0ZShzeW1ib2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLl9yZXNvbHZlU3ltYm9sTWVtYmVycyA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVtYmVycyA9IHN0YXRpY1N5bWJvbC5tZW1iZXJzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYXNlUmVzb2x2ZWRTeW1ib2wgPSB0aGlzLnJlc29sdmVTeW1ib2wodGhpcy5nZXRTdGF0aWNTeW1ib2woc3RhdGljU3ltYm9sLmZpbGVQYXRoLCBzdGF0aWNTeW1ib2wubmFtZSkpO1xuICAgICAgICBpZiAoIWJhc2VSZXNvbHZlZFN5bWJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZU1ldGFkYXRhID0gYmFzZVJlc29sdmVkU3ltYm9sLm1ldGFkYXRhO1xuICAgICAgICBpZiAoYmFzZU1ldGFkYXRhIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkU3RhdGljU3ltYm9sKHN0YXRpY1N5bWJvbCwgdGhpcy5nZXRTdGF0aWNTeW1ib2woYmFzZU1ldGFkYXRhLmZpbGVQYXRoLCBiYXNlTWV0YWRhdGEubmFtZSwgbWVtYmVycykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJhc2VNZXRhZGF0YSAmJiBiYXNlTWV0YWRhdGEuX19zeW1ib2xpYyA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgaWYgKGJhc2VNZXRhZGF0YS5zdGF0aWNzICYmIG1lbWJlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFN0YXRpY1N5bWJvbChzdGF0aWNTeW1ib2wsIGJhc2VNZXRhZGF0YS5zdGF0aWNzW21lbWJlcnNbMF1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gYmFzZU1ldGFkYXRhO1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IG1lbWJlcnMubGVuZ3RoICYmIHZhbHVlOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlW21lbWJlcnNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFN0YXRpY1N5bWJvbChzdGF0aWNTeW1ib2wsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGljU3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuX3Jlc29sdmVTeW1ib2xGcm9tU3VtbWFyeSA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VtbWFyeSA9IHRoaXMuc3VtbWFyeVJlc29sdmVyLnJlc29sdmVTdW1tYXJ5KHN0YXRpY1N5bWJvbCk7XG4gICAgICAgIHJldHVybiBzdW1tYXJ5ID8gbmV3IFJlc29sdmVkU3RhdGljU3ltYm9sKHN0YXRpY1N5bWJvbCwgc3VtbWFyeS5tZXRhZGF0YSkgOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZ2V0U3RhdGljU3ltYm9sIHByb2R1Y2VzIGEgVHlwZSB3aG9zZSBtZXRhZGF0YSBpcyBrbm93biBidXQgd2hvc2UgaW1wbGVtZW50YXRpb24gaXMgbm90IGxvYWRlZC5cbiAgICAgKiBBbGwgdHlwZXMgcGFzc2VkIHRvIHRoZSBTdGF0aWNSZXNvbHZlciBzaG91bGQgYmUgcHNldWRvLXR5cGVzIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBkZWNsYXJhdGlvbkZpbGUgdGhlIGFic29sdXRlIHBhdGggb2YgdGhlIGZpbGUgd2hlcmUgdGhlIHN5bWJvbCBpcyBkZWNsYXJlZFxuICAgICAqIEBwYXJhbSB7P30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgdHlwZS5cbiAgICAgKiBAcGFyYW0gez89fSBtZW1iZXJzIGEgc3ltYm9sIGZvciBhIHN0YXRpYyBtZW1iZXIgb2YgdGhlIG5hbWVkIHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRTdGF0aWNTeW1ib2wgPSBmdW5jdGlvbiAoZGVjbGFyYXRpb25GaWxlLCBuYW1lLCBtZW1iZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRpY1N5bWJvbENhY2hlLmdldChkZWNsYXJhdGlvbkZpbGUsIG5hbWUsIG1lbWJlcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmaWxlUGF0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmdldFN5bWJvbHNPZiA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICAvLyBOb3RlOiBTb21lIHVzZXJzIHVzZSBsaWJyYXJpZXMgdGhhdCB3ZXJlIG5vdCBjb21waWxlZCB3aXRoIG5nYywgaS5lLiB0aGV5IGRvbid0XG4gICAgICAgIC8vIGhhdmUgc3VtbWFyaWVzLCBvbmx5IC5kLnRzIGZpbGVzLiBTbyB3ZSBhbHdheXMgbmVlZCB0byBjaGVjayBib3RoLCB0aGUgc3VtbWFyeVxuICAgICAgICAvLyBhbmQgbWV0YWRhdGEuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbHMgPSBuZXcgU2V0KHRoaXMuc3VtbWFyeVJlc29sdmVyLmdldFN5bWJvbHNPZihmaWxlUGF0aCkpO1xuICAgICAgICB0aGlzLl9jcmVhdGVTeW1ib2xzT2YoZmlsZVBhdGgpO1xuICAgICAgICB0aGlzLnJlc29sdmVkU3ltYm9scy5mb3JFYWNoKGZ1bmN0aW9uIChyZXNvbHZlZFN5bWJvbCkge1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkU3ltYm9sLnN5bWJvbC5maWxlUGF0aCA9PT0gZmlsZVBhdGgpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xzLmFkZChyZXNvbHZlZFN5bWJvbC5zeW1ib2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oc3ltYm9scyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZpbGVQYXRoXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuX2NyZWF0ZVN5bWJvbHNPZiA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5yZXNvbHZlZEZpbGVQYXRocy5oYXMoZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvbHZlZEZpbGVQYXRocy5hZGQoZmlsZVBhdGgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFN5bWJvbHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWV0YWRhdGEgPSB0aGlzLmdldE1vZHVsZU1ldGFkYXRhKGZpbGVQYXRoKTtcbiAgICAgICAgaWYgKG1ldGFkYXRhWydtZXRhZGF0YSddKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgZGlyZWN0IGRlY2xhcmF0aW9ucyBvZiB0aGUgc3ltYm9sXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b3BMZXZlbFN5bWJvbE5hbWVzXzEgPSBuZXcgU2V0KE9iamVjdC5rZXlzKG1ldGFkYXRhWydtZXRhZGF0YSddKS5tYXAodW5lc2NhcGVJZGVudGlmaWVyKSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW5zXzEgPSBtZXRhZGF0YVsnb3JpZ2lucyddIHx8IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobWV0YWRhdGFbJ21ldGFkYXRhJ10pLmZvckVhY2goZnVuY3Rpb24gKG1ldGFkYXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sTWV0YSA9IG1ldGFkYXRhWydtZXRhZGF0YSddW21ldGFkYXRhS2V5XTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gdW5lc2NhcGVJZGVudGlmaWVyKG1ldGFkYXRhS2V5KTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2wgPSBfdGhpcy5nZXRTdGF0aWNTeW1ib2woZmlsZVBhdGgsIG5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGltcG9ydFN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFbJ2ltcG9ydEFzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5kZXggYnVuZGxlIGluZGV4ZXMgc2hvdWxkIHVzZSB0aGUgaW1wb3J0QXMgbW9kdWxlIG5hbWUgaW5zdGVhZCBvZiBhIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyB0byB0aGUgLmQudHMgZmlsZSBkaXJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0U3ltYm9sID0gX3RoaXMuZ2V0U3RhdGljU3ltYm9sKG1ldGFkYXRhWydpbXBvcnRBcyddLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVjb3JkSW1wb3J0QXMoc3ltYm9sLCBpbXBvcnRTeW1ib2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW4gPSBvcmlnaW5zXzEuaGFzT3duUHJvcGVydHkobWV0YWRhdGFLZXkpICYmIG9yaWdpbnNfMVttZXRhZGF0YUtleV07XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc3ltYm9sIGlzIGZyb20gYSBidW5kbGVkIGluZGV4LCB1c2UgdGhlIGRlY2xhcmF0aW9uIGxvY2F0aW9uIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBzeW1ib2wgc28gcmVsYXRpdmUgcmVmZXJlbmNlcyAoc3VjaCBhcyAnLi9teS5odG1sJykgd2lsbCBiZSBjYWxjdWxhdGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3JpZ2luRmlsZVBhdGggPSBfdGhpcy5yZXNvbHZlTW9kdWxlKG9yaWdpbiwgZmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbkZpbGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXBvcnRFcnJvcihuZXcgRXJyb3IoXCJDb3VsZG4ndCByZXNvbHZlIG9yaWdpbmFsIHN5bWJvbCBmb3IgXCIgKyBvcmlnaW4gKyBcIiBmcm9tIFwiICsgZmlsZVBhdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN5bWJvbFJlc291cmNlUGF0aHMuc2V0KHN5bWJvbCwgb3JpZ2luRmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmVkU3ltYm9scy5wdXNoKF90aGlzLmNyZWF0ZVJlc29sdmVkU3ltYm9sKHN5bWJvbCwgZmlsZVBhdGgsIHRvcExldmVsU3ltYm9sTmFtZXNfMSwgc3ltYm9sTWV0YSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIHRoZSBzeW1ib2xzIGluIG9uZSBvZiB0aGUgcmUtZXhwb3J0IGxvY2F0aW9uXG4gICAgICAgIGlmIChtZXRhZGF0YVsnZXhwb3J0cyddKSB7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChtb2R1bGVFeHBvcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdGhlIHN5bWJvbHMgaW4gdGhlIGxpc3Qgb2YgZXhwbGljaXRseSByZS1leHBvcnRlZCBzeW1ib2xzLlxuICAgICAgICAgICAgICAgIGlmIChtb2R1bGVFeHBvcnQuZXhwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUV4cG9ydC5leHBvcnQuZm9yRWFjaChmdW5jdGlvbiAoZXhwb3J0U3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2xOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBvcnRTeW1ib2wgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sTmFtZSA9IGV4cG9ydFN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbE5hbWUgPSBleHBvcnRTeW1ib2wuYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xOYW1lID0gdW5lc2NhcGVJZGVudGlmaWVyKHN5bWJvbE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltTmFtZSA9IHN5bWJvbE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cG9ydFN5bWJvbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1OYW1lID0gdW5lc2NhcGVJZGVudGlmaWVyKGV4cG9ydFN5bWJvbC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkTW9kdWxlID0gX3RoaXMucmVzb2x2ZU1vZHVsZShtb2R1bGVFeHBvcnQuZnJvbSwgZmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFyZ2V0U3ltYm9sID0gX3RoaXMuZ2V0U3RhdGljU3ltYm9sKHJlc29sdmVkTW9kdWxlLCBzeW1OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VTeW1ib2wgPSBfdGhpcy5nZXRTdGF0aWNTeW1ib2woZmlsZVBhdGgsIHN5bWJvbE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkU3ltYm9scy5wdXNoKF90aGlzLmNyZWF0ZUV4cG9ydChzb3VyY2VTeW1ib2wsIHRhcmdldFN5bWJvbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSB0aGUgc3ltYm9scyB2aWEgZXhwb3J0ICogZGlyZWN0aXZlcy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRNb2R1bGUgPSB0aGlzXzEucmVzb2x2ZU1vZHVsZShtb2R1bGVFeHBvcnQuZnJvbSwgZmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5lc3RlZEV4cG9ydHMgPSB0aGlzXzEuZ2V0U3ltYm9sc09mKHJlc29sdmVkTW9kdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lc3RlZEV4cG9ydHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0U3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlU3ltYm9sID0gX3RoaXMuZ2V0U3RhdGljU3ltYm9sKGZpbGVQYXRoLCB0YXJnZXRTeW1ib2wubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRTeW1ib2xzLnB1c2goX3RoaXMuY3JlYXRlRXhwb3J0KHNvdXJjZVN5bWJvbCwgdGFyZ2V0U3ltYm9sKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBtZXRhZGF0YVsnZXhwb3J0cyddOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBtb2R1bGVFeHBvcnQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgX2xvb3BfMSgvKiogQHR5cGUgez99ICovIG1vZHVsZUV4cG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZWRTeW1ib2xzLmZvckVhY2goZnVuY3Rpb24gKHJlc29sdmVkU3ltYm9sKSB7IHJldHVybiBfdGhpcy5yZXNvbHZlZFN5bWJvbHMuc2V0KHJlc29sdmVkU3ltYm9sLnN5bWJvbCwgcmVzb2x2ZWRTeW1ib2wpOyB9KTtcbiAgICAgICAgdGhpcy5zeW1ib2xGcm9tRmlsZS5zZXQoZmlsZVBhdGgsIHJlc29sdmVkU3ltYm9scy5tYXAoZnVuY3Rpb24gKHJlc29sdmVkU3ltYm9sKSB7IHJldHVybiByZXNvbHZlZFN5bWJvbC5zeW1ib2w7IH0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3ltYm9sXG4gICAgICogQHBhcmFtIHs/fSB0b3BMZXZlbFBhdGhcbiAgICAgKiBAcGFyYW0gez99IHRvcExldmVsU3ltYm9sTmFtZXNcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuY3JlYXRlUmVzb2x2ZWRTeW1ib2wgPSBmdW5jdGlvbiAoc291cmNlU3ltYm9sLCB0b3BMZXZlbFBhdGgsIHRvcExldmVsU3ltYm9sTmFtZXMsIG1ldGFkYXRhKSB7XG4gICAgICAgIC8vIEZvciBjbGFzc2VzIHRoYXQgZG9uJ3QgaGF2ZSBBbmd1bGFyIHN1bW1hcmllcyAvIG1ldGFkYXRhLFxuICAgICAgICAvLyB3ZSBvbmx5IGtlZXAgdGhlaXIgYXJpdHksIGJ1dCBub3RoaW5nIGVsc2VcbiAgICAgICAgLy8gKGUuZy4gdGhlaXIgY29uc3RydWN0b3IgcGFyYW1ldGVycykuXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgdG8gcHJldmVudCBpbnRyb2R1Y2luZyBkZWVwIGltcG9ydHNcbiAgICAgICAgLy8gYXMgd2UgZGlkbid0IGdlbmVyYXRlIC5uZ2ZhY3RvcnkudHMgZmlsZXMgd2l0aCBwcm9wZXIgcmVleHBvcnRzLlxuICAgICAgICBpZiAodGhpcy5zdW1tYXJ5UmVzb2x2ZXIuaXNMaWJyYXJ5RmlsZShzb3VyY2VTeW1ib2wuZmlsZVBhdGgpICYmIG1ldGFkYXRhICYmXG4gICAgICAgICAgICBtZXRhZGF0YVsnX19zeW1ib2xpYyddID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lZE1ldGFfMSA9IHsgX19zeW1ib2xpYzogJ2NsYXNzJywgYXJpdHk6IG1ldGFkYXRhLmFyaXR5IH07XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkU3RhdGljU3ltYm9sKHNvdXJjZVN5bWJvbCwgdHJhbnNmb3JtZWRNZXRhXzEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgUmVmZXJlbmNlVHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKFJlZmVyZW5jZVRyYW5zZm9ybWVyLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gUmVmZXJlbmNlVHJhbnNmb3JtZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IG1hcFxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBmdW5jdGlvblBhcmFtc1xuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUmVmZXJlbmNlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwID0gZnVuY3Rpb24gKG1hcCwgZnVuY3Rpb25QYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2xpYyA9IG1hcFsnX19zeW1ib2xpYyddO1xuICAgICAgICAgICAgICAgIGlmIChzeW1ib2xpYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRMZW4gPSBmdW5jdGlvblBhcmFtcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUGFyYW1zLnB1c2guYXBwbHkoZnVuY3Rpb25QYXJhbXMsIChtYXBbJ3BhcmFtZXRlcnMnXSB8fCBbXSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwLmNhbGwodGhpcywgbWFwLCBmdW5jdGlvblBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUGFyYW1zLmxlbmd0aCA9IG9sZExlbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3ltYm9saWMgPT09ICdyZWZlcmVuY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZV8xID0gbWFwWydtb2R1bGUnXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IG1hcFsnbmFtZSddID8gdW5lc2NhcGVJZGVudGlmaWVyKG1hcFsnbmFtZSddKSA6IG1hcFsnbmFtZSddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbGVQYXRoID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kdWxlXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVQYXRoID0gKChzZWxmLnJlc29sdmVNb2R1bGUobW9kdWxlXzEsIHNvdXJjZVN5bWJvbC5maWxlUGF0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsZVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3N5bWJvbGljOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkNvdWxkIG5vdCByZXNvbHZlIFwiICsgbW9kdWxlXzEgKyBcIiByZWxhdGl2ZSB0byBcIiArIHNvdXJjZVN5bWJvbC5maWxlUGF0aCArIFwiLlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldFN0YXRpY1N5bWJvbChmaWxlUGF0aCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZnVuY3Rpb25QYXJhbXMuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWZlcmVuY2UgdG8gYSBmdW5jdGlvbiBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IF9fc3ltYm9saWM6ICdyZWZlcmVuY2UnLCBuYW1lOiBuYW1lIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9wTGV2ZWxTeW1ib2xOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRTdGF0aWNTeW1ib2wodG9wTGV2ZWxQYXRoLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFtYmllbnQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwLmNhbGwodGhpcywgbWFwLCBmdW5jdGlvblBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBSZWZlcmVuY2VUcmFuc2Zvcm1lcjtcbiAgICAgICAgfShWYWx1ZVRyYW5zZm9ybWVyKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVkTWV0YSA9IHZpc2l0VmFsdWUobWV0YWRhdGEsIG5ldyBSZWZlcmVuY2VUcmFuc2Zvcm1lcigpLCBbXSk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZE1ldGEgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUV4cG9ydChzb3VyY2VTeW1ib2wsIHRyYW5zZm9ybWVkTWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFN0YXRpY1N5bWJvbChzb3VyY2VTeW1ib2wsIHRyYW5zZm9ybWVkTWV0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVN5bWJvbFxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0U3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuY3JlYXRlRXhwb3J0ID0gZnVuY3Rpb24gKHNvdXJjZVN5bWJvbCwgdGFyZ2V0U3ltYm9sKSB7XG4gICAgICAgIHNvdXJjZVN5bWJvbC5hc3NlcnROb01lbWJlcnMoKTtcbiAgICAgICAgdGFyZ2V0U3ltYm9sLmFzc2VydE5vTWVtYmVycygpO1xuICAgICAgICBpZiAodGhpcy5zdW1tYXJ5UmVzb2x2ZXIuaXNMaWJyYXJ5RmlsZShzb3VyY2VTeW1ib2wuZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhc2UgaXMgZm9yIGFuIG5nIGxpYnJhcnkgaW1wb3J0aW5nIHN5bWJvbHMgZnJvbSBhIHBsYWluIHRzIGxpYnJhcnlcbiAgICAgICAgICAgIC8vIHRyYW5zaXRpdmVseS5cbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIHJlbHkgb24gdGhlIGZhY3QgdGhhdCB3ZSBkaXNjb3ZlciBzeW1ib2xzIGluIHRoZSBkaXJlY3Rpb25cbiAgICAgICAgICAgIC8vIGZyb20gc291cmNlIGZpbGVzIHRvIGxpYnJhcnkgZmlsZXNcbiAgICAgICAgICAgIHRoaXMuaW1wb3J0QXMuc2V0KHRhcmdldFN5bWJvbCwgdGhpcy5nZXRJbXBvcnRBcyhzb3VyY2VTeW1ib2wpIHx8IHNvdXJjZVN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFN0YXRpY1N5bWJvbChzb3VyY2VTeW1ib2wsIHRhcmdldFN5bWJvbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEBwYXJhbSB7Pz19IHBhdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgY29udGV4dCwgcGF0aCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvclJlY29yZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVjb3JkZXIoZXJyb3IsIChjb250ZXh0ICYmIGNvbnRleHQuZmlsZVBhdGgpIHx8IHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlIGFuIGFic29sdXRlIHBhdGggdG8gYSBtb2R1bGUgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRNb2R1bGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlTWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhQ2FjaGUuZ2V0KG1vZHVsZSk7XG4gICAgICAgIGlmICghbW9kdWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZU1ldGFkYXRhcyA9IHRoaXMuaG9zdC5nZXRNZXRhZGF0YUZvcihtb2R1bGUpO1xuICAgICAgICAgICAgaWYgKG1vZHVsZU1ldGFkYXRhcykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1heFZlcnNpb25fMSA9IC0xO1xuICAgICAgICAgICAgICAgIG1vZHVsZU1ldGFkYXRhcy5mb3JFYWNoKGZ1bmN0aW9uIChtZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWRbJ3ZlcnNpb24nXSA+IG1heFZlcnNpb25fMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4VmVyc2lvbl8xID0gbWRbJ3ZlcnNpb24nXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZU1ldGFkYXRhID0gbWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbW9kdWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVNZXRhZGF0YSA9XG4gICAgICAgICAgICAgICAgICAgIHsgX19zeW1ib2xpYzogJ21vZHVsZScsIHZlcnNpb246IFNVUFBPUlRFRF9TQ0hFTUFfVkVSU0lPTiwgbW9kdWxlOiBtb2R1bGUsIG1ldGFkYXRhOiB7fSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZHVsZU1ldGFkYXRhWyd2ZXJzaW9uJ10gIT0gU1VQUE9SVEVEX1NDSEVNQV9WRVJTSU9OKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JNZXNzYWdlID0gbW9kdWxlTWV0YWRhdGFbJ3ZlcnNpb24nXSA9PSAyID9cbiAgICAgICAgICAgICAgICAgICAgXCJVbnN1cHBvcnRlZCBtZXRhZGF0YSB2ZXJzaW9uIFwiICsgbW9kdWxlTWV0YWRhdGFbJ3ZlcnNpb24nXSArIFwiIGZvciBtb2R1bGUgXCIgKyBtb2R1bGUgKyBcIi4gVGhpcyBtb2R1bGUgc2hvdWxkIGJlIGNvbXBpbGVkIHdpdGggYSBuZXdlciB2ZXJzaW9uIG9mIG5nY1wiIDpcbiAgICAgICAgICAgICAgICAgICAgXCJNZXRhZGF0YSB2ZXJzaW9uIG1pc21hdGNoIGZvciBtb2R1bGUgXCIgKyBtb2R1bGUgKyBcIiwgZm91bmQgdmVyc2lvbiBcIiArIG1vZHVsZU1ldGFkYXRhWyd2ZXJzaW9uJ10gKyBcIiwgZXhwZWN0ZWQgXCIgKyBTVVBQT1JURURfU0NIRU1BX1ZFUlNJT047XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGUuc2V0KG1vZHVsZSwgbW9kdWxlTWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVNZXRhZGF0YTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlXG4gICAgICogQHBhcmFtIHs/fSBzeW1ib2xOYW1lXG4gICAgICogQHBhcmFtIHs/PX0gY29udGFpbmluZ0ZpbGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRTeW1ib2xCeU1vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGUsIHN5bWJvbE5hbWUsIGNvbnRhaW5pbmdGaWxlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbGVQYXRoID0gdGhpcy5yZXNvbHZlTW9kdWxlKG1vZHVsZSwgY29udGFpbmluZ0ZpbGUpO1xuICAgICAgICBpZiAoIWZpbGVQYXRoKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIG1vZHVsZSBcIiArIG1vZHVsZSArIChjb250YWluaW5nRmlsZSA/IFwiIHJlbGF0aXZlIHRvICQge1xcbiAgICAgICAgICAgIGNvbnRhaW5pbmdGaWxlXFxuICAgICAgICAgIH0gXCIgOiAnJykpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRpY1N5bWJvbChcIkVSUk9SOlwiICsgbW9kdWxlLCBzeW1ib2xOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0aWNTeW1ib2woZmlsZVBhdGgsIHN5bWJvbE5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVcbiAgICAgKiBAcGFyYW0gez89fSBjb250YWluaW5nRmlsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmVNb2R1bGUgPSBmdW5jdGlvbiAobW9kdWxlLCBjb250YWluaW5nRmlsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaG9zdC5tb2R1bGVOYW1lVG9GaWxlTmFtZShtb2R1bGUsIGNvbnRhaW5pbmdGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIG1vZHVsZSAnXCIgKyBtb2R1bGUgKyBcIicgcmVsYXRpdmUgdG8gZmlsZSBcIiArIGNvbnRhaW5pbmdGaWxlKTtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoZSwgdW5kZWZpbmVkLCBjb250YWluaW5nRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljU3ltYm9sUmVzb2x2ZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGlkZW50aWZpZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlSWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIGlkZW50aWZpZXIuc3RhcnRzV2l0aCgnX19fJykgPyBpZGVudGlmaWVyLnN1YnN0cigxKSA6IGlkZW50aWZpZXI7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQW90U3VtbWFyeVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGhvc3RcbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gQW90U3VtbWFyeVJlc29sdmVyKGhvc3QsIHN0YXRpY1N5bWJvbENhY2hlKSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuc3RhdGljU3ltYm9sQ2FjaGUgPSBzdGF0aWNTeW1ib2xDYWNoZTtcbiAgICAgICAgdGhpcy5zdW1tYXJ5Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubG9hZGVkRmlsZVBhdGhzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmltcG9ydEFzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZpbGVQYXRoXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmlzTGlicmFyeUZpbGUgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgLy8gTm90ZTogV2UgbmVlZCB0byBzdHJpcCB0aGUgLm5nZmFjdG9yeS4gZmlsZSBwYXRoLFxuICAgICAgICAvLyBzbyB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIGZvciBnZW5lcmF0ZWQgZmlsZXNcbiAgICAgICAgLy8gKGZvciB3aGljaCBob3N0LmlzU291cmNlRmlsZSB3aWxsIGFsd2F5cyByZXR1cm4gZmFsc2UpLlxuICAgICAgICByZXR1cm4gIXRoaXMuaG9zdC5pc1NvdXJjZUZpbGUoc3RyaXBOZ0ZhY3RvcnkoZmlsZVBhdGgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZVBhdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuZ2V0TGlicmFyeUZpbGVOYW1lID0gZnVuY3Rpb24gKGZpbGVQYXRoKSB7IHJldHVybiB0aGlzLmhvc3QuZ2V0T3V0cHV0RmlsZU5hbWUoZmlsZVBhdGgpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGljU3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmVTdW1tYXJ5ID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICBzdGF0aWNTeW1ib2wuYXNzZXJ0Tm9NZW1iZXJzKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1bW1hcnkgPSB0aGlzLnN1bW1hcnlDYWNoZS5nZXQoc3RhdGljU3ltYm9sKTtcbiAgICAgICAgaWYgKCFzdW1tYXJ5KSB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkU3VtbWFyeUZpbGUoc3RhdGljU3ltYm9sLmZpbGVQYXRoKTtcbiAgICAgICAgICAgIHN1bW1hcnkgPSAoKHRoaXMuc3VtbWFyeUNhY2hlLmdldChzdGF0aWNTeW1ib2wpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bW1hcnk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZpbGVQYXRoXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmdldFN5bWJvbHNPZiA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICB0aGlzLl9sb2FkU3VtbWFyeUZpbGUoZmlsZVBhdGgpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnN1bW1hcnlDYWNoZS5rZXlzKCkpLmZpbHRlcihmdW5jdGlvbiAoc3ltYm9sKSB7IHJldHVybiBzeW1ib2wuZmlsZVBhdGggPT09IGZpbGVQYXRoOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGljU3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmdldEltcG9ydEFzID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICBzdGF0aWNTeW1ib2wuYXNzZXJ0Tm9NZW1iZXJzKCk7XG4gICAgICAgIHJldHVybiAoKHRoaXMuaW1wb3J0QXMuZ2V0KHN0YXRpY1N5bWJvbCkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZVBhdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuX2xvYWRTdW1tYXJ5RmlsZSA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5sb2FkZWRGaWxlUGF0aHMuaGFzKGZpbGVQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZGVkRmlsZVBhdGhzLmFkZChmaWxlUGF0aCk7XG4gICAgICAgIGlmICh0aGlzLmlzTGlicmFyeUZpbGUoZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdW1tYXJ5RmlsZVBhdGggPSBzdW1tYXJ5RmlsZU5hbWUoZmlsZVBhdGgpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ganNvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAganNvbiA9IHRoaXMuaG9zdC5sb2FkU3VtbWFyeShzdW1tYXJ5RmlsZVBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgbG9hZGluZyBzdW1tYXJ5IGZpbGUgXCIgKyBzdW1tYXJ5RmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGRlc2VyaWFsaXplU3VtbWFyaWVzKHRoaXMuc3RhdGljU3ltYm9sQ2FjaGUsIGpzb24pLCBzdW1tYXJpZXMgPSBfYS5zdW1tYXJpZXMsIGltcG9ydEFzID0gX2EuaW1wb3J0QXM7XG4gICAgICAgICAgICAgICAgc3VtbWFyaWVzLmZvckVhY2goZnVuY3Rpb24gKHN1bW1hcnkpIHsgcmV0dXJuIF90aGlzLnN1bW1hcnlDYWNoZS5zZXQoc3VtbWFyeS5zeW1ib2wsIHN1bW1hcnkpOyB9KTtcbiAgICAgICAgICAgICAgICBpbXBvcnRBcy5mb3JFYWNoKGZ1bmN0aW9uIChpbXBvcnRBcykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbXBvcnRBcy5zZXQoaW1wb3J0QXMuc3ltYm9sLCBfdGhpcy5zdGF0aWNTeW1ib2xDYWNoZS5nZXQobmdmYWN0b3J5RmlsZVBhdGgoZmlsZVBhdGgpLCBpbXBvcnRBcy5pbXBvcnRBcykpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQW90U3VtbWFyeVJlc29sdmVyO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBBb3RDb21waWxlciBiYXNlZCBvbiBvcHRpb25zIGFuZCBhIGhvc3QuXG4gKiBAcGFyYW0gez99IGNvbXBpbGVySG9zdFxuICogQHBhcmFtIHs/fSBvcHRpb25zXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVBb3RDb21waWxlcihjb21waWxlckhvc3QsIG9wdGlvbnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2xhdGlvbnMgPSBvcHRpb25zLnRyYW5zbGF0aW9ucyB8fCAnJztcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cmxSZXNvbHZlciA9IGNyZWF0ZU9mZmxpbmVDb21waWxlVXJsUmVzb2x2ZXIoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2xDYWNoZSA9IG5ldyBTdGF0aWNTeW1ib2xDYWNoZSgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1bW1hcnlSZXNvbHZlciA9IG5ldyBBb3RTdW1tYXJ5UmVzb2x2ZXIoY29tcGlsZXJIb3N0LCBzeW1ib2xDYWNoZSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sUmVzb2x2ZXIgPSBuZXcgU3RhdGljU3ltYm9sUmVzb2x2ZXIoY29tcGlsZXJIb3N0LCBzeW1ib2xDYWNoZSwgc3VtbWFyeVJlc29sdmVyKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0aWNSZWZsZWN0b3IgPSBuZXcgU3RhdGljUmVmbGVjdG9yKHN1bW1hcnlSZXNvbHZlciwgc3ltYm9sUmVzb2x2ZXIpO1xuICAgIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmluc3RhbGwoc3RhdGljUmVmbGVjdG9yKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb25zb2xlID0gbmV3IMm1Q29uc29sZSgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGh0bWxQYXJzZXIgPSBuZXcgSTE4Tkh0bWxQYXJzZXIobmV3IEh0bWxQYXJzZXIoKSwgdHJhbnNsYXRpb25zLCBvcHRpb25zLmkxOG5Gb3JtYXQsIE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5Lldhcm5pbmcsIGNvbnNvbGUpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbmZpZyA9IG5ldyBDb21waWxlckNvbmZpZyh7XG4gICAgICAgIGRlZmF1bHRFbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCxcbiAgICAgICAgdXNlSml0OiBmYWxzZSxcbiAgICAgICAgZW5hYmxlTGVnYWN5VGVtcGxhdGU6IG9wdGlvbnMuZW5hYmxlTGVnYWN5VGVtcGxhdGUgIT09IGZhbHNlLFxuICAgIH0pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vcm1hbGl6ZXIgPSBuZXcgRGlyZWN0aXZlTm9ybWFsaXplcih7IGdldDogZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gY29tcGlsZXJIb3N0LmxvYWRSZXNvdXJjZSh1cmwpOyB9IH0sIHVybFJlc29sdmVyLCBodG1sUGFyc2VyLCBjb25maWcpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb25QYXJzZXIgPSBuZXcgUGFyc2VyKG5ldyBMZXhlcigpKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50U2NoZW1hUmVnaXN0cnkgPSBuZXcgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG1wbFBhcnNlciA9IG5ldyBUZW1wbGF0ZVBhcnNlcihjb25maWcsIGV4cHJlc3Npb25QYXJzZXIsIGVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgaHRtbFBhcnNlciwgY29uc29sZSwgW10pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVyID0gbmV3IENvbXBpbGVNZXRhZGF0YVJlc29sdmVyKGNvbmZpZywgbmV3IE5nTW9kdWxlUmVzb2x2ZXIoc3RhdGljUmVmbGVjdG9yKSwgbmV3IERpcmVjdGl2ZVJlc29sdmVyKHN0YXRpY1JlZmxlY3RvciksIG5ldyBQaXBlUmVzb2x2ZXIoc3RhdGljUmVmbGVjdG9yKSwgc3VtbWFyeVJlc29sdmVyLCBlbGVtZW50U2NoZW1hUmVnaXN0cnksIG5vcm1hbGl6ZXIsIGNvbnNvbGUsIHN5bWJvbENhY2hlLCBzdGF0aWNSZWZsZWN0b3IpO1xuICAgIC8vIFRPRE8odmljYik6IGRvIG5vdCBwYXNzIG9wdGlvbnMuaTE4bkZvcm1hdCBoZXJlXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW1wb3J0UmVzb2x2ZXIgPSB7XG4gICAgICAgIGdldEltcG9ydEFzOiBmdW5jdGlvbiAoc3ltYm9sKSB7IHJldHVybiAoKHN5bWJvbFJlc29sdmVyLmdldEltcG9ydEFzKHN5bWJvbCkpKTsgfSxcbiAgICAgICAgZmlsZU5hbWVUb01vZHVsZU5hbWU6IGZ1bmN0aW9uIChmaWxlTmFtZSwgY29udGFpbmluZ0ZpbGVQYXRoKSB7IHJldHVybiBjb21waWxlckhvc3QuZmlsZU5hbWVUb01vZHVsZU5hbWUoZmlsZU5hbWUsIGNvbnRhaW5pbmdGaWxlUGF0aCk7IH0sXG4gICAgICAgIGdldFR5cGVBcml0eTogZnVuY3Rpb24gKHN5bWJvbCkgeyByZXR1cm4gKChzeW1ib2xSZXNvbHZlci5nZXRUeXBlQXJpdHkoc3ltYm9sKSkpOyB9XG4gICAgfTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3Q29tcGlsZXIgPSBuZXcgVmlld0NvbXBpbGVyKGNvbmZpZywgZWxlbWVudFNjaGVtYVJlZ2lzdHJ5KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21waWxlciA9IG5ldyBBb3RDb21waWxlcihjb25maWcsIGNvbXBpbGVySG9zdCwgcmVzb2x2ZXIsIHRtcGxQYXJzZXIsIG5ldyBTdHlsZUNvbXBpbGVyKHVybFJlc29sdmVyKSwgdmlld0NvbXBpbGVyLCBuZXcgTmdNb2R1bGVDb21waWxlcigpLCBuZXcgVHlwZVNjcmlwdEVtaXR0ZXIoaW1wb3J0UmVzb2x2ZXIpLCBzdW1tYXJ5UmVzb2x2ZXIsIG9wdGlvbnMubG9jYWxlIHx8IG51bGwsIG9wdGlvbnMuaTE4bkZvcm1hdCB8fCBudWxsLCBvcHRpb25zLmdlbkZpbGVQcmVhbWJsZSB8fCBudWxsLCBzeW1ib2xSZXNvbHZlcik7XG4gICAgcmV0dXJuIHsgY29tcGlsZXI6IGNvbXBpbGVyLCByZWZsZWN0b3I6IHN0YXRpY1JlZmxlY3RvciB9O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAqIEBwYXJhbSB7P30gcmVzdWx0VmFyc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaW50ZXJwcmV0U3RhdGVtZW50cyhzdGF0ZW1lbnRzLCByZXN1bHRWYXJzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RtdHNXaXRoUmV0dXJuID0gc3RhdGVtZW50cy5jb25jYXQoW25ldyBSZXR1cm5TdGF0ZW1lbnQobGl0ZXJhbEFycihyZXN1bHRWYXJzLm1hcChmdW5jdGlvbiAocmVzdWx0VmFyKSB7IHJldHVybiB2YXJpYWJsZShyZXN1bHRWYXIpOyB9KSkpXSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R4ID0gbmV3IF9FeGVjdXRpb25Db250ZXh0KG51bGwsIG51bGwsIG51bGwsIG5ldyBNYXAoKSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBTdGF0ZW1lbnRJbnRlcnByZXRlcigpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHZpc2l0b3IudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXRzV2l0aFJldHVybiwgY3R4KTtcbiAgICByZXR1cm4gcmVzdWx0ICE9IG51bGwgPyByZXN1bHQudmFsdWUgOiBudWxsO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZhck5hbWVzXG4gKiBAcGFyYW0gez99IHZhclZhbHVlc1xuICogQHBhcmFtIHs/fSBzdGF0ZW1lbnRzXG4gKiBAcGFyYW0gez99IGN0eFxuICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfZXhlY3V0ZUZ1bmN0aW9uU3RhdGVtZW50cyh2YXJOYW1lcywgdmFyVmFsdWVzLCBzdGF0ZW1lbnRzLCBjdHgsIHZpc2l0b3IpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZEN0eCA9IGN0eC5jcmVhdGVDaGlsZFdpaHRMb2NhbFZhcnMoKTtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgdmFyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hpbGRDdHgudmFycy5zZXQodmFyTmFtZXNbaV0sIHZhclZhbHVlc1tpXSk7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHZpc2l0b3IudmlzaXRBbGxTdGF0ZW1lbnRzKHN0YXRlbWVudHMsIGNoaWxkQ3R4KTtcbiAgICByZXR1cm4gcmVzdWx0ID8gcmVzdWx0LnZhbHVlIDogbnVsbDtcbn1cbnZhciBfRXhlY3V0aW9uQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcGFyYW0gez99IGluc3RhbmNlXG4gICAgICogQHBhcmFtIHs/fSBjbGFzc05hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfRXhlY3V0aW9uQ29udGV4dChwYXJlbnQsIGluc3RhbmNlLCBjbGFzc05hbWUsIHZhcnMpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIHRoaXMudmFycyA9IHZhcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0V4ZWN1dGlvbkNvbnRleHQucHJvdG90eXBlLmNyZWF0ZUNoaWxkV2lodExvY2FsVmFycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfRXhlY3V0aW9uQ29udGV4dCh0aGlzLCB0aGlzLmluc3RhbmNlLCB0aGlzLmNsYXNzTmFtZSwgbmV3IE1hcCgpKTtcbiAgICB9O1xuICAgIHJldHVybiBfRXhlY3V0aW9uQ29udGV4dDtcbn0oKSk7XG52YXIgUmV0dXJuVmFsdWUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZXR1cm5WYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBSZXR1cm5WYWx1ZTtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gX2NsYXNzU3RtdFxuICogQHBhcmFtIHs/fSBfY3R4XG4gKiBAcGFyYW0gez99IF92aXNpdG9yXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVEeW5hbWljQ2xhc3MoX2NsYXNzU3RtdCwgX2N0eCwgX3Zpc2l0b3IpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wZXJ0eURlc2NyaXB0b3JzID0ge307XG4gICAgX2NsYXNzU3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikge1xuICAgICAgICAvLyBOb3RlOiB1c2UgYGZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGFycm93IGZ1bmN0aW9uIHRvIGNhcHR1cmUgYHRoaXNgXG4gICAgICAgIHByb3BlcnR5RGVzY3JpcHRvcnNbZ2V0dGVyLm5hbWVdID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluc3RhbmNlQ3R4ID0gbmV3IF9FeGVjdXRpb25Db250ZXh0KF9jdHgsIHRoaXMsIF9jbGFzc1N0bXQubmFtZSwgX2N0eC52YXJzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHMoW10sIFtdLCBnZXR0ZXIuYm9keSwgaW5zdGFuY2VDdHgsIF92aXNpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBfY2xhc3NTdG10Lm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtTmFtZXMgPSBtZXRob2QucGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLm5hbWU7IH0pO1xuICAgICAgICAvLyBOb3RlOiB1c2UgYGZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGFycm93IGZ1bmN0aW9uIHRvIGNhcHR1cmUgYHRoaXNgXG4gICAgICAgIHByb3BlcnR5RGVzY3JpcHRvcnNbKChtZXRob2QubmFtZSkpXSA9IHtcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnN0YW5jZUN0eCA9IG5ldyBfRXhlY3V0aW9uQ29udGV4dChfY3R4LCB0aGlzLCBfY2xhc3NTdG10Lm5hbWUsIF9jdHgudmFycyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKHBhcmFtTmFtZXMsIGFyZ3MsIG1ldGhvZC5ib2R5LCBpbnN0YW5jZUN0eCwgX3Zpc2l0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0b3JQYXJhbU5hbWVzID0gX2NsYXNzU3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0ubmFtZTsgfSk7XG4gICAgLy8gTm90ZTogdXNlIGBmdW5jdGlvbmAgaW5zdGVhZCBvZiBhcnJvdyBmdW5jdGlvbiB0byBjYXB0dXJlIGB0aGlzYFxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5zdGFuY2VDdHggPSBuZXcgX0V4ZWN1dGlvbkNvbnRleHQoX2N0eCwgdGhpcywgX2NsYXNzU3RtdC5uYW1lLCBfY3R4LnZhcnMpO1xuICAgICAgICBfY2xhc3NTdG10LmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkgeyBfdGhpc1tmaWVsZC5uYW1lXSA9IHVuZGVmaW5lZDsgfSk7XG4gICAgICAgIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKGN0b3JQYXJhbU5hbWVzLCBhcmdzLCBfY2xhc3NTdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGluc3RhbmNlQ3R4LCBfdmlzaXRvcik7XG4gICAgfTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdXBlckNsYXNzID0gX2NsYXNzU3RtdC5wYXJlbnQgPyBfY2xhc3NTdG10LnBhcmVudC52aXNpdEV4cHJlc3Npb24oX3Zpc2l0b3IsIF9jdHgpIDogT2JqZWN0O1xuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSwgcHJvcGVydHlEZXNjcmlwdG9ycyk7XG4gICAgcmV0dXJuIGN0b3I7XG59XG52YXIgU3RhdGVtZW50SW50ZXJwcmV0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlbWVudEludGVycHJldGVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLmRlYnVnQXN0ID0gZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZGVidWdPdXRwdXRBc3RBc1R5cGVTY3JpcHQoYXN0KTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC52YXJzLnNldChzdG10Lm5hbWUsIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRXcml0ZVZhckV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VyckN0eCA9IGN0eDtcbiAgICAgICAgd2hpbGUgKGN1cnJDdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN1cnJDdHgudmFycy5oYXMoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGN1cnJDdHgudmFycy5zZXQoZXhwci5uYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyckN0eCA9ICgoY3VyckN0eC5wYXJlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgZGVjbGFyZWQgdmFyaWFibGUgXCIgKyBleHByLm5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFyTmFtZSA9ICgoYXN0Lm5hbWUpKTtcbiAgICAgICAgaWYgKGFzdC5idWlsdGluICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXN0LmJ1aWx0aW4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuU3VwZXI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHguaW5zdGFuY2UuX19wcm90b19fO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5UaGlzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lmluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaEVycm9yOlxuICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gQ0FUQ0hfRVJST1JfVkFSJDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaFN0YWNrOlxuICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gQ0FUQ0hfU1RBQ0tfVkFSJDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiB2YXJpYWJsZSBcIiArIGFzdC5idWlsdGluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyQ3R4ID0gY3R4O1xuICAgICAgICB3aGlsZSAoY3VyckN0eCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3VyckN0eC52YXJzLmhhcyh2YXJOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyQ3R4LnZhcnMuZ2V0KHZhck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyckN0eCA9ICgoY3VyckN0eC5wYXJlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgZGVjbGFyZWQgdmFyaWFibGUgXCIgKyB2YXJOYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRXcml0ZUtleUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY2VpdmVyID0gZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBleHByLmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJlY2VpdmVyW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0V3JpdGVQcm9wRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjZWl2ZXIgPSBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJlY2VpdmVyW2V4cHIubmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY2VpdmVyID0gZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdDtcbiAgICAgICAgaWYgKGV4cHIuYnVpbHRpbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGV4cHIuYnVpbHRpbikge1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheTpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIuY29uY2F0LmFwcGx5KHJlY2VpdmVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGU6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyLnN1YnNjcmliZSh7IG5leHQ6IGFyZ3NbMF0gfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5CaW5kOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlci5iaW5kLmFwcGx5KHJlY2VpdmVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBidWlsdGluIG1ldGhvZCBcIiArIGV4cHIuYnVpbHRpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlclsoKGV4cHIubmFtZSkpXS5hcHBseShyZWNlaXZlciwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoc3RtdC5hcmdzLCBjdHgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbkV4cHIgPSBzdG10LmZuO1xuICAgICAgICBpZiAoZm5FeHByIGluc3RhbmNlb2YgUmVhZFZhckV4cHIgJiYgZm5FeHByLmJ1aWx0aW4gPT09IEJ1aWx0aW5WYXIuU3VwZXIpIHtcbiAgICAgICAgICAgIGN0eC5pbnN0YW5jZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IuYXBwbHkoY3R4Lmluc3RhbmNlLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm4kJDEgPSBzdG10LmZuLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIGZuJCQxLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0UmV0dXJuU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXR1cm5WYWx1ZShzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGF6eiA9IGNyZWF0ZUR5bmFtaWNDbGFzcyhzdG10LCBjdHgsIHRoaXMpO1xuICAgICAgICBjdHgudmFycy5zZXQoc3RtdC5uYW1lLCBjbGF6eik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICByZXR1cm4gc3RtdC5leHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdElmU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uZGl0aW9uID0gc3RtdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0bXQuZmFsc2VDYXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmZhbHNlQ2FzZSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5ib2R5U3RtdHMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoaWxkQ3R4ID0gY3R4LmNyZWF0ZUNoaWxkV2lodExvY2FsVmFycygpO1xuICAgICAgICAgICAgY2hpbGRDdHgudmFycy5zZXQoQ0FUQ0hfRVJST1JfVkFSJDIsIGUpO1xuICAgICAgICAgICAgY2hpbGRDdHgudmFycy5zZXQoQ0FUQ0hfU1RBQ0tfVkFSJDIsIGUuc3RhY2spO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY2F0Y2hTdG10cywgY2hpbGRDdHgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0VGhyb3dTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB0aHJvdyBzdG10LmVycm9yLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0Q29tbWVudFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJbnN0YW50aWF0ZUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhenogPSBhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICByZXR1cm4gbmV3IChjbGF6ei5iaW5kLmFwcGx5KGNsYXp6LCBbdm9pZCAwXS5jb25jYXQoYXJncykpKSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgcmV0dXJuIGFzdC52YWx1ZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIGFzdC52YWx1ZS5yZWZlcmVuY2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgaWYgKGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCkpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXN0LmZhbHNlQ2FzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN0LmZhbHNlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdE5vdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuICFhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbU5hbWVzID0gYXN0LnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5uYW1lOyB9KTtcbiAgICAgICAgcmV0dXJuIF9kZWNsYXJlRm4ocGFyYW1OYW1lcywgYXN0LnN0YXRlbWVudHMsIGN0eCwgdGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1OYW1lcyA9IHN0bXQucGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLm5hbWU7IH0pO1xuICAgICAgICBjdHgudmFycy5zZXQoc3RtdC5uYW1lLCBfZGVjbGFyZUZuKHBhcmFtTmFtZXMsIHN0bXQuc3RhdGVtZW50cywgY3R4LCB0aGlzKSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxocyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFzdC5saHMudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByaHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBhc3QucmhzLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY3R4KTsgfTtcbiAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRXF1YWxzOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA9PSByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA9PT0gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk5vdEVxdWFsczpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgIT0gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgIT09IHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5BbmQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICYmIHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5PcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgfHwgcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLlBsdXM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICsgcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk1pbnVzOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAtIHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5EaXZpZGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpIC8gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk11bHRpcGx5OlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAqIHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Nb2R1bG86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICUgcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkxvd2VyOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA8IHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFsczpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPD0gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkJpZ2dlcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPiByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA+PSByaHMoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcGVyYXRvciBcIiArIGFzdC5vcGVyYXRvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY2VpdmVyID0gYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICByZXN1bHQgPSByZWNlaXZlclthc3QubmFtZV07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRSZWFkS2V5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcCA9IGFzdC5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIHJlY2VpdmVyW3Byb3BdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjdHgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0ge307XG4gICAgICAgIGFzdC5lbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiAoKHJlc3VsdCkpW2VudHJ5LmtleV0gPSBlbnRyeS52YWx1ZS52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdENvbW1hRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWVzID0gdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5wYXJ0cywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uc1xuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRBbGxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChleHByZXNzaW9ucywgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGVtZW50c1xuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRBbGxTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHN0YXRlbWVudHMsIGN0eCkge1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgc3RhdGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RtdCA9IHN0YXRlbWVudHNbaV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWwgPSBzdG10LnZpc2l0U3RhdGVtZW50KHRoaXMsIGN0eCk7XG4gICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgUmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlbWVudEludGVycHJldGVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB2YXJOYW1lc1xuICogQHBhcmFtIHs/fSBzdGF0ZW1lbnRzXG4gKiBAcGFyYW0gez99IGN0eFxuICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfZGVjbGFyZUZuKHZhck5hbWVzLCBzdGF0ZW1lbnRzLCBjdHgsIHZpc2l0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZXhlY3V0ZUZ1bmN0aW9uU3RhdGVtZW50cyh2YXJOYW1lcywgYXJncywgc3RhdGVtZW50cywgY3R4LCB2aXNpdG9yKTtcbiAgICB9O1xufVxudmFyIENBVENIX0VSUk9SX1ZBUiQyID0gJ2Vycm9yJztcbnZhciBDQVRDSF9TVEFDS19WQVIkMiA9ICdzdGFjayc7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGZhbHNlKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGN0eC5wdXNoQ2xhc3Moc3RtdCk7XG4gICAgICAgIHRoaXMuX3Zpc2l0Q2xhc3NDb25zdHJ1Y3RvcihzdG10LCBjdHgpO1xuICAgICAgICBpZiAoc3RtdC5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIHN0bXQubmFtZSArIFwiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoXCIpO1xuICAgICAgICAgICAgc3RtdC5wYXJlbnQudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIi5wcm90b3R5cGUpO1wiKTtcbiAgICAgICAgfVxuICAgICAgICBzdG10LmdldHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZ2V0dGVyKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc0dldHRlcihzdG10LCBnZXR0ZXIsIGN0eCk7IH0pO1xuICAgICAgICBzdG10Lm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc01ldGhvZChzdG10LCBtZXRob2QsIGN0eCk7IH0pO1xuICAgICAgICBjdHgucG9wQ2xhc3MoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJmdW5jdGlvbiBcIiArIHN0bXQubmFtZSArIFwiKFwiKTtcbiAgICAgICAgaWYgKHN0bXQuY29uc3RydWN0b3JNZXRob2QgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCIpIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgaWYgKHN0bXQuY29uc3RydWN0b3JNZXRob2QgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHN0bXQuY29uc3RydWN0b3JNZXRob2QuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ2YXIgc2VsZiA9IHRoaXM7XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY29uc3RydWN0b3JNZXRob2QuYm9keSwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifVwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gZ2V0dGVyXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NHZXR0ZXIgPSBmdW5jdGlvbiAoc3RtdCwgZ2V0dGVyLCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJPYmplY3QuZGVmaW5lUHJvcGVydHkoXCIgKyBzdG10Lm5hbWUgKyBcIi5wcm90b3R5cGUsICdcIiArIGdldHRlci5uYW1lICsgXCInLCB7IGdldDogZnVuY3Rpb24oKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIGlmIChnZXR0ZXIuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcInZhciBzZWxmID0gdGhpcztcIik7XG4gICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhnZXR0ZXIuYm9keSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifX0pO1wiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gbWV0aG9kXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NNZXRob2QgPSBmdW5jdGlvbiAoc3RtdCwgbWV0aG9kLCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIHN0bXQubmFtZSArIFwiLnByb3RvdHlwZS5cIiArIG1ldGhvZC5uYW1lICsgXCIgPSBmdW5jdGlvbihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKG1ldGhvZC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIGlmIChtZXRob2QuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcInZhciBzZWxmID0gdGhpcztcIik7XG4gICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhtZXRob2QuYm9keSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifTtcIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgaWYgKGFzdC5idWlsdGluID09PSBCdWlsdGluVmFyLlRoaXMpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsICdzZWxmJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXN0LmJ1aWx0aW4gPT09IEJ1aWx0aW5WYXIuU3VwZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidzdXBlcicgbmVlZHMgdG8gYmUgaGFuZGxlZCBhdCBhIHBhcmVudCBhc3Qgbm9kZSwgbm90IGF0IHRoZSB2YXJpYWJsZSBsZXZlbCFcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIuY2FsbCh0aGlzLCBhc3QsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJ2YXIgXCIgKyBzdG10Lm5hbWUgKyBcIiA9IFwiKTtcbiAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCI7XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZuRXhwciA9IGV4cHIuZm47XG4gICAgICAgIGlmIChmbkV4cHIgaW5zdGFuY2VvZiBSZWFkVmFyRXhwciAmJiBmbkV4cHIuYnVpbHRpbiA9PT0gQnVpbHRpblZhci5TdXBlcikge1xuICAgICAgICAgICAgKCgoKGN0eC5jdXJyZW50Q2xhc3MpKS5wYXJlbnQpKS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCBcIi5jYWxsKHRoaXNcIik7XG4gICAgICAgICAgICBpZiAoZXhwci5hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgXCIsIFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoZXhwci5hcmdzLCBjdHgsICcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgXCIpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwci5jYWxsKHRoaXMsIGV4cHIsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiZnVuY3Rpb24oXCIpO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhhc3QucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihhc3QsIFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGFzdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcImZ1bmN0aW9uIFwiICsgc3RtdC5uYW1lICsgXCIoXCIpO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhzdG10LnBhcmFtcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCIpIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ0cnkge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn0gY2F0Y2ggKFwiICsgQ0FUQ0hfRVJST1JfVkFSJDEubmFtZSArIFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhdGNoU3RtdHMgPSBbLyoqIEB0eXBlIHs/fSAqLyAoQ0FUQ0hfU1RBQ0tfVkFSJDEuc2V0KENBVENIX0VSUk9SX1ZBUiQxLnByb3AoJ3N0YWNrJykpLnRvRGVjbFN0bXQobnVsbCwgW1xuICAgICAgICAgICAgICAgIFN0bXRNb2RpZmllci5GaW5hbFxuICAgICAgICAgICAgXSkpXS5jb25jYXQoc3RtdC5jYXRjaFN0bXRzKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoY2F0Y2hTdG10cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCBjdHgpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBjdHgucHJpbnQobnVsbCwgcGFyYW0ubmFtZSk7IH0sIHBhcmFtcywgY3R4LCAnLCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRob2RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuZ2V0QnVpbHRpbk1ldGhvZE5hbWUgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWU7XG4gICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuQ29uY2F0QXJyYXk6XG4gICAgICAgICAgICAgICAgbmFtZSA9ICdjb25jYXQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGU6XG4gICAgICAgICAgICAgICAgbmFtZSA9ICdzdWJzY3JpYmUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLkJpbmQ6XG4gICAgICAgICAgICAgICAgbmFtZSA9ICdiaW5kJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBidWlsdGluIG1ldGhvZDogXCIgKyBtZXRob2QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvcjtcbn0oQWJzdHJhY3RFbWl0dGVyVmlzaXRvcikpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IHNvdXJjZVVybFxuICogQHBhcmFtIHs/fSBjdHhcbiAqIEBwYXJhbSB7P30gdmFyc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXZhbEV4cHJlc3Npb24oc291cmNlVXJsJCQxLCBjdHgsIHZhcnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbkJvZHkgPSBjdHgudG9Tb3VyY2UoKSArIFwiXFxuLy8jIHNvdXJjZVVSTD1cIiArIHNvdXJjZVVybCQkMTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbkFyZ05hbWVzID0gW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm5BcmdWYWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGFyZ05hbWUgaW4gdmFycykge1xuICAgICAgICBmbkFyZ05hbWVzLnB1c2goYXJnTmFtZSk7XG4gICAgICAgIGZuQXJnVmFsdWVzLnB1c2godmFyc1thcmdOYW1lXSk7XG4gICAgfVxuICAgIGlmIChpc0Rldk1vZGUoKSkge1xuICAgICAgICAvLyB1c2luZyBgbmV3IEZ1bmN0aW9uKC4uLilgIGdlbmVyYXRlcyBhIGhlYWRlciwgMSBsaW5lIG9mIG5vIGFyZ3VtZW50cywgMiBsaW5lcyBvdGhlcndpc2VcbiAgICAgICAgLy8gRS5nLiBgYGBcbiAgICAgICAgLy8gZnVuY3Rpb24gYW5vbnltb3VzKGEsYixjXG4gICAgICAgIC8vIC8qKi8pIHsgLi4uIH1gYGBcbiAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBoYXJkIGNvZGUgdGhpcyBmYWN0LCBzbyB3ZSBhdXRvIGRldGVjdCBpdCB2aWEgYW4gZW1wdHkgZnVuY3Rpb24gZmlyc3QuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVtcHR5Rm4gPSBuZXcgKEZ1bmN0aW9uLmJpbmQuYXBwbHkoRnVuY3Rpb24sIFt2b2lkIDBdLmNvbmNhdChmbkFyZ05hbWVzLmNvbmNhdCgncmV0dXJuIG51bGw7JykpKSkoKS50b1N0cmluZygpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoZWFkZXJMaW5lcyA9IGVtcHR5Rm4uc2xpY2UoMCwgZW1wdHlGbi5pbmRleE9mKCdyZXR1cm4gbnVsbDsnKSkuc3BsaXQoJ1xcbicpLmxlbmd0aCAtIDE7XG4gICAgICAgIGZuQm9keSArPSBcIlxcblwiICsgY3R4LnRvU291cmNlTWFwR2VuZXJhdG9yKHNvdXJjZVVybCQkMSwgc291cmNlVXJsJCQxLCBoZWFkZXJMaW5lcykudG9Kc0NvbW1lbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24uYmluZC5hcHBseShGdW5jdGlvbiwgW3ZvaWQgMF0uY29uY2F0KGZuQXJnTmFtZXMuY29uY2F0KGZuQm9keSkpKSkoKS5hcHBseSh2b2lkIDAsIGZuQXJnVmFsdWVzKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzb3VyY2VVcmxcbiAqIEBwYXJhbSB7P30gc3RhdGVtZW50c1xuICogQHBhcmFtIHs/fSByZXN1bHRWYXJzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBqaXRTdGF0ZW1lbnRzKHNvdXJjZVVybCQkMSwgc3RhdGVtZW50cywgcmVzdWx0VmFycykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnZlcnRlciA9IG5ldyBKaXRFbWl0dGVyVmlzaXRvcigpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0eCA9IEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290KHJlc3VsdFZhcnMpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJldHVyblN0bXQgPSBuZXcgUmV0dXJuU3RhdGVtZW50KGxpdGVyYWxBcnIocmVzdWx0VmFycy5tYXAoZnVuY3Rpb24gKHJlc3VsdFZhcikgeyByZXR1cm4gdmFyaWFibGUocmVzdWx0VmFyKTsgfSkpKTtcbiAgICBjb252ZXJ0ZXIudmlzaXRBbGxTdGF0ZW1lbnRzKHN0YXRlbWVudHMuY29uY2F0KFtyZXR1cm5TdG10XSksIGN0eCk7XG4gICAgcmV0dXJuIGV2YWxFeHByZXNzaW9uKHNvdXJjZVVybCQkMSwgY3R4LCBjb252ZXJ0ZXIuZ2V0QXJncygpKTtcbn1cbnZhciBKaXRFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEppdEVtaXR0ZXJWaXNpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEppdEVtaXR0ZXJWaXNpdG9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZXZhbEFyZ05hbWVzID0gW107XG4gICAgICAgIF90aGlzLl9ldmFsQXJnVmFsdWVzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuZ2V0QXJncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB0aGlzLl9ldmFsQXJnTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFt0aGlzLl9ldmFsQXJnTmFtZXNbaV1dID0gdGhpcy5fZXZhbEFyZ1ZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gYXN0LnZhbHVlLnJlZmVyZW5jZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWQgPSB0aGlzLl9ldmFsQXJnVmFsdWVzLmluZGV4T2YodmFsdWUpO1xuICAgICAgICBpZiAoaWQgPT09IC0xKSB7XG4gICAgICAgICAgICBpZCA9IHRoaXMuX2V2YWxBcmdWYWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fZXZhbEFyZ1ZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBpZGVudGlmaWVyTmFtZShhc3QudmFsdWUpIHx8ICd2YWwnO1xuICAgICAgICAgICAgdGhpcy5fZXZhbEFyZ05hbWVzLnB1c2goXCJqaXRfXCIgKyBuYW1lICsgaWQpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChhc3QsIHRoaXMuX2V2YWxBcmdOYW1lc1tpZF0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBKaXRFbWl0dGVyVmlzaXRvcjtcbn0oQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEFuIGludGVybmFsIG1vZHVsZSBvZiB0aGUgQW5ndWxhciBjb21waWxlciB0aGF0IGJlZ2lucyB3aXRoIGNvbXBvbmVudCB0eXBlcyxcbiAqIGV4dHJhY3RzIHRlbXBsYXRlcywgYW5kIGV2ZW50dWFsbHkgcHJvZHVjZXMgYSBjb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBjb21wb25lbnRcbiAqIHJlYWR5IGZvciBsaW5raW5nIGludG8gYW4gYXBwbGljYXRpb24uXG4gKlxuICogXFxAc2VjdXJpdHkgV2hlbiBjb21waWxpbmcgdGVtcGxhdGVzIGF0IHJ1bnRpbWUsIHlvdSBtdXN0IGVuc3VyZSB0aGF0IHRoZSBlbnRpcmUgdGVtcGxhdGUgY29tZXNcbiAqIGZyb20gYSB0cnVzdGVkIHNvdXJjZS4gQXR0YWNrZXItY29udHJvbGxlZCBkYXRhIGludHJvZHVjZWQgYnkgYSB0ZW1wbGF0ZSBjb3VsZCBleHBvc2UgeW91clxuICogYXBwbGljYXRpb24gdG8gWFNTIHJpc2tzLiAgRm9yIG1vcmUgZGV0YWlsLCBzZWUgdGhlIFtTZWN1cml0eSBHdWlkZV0oaHR0cDovL2cuY28vbmcvc2VjdXJpdHkpLlxuICovXG52YXIgSml0Q29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2luamVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBfbWV0YWRhdGFSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gX3RlbXBsYXRlUGFyc2VyXG4gICAgICogQHBhcmFtIHs/fSBfc3R5bGVDb21waWxlclxuICAgICAqIEBwYXJhbSB7P30gX3ZpZXdDb21waWxlclxuICAgICAqIEBwYXJhbSB7P30gX25nTW9kdWxlQ29tcGlsZXJcbiAgICAgKiBAcGFyYW0gez99IF9jb21waWxlckNvbmZpZ1xuICAgICAqIEBwYXJhbSB7P30gX2NvbnNvbGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBKaXRDb21waWxlcihfaW5qZWN0b3IsIF9tZXRhZGF0YVJlc29sdmVyLCBfdGVtcGxhdGVQYXJzZXIsIF9zdHlsZUNvbXBpbGVyLCBfdmlld0NvbXBpbGVyLCBfbmdNb2R1bGVDb21waWxlciwgX2NvbXBpbGVyQ29uZmlnLCBfY29uc29sZSkge1xuICAgICAgICB0aGlzLl9pbmplY3RvciA9IF9pbmplY3RvcjtcbiAgICAgICAgdGhpcy5fbWV0YWRhdGFSZXNvbHZlciA9IF9tZXRhZGF0YVJlc29sdmVyO1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZVBhcnNlciA9IF90ZW1wbGF0ZVBhcnNlcjtcbiAgICAgICAgdGhpcy5fc3R5bGVDb21waWxlciA9IF9zdHlsZUNvbXBpbGVyO1xuICAgICAgICB0aGlzLl92aWV3Q29tcGlsZXIgPSBfdmlld0NvbXBpbGVyO1xuICAgICAgICB0aGlzLl9uZ01vZHVsZUNvbXBpbGVyID0gX25nTW9kdWxlQ29tcGlsZXI7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVyQ29uZmlnID0gX2NvbXBpbGVyQ29uZmlnO1xuICAgICAgICB0aGlzLl9jb25zb2xlID0gX2NvbnNvbGU7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWRIb3N0VGVtcGxhdGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWREaXJlY3RpdmVXcmFwcGVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fc2hhcmVkU3R5bGVzaGVldENvdW50ID0gMDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEppdENvbXBpbGVyLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pbmplY3RvcjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMuX2NvbXBpbGVNb2R1bGVBbmRDb21wb25lbnRzKG1vZHVsZVR5cGUsIHRydWUpLnN5bmNSZXN1bHQpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5fY29tcGlsZU1vZHVsZUFuZENvbXBvbmVudHMobW9kdWxlVHlwZSwgZmFsc2UpLmFzeW5jUmVzdWx0KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMuX2NvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzKG1vZHVsZVR5cGUsIHRydWUpLnN5bmNSZXN1bHQpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMuX2NvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzKG1vZHVsZVR5cGUsIGZhbHNlKS5hc3luY1Jlc3VsdCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5nZXROZ0NvbnRlbnRTZWxlY3RvcnMgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuX2NvbnNvbGUud2FybignQ29tcGlsZXIuZ2V0TmdDb250ZW50U2VsZWN0b3JzIGlzIGRlcHJlY2F0ZWQuIFVzZSBDb21wb25lbnRGYWN0b3J5Lm5nQ29udGVudFNlbGVjdG9ycyBpbnN0ZWFkIScpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZSA9IHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5nZXQoY29tcG9uZW50KTtcbiAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbXBvbmVudCBcIiArIMm1c3RyaW5naWZ5KGNvbXBvbmVudCkgKyBcIiBpcyBub3QgeWV0IGNvbXBpbGVkIVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCh0ZW1wbGF0ZS5jb21wTWV0YS50ZW1wbGF0ZSkpLm5nQ29udGVudFNlbGVjdG9ycztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHBhcmFtIHs/fSBpc1N5bmNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZU1vZHVsZUFuZENvbXBvbmVudHMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSwgaXNTeW5jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvYWRpbmdQcm9taXNlID0gdGhpcy5fbG9hZE1vZHVsZXMobW9kdWxlVHlwZSwgaXNTeW5jKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3JlYXRlUmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2NvbXBpbGVDb21wb25lbnRzKG1vZHVsZVR5cGUsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jb21waWxlTW9kdWxlKG1vZHVsZVR5cGUpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN5bmNBc3luY1Jlc3VsdChjcmVhdGVSZXN1bHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN5bmNBc3luY1Jlc3VsdChudWxsLCBsb2FkaW5nUHJvbWlzZS50aGVuKGNyZWF0ZVJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEBwYXJhbSB7P30gaXNTeW5jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGlzU3luYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2FkaW5nUHJvbWlzZSA9IHRoaXMuX2xvYWRNb2R1bGVzKG1vZHVsZVR5cGUsIGlzU3luYyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNyZWF0ZVJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudEZhY3RvcmllcyA9IFtdO1xuICAgICAgICAgICAgX3RoaXMuX2NvbXBpbGVDb21wb25lbnRzKG1vZHVsZVR5cGUsIGNvbXBvbmVudEZhY3Rvcmllcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsZVdpdGhDb21wb25lbnRGYWN0b3JpZXMoX3RoaXMuX2NvbXBpbGVNb2R1bGUobW9kdWxlVHlwZSksIGNvbXBvbmVudEZhY3Rvcmllcyk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3luY0FzeW5jUmVzdWx0KGNyZWF0ZVJlc3VsdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3luY0FzeW5jUmVzdWx0KG51bGwsIGxvYWRpbmdQcm9taXNlLnRoZW4oY3JlYXRlUmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWFpbk1vZHVsZVxuICAgICAqIEBwYXJhbSB7P30gaXNTeW5jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX2xvYWRNb2R1bGVzID0gZnVuY3Rpb24gKG1haW5Nb2R1bGUsIGlzU3luYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2FkaW5nUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGUgPSAoKHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVNZXRhZGF0YShtYWluTW9kdWxlKSkpO1xuICAgICAgICAvLyBOb3RlOiB0aGUgbG9hZGluZ1Byb21pc2UgZm9yIGEgbW9kdWxlIG9ubHkgaW5jbHVkZXMgdGhlIGxvYWRpbmcgb2YgdGhlIGV4cG9ydGVkIGRpcmVjdGl2ZXNcbiAgICAgICAgLy8gb2YgaW1wb3J0ZWQgbW9kdWxlcy5cbiAgICAgICAgLy8gSG93ZXZlciwgZm9yIHJ1bnRpbWUgY29tcGlsYXRpb24sIHdlIHdhbnQgdG8gdHJhbnNpdGl2ZWx5IGNvbXBpbGUgYWxsIG1vZHVsZXMsXG4gICAgICAgIC8vIHNvIHdlIGFsc28gbmVlZCB0byBjYWxsIGxvYWROZ01vZHVsZURpcmVjdGl2ZUFuZFBpcGVNZXRhZGF0YSBmb3IgYWxsIG5lc3RlZCBtb2R1bGVzLlxuICAgICAgICBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobG9jYWxNb2R1bGVNZXRhKSB7XG4gICAgICAgICAgICBsb2FkaW5nUHJvbWlzZXMucHVzaChfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5sb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGEobG9jYWxNb2R1bGVNZXRhLnJlZmVyZW5jZSwgaXNTeW5jKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobG9hZGluZ1Byb21pc2VzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVNb2R1bGUgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ01vZHVsZUZhY3RvcnkgPSAoKHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZS5nZXQobW9kdWxlVHlwZSkpKTtcbiAgICAgICAgaWYgKCFuZ01vZHVsZUZhY3RvcnkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZU1ldGFfMSA9ICgodGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKG1vZHVsZVR5cGUpKSk7XG4gICAgICAgICAgICAvLyBBbHdheXMgcHJvdmlkZSBhIGJvdW5kIENvbXBpbGVyXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHRyYVByb3ZpZGVycyA9IFt0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldFByb3ZpZGVyTWV0YWRhdGEobmV3IFByb3ZpZGVyTWV0YShDb21waWxlciwgeyB1c2VGYWN0b3J5OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTW9kdWxlQm91bmRDb21waWxlcihfdGhpcywgbW9kdWxlTWV0YV8xLnR5cGUucmVmZXJlbmNlKTsgfSB9KSldO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcGlsZVJlc3VsdCA9IHRoaXMuX25nTW9kdWxlQ29tcGlsZXIuY29tcGlsZShtb2R1bGVNZXRhXzEsIGV4dHJhUHJvdmlkZXJzKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY29tcGlsZXJDb25maWcudXNlSml0KSB7XG4gICAgICAgICAgICAgICAgbmdNb2R1bGVGYWN0b3J5ID1cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwcmV0U3RhdGVtZW50cyhjb21waWxlUmVzdWx0LnN0YXRlbWVudHMsIFtjb21waWxlUmVzdWx0Lm5nTW9kdWxlRmFjdG9yeVZhcl0pWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmdNb2R1bGVGYWN0b3J5ID0gaml0U3RhdGVtZW50cyhuZ01vZHVsZUppdFVybChtb2R1bGVNZXRhXzEpLCBjb21waWxlUmVzdWx0LnN0YXRlbWVudHMsIFtjb21waWxlUmVzdWx0Lm5nTW9kdWxlRmFjdG9yeVZhcl0pWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlLnNldChtb2R1bGVNZXRhXzEudHlwZS5yZWZlcmVuY2UsIG5nTW9kdWxlRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5nTW9kdWxlRmFjdG9yeTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBtYWluTW9kdWxlXG4gICAgICogQHBhcmFtIHs/fSBhbGxDb21wb25lbnRGYWN0b3JpZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvbXBvbmVudHMgPSBmdW5jdGlvbiAobWFpbk1vZHVsZSwgYWxsQ29tcG9uZW50RmFjdG9yaWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlID0gKCh0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEobWFpbk1vZHVsZSkpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlQnlEaXJlY3RpdmUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKGxvY2FsTW9kdWxlU3VtbWFyeSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG9jYWxNb2R1bGVNZXRhID0gKChfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKGxvY2FsTW9kdWxlU3VtbWFyeS5yZWZlcmVuY2UpKSk7XG4gICAgICAgICAgICBsb2NhbE1vZHVsZU1ldGEuZGVjbGFyZWREaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVCeURpcmVjdGl2ZS5zZXQoZGlySWRlbnRpZmllci5yZWZlcmVuY2UsIGxvY2FsTW9kdWxlTWV0YSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyTWV0YSA9IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKGRpcklkZW50aWZpZXIucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyTWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuYWRkKF90aGlzLl9jcmVhdGVDb21waWxlZFRlbXBsYXRlKGRpck1ldGEsIGxvY2FsTW9kdWxlTWV0YSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsQ29tcG9uZW50RmFjdG9yaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZSA9IF90aGlzLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZShkaXJNZXRhLnR5cGUucmVmZXJlbmNlLCBsb2NhbE1vZHVsZU1ldGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLmFkZCh0ZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxDb21wb25lbnRGYWN0b3JpZXMucHVzaCgvKiogQHR5cGUgez99ICovIChkaXJNZXRhLmNvbXBvbmVudEZhY3RvcnkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKGxvY2FsTW9kdWxlU3VtbWFyeSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG9jYWxNb2R1bGVNZXRhID0gKChfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKGxvY2FsTW9kdWxlU3VtbWFyeS5yZWZlcmVuY2UpKSk7XG4gICAgICAgICAgICBsb2NhbE1vZHVsZU1ldGEuZGVjbGFyZWREaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJNZXRhID0gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoZGlySWRlbnRpZmllci5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgIGlmIChkaXJNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpck1ldGEuZW50cnlDb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5Q29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlTWV0YSA9ICgobW9kdWxlQnlEaXJlY3RpdmUuZ2V0KGVudHJ5Q29tcG9uZW50VHlwZS5jb21wb25lbnRUeXBlKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLmFkZChfdGhpcy5fY3JlYXRlQ29tcGlsZWRIb3N0VGVtcGxhdGUoZW50cnlDb21wb25lbnRUeXBlLmNvbXBvbmVudFR5cGUsIG1vZHVsZU1ldGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb2NhbE1vZHVsZU1ldGEuZW50cnlDb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5Q29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZU1ldGEgPSAoKG1vZHVsZUJ5RGlyZWN0aXZlLmdldChlbnRyeUNvbXBvbmVudFR5cGUuY29tcG9uZW50VHlwZSkpKTtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuYWRkKF90aGlzLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZShlbnRyeUNvbXBvbmVudFR5cGUuY29tcG9uZW50VHlwZSwgbW9kdWxlTWV0YSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0ZW1wbGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAodGVtcGxhdGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlVGVtcGxhdGUodGVtcGxhdGUpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLmNsZWFyQ2FjaGVGb3IgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB0aGlzLl9jb21waWxlZE5nTW9kdWxlQ2FjaGUuZGVsZXRlKHR5cGUpO1xuICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmNsZWFyQ2FjaGVGb3IodHlwZSk7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkSG9zdFRlbXBsYXRlQ2FjaGUuZGVsZXRlKHR5cGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21waWxlZFRlbXBsYXRlID0gdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKGNvbXBpbGVkVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuY2xlYXJDYWNoZSgpO1xuICAgICAgICB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWRIb3N0VGVtcGxhdGVDYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9jb21waWxlZE5nTW9kdWxlQ2FjaGUuY2xlYXIoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcFR5cGVcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX2NyZWF0ZUNvbXBpbGVkSG9zdFRlbXBsYXRlID0gZnVuY3Rpb24gKGNvbXBUeXBlLCBuZ01vZHVsZSkge1xuICAgICAgICBpZiAoIW5nTW9kdWxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wb25lbnQgXCIgKyDJtXN0cmluZ2lmeShjb21wVHlwZSkgKyBcIiBpcyBub3QgcGFydCBvZiBhbnkgTmdNb2R1bGUgb3IgdGhlIG1vZHVsZSBoYXMgbm90IGJlZW4gaW1wb3J0ZWQgaW50byB5b3VyIG1vZHVsZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcGlsZWRUZW1wbGF0ZSA9IHRoaXMuX2NvbXBpbGVkSG9zdFRlbXBsYXRlQ2FjaGUuZ2V0KGNvbXBUeXBlKTtcbiAgICAgICAgaWYgKCFjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wTWV0YSA9IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoY29tcFR5cGUpO1xuICAgICAgICAgICAgYXNzZXJ0Q29tcG9uZW50KGNvbXBNZXRhKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudEZhY3RvcnkgPSAoY29tcE1ldGEuY29tcG9uZW50RmFjdG9yeSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0Q2xhc3MgPSB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldEhvc3RDb21wb25lbnRUeXBlKGNvbXBUeXBlKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RNZXRhID0gY3JlYXRlSG9zdENvbXBvbmVudE1ldGEoaG9zdENsYXNzLCBjb21wTWV0YSwgLyoqIEB0eXBlIHs/fSAqLyAoybVnZXRDb21wb25lbnRWaWV3RGVmaW5pdGlvbkZhY3RvcnkoY29tcG9uZW50RmFjdG9yeSkpKTtcbiAgICAgICAgICAgIGNvbXBpbGVkVGVtcGxhdGUgPVxuICAgICAgICAgICAgICAgIG5ldyBDb21waWxlZFRlbXBsYXRlKHRydWUsIGNvbXBNZXRhLnR5cGUsIGhvc3RNZXRhLCBuZ01vZHVsZSwgW2NvbXBNZXRhLnR5cGVdKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkSG9zdFRlbXBsYXRlQ2FjaGUuc2V0KGNvbXBUeXBlLCBjb21waWxlZFRlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGlsZWRUZW1wbGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcE1ldGFcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX2NyZWF0ZUNvbXBpbGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAoY29tcE1ldGEsIG5nTW9kdWxlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBpbGVkVGVtcGxhdGUgPSB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUuZ2V0KGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgaWYgKCFjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgICAgICAgICBhc3NlcnRDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICAgICAgY29tcGlsZWRUZW1wbGF0ZSA9IG5ldyBDb21waWxlZFRlbXBsYXRlKGZhbHNlLCBjb21wTWV0YS50eXBlLCBjb21wTWV0YSwgbmdNb2R1bGUsIG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUuZGlyZWN0aXZlcyk7XG4gICAgICAgICAgICB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUuc2V0KGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlLCBjb21waWxlZFRlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGlsZWRUZW1wbGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZVRlbXBsYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5pc0NvbXBpbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcE1ldGEgPSB0ZW1wbGF0ZS5jb21wTWV0YTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXNDb21waWxlUmVzdWx0ID0gdGhpcy5fc3R5bGVDb21waWxlci5jb21waWxlQ29tcG9uZW50KGNvbXBNZXRhKTtcbiAgICAgICAgc3R5bGVzQ29tcGlsZVJlc3VsdC5leHRlcm5hbFN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsLnNldCgvKiogQHR5cGUgez99ICovICgoci5tZXRhLm1vZHVsZVVybCkpLCByKTsgfSk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVTdHlsZXNDb21waWxlUmVzdWx0KHN0eWxlc0NvbXBpbGVSZXN1bHQuY29tcG9uZW50U3R5bGVzaGVldCwgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyZWN0aXZlcyA9IHRlbXBsYXRlLmRpcmVjdGl2ZXMubWFwKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZVN1bW1hcnkoZGlyLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaXBlcyA9IHRlbXBsYXRlLm5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUucGlwZXMubWFwKGZ1bmN0aW9uIChwaXBlKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRQaXBlU3VtbWFyeShwaXBlLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl90ZW1wbGF0ZVBhcnNlci5wYXJzZShjb21wTWV0YSwgLyoqIEB0eXBlIHs/fSAqLyAoKCgoY29tcE1ldGEudGVtcGxhdGUpKS50ZW1wbGF0ZSkpLCBkaXJlY3RpdmVzLCBwaXBlcywgdGVtcGxhdGUubmdNb2R1bGUuc2NoZW1hcywgdGVtcGxhdGVTb3VyY2VVcmwodGVtcGxhdGUubmdNb2R1bGUudHlwZSwgdGVtcGxhdGUuY29tcE1ldGEsIC8qKiBAdHlwZSB7P30gKi8gKCh0ZW1wbGF0ZS5jb21wTWV0YS50ZW1wbGF0ZSkpKSksIHBhcnNlZFRlbXBsYXRlID0gX2EudGVtcGxhdGUsIHVzZWRQaXBlcyA9IF9hLnBpcGVzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21waWxlUmVzdWx0ID0gdGhpcy5fdmlld0NvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQoY29tcE1ldGEsIHBhcnNlZFRlbXBsYXRlLCB2YXJpYWJsZShzdHlsZXNDb21waWxlUmVzdWx0LmNvbXBvbmVudFN0eWxlc2hlZXQuc3R5bGVzVmFyKSwgdXNlZFBpcGVzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGVtZW50cyA9IHN0eWxlc0NvbXBpbGVSZXN1bHQuY29tcG9uZW50U3R5bGVzaGVldC5zdGF0ZW1lbnRzLmNvbmNhdChjb21waWxlUmVzdWx0LnN0YXRlbWVudHMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3Q2xhc3NBbmRSZW5kZXJlclR5cGVWYXJzID0gY29tcE1ldGEuaXNIb3N0ID9cbiAgICAgICAgICAgIFtjb21waWxlUmVzdWx0LnZpZXdDbGFzc1Zhcl0gOlxuICAgICAgICAgICAgW2NvbXBpbGVSZXN1bHQudmlld0NsYXNzVmFyLCBjb21waWxlUmVzdWx0LnJlbmRlcmVyVHlwZVZhcl07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdDbGFzcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVuZGVyZXJUeXBlO1xuICAgICAgICBpZiAoIXRoaXMuX2NvbXBpbGVyQ29uZmlnLnVzZUppdCkge1xuICAgICAgICAgICAgX2IgPSBpbnRlcnByZXRTdGF0ZW1lbnRzKHN0YXRlbWVudHMsIHZpZXdDbGFzc0FuZFJlbmRlcmVyVHlwZVZhcnMpLCB2aWV3Q2xhc3MgPSBfYlswXSwgcmVuZGVyZXJUeXBlID0gX2JbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfYyA9IGppdFN0YXRlbWVudHModGVtcGxhdGVKaXRVcmwodGVtcGxhdGUubmdNb2R1bGUudHlwZSwgdGVtcGxhdGUuY29tcE1ldGEpLCBzdGF0ZW1lbnRzLCB2aWV3Q2xhc3NBbmRSZW5kZXJlclR5cGVWYXJzKSwgdmlld0NsYXNzID0gX2NbMF0sIHJlbmRlcmVyVHlwZSA9IF9jWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlLmNvbXBpbGVkKHZpZXdDbGFzcywgcmVuZGVyZXJUeXBlKTtcbiAgICAgICAgdmFyIF9iLCBfYztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVzdWx0XG4gICAgICogQHBhcmFtIHs/fSBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fcmVzb2x2ZVN0eWxlc0NvbXBpbGVSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0LCBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmVzdWx0LmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXAsIGkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5lc3RlZENvbXBpbGVSZXN1bHQgPSAoKGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybC5nZXQoZGVwLm1vZHVsZVVybCkpKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5lc3RlZFN0eWxlc0FyciA9IF90aGlzLl9yZXNvbHZlQW5kRXZhbFN0eWxlc0NvbXBpbGVSZXN1bHQobmVzdGVkQ29tcGlsZVJlc3VsdCwgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsKTtcbiAgICAgICAgICAgIGRlcC52YWx1ZVBsYWNlaG9sZGVyLnJlZmVyZW5jZSA9IG5lc3RlZFN0eWxlc0FycjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlc3VsdFxuICAgICAqIEBwYXJhbSB7P30gZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX3Jlc29sdmVBbmRFdmFsU3R5bGVzQ29tcGlsZVJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlU3R5bGVzQ29tcGlsZVJlc3VsdChyZXN1bHQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCk7XG4gICAgICAgIGlmICghdGhpcy5fY29tcGlsZXJDb25maWcudXNlSml0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJwcmV0U3RhdGVtZW50cyhyZXN1bHQuc3RhdGVtZW50cywgW3Jlc3VsdC5zdHlsZXNWYXJdKVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBqaXRTdGF0ZW1lbnRzKHNoYXJlZFN0eWxlc2hlZXRKaXRVcmwocmVzdWx0Lm1ldGEsIHRoaXMuX3NoYXJlZFN0eWxlc2hlZXRDb3VudCsrKSwgcmVzdWx0LnN0YXRlbWVudHMsIFtyZXN1bHQuc3R5bGVzVmFyXSlbMF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBKaXRDb21waWxlcjtcbn0oKSk7XG5KaXRDb21waWxlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5KaXRDb21waWxlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEluamVjdG9yLCB9LFxuICAgIHsgdHlwZTogQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIsIH0sXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVBhcnNlciwgfSxcbiAgICB7IHR5cGU6IFN0eWxlQ29tcGlsZXIsIH0sXG4gICAgeyB0eXBlOiBWaWV3Q29tcGlsZXIsIH0sXG4gICAgeyB0eXBlOiBOZ01vZHVsZUNvbXBpbGVyLCB9LFxuICAgIHsgdHlwZTogQ29tcGlsZXJDb25maWcsIH0sXG4gICAgeyB0eXBlOiDJtUNvbnNvbGUsIH0sXG5dOyB9O1xudmFyIENvbXBpbGVkVGVtcGxhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaXNIb3N0XG4gICAgICogQHBhcmFtIHs/fSBjb21wVHlwZVxuICAgICAqIEBwYXJhbSB7P30gY29tcE1ldGFcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZWRUZW1wbGF0ZShpc0hvc3QsIGNvbXBUeXBlLCBjb21wTWV0YSwgbmdNb2R1bGUsIGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgdGhpcy5pc0hvc3QgPSBpc0hvc3Q7XG4gICAgICAgIHRoaXMuY29tcFR5cGUgPSBjb21wVHlwZTtcbiAgICAgICAgdGhpcy5jb21wTWV0YSA9IGNvbXBNZXRhO1xuICAgICAgICB0aGlzLm5nTW9kdWxlID0gbmdNb2R1bGU7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgICAgIHRoaXMuX3ZpZXdDbGFzcyA9ICgobnVsbCkpO1xuICAgICAgICB0aGlzLmlzQ29tcGlsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aWV3Q2xhc3NcbiAgICAgKiBAcGFyYW0gez99IHJlbmRlcmVyVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZWRUZW1wbGF0ZS5wcm90b3R5cGUuY29tcGlsZWQgPSBmdW5jdGlvbiAodmlld0NsYXNzLCByZW5kZXJlclR5cGUpIHtcbiAgICAgICAgdGhpcy5fdmlld0NsYXNzID0gdmlld0NsYXNzO1xuICAgICAgICAoKHRoaXMuY29tcE1ldGEuY29tcG9uZW50Vmlld1R5cGUpKS5zZXREZWxlZ2F0ZSh2aWV3Q2xhc3MpO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHByb3AgaW4gcmVuZGVyZXJUeXBlKSB7XG4gICAgICAgICAgICAoKHRoaXMuY29tcE1ldGEucmVuZGVyZXJUeXBlKSlbcHJvcF0gPSByZW5kZXJlclR5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NvbXBpbGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBDb21waWxlZFRlbXBsYXRlO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBtZXRhXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBhc3NlcnRDb21wb25lbnQobWV0YSkge1xuICAgIGlmICghbWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY29tcGlsZSAnXCIgKyBpZGVudGlmaWVyTmFtZShtZXRhLnR5cGUpICsgXCInIGJlY2F1c2UgaXQgaXMgbm90IGEgY29tcG9uZW50LlwiKTtcbiAgICB9XG59XG4vKipcbiAqIEltcGxlbWVudHMgYENvbXBpbGVyYCBieSBkZWxlZ2F0aW5nIHRvIHRoZSBKaXRDb21waWxlciB1c2luZyBhIGtub3duIG1vZHVsZS5cbiAqL1xudmFyIE1vZHVsZUJvdW5kQ29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2RlbGVnYXRlXG4gICAgICogQHBhcmFtIHs/fSBfbmdNb2R1bGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNb2R1bGVCb3VuZENvbXBpbGVyKF9kZWxlZ2F0ZSwgX25nTW9kdWxlKSB7XG4gICAgICAgIHRoaXMuX2RlbGVnYXRlID0gX2RlbGVnYXRlO1xuICAgICAgICB0aGlzLl9uZ01vZHVsZSA9IF9uZ01vZHVsZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLCBcIl9pbmplY3RvclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5pbmplY3RvcjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVTeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNvbXBpbGVNb2R1bGVTeW5jKG1vZHVsZVR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5jb21waWxlTW9kdWxlQXN5bmMobW9kdWxlVHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTW9kdWxlQm91bmRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNTeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzU3luYyhtb2R1bGVUeXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c0FzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzQXN5bmMobW9kdWxlVHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTW9kdWxlQm91bmRDb21waWxlci5wcm90b3R5cGUuZ2V0TmdDb250ZW50U2VsZWN0b3JzID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuZ2V0TmdDb250ZW50U2VsZWN0b3JzKGNvbXBvbmVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGNhY2hlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTW9kdWxlQm91bmRDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fZGVsZWdhdGUuY2xlYXJDYWNoZSgpOyB9O1xuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgY2FjaGUgZm9yIHRoZSBnaXZlbiBjb21wb25lbnQvbmdNb2R1bGUuXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlRm9yID0gZnVuY3Rpb24gKHR5cGUpIHsgdGhpcy5fZGVsZWdhdGUuY2xlYXJDYWNoZUZvcih0eXBlKTsgfTtcbiAgICByZXR1cm4gTW9kdWxlQm91bmRDb21waWxlcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciBtZXNzYWdlIGV4dHJhY3RlZCBmcm9tIHRoZSB0ZW1wbGF0ZXMuXG4gKi9cbnZhciBNZXNzYWdlQnVuZGxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9odG1sUGFyc2VyXG4gICAgICogQHBhcmFtIHs/fSBfaW1wbGljaXRUYWdzXG4gICAgICogQHBhcmFtIHs/fSBfaW1wbGljaXRBdHRyc1xuICAgICAqIEBwYXJhbSB7Pz19IF9sb2NhbGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZXNzYWdlQnVuZGxlKF9odG1sUGFyc2VyLCBfaW1wbGljaXRUYWdzLCBfaW1wbGljaXRBdHRycywgX2xvY2FsZSkge1xuICAgICAgICBpZiAoX2xvY2FsZSA9PT0gdm9pZCAwKSB7IF9sb2NhbGUgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgdGhpcy5faW1wbGljaXRUYWdzID0gX2ltcGxpY2l0VGFncztcbiAgICAgICAgdGhpcy5faW1wbGljaXRBdHRycyA9IF9pbXBsaWNpdEF0dHJzO1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB0aGlzLl9tZXNzYWdlcyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGh0bWxcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7P30gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWVzc2FnZUJ1bmRsZS5wcm90b3R5cGUudXBkYXRlRnJvbVRlbXBsYXRlID0gZnVuY3Rpb24gKGh0bWwsIHVybCwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBodG1sUGFyc2VyUmVzdWx0ID0gdGhpcy5faHRtbFBhcnNlci5wYXJzZShodG1sLCB1cmwsIHRydWUsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICBpZiAoaHRtbFBhcnNlclJlc3VsdC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbFBhcnNlclJlc3VsdC5lcnJvcnM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTE4blBhcnNlclJlc3VsdCA9IGV4dHJhY3RNZXNzYWdlcyhodG1sUGFyc2VyUmVzdWx0LnJvb3ROb2RlcywgaW50ZXJwb2xhdGlvbkNvbmZpZywgdGhpcy5faW1wbGljaXRUYWdzLCB0aGlzLl9pbXBsaWNpdEF0dHJzKTtcbiAgICAgICAgaWYgKGkxOG5QYXJzZXJSZXN1bHQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGkxOG5QYXJzZXJSZXN1bHQuZXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuX21lc3NhZ2VzKS5wdXNoLmFwcGx5KF9hLCBpMThuUGFyc2VyUmVzdWx0Lm1lc3NhZ2VzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWVzc2FnZUJ1bmRsZS5wcm90b3R5cGUuZ2V0TWVzc2FnZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tZXNzYWdlczsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlcmlhbGl6ZXJcbiAgICAgKiBAcGFyYW0gez89fSBmaWx0ZXJTb3VyY2VzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZXNzYWdlQnVuZGxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzZXJpYWxpemVyLCBmaWx0ZXJTb3VyY2VzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lc3NhZ2VzID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcHBlclZpc2l0b3IgPSBuZXcgTWFwUGxhY2Vob2xkZXJOYW1lcygpO1xuICAgICAgICAvLyBEZWR1cGxpY2F0ZSBtZXNzYWdlcyBiYXNlZCBvbiB0aGVpciBJRFxuICAgICAgICB0aGlzLl9tZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9IHNlcmlhbGl6ZXIuZGlnZXN0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKCFtZXNzYWdlcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1tpZF0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKF9hID0gbWVzc2FnZXNbaWRdLnNvdXJjZXMpLnB1c2guYXBwbHkoX2EsIG1lc3NhZ2Uuc291cmNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmFuc2Zvcm0gcGxhY2Vob2xkZXIgbmFtZXMgdXNpbmcgdGhlIHNlcmlhbGl6ZXIgbWFwcGluZ1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtc2dMaXN0ID0gT2JqZWN0LmtleXMobWVzc2FnZXMpLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcHBlciA9IHNlcmlhbGl6ZXIuY3JlYXRlTmFtZU1hcHBlcihtZXNzYWdlc1tpZF0pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3JjID0gbWVzc2FnZXNbaWRdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXMgPSBtYXBwZXIgPyBtYXBwZXJWaXNpdG9yLmNvbnZlcnQoc3JjLm5vZGVzLCBtYXBwZXIpIDogc3JjLm5vZGVzO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZWRNZXNzYWdlID0gbmV3IE1lc3NhZ2Uobm9kZXMsIHt9LCB7fSwgc3JjLm1lYW5pbmcsIHNyYy5kZXNjcmlwdGlvbiwgaWQpO1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRNZXNzYWdlLnNvdXJjZXMgPSBzcmMuc291cmNlcztcbiAgICAgICAgICAgIGlmIChmaWx0ZXJTb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRNZXNzYWdlLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBzb3VyY2UuZmlsZVBhdGggPSBmaWx0ZXJTb3VyY2VzKHNvdXJjZS5maWxlUGF0aCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkTWVzc2FnZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyLndyaXRlKG1zZ0xpc3QsIHRoaXMuX2xvY2FsZSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVzc2FnZUJ1bmRsZTtcbn0oKSk7XG52YXIgTWFwUGxhY2Vob2xkZXJOYW1lcyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcFBsYWNlaG9sZGVyTmFtZXMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFwUGxhY2Vob2xkZXJOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVzXG4gICAgICogQHBhcmFtIHs/fSBtYXBwZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1hcFBsYWNlaG9sZGVyTmFtZXMucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAobm9kZXMsIG1hcHBlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbWFwcGVyID8gbm9kZXMubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnZpc2l0KF90aGlzLCBtYXBwZXIpOyB9KSA6IG5vZGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7P30gbWFwcGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNYXBQbGFjZWhvbGRlck5hbWVzLnByb3RvdHlwZS52aXNpdFRhZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBtYXBwZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnROYW1lID0gKChtYXBwZXIudG9QdWJsaWNOYW1lKHBoLnN0YXJ0TmFtZSkpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xvc2VOYW1lID0gcGguY2xvc2VOYW1lID8gKChtYXBwZXIudG9QdWJsaWNOYW1lKHBoLmNsb3NlTmFtZSkpKSA6IHBoLmNsb3NlTmFtZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRyZW4gPSBwaC5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4udmlzaXQoX3RoaXMsIG1hcHBlcik7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IFRhZ1BsYWNlaG9sZGVyKHBoLnRhZywgcGguYXR0cnMsIHN0YXJ0TmFtZSwgY2xvc2VOYW1lLCBjaGlsZHJlbiwgcGguaXNWb2lkLCBwaC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez99IG1hcHBlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWFwUGxhY2Vob2xkZXJOYW1lcy5wcm90b3R5cGUudmlzaXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgbWFwcGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGxhY2Vob2xkZXIocGgudmFsdWUsIC8qKiBAdHlwZSB7P30gKi8gKChtYXBwZXIudG9QdWJsaWNOYW1lKHBoLm5hbWUpKSksIHBoLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7P30gbWFwcGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNYXBQbGFjZWhvbGRlck5hbWVzLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBtYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJY3VQbGFjZWhvbGRlcihwaC52YWx1ZSwgLyoqIEB0eXBlIHs/fSAqLyAoKG1hcHBlci50b1B1YmxpY05hbWUocGgubmFtZSkpKSwgcGguc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwUGxhY2Vob2xkZXJOYW1lcztcbn0oQ2xvbmVWaXNpdG9yKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEV4dHJhY3QgaTE4biBtZXNzYWdlcyBmcm9tIHNvdXJjZSBjb2RlXG4gKi9cbnZhciBFeHRyYWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaG9zdFxuICAgICAqIEBwYXJhbSB7P30gc3RhdGljU3ltYm9sUmVzb2x2ZXJcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VCdW5kbGVcbiAgICAgKiBAcGFyYW0gez99IG1ldGFkYXRhUmVzb2x2ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFeHRyYWN0b3IoaG9zdCwgc3RhdGljU3ltYm9sUmVzb2x2ZXIsIG1lc3NhZ2VCdW5kbGUsIG1ldGFkYXRhUmVzb2x2ZXIpIHtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5zdGF0aWNTeW1ib2xSZXNvbHZlciA9IHN0YXRpY1N5bWJvbFJlc29sdmVyO1xuICAgICAgICB0aGlzLm1lc3NhZ2VCdW5kbGUgPSBtZXNzYWdlQnVuZGxlO1xuICAgICAgICB0aGlzLm1ldGFkYXRhUmVzb2x2ZXIgPSBtZXRhZGF0YVJlc29sdmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJvb3RGaWxlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXh0cmFjdG9yLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKHJvb3RGaWxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9ncmFtU3ltYm9scyA9IGV4dHJhY3RQcm9ncmFtU3ltYm9scyh0aGlzLnN0YXRpY1N5bWJvbFJlc29sdmVyLCByb290RmlsZXMsIHRoaXMuaG9zdCk7XG4gICAgICAgIHZhciBfYSA9IGFuYWx5emVBbmRWYWxpZGF0ZU5nTW9kdWxlcyhwcm9ncmFtU3ltYm9scywgdGhpcy5ob3N0LCB0aGlzLm1ldGFkYXRhUmVzb2x2ZXIpLCBmaWxlcyA9IF9hLmZpbGVzLCBuZ01vZHVsZXMgPSBfYS5uZ01vZHVsZXM7XG4gICAgICAgIHJldHVybiBQcm9taXNlXG4gICAgICAgICAgICAuYWxsKG5nTW9kdWxlcy5tYXAoZnVuY3Rpb24gKG5nTW9kdWxlKSB7IHJldHVybiBfdGhpcy5tZXRhZGF0YVJlc29sdmVyLmxvYWROZ01vZHVsZURpcmVjdGl2ZUFuZFBpcGVNZXRhZGF0YShuZ01vZHVsZS50eXBlLnJlZmVyZW5jZSwgZmFsc2UpOyB9KSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBNZXRhcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZpbGUuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpck1ldGEgPSBfdGhpcy5tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyTWV0YSAmJiBkaXJNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wTWV0YXMucHVzaChkaXJNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbXBNZXRhcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wTWV0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBodG1sID0gKCgoKGNvbXBNZXRhLnRlbXBsYXRlKSkudGVtcGxhdGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW50ZXJwb2xhdGlvbkNvbmZpZyA9IEludGVycG9sYXRpb25Db25maWcuZnJvbUFycmF5KC8qKiBAdHlwZSB7P30gKi8gKChjb21wTWV0YS50ZW1wbGF0ZSkpLmludGVycG9sYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsICgoX3RoaXMubWVzc2FnZUJ1bmRsZS51cGRhdGVGcm9tVGVtcGxhdGUoaHRtbCwgZmlsZS5zcmNVcmwsIGludGVycG9sYXRpb25Db25maWcpKSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRvU3RyaW5nKCk7IH0pLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5tZXNzYWdlQnVuZGxlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaG9zdFxuICAgICAqIEBwYXJhbSB7P30gbG9jYWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHRyYWN0b3IuY3JlYXRlID0gZnVuY3Rpb24gKGhvc3QsIGxvY2FsZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBodG1sUGFyc2VyID0gbmV3IEkxOE5IdG1sUGFyc2VyKG5ldyBIdG1sUGFyc2VyKCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cmxSZXNvbHZlciA9IGNyZWF0ZU9mZmxpbmVDb21waWxlVXJsUmVzb2x2ZXIoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sQ2FjaGUgPSBuZXcgU3RhdGljU3ltYm9sQ2FjaGUoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VtbWFyeVJlc29sdmVyID0gbmV3IEFvdFN1bW1hcnlSZXNvbHZlcihob3N0LCBzeW1ib2xDYWNoZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRpY1N5bWJvbFJlc29sdmVyID0gbmV3IFN0YXRpY1N5bWJvbFJlc29sdmVyKGhvc3QsIHN5bWJvbENhY2hlLCBzdW1tYXJ5UmVzb2x2ZXIpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0aWNSZWZsZWN0b3IgPSBuZXcgU3RhdGljUmVmbGVjdG9yKHN1bW1hcnlSZXNvbHZlciwgc3RhdGljU3ltYm9sUmVzb2x2ZXIpO1xuICAgICAgICBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5pbnN0YWxsKHN0YXRpY1JlZmxlY3Rvcik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbmZpZyA9IG5ldyBDb21waWxlckNvbmZpZyh7IGRlZmF1bHRFbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCwgdXNlSml0OiBmYWxzZSB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9ybWFsaXplciA9IG5ldyBEaXJlY3RpdmVOb3JtYWxpemVyKHsgZ2V0OiBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBob3N0LmxvYWRSZXNvdXJjZSh1cmwpOyB9IH0sIHVybFJlc29sdmVyLCBodG1sUGFyc2VyLCBjb25maWcpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50U2NoZW1hUmVnaXN0cnkgPSBuZXcgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVyID0gbmV3IENvbXBpbGVNZXRhZGF0YVJlc29sdmVyKGNvbmZpZywgbmV3IE5nTW9kdWxlUmVzb2x2ZXIoc3RhdGljUmVmbGVjdG9yKSwgbmV3IERpcmVjdGl2ZVJlc29sdmVyKHN0YXRpY1JlZmxlY3RvciksIG5ldyBQaXBlUmVzb2x2ZXIoc3RhdGljUmVmbGVjdG9yKSwgc3VtbWFyeVJlc29sdmVyLCBlbGVtZW50U2NoZW1hUmVnaXN0cnksIG5vcm1hbGl6ZXIsIG5ldyDJtUNvbnNvbGUoKSwgc3ltYm9sQ2FjaGUsIHN0YXRpY1JlZmxlY3Rvcik7XG4gICAgICAgIC8vIFRPRE8odmljYik6IGltcGxpY2l0IHRhZ3MgJiBhdHRyaWJ1dGVzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lc3NhZ2VCdW5kbGUgPSBuZXcgTWVzc2FnZUJ1bmRsZShodG1sUGFyc2VyLCBbXSwge30sIGxvY2FsZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4dHJhY3RvciA9IG5ldyBFeHRyYWN0b3IoaG9zdCwgc3RhdGljU3ltYm9sUmVzb2x2ZXIsIG1lc3NhZ2VCdW5kbGUsIHJlc29sdmVyKTtcbiAgICAgICAgcmV0dXJuIHsgZXh0cmFjdG9yOiBleHRyYWN0b3IsIHN0YXRpY1JlZmxlY3Rvcjogc3RhdGljUmVmbGVjdG9yIH07XG4gICAgfTtcbiAgICByZXR1cm4gRXh0cmFjdG9yO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfTk9fUkVTT1VSQ0VfTE9BREVSID0ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gUmVzb3VyY2VMb2FkZXIgaW1wbGVtZW50YXRpb24gaGFzIGJlZW4gcHJvdmlkZWQuIENhbid0IHJlYWQgdGhlIHVybCBcXFwiXCIgKyB1cmwgKyBcIlxcXCJcIik7XG4gICAgfVxufTtcbnZhciBiYXNlSHRtbFBhcnNlciA9IG5ldyBJbmplY3Rpb25Ub2tlbignSHRtbFBhcnNlcicpO1xuLyoqXG4gKiBAcGFyYW0gez99IHBhcnNlclxuICogQHBhcmFtIHs/fSB0cmFuc2xhdGlvbnNcbiAqIEBwYXJhbSB7P30gZm9ybWF0XG4gKiBAcGFyYW0gez99IGNvbmZpZ1xuICogQHBhcmFtIHs/fSBjb25zb2xlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpMThuSHRtbFBhcnNlckZhY3RvcnkocGFyc2VyLCB0cmFuc2xhdGlvbnMsIGZvcm1hdCwgY29uZmlnLCBjb25zb2xlKSB7XG4gICAgcmV0dXJuIG5ldyBJMThOSHRtbFBhcnNlcihwYXJzZXIsIHRyYW5zbGF0aW9ucywgZm9ybWF0LCAvKiogQHR5cGUgez99ICovICgoY29uZmlnLm1pc3NpbmdUcmFuc2xhdGlvbikpLCBjb25zb2xlKTtcbn1cbi8qKlxuICogQSBzZXQgb2YgcHJvdmlkZXJzIHRoYXQgcHJvdmlkZSBgSml0Q29tcGlsZXJgIGFuZCBpdHMgZGVwZW5kZW5jaWVzIHRvIHVzZSBmb3JcbiAqIHRlbXBsYXRlIGNvbXBpbGF0aW9uLlxuICovXG52YXIgQ09NUElMRVJfUFJPVklERVJTID0gW1xuICAgIHsgcHJvdmlkZTogybVSZWZsZWN0b3IsIHVzZVZhbHVlOiDJtXJlZmxlY3RvciB9LFxuICAgIHsgcHJvdmlkZTogybVSZWZsZWN0b3JSZWFkZXIsIHVzZUV4aXN0aW5nOiDJtVJlZmxlY3RvciB9LFxuICAgIHsgcHJvdmlkZTogUmVzb3VyY2VMb2FkZXIsIHVzZVZhbHVlOiBfTk9fUkVTT1VSQ0VfTE9BREVSIH0sXG4gICAgU3VtbWFyeVJlc29sdmVyLFxuICAgIMm1Q29uc29sZSxcbiAgICBMZXhlcixcbiAgICBQYXJzZXIsXG4gICAge1xuICAgICAgICBwcm92aWRlOiBiYXNlSHRtbFBhcnNlcixcbiAgICAgICAgdXNlQ2xhc3M6IEh0bWxQYXJzZXIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHByb3ZpZGU6IEkxOE5IdG1sUGFyc2VyLFxuICAgICAgICB1c2VGYWN0b3J5OiBpMThuSHRtbFBhcnNlckZhY3RvcnksXG4gICAgICAgIGRlcHM6IFtcbiAgICAgICAgICAgIGJhc2VIdG1sUGFyc2VyLFxuICAgICAgICAgICAgW25ldyBPcHRpb25hbCgpLCBuZXcgSW5qZWN0KFRSQU5TTEFUSU9OUyldLFxuICAgICAgICAgICAgW25ldyBPcHRpb25hbCgpLCBuZXcgSW5qZWN0KFRSQU5TTEFUSU9OU19GT1JNQVQpXSxcbiAgICAgICAgICAgIFtDb21waWxlckNvbmZpZ10sXG4gICAgICAgICAgICBbybVDb25zb2xlXSxcbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBwcm92aWRlOiBIdG1sUGFyc2VyLFxuICAgICAgICB1c2VFeGlzdGluZzogSTE4Tkh0bWxQYXJzZXIsXG4gICAgfSxcbiAgICBUZW1wbGF0ZVBhcnNlcixcbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLFxuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLFxuICAgIERFRkFVTFRfUEFDS0FHRV9VUkxfUFJPVklERVIsXG4gICAgU3R5bGVDb21waWxlcixcbiAgICBWaWV3Q29tcGlsZXIsXG4gICAgTmdNb2R1bGVDb21waWxlcixcbiAgICB7IHByb3ZpZGU6IENvbXBpbGVyQ29uZmlnLCB1c2VWYWx1ZTogbmV3IENvbXBpbGVyQ29uZmlnKCkgfSxcbiAgICBKaXRDb21waWxlcixcbiAgICB7IHByb3ZpZGU6IENvbXBpbGVyLCB1c2VFeGlzdGluZzogSml0Q29tcGlsZXIgfSxcbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnksXG4gICAgeyBwcm92aWRlOiBFbGVtZW50U2NoZW1hUmVnaXN0cnksIHVzZUV4aXN0aW5nOiBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkgfSxcbiAgICBVcmxSZXNvbHZlcixcbiAgICBEaXJlY3RpdmVSZXNvbHZlcixcbiAgICBQaXBlUmVzb2x2ZXIsXG4gICAgTmdNb2R1bGVSZXNvbHZlcixcbl07XG52YXIgSml0Q29tcGlsZXJGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlZmF1bHRPcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gSml0Q29tcGlsZXJGYWN0b3J5KGRlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgIHZhciBjb21waWxlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1c2VEZWJ1ZzogaXNEZXZNb2RlKCksXG4gICAgICAgICAgICB1c2VKaXQ6IHRydWUsXG4gICAgICAgICAgICBkZWZhdWx0RW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQsXG4gICAgICAgICAgICBtaXNzaW5nVHJhbnNsYXRpb246IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5Lldhcm5pbmcsXG4gICAgICAgICAgICBlbmFibGVMZWdhY3lUZW1wbGF0ZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdE9wdGlvbnMgPSBbY29tcGlsZXJPcHRpb25zXS5jb25jYXQoZGVmYXVsdE9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUNvbXBpbGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gW107IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3B0cyA9IF9tZXJnZU9wdGlvbnModGhpcy5fZGVmYXVsdE9wdGlvbnMuY29uY2F0KG9wdGlvbnMpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXG4gICAgICAgICAgICBDT01QSUxFUl9QUk9WSURFUlMsIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBDb21waWxlckNvbmZpZyxcbiAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZXJDb25maWcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0IGV4cGxpY2l0IHZhbHVlcyBmcm9tIHRoZSBjb21waWxlciBvcHRpb25zIG92ZXJ3cml0ZSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBhcHAgcHJvdmlkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VKaXQ6IG9wdHMudXNlSml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0IGV4cGxpY2l0IHZhbHVlcyBmcm9tIHRoZSBjb21waWxlciBvcHRpb25zIG92ZXJ3cml0ZSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBhcHAgcHJvdmlkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0RW5jYXBzdWxhdGlvbjogb3B0cy5kZWZhdWx0RW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmdUcmFuc2xhdGlvbjogb3B0cy5taXNzaW5nVHJhbnNsYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVMZWdhY3lUZW1wbGF0ZTogb3B0cy5lbmFibGVMZWdhY3lUZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZXBzOiBbXVxuICAgICAgICAgICAgfSwgLyoqIEB0eXBlIHs/fSAqLyAoKG9wdHMucHJvdmlkZXJzKSlcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiBpbmplY3Rvci5nZXQoQ29tcGlsZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIEppdENvbXBpbGVyRmFjdG9yeTtcbn0oKSk7XG5KaXRDb21waWxlckZhY3RvcnkuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBpbGVySW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuSml0Q29tcGlsZXJGYWN0b3J5LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW0NPTVBJTEVSX09QVElPTlMsXSB9LF0gfSxcbl07IH07XG4vKipcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9pbml0UmVmbGVjdG9yKCkge1xuICAgIMm1cmVmbGVjdG9yLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMgPSBuZXcgybVSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzKCk7XG59XG4vKipcbiAqIEEgcGxhdGZvcm0gdGhhdCBpbmNsdWRlZCBjb3JlUGxhdGZvcm0gYW5kIHRoZSBjb21waWxlci5cbiAqXG4gKiBcXEBleHBlcmltZW50YWxcbiAqL1xudmFyIHBsYXRmb3JtQ29yZUR5bmFtaWMgPSBjcmVhdGVQbGF0Zm9ybUZhY3RvcnkocGxhdGZvcm1Db3JlLCAnY29yZUR5bmFtaWMnLCBbXG4gICAgeyBwcm92aWRlOiBDT01QSUxFUl9PUFRJT05TLCB1c2VWYWx1ZToge30sIG11bHRpOiB0cnVlIH0sXG4gICAgeyBwcm92aWRlOiBDb21waWxlckZhY3RvcnksIHVzZUNsYXNzOiBKaXRDb21waWxlckZhY3RvcnkgfSxcbiAgICB7IHByb3ZpZGU6IFBMQVRGT1JNX0lOSVRJQUxJWkVSLCB1c2VWYWx1ZTogX2luaXRSZWZsZWN0b3IsIG11bHRpOiB0cnVlIH0sXG5dKTtcbi8qKlxuICogQHBhcmFtIHs/fSBvcHRpb25zQXJyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfbWVyZ2VPcHRpb25zKG9wdGlvbnNBcnIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VKaXQ6IF9sYXN0RGVmaW5lZChvcHRpb25zQXJyLm1hcChmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gb3B0aW9ucy51c2VKaXQ7IH0pKSxcbiAgICAgICAgZGVmYXVsdEVuY2Fwc3VsYXRpb246IF9sYXN0RGVmaW5lZChvcHRpb25zQXJyLm1hcChmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gb3B0aW9ucy5kZWZhdWx0RW5jYXBzdWxhdGlvbjsgfSkpLFxuICAgICAgICBwcm92aWRlcnM6IF9tZXJnZUFycmF5cyhvcHRpb25zQXJyLm1hcChmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gKChvcHRpb25zLnByb3ZpZGVycykpOyB9KSksXG4gICAgICAgIG1pc3NpbmdUcmFuc2xhdGlvbjogX2xhc3REZWZpbmVkKG9wdGlvbnNBcnIubWFwKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiBvcHRpb25zLm1pc3NpbmdUcmFuc2xhdGlvbjsgfSkpLFxuICAgIH07XG59XG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0gez99IGFyZ3NcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9sYXN0RGVmaW5lZChhcmdzKSB7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gYXJncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoYXJnc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHBhcnRzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfbWVyZ2VBcnJheXMocGFydHMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBbXTtcbiAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7IHJldHVybiBwYXJ0ICYmIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgcGFydCk7IH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEludGVyZmFjZSB0aGF0IGRlZmluZXMgaG93IGltcG9ydCBzdGF0ZW1lbnRzIHNob3VsZCBiZSBnZW5lcmF0ZWQuXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEltcG9ydFJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbXBvcnRSZXNvbHZlcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBmaWxlIHBhdGggdG8gYSBtb2R1bGUgbmFtZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIGBpbXBvcnQuXG4gICAgICogSS5lLiBgcGF0aC90by9pbXBvcnRlZEZpbGUudHNgIHNob3VsZCBiZSBpbXBvcnRlZCBieSBgcGF0aC90by9jb250YWluaW5nRmlsZS50c2AuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBpbXBvcnRlZEZpbGVQYXRoXG4gICAgICogQHBhcmFtIHs/fSBjb250YWluaW5nRmlsZVBhdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEltcG9ydFJlc29sdmVyLnByb3RvdHlwZS5maWxlTmFtZVRvTW9kdWxlTmFtZSA9IGZ1bmN0aW9uIChpbXBvcnRlZEZpbGVQYXRoLCBjb250YWluaW5nRmlsZVBhdGgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gU3RhdGljU3ltYm9sIGludG8gYW5vdGhlciBTdGF0aWNTeW1ib2wgdGhhdCBzaG91bGQgYmUgdXNlZFxuICAgICAqIHRvIGdlbmVyYXRlIHRoZSBpbXBvcnQgZnJvbS5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHN5bWJvbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW1wb3J0UmVzb2x2ZXIucHJvdG90eXBlLmdldEltcG9ydEFzID0gZnVuY3Rpb24gKHN5bWJvbCkgeyB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgYXJpdHkgb2YgYSB0eXBlLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gc3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJbXBvcnRSZXNvbHZlci5wcm90b3R5cGUuZ2V0VHlwZUFyaXR5ID0gZnVuY3Rpb24gKHN5bWJvbCkgeyB9O1xuICAgIHJldHVybiBJbXBvcnRSZXNvbHZlcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBtb2R1bGVcbiAqIEBkZXNjcmlwdGlvblxuICogRW50cnkgcG9pbnQgZm9yIGFsbCBBUElzIG9mIHRoZSBjb21waWxlciBwYWNrYWdlLlxuICpcbiAqIDxkaXYgY2xhc3M9XCJjYWxsb3V0IGlzLWNyaXRpY2FsXCI+XG4gKiAgIDxoZWFkZXI+VW5zdGFibGUgQVBJczwvaGVhZGVyPlxuICogICA8cD5cbiAqICAgICBBbGwgY29tcGlsZXIgYXBpcyBhcmUgY3VycmVudGx5IGNvbnNpZGVyZWQgZXhwZXJpbWVudGFsIGFuZCBwcml2YXRlIVxuICogICA8L3A+XG4gKiAgIDxwPlxuICogICAgIFdlIGV4cGVjdCB0aGUgQVBJcyBpbiB0aGlzIHBhY2thZ2UgdG8ga2VlcCBvbiBjaGFuZ2luZy4gRG8gbm90IHJlbHkgb24gdGhlbS5cbiAqICAgPC9wPlxuICogPC9kaXY+XG4gKi9cbi8vIFRoaXMgZmlsZSBvbmx5IHJlZXhwb3J0cyBjb250ZW50IG9mIHRoZSBgc3JjYCBmb2xkZXIuIEtlZXAgaXQgdGhhdCB3YXkuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBtb2R1bGVcbiAqIEBkZXNjcmlwdGlvblxuICogRW50cnkgcG9pbnQgZm9yIGFsbCBwdWJsaWMgQVBJcyBvZiB0aGUgY29tcGlsZXIgcGFja2FnZS5cbiAqL1xuLy8gVGhpcyBmaWxlIG9ubHkgcmVleHBvcnRzIGNvbnRlbnQgb2YgdGhlIGBzcmNgIGZvbGRlci4gS2VlcCBpdCB0aGF0IHdheS5cbmV4cG9ydCB7IFZFUlNJT04sIFRFTVBMQVRFX1RSQU5TRk9STVMsIENvbXBpbGVyQ29uZmlnLCBKaXRDb21waWxlciwgRGlyZWN0aXZlUmVzb2x2ZXIsIFBpcGVSZXNvbHZlciwgTmdNb2R1bGVSZXNvbHZlciwgREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRywgSW50ZXJwb2xhdGlvbkNvbmZpZywgTmdNb2R1bGVDb21waWxlciwgVmlld0NvbXBpbGVyLCBpc1N5bnRheEVycm9yLCBzeW50YXhFcnJvciwgVGV4dEFzdCwgQm91bmRUZXh0QXN0LCBBdHRyQXN0LCBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdCwgQm91bmRFdmVudEFzdCwgUmVmZXJlbmNlQXN0LCBWYXJpYWJsZUFzdCwgRWxlbWVudEFzdCwgRW1iZWRkZWRUZW1wbGF0ZUFzdCwgQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdCwgRGlyZWN0aXZlQXN0LCBQcm92aWRlckFzdCwgUHJvdmlkZXJBc3RUeXBlLCBOZ0NvbnRlbnRBc3QsIFByb3BlcnR5QmluZGluZ1R5cGUsIHRlbXBsYXRlVmlzaXRBbGwsIENvbXBpbGVBbmltYXRpb25FbnRyeU1ldGFkYXRhLCBDb21waWxlQW5pbWF0aW9uU3RhdGVNZXRhZGF0YSwgQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSwgQ29tcGlsZUFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhLCBDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEsIENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhLCBDb21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSwgQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSwgQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhLCBDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YSwgQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGEsIGlkZW50aWZpZXJOYW1lLCBpZGVudGlmaWVyTW9kdWxlVXJsLCB2aWV3Q2xhc3NOYW1lLCByZW5kZXJlclR5cGVOYW1lLCBob3N0Vmlld0NsYXNzTmFtZSwgZGlyV3JhcHBlckNsYXNzTmFtZSwgY29tcG9uZW50RmFjdG9yeU5hbWUsIENvbXBpbGVTdW1tYXJ5S2luZCwgdG9rZW5OYW1lLCB0b2tlblJlZmVyZW5jZSwgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSwgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEsIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSwgY3JlYXRlSG9zdENvbXBvbmVudE1ldGEsIENvbXBpbGVQaXBlTWV0YWRhdGEsIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhLCBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEsIFByb3ZpZGVyTWV0YSwgZmxhdHRlbiwgc291cmNlVXJsLCB0ZW1wbGF0ZVNvdXJjZVVybCwgc2hhcmVkU3R5bGVzaGVldEppdFVybCwgbmdNb2R1bGVKaXRVcmwsIHRlbXBsYXRlSml0VXJsLCBjcmVhdGVBb3RDb21waWxlciwgQW90Q29tcGlsZXIsIGFuYWx5emVOZ01vZHVsZXMsIGFuYWx5emVBbmRWYWxpZGF0ZU5nTW9kdWxlcywgZXh0cmFjdFByb2dyYW1TeW1ib2xzLCBHZW5lcmF0ZWRGaWxlLCBTdGF0aWNSZWZsZWN0b3IsIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLCBTdGF0aWNTeW1ib2wsIFN0YXRpY1N5bWJvbENhY2hlLCBSZXNvbHZlZFN0YXRpY1N5bWJvbCwgU3RhdGljU3ltYm9sUmVzb2x2ZXIsIHVuZXNjYXBlSWRlbnRpZmllciwgQW90U3VtbWFyeVJlc29sdmVyLCBTdW1tYXJ5UmVzb2x2ZXIsIGkxOG5IdG1sUGFyc2VyRmFjdG9yeSwgQ09NUElMRVJfUFJPVklERVJTLCBKaXRDb21waWxlckZhY3RvcnksIHBsYXRmb3JtQ29yZUR5bmFtaWMsIGNyZWF0ZVVybFJlc29sdmVyV2l0aG91dFBhY2thZ2VQcmVmaXgsIGNyZWF0ZU9mZmxpbmVDb21waWxlVXJsUmVzb2x2ZXIsIERFRkFVTFRfUEFDS0FHRV9VUkxfUFJPVklERVIsIFVybFJlc29sdmVyLCBnZXRVcmxTY2hlbWUsIFJlc291cmNlTG9hZGVyLCBFbGVtZW50U2NoZW1hUmVnaXN0cnksIEV4dHJhY3RvciwgSTE4Tkh0bWxQYXJzZXIsIE1lc3NhZ2VCdW5kbGUsIFNlcmlhbGl6ZXIsIFhsaWZmLCBYbGlmZjIsIFhtYiwgWHRiLCBEaXJlY3RpdmVOb3JtYWxpemVyLCBQYXJzZXJFcnJvciwgUGFyc2VTcGFuLCBBU1QsIFF1b3RlLCBFbXB0eUV4cHIsIEltcGxpY2l0UmVjZWl2ZXIsIENoYWluLCBDb25kaXRpb25hbCwgUHJvcGVydHlSZWFkLCBQcm9wZXJ0eVdyaXRlLCBTYWZlUHJvcGVydHlSZWFkLCBLZXllZFJlYWQsIEtleWVkV3JpdGUsIEJpbmRpbmdQaXBlLCBMaXRlcmFsUHJpbWl0aXZlLCBMaXRlcmFsQXJyYXksIExpdGVyYWxNYXAsIEludGVycG9sYXRpb24sIEJpbmFyeSwgUHJlZml4Tm90LCBNZXRob2RDYWxsLCBTYWZlTWV0aG9kQ2FsbCwgRnVuY3Rpb25DYWxsLCBBU1RXaXRoU291cmNlLCBUZW1wbGF0ZUJpbmRpbmcsIFJlY3Vyc2l2ZUFzdFZpc2l0b3IsIEFzdFRyYW5zZm9ybWVyLCBUb2tlblR5cGUsIExleGVyLCBUb2tlbiwgRU9GLCBpc0lkZW50aWZpZXIsIGlzUXVvdGUsIFNwbGl0SW50ZXJwb2xhdGlvbiwgVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQsIFBhcnNlciwgX1BhcnNlQVNULCBFUlJPUl9DT0xMRUNUT1JfVE9LRU4sIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLCBjb21wb25lbnRNb2R1bGVVcmwsIFRleHQsIEV4cGFuc2lvbiwgRXhwYW5zaW9uQ2FzZSwgQXR0cmlidXRlJDEgYXMgQXR0cmlidXRlLCBFbGVtZW50LCBDb21tZW50LCB2aXNpdEFsbCwgUGFyc2VUcmVlUmVzdWx0LCBUcmVlRXJyb3IsIEh0bWxQYXJzZXIsIEh0bWxUYWdEZWZpbml0aW9uLCBnZXRIdG1sVGFnRGVmaW5pdGlvbiwgVGFnQ29udGVudFR5cGUsIHNwbGl0TnNOYW1lLCBpc05nQ29udGFpbmVyLCBpc05nQ29udGVudCwgaXNOZ1RlbXBsYXRlLCBnZXROc1ByZWZpeCwgbWVyZ2VOc0FuZE5hbWUsIE5BTUVEX0VOVElUSUVTLCBJbXBvcnRSZXNvbHZlciwgZGVidWdPdXRwdXRBc3RBc1R5cGVTY3JpcHQsIFR5cGVTY3JpcHRFbWl0dGVyLCBQYXJzZUxvY2F0aW9uLCBQYXJzZVNvdXJjZUZpbGUsIFBhcnNlU291cmNlU3BhbiwgUGFyc2VFcnJvckxldmVsLCBQYXJzZUVycm9yLCB0eXBlU291cmNlU3BhbiwgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBDc3NTZWxlY3RvciwgU2VsZWN0b3JNYXRjaGVyLCBTZWxlY3Rvckxpc3RDb250ZXh0LCBTZWxlY3RvckNvbnRleHQsIFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5LCBTdHlsZXNDb21waWxlUmVzdWx0LCBDb21waWxlZFN0eWxlc2hlZXQsIFN0eWxlQ29tcGlsZXIsIFRlbXBsYXRlUGFyc2VFcnJvciwgVGVtcGxhdGVQYXJzZVJlc3VsdCwgVGVtcGxhdGVQYXJzZXIsIHNwbGl0Q2xhc3NlcywgY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yLCByZW1vdmVTdW1tYXJ5RHVwbGljYXRlcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGlsZXIuanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21waWxlci5lczUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9AYW5ndWxhci9jb21waWxlci9AYW5ndWxhci9jb21waWxlci5lczUuanNcbi8vIG1vZHVsZSBpZCA9IDIxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 214:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    }return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = __webpack_require__(36);\nvar AppComponent = function AppComponent() {\n    _classCallCheck(this, AppComponent);\n\n    this.title = 'app works!';\n};\nAppComponent = __decorate([core_1.Component({\n    selector: 'app-root',\n    template: __webpack_require__(406),\n    styles: [__webpack_require__(405)]\n})], AppComponent);\nexports.AppComponent = AppComponent;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9hcHAuY29tcG9uZW50LnRzPzUyYTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2FwcC1yb290JyxcbiAgdGVtcGxhdGU6IHJlcXVpcmUoJy4uL3RlbXBsYXRlcy9hcHAuY29tcG9uZW50Lmh0bWwnKSxcbiAgc3R5bGVzOiBbcmVxdWlyZSgnLi4vc2Fzcy9hcHAuY29tcG9uZW50LnNjc3MnKV1cbn0pXG5leHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgdGl0bGUgPSAnYXBwIHdvcmtzISc7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NjcmlwdHMvYXBwLmNvbXBvbmVudC50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFPQTs7O0FBQ0E7QUFDQTtBQUZBO0FBSkE7QUFDQTtBQUNBO0FBSEE7QUFLQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 215:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = __webpack_require__(36);\nvar environment_1 = __webpack_require__(207);\nvar platform_browser_dynamic_1 = __webpack_require__(204);\nvar app_module_1 = __webpack_require__(206);\n__webpack_require__(209);\nplatform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(app_module_1.AppModule);\nif (environment_1.environment.production) {\n    core_1.enableProdMode();\n}\nplatform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(app_module_1.AppModule);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9tYWluLnRzPzc3MDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZW5hYmxlUHJvZE1vZGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGVudmlyb25tZW50IH0gZnJvbSAnLi9lbnZpcm9ubWVudHMvZW52aXJvbm1lbnQnO1xuaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG5cbmltcG9ydCB7IEFwcE1vZHVsZSB9IGZyb20gJy4vYXBwLm1vZHVsZSc7XG5pbXBvcnQgJy4uL2Nzcy9zdHlsZXMuc2NzcydcbnBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcblxuaWYgKGVudmlyb25tZW50LnByb2R1Y3Rpb24pIHtcbiAgICBlbmFibGVQcm9kTW9kZSgpO1xufVxuXG5wbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zY3JpcHRzL21haW4udHMiXSwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 405:
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2Fzcy9hcHAuY29tcG9uZW50LnNjc3M/ZDQ0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc2Fzcy9hcHAuY29tcG9uZW50LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDQwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 406:
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"templates/app.component.html\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vdGVtcGxhdGVzL2FwcC5jb21wb25lbnQuaHRtbD9iMTUxIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcInRlbXBsYXRlcy9hcHAuY29tcG9uZW50Lmh0bWxcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3RlbXBsYXRlcy9hcHAuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDQwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ })

},[215]);